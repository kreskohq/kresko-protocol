{
  "stats": {
    "suites": 90,
    "tests": 277,
    "passes": 256,
    "pending": 21,
    "failures": 0,
    "start": "2024-02-03T03:57:20.878Z",
    "end": "2024-02-03T03:58:44.485Z",
    "duration": 83607,
    "testsRegistered": 277,
    "passPercent": 100,
    "pendingPercent": 7.581227436823104,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false
  },
  "results": [
    {
      "uuid": "57f045e7-0560-48da-99cf-446e6c25f95d",
      "title": "",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "04afce0c-2d57-4639-a75a-463c8032f117",
          "title": "Asset Amounts & Values",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/asset-values/00-asset-values.ts",
          "file": "/src/test/asset-values/00-asset-values.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"Asset Amounts & Values\"",
              "fullTitle": "Asset Amounts & Values \"before each\" hook in \"Asset Amounts & Values\"",
              "timedOut": false,
              "duration": 2,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "f = await (0, _fixtures.assetValuesFixture)();\nf.user = hre.users.userEight;\nUser = hre.Diamond.connect(f.user);",
              "err": {},
              "uuid": "f9bfe3d4-b668-45a8-9065-4d3571c2744b",
              "parentUUID": "04afce0c-2d57-4639-a75a-463c8032f117",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "288798d4-7386-48de-b865-6b16ff2342f7",
              "title": "#Collateral Deposit Values",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/asset-values/00-asset-values.ts",
              "file": "/src/test/asset-values/00-asset-values.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should return the correct deposit value with 18 decimals",
                  "fullTitle": "Asset Amounts & Values #Collateral Deposit Values should return the correct deposit value with 18 decimals",
                  "timedOut": false,
                  "duration": 23,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const depositAmount = (0, _values.toBig)(10);\nconst expectedDepositValue = (0, _values.toBig)(50, f.oracleDecimals) // cfactor = 0.5, collateralPrice = 10, depositAmount = 10\n;\nawait User.depositCollateral(f.user.address, f.CollateralAsset.address, depositAmount);\nconst depositValue = await hre.Diamond.getAccountTotalCollateralValue(f.user.address);\n(0, _chai.expect)(depositValue).to.equal(expectedDepositValue);",
                  "err": {},
                  "uuid": "d4f45de5-67c4-4383-84b4-66ce9bd64880",
                  "parentUUID": "288798d4-7386-48de-b865-6b16ff2342f7",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return the correct deposit value with less than 18 decimals",
                  "fullTitle": "Asset Amounts & Values #Collateral Deposit Values should return the correct deposit value with less than 18 decimals",
                  "timedOut": false,
                  "duration": 21,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const depositAmount = (0, _values.toBig)(10, 8);\nconst expectedDepositValue = (0, _values.toBig)(50, f.oracleDecimals) // cfactor = 0.5, collateralPrice = 10, depositAmount = 10\n;\nawait User.depositCollateral(f.user.address, f.CollateralAsset8Dec.address, depositAmount);\nconst depositValue = await hre.Diamond.getAccountTotalCollateralValue(f.user.address);\n(0, _chai.expect)(depositValue).to.equal(expectedDepositValue);",
                  "err": {},
                  "uuid": "48252ab3-3fb1-46c6-aaa1-628d8befeea1",
                  "parentUUID": "288798d4-7386-48de-b865-6b16ff2342f7",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return the correct deposit value with over 18 decimals",
                  "fullTitle": "Asset Amounts & Values #Collateral Deposit Values should return the correct deposit value with over 18 decimals",
                  "timedOut": false,
                  "duration": 20,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const depositAmount = (0, _values.toBig)(10, 21);\nconst expectedDepositValue = (0, _values.toBig)(50, f.oracleDecimals) // cfactor = 0.5, collateralPrice = 10, depositAmount = 10\n;\nawait User.depositCollateral(f.user.address, f.CollateralAsset21Dec.address, depositAmount);\nconst depositValue = await hre.Diamond.getAccountTotalCollateralValue(f.user.address);\n(0, _chai.expect)(depositValue).to.equal(expectedDepositValue);",
                  "err": {},
                  "uuid": "478668de-1475-4315-bf5a-4e3c60f2bda8",
                  "parentUUID": "288798d4-7386-48de-b865-6b16ff2342f7",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return the correct deposit value combination of different decimals",
                  "fullTitle": "Asset Amounts & Values #Collateral Deposit Values should return the correct deposit value combination of different decimals",
                  "timedOut": false,
                  "duration": 52,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await User.depositCollateral(f.user.address, f.CollateralAsset.address, (0, _values.toBig)(10));\nawait User.depositCollateral(f.user.address, f.CollateralAsset8Dec.address, (0, _values.toBig)(10, 8));\nawait User.depositCollateral(f.user.address, f.CollateralAsset21Dec.address, (0, _values.toBig)(10, 21));\nconst expectedDepositValue = (0, _values.toBig)(150, f.oracleDecimals) // cfactor = 0.5, collateralPrice = 10, depositAmount = 30\n;\nconst depositValue = await hre.Diamond.getAccountTotalCollateralValue(f.user.address);\n(0, _chai.expect)(depositValue).to.equal(expectedDepositValue);",
                  "err": {},
                  "uuid": "f57a0363-c9ca-4201-8266-c14352e6c19e",
                  "parentUUID": "288798d4-7386-48de-b865-6b16ff2342f7",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "d4f45de5-67c4-4383-84b4-66ce9bd64880",
                "48252ab3-3fb1-46c6-aaa1-628d8befeea1",
                "478668de-1475-4315-bf5a-4e3c60f2bda8",
                "f57a0363-c9ca-4201-8266-c14352e6c19e"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 116,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            },
            {
              "uuid": "167ed018-5914-4458-853c-eb1f5dfc549a",
              "title": "#Collateral Deposit Amount",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/asset-values/00-asset-values.ts",
              "file": "/src/test/asset-values/00-asset-values.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should return the correct deposit amount with 18 decimals",
                  "fullTitle": "Asset Amounts & Values #Collateral Deposit Amount should return the correct deposit amount with 18 decimals",
                  "timedOut": false,
                  "duration": 60,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const depositAmount = (0, _values.toBig)(10);\nawait User.depositCollateral(f.user.address, f.CollateralAsset.address, depositAmount);\nconst withdrawIndex = await _optimizations.default.getAccountDepositIndex(f.user.address, f.CollateralAsset.address);\nconst deposits = await hre.Diamond.getAccountCollateralAmount(f.user.address, f.CollateralAsset.address);\n(0, _chai.expect)(deposits).to.equal(depositAmount);\nawait User.withdrawCollateral({\n    account: f.user.address,\n    asset: f.CollateralAsset.address,\n    amount: depositAmount,\n    collateralIndex: withdrawIndex,\n    receiver: f.user.address\n}, await hre.updateData());\nconst balance = await f.CollateralAsset.balanceOf(f.user.address);\n(0, _chai.expect)(balance).to.equal((0, _values.toBig)(f.startingBalance));",
                  "err": {},
                  "uuid": "faed8fad-b49e-487e-86e3-e8217f85ff5f",
                  "parentUUID": "167ed018-5914-4458-853c-eb1f5dfc549a",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return the correct deposit amount with less than 18 decimals",
                  "fullTitle": "Asset Amounts & Values #Collateral Deposit Amount should return the correct deposit amount with less than 18 decimals",
                  "timedOut": false,
                  "duration": 59,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const depositAmount = (0, _values.toBig)(10, 8);\nawait User.depositCollateral(f.user.address, f.CollateralAsset8Dec.address, depositAmount);\nconst withdrawIndex = await _optimizations.default.getAccountDepositIndex(f.user.address, f.CollateralAsset8Dec.address);\nconst deposits = await hre.Diamond.getAccountCollateralAmount(f.user.address, f.CollateralAsset8Dec.address);\n(0, _chai.expect)(deposits).to.equal(depositAmount);\nawait User.withdrawCollateral({\n    account: f.user.address,\n    asset: f.CollateralAsset8Dec.address,\n    amount: depositAmount,\n    collateralIndex: withdrawIndex,\n    receiver: f.user.address\n}, await hre.updateData());\nconst balance = await f.CollateralAsset8Dec.balanceOf(f.user.address);\n(0, _chai.expect)(balance).to.equal((0, _values.toBig)(f.startingBalance, 8));",
                  "err": {},
                  "uuid": "4adda3d4-0039-4911-b85f-af6b65c25bfb",
                  "parentUUID": "167ed018-5914-4458-853c-eb1f5dfc549a",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return the correct deposit value with over 18 decimals",
                  "fullTitle": "Asset Amounts & Values #Collateral Deposit Amount should return the correct deposit value with over 18 decimals",
                  "timedOut": false,
                  "duration": 64,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const depositAmount = (0, _values.toBig)(10, 21);\nawait User.depositCollateral(f.user.address, f.CollateralAsset21Dec.address, depositAmount);\nconst collateralIndex = await _optimizations.default.getAccountDepositIndex(f.user.address, f.CollateralAsset21Dec.address);\nconst deposits = await hre.Diamond.getAccountCollateralAmount(f.user.address, f.CollateralAsset21Dec.address);\n(0, _chai.expect)(deposits).to.equal(depositAmount);\nawait User.withdrawCollateral({\n    account: f.user.address,\n    asset: f.CollateralAsset21Dec.address,\n    amount: depositAmount,\n    collateralIndex,\n    receiver: f.user.address\n}, await hre.updateData());\nconst balance = await f.CollateralAsset21Dec.balanceOf(f.user.address);\n(0, _chai.expect)(balance).to.equal((0, _values.toBig)(f.startingBalance, 21));",
                  "err": {},
                  "uuid": "7310d4c0-c75f-439f-ae31-2ca97ca1e216",
                  "parentUUID": "167ed018-5914-4458-853c-eb1f5dfc549a",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "faed8fad-b49e-487e-86e3-e8217f85ff5f",
                "4adda3d4-0039-4911-b85f-af6b65c25bfb",
                "7310d4c0-c75f-439f-ae31-2ca97ca1e216"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 183,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            },
            {
              "uuid": "d3e53aee-23aa-4642-92c8-d5ec339dd618",
              "title": "#Kresko Asset Debt Values",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/asset-values/00-asset-values.ts",
              "file": "/src/test/asset-values/00-asset-values.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should return the correct debt value (+CR) with 18 decimal collateral",
                  "fullTitle": "Asset Amounts & Values #Kresko Asset Debt Values should return the correct debt value (+CR) with 18 decimal collateral",
                  "timedOut": false,
                  "duration": 145,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const depositAmount = (0, _values.toBig)(10);\nawait User.depositCollateral(f.user.address, f.CollateralAsset.address, depositAmount);\nconst mintAmount = (0, _values.toBig)(1);\nconst expectedMintValue = (0, _values.toBig)(20, f.oracleDecimals) // kFactor = 2, krAssetPrice = 10, mintAmount = 1, openFee = 0.1\n;\nawait User.mintKreskoAsset({\n    account: f.user.address,\n    krAsset: f.KreskoAsset.address,\n    amount: mintAmount,\n    receiver: f.user.address\n}, await hre.updateData());\nconst expectedDepositValue = (0, _values.toBig)(49.5, f.oracleDecimals) // cfactor = 0.5, collateralPrice = 10, depositAmount = 10, openFee = 0.1\n;\nconst depositValue = await hre.Diamond.getAccountTotalCollateralValue(f.user.address);\n(0, _chai.expect)(depositValue).to.equal(expectedDepositValue);\nconst mintValue = await hre.Diamond.getAccountTotalDebtValue(f.user.address);\n(0, _chai.expect)(mintValue).to.equal(expectedMintValue);\nconst assetValue = await hre.Diamond.getValue(f.KreskoAsset.address, mintAmount);\nconst kFactor = (await hre.Diamond.getAsset(f.KreskoAsset.address)).kFactor;\n(0, _chai.expect)(assetValue).to.equal(expectedMintValue.percentDiv(kFactor));\nconst collateralRatio = await hre.Diamond.getAccountCollateralRatio(f.user.address);\n(0, _chai.expect)(collateralRatio).to.equal(expectedDepositValue.percentDiv(expectedMintValue)) // 2.475\n;",
                  "err": {},
                  "uuid": "33eee60e-1fc0-42cb-8aae-d811c7370622",
                  "parentUUID": "d3e53aee-23aa-4642-92c8-d5ec339dd618",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return the correct debt value (+CR) with less than 18 decimal collateral",
                  "fullTitle": "Asset Amounts & Values #Kresko Asset Debt Values should return the correct debt value (+CR) with less than 18 decimal collateral",
                  "timedOut": false,
                  "duration": 154,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const depositAmount = (0, _values.toBig)(10, 8);\nawait User.depositCollateral(f.user.address, f.CollateralAsset8Dec.address, depositAmount);\nconst mintAmount = (0, _values.toBig)(1);\nconst expectedMintValue = (0, _values.toBig)(20, f.oracleDecimals) // kFactor = 2, krAssetPrice = 10, mintAmount = 1, openFee = 0.1\n;\nawait User.mintKreskoAsset({\n    account: f.user.address,\n    krAsset: f.KreskoAsset.address,\n    amount: mintAmount,\n    receiver: f.user.address\n}, await hre.updateData());\nconst expectedDepositValue = (0, _values.toBig)(49.5, f.oracleDecimals) // cfactor = 0.5, collateralPrice = 10, depositAmount = 10, openFee = 0.1\n;\nconst depositValue = await hre.Diamond.getAccountTotalCollateralValue(f.user.address);\n(0, _chai.expect)(depositValue).to.equal(expectedDepositValue);\nconst mintValue = await hre.Diamond.getAccountTotalDebtValue(f.user.address);\n(0, _chai.expect)(mintValue).to.equal(expectedMintValue);\nconst assetValue = await hre.Diamond.getValue(f.KreskoAsset.address, mintAmount);\nconst kFactor = (await hre.Diamond.getAsset(f.KreskoAsset.address)).kFactor;\n(0, _chai.expect)(assetValue).to.equal(expectedMintValue.percentDiv(kFactor));\nconst collateralRatio = await hre.Diamond.getAccountCollateralRatio(f.user.address);\n(0, _chai.expect)(collateralRatio).to.equal(expectedDepositValue.percentDiv(expectedMintValue)) // 2.475\n;",
                  "err": {},
                  "uuid": "ae8974fc-836a-4684-86a2-305b25dd8fc7",
                  "parentUUID": "d3e53aee-23aa-4642-92c8-d5ec339dd618",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return the correct debt value (+CR) with more than 18 decimal collateral",
                  "fullTitle": "Asset Amounts & Values #Kresko Asset Debt Values should return the correct debt value (+CR) with more than 18 decimal collateral",
                  "timedOut": false,
                  "duration": 156,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const depositAmount = (0, _values.toBig)(10, 21);\nawait User.depositCollateral(f.user.address, f.CollateralAsset21Dec.address, depositAmount);\nconst mintAmount = (0, _values.toBig)(1);\nconst expectedMintValue = (0, _values.toBig)(20, f.oracleDecimals) // kFactor = 2, krAssetPrice = 10, mintAmount = 1, openFee = 0.1\n;\nawait User.mintKreskoAsset({\n    account: f.user.address,\n    krAsset: f.KreskoAsset.address,\n    amount: mintAmount,\n    receiver: f.user.address\n}, await hre.updateData());\nconst expectedDepositValue = (0, _values.toBig)(49.5, f.oracleDecimals) // cfactor = 0.5, collateralPrice = 10, depositAmount = 10, openFee = 0.1\n;\nconst depositValue = await hre.Diamond.getAccountTotalCollateralValue(f.user.address);\n(0, _chai.expect)(depositValue).to.equal(expectedDepositValue);\nconst mintValue = await hre.Diamond.getAccountTotalDebtValue(f.user.address);\n(0, _chai.expect)(mintValue).to.equal(expectedMintValue);\nconst assetValue = await hre.Diamond.getValue(f.KreskoAsset.address, mintAmount);\nconst kFactor = (await hre.Diamond.getAsset(f.KreskoAsset.address)).kFactor;\n(0, _chai.expect)(assetValue).to.equal(expectedMintValue.percentDiv(kFactor));\nconst collateralRatio = await hre.Diamond.getAccountCollateralRatio(f.user.address);\n(0, _chai.expect)(collateralRatio).to.equal(expectedDepositValue.percentDiv(expectedMintValue)) // 2.475\n;",
                  "err": {},
                  "uuid": "f90d8f7c-96b0-4ef2-a8d1-040a2eb80595",
                  "parentUUID": "d3e53aee-23aa-4642-92c8-d5ec339dd618",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "33eee60e-1fc0-42cb-8aae-d811c7370622",
                "ae8974fc-836a-4684-86a2-305b25dd8fc7",
                "f90d8f7c-96b0-4ef2-a8d1-040a2eb80595"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 455,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "acb01b78-0088-43ef-8762-5bc5eaaf31ce",
          "title": "Diamond",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/diamond/00-init.ts",
          "file": "/src/test/diamond/00-init.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"Diamond\"",
              "fullTitle": "Diamond \"before each\" hook in \"Diamond\"",
              "timedOut": false,
              "duration": 1,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "f = await (0, _fixtures.diamondFixture)();",
              "err": {},
              "uuid": "8215b6da-a676-4e34-983b-045897dffed6",
              "parentUUID": "acb01b78-0088-43ef-8762-5bc5eaaf31ce",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "6142f890-56ef-4d81-a728-a2e3309861ac",
              "title": "#initialization",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/diamond/00-init.ts",
              "file": "/src/test/diamond/00-init.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "sets correct state",
                  "fullTitle": "Diamond #initialization sets correct state",
                  "timedOut": false,
                  "duration": 6,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, _chai.expect)(await _hardhat.default.Diamond.owner()).to.equal(_hardhat.default.users.deployer.address);\n(0, _chai.expect)(await _hardhat.default.Diamond.initialized()).to.equal(true);",
                  "err": {},
                  "uuid": "f492fd49-60ae-49ed-8898-17306269d571",
                  "parentUUID": "6142f890-56ef-4d81-a728-a2e3309861ac",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "sets standard facet addresses",
                  "fullTitle": "Diamond #initialization sets standard facet addresses",
                  "timedOut": false,
                  "duration": 49,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const facetAddressesOnChain = (await _hardhat.default.Diamond.facets()).map((f)=>f.facetAddress);\nconst facetAddressesArtifact = f.facets.map((f)=>f.facetAddress);\n(0, _chai.expect)(facetAddressesOnChain.length).to.equal(facetAddressesArtifact.length);\n(0, _chai.expect)(facetAddressesOnChain).to.have.members(facetAddressesArtifact);",
                  "err": {},
                  "uuid": "9de055c7-073e-4118-aac2-041fe59a4231",
                  "parentUUID": "6142f890-56ef-4d81-a728-a2e3309861ac",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "sets selectors of standard facets",
                  "fullTitle": "Diamond #initialization sets selectors of standard facets",
                  "timedOut": false,
                  "duration": 49,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const facetsSelectorsOnChain = (await _hardhat.default.Diamond.facets()).flatMap((f)=>f.functionSelectors);\nconst facetSelectorsOnArtifact = f.facets.flatMap((f)=>f.functionSelectors);\n(0, _chai.expect)(facetsSelectorsOnChain.length).to.equal(facetSelectorsOnArtifact.length);\n(0, _chai.expect)(facetsSelectorsOnChain).to.have.members(facetSelectorsOnArtifact);",
                  "err": {},
                  "uuid": "782e62aa-cc1a-4a1e-9838-f58891e68db3",
                  "parentUUID": "6142f890-56ef-4d81-a728-a2e3309861ac",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "f492fd49-60ae-49ed-8898-17306269d571",
                "9de055c7-073e-4118-aac2-041fe59a4231",
                "782e62aa-cc1a-4a1e-9838-f58891e68db3"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 104,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "fa88341f-1e00-4b2d-baae-de010ce98338",
          "title": "Diamond",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/diamond/01-ownership.ts",
          "file": "/src/test/diamond/01-ownership.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"Diamond\"",
              "fullTitle": "Diamond \"before each\" hook in \"Diamond\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "await (0, _fixtures.diamondFixture)();",
              "err": {},
              "uuid": "7757b795-81dc-45ef-bea8-f43ee0dbfbf6",
              "parentUUID": "fa88341f-1e00-4b2d-baae-de010ce98338",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "2a65107c-939d-4032-baa1-f002f4c8b9d2",
              "title": "#ownership",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/diamond/01-ownership.ts",
              "file": "/src/test/diamond/01-ownership.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "sets correct owner",
                  "fullTitle": "Diamond #ownership sets correct owner",
                  "timedOut": false,
                  "duration": 3,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, _chai.expect)(await hre.Diamond.owner()).to.equal(hre.addr.deployer);",
                  "err": {},
                  "uuid": "6c8c46b1-5786-4430-bf73-513e497642ed",
                  "parentUUID": "2a65107c-939d-4032-baa1-f002f4c8b9d2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "sets correct default admin role",
                  "fullTitle": "Diamond #ownership sets correct default admin role",
                  "timedOut": false,
                  "duration": 4,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, _chai.expect)(await hre.Diamond.hasRole(_roles.Role.ADMIN, hre.addr.deployer)).to.equal(true);",
                  "err": {},
                  "uuid": "a7168890-6639-4a0d-9b1d-fc481284fd4a",
                  "parentUUID": "2a65107c-939d-4032-baa1-f002f4c8b9d2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "sets a new pending owner",
                  "fullTitle": "Diamond #ownership sets a new pending owner",
                  "timedOut": false,
                  "duration": 8,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const pendingOwner = hre.users.userOne;\nawait hre.Diamond.transferOwnership(pendingOwner.address);\n(0, _chai.expect)(await hre.Diamond.pendingOwner()).to.equal(pendingOwner.address);",
                  "err": {},
                  "uuid": "11240452-5c1f-43b9-9eeb-d8ccf83d858a",
                  "parentUUID": "2a65107c-939d-4032-baa1-f002f4c8b9d2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "sets the pending owner as new owner",
                  "fullTitle": "Diamond #ownership sets the pending owner as new owner",
                  "timedOut": false,
                  "duration": 14,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const pendingOwner = hre.users.userOne;\nawait hre.Diamond.transferOwnership(pendingOwner.address);\nawait hre.Diamond.connect(pendingOwner).acceptOwnership();\n(0, _chai.expect)(await hre.Diamond.owner()).to.equal(pendingOwner.address);",
                  "err": {},
                  "uuid": "691943e5-57e3-4c63-938f-57006f998d25",
                  "parentUUID": "2a65107c-939d-4032-baa1-f002f4c8b9d2",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "6c8c46b1-5786-4430-bf73-513e497642ed",
                "a7168890-6639-4a0d-9b1d-fc481284fd4a",
                "11240452-5c1f-43b9-9eeb-d8ccf83d858a",
                "691943e5-57e3-4c63-938f-57006f998d25"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 29,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "159a3821-21ff-430f-a29b-dd2168b3c840",
          "title": "Diamond",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/diamond/02-upgrades.ts",
          "file": "/src/test/diamond/02-upgrades.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"Diamond\"",
              "fullTitle": "Diamond \"before each\" hook in \"Diamond\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "await (0, _fixtures.diamondFixture)();",
              "err": {},
              "uuid": "d35db401-4bba-4f80-b285-7b42e7262765",
              "parentUUID": "159a3821-21ff-430f-a29b-dd2168b3c840",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "3f41feb0-b316-4dc5-9fa0-93da1ac7f929",
              "title": "#upgrades",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/diamond/02-upgrades.ts",
              "file": "/src/test/diamond/02-upgrades.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "can add a new facet",
                  "fullTitle": "Diamond #upgrades can add a new facet",
                  "timedOut": false,
                  "duration": 947,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const Factory = await _smock.smock.mock('SmockFacet');\nconst SmockFacet = await Factory.deploy();\nconst [SmockInitializer] = await hre.deploy('SmockInit');\nconst signatures = hre.getSignatures([\n    ..._typechain.SmockFacet__factory.abi\n]);\nconst Cut = {\n    facetAddress: SmockFacet.address,\n    functionSelectors: signatures,\n    action: _types.FacetCutAction.Add\n};\nconst initData = await SmockInitializer.populateTransaction.initialize(hre.addr.userOne);\nawait hre.Diamond.diamondCut([\n    Cut\n], initData.to, initData.data);\nconst TEST_OPERATOR_ROLE = hre.ethers.utils.id('kresko.test.operator');\nconst isTestOperator = await hre.Diamond.hasRole(TEST_OPERATOR_ROLE, hre.addr.userOne);\n// Succesfully added the new operator through the initialization contract\n(0, _chai.expect)(isTestOperator).to.equal(true);\nconst Facet = await hre.ethers.getContractAt([\n    ..._typechain.SmockFacet__factory.abi\n], hre.Diamond.address);\n// Ensure facet has it's own storage\nconst operatorFromNewStorage = await Facet.operator() // Retrieved from SmockStorage\n;\n(0, _chai.expect)(operatorFromNewStorage).to.equal(hre.addr.userOne);",
                  "err": {},
                  "uuid": "9710d655-9d6d-48d7-bcb1-169d64a14fd8",
                  "parentUUID": "3f41feb0-b316-4dc5-9fa0-93da1ac7f929",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can remove a facet",
                  "fullTitle": "Diamond #upgrades can remove a facet",
                  "timedOut": false,
                  "duration": 468,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const NewFacet = await (0, _addfacet.addFacet)({\n    name: 'SmockFacet',\n    initializerName: 'SmockInit',\n    initializerArgs: hre.addr.userOne\n});\nconst facetsBefore = await hre.Diamond.facets();\n(0, _chai.expect)(facetsBefore.filter((f)=>f.facetAddress === NewFacet.address).length).to.equal(1);\nawait (0, _removefacet.removeFacet)({\n    name: 'SmockFacet'\n});\nconst facetsAfter = await hre.Diamond.facets();\n(0, _chai.expect)(facetsBefore.length - facetsAfter.length).to.equal(1);\n(0, _chai.expect)(facetsAfter).to.not.deep.contain(NewFacet.address);",
                  "err": {},
                  "uuid": "b96ef108-8a37-4981-a770-1c499ce27575",
                  "parentUUID": "3f41feb0-b316-4dc5-9fa0-93da1ac7f929",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can remove a function",
                  "fullTitle": "Diamond #upgrades can remove a function",
                  "timedOut": false,
                  "duration": 52,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Delete acceptOwnership from DiamondStateFacet\n// Check there is no pending owner\nlet pendingOwner = await hre.Diamond.pendingOwner();\n(0, _chai.expect)(pendingOwner).to.equal(hre.ethers.constants.AddressZero);\n// Transfer to eg. wrong address\nconst wrongOwner = hre.addr.notAdmin;\nawait hre.Diamond.transferOwnership(wrongOwner);\n// Ensure\npendingOwner = await hre.Diamond.pendingOwner();\n(0, _chai.expect)(pendingOwner).to.equal(wrongOwner);\n// Fragment and signature for acceptOwnersip\nconst functionFragment = hre.Diamond.interface.functions['acceptOwnership()'];\nconst signature = hre.ethers.utils.Interface.getSighash(functionFragment);\nconst facetAddress = await hre.Diamond.facetAddress(signature);\nconst functions = await hre.Diamond.facetFunctionSelectors(facetAddress);\nconst Cut = {\n    facetAddress: hre.ethers.constants.AddressZero,\n    action: _types.FacetCutAction.Remove,\n    functionSelectors: [\n        signature\n    ]\n};\n// We will set a correct owner with delegatecall into the Diamond itself with the cut transaction\nconst correctOwner = hre.addr.userOne;\nconst initData = await hre.Diamond.populateTransaction.transferOwnership(correctOwner);\nawait hre.Diamond.diamondCut([\n    Cut\n], initData.to, initData.data);\n// Ensure rest of the functions remain\nconst functionsAfterCut = await hre.Diamond.facetFunctionSelectors(facetAddress);\n(0, _chai.expect)(functionsAfterCut.length).to.equal(functions.length - 1);\n// Ensure delegatecall did set the correct pending owner with the cut\nconst contract = await hre.ethers.getContractAt('DSCore', hre.Diamond.address);\nconst filter = contract.filters.PendingOwnershipTransfer(hre.addr.deployer, correctOwner);\nconst [event] = await contract.queryFilter(filter);\nconst { previousOwner, newOwner } = event.args;\n(0, _chai.expect)(previousOwner).to.equal(hre.addr.deployer);\n(0, _chai.expect)(newOwner).to.equal(correctOwner);\n// Ensure there is no function to accept the ownership\nawait (0, _chai.expect)(hre.Diamond.connect(hre.users.notAdmin).acceptOwnership()).to.be.reverted;",
                  "err": {},
                  "uuid": "42cdc273-6a17-4b1e-a338-2065a0db2e48",
                  "parentUUID": "3f41feb0-b316-4dc5-9fa0-93da1ac7f929",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can replace a function",
                  "fullTitle": "Diamond #upgrades can replace a function",
                  "timedOut": false,
                  "duration": 79,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Same as above but instead replace the function\n// Check there is no pending owner\nlet pendingOwner = await hre.Diamond.pendingOwner();\n(0, _chai.expect)(pendingOwner).to.equal(hre.ethers.constants.AddressZero);\n// Transfer to eg. wrong address\nconst wrongOwner = hre.addr.notAdmin;\nawait hre.Diamond.transferOwnership(wrongOwner);\n// Ensure\npendingOwner = await hre.Diamond.pendingOwner();\n(0, _chai.expect)(pendingOwner).to.equal(wrongOwner);\n// Fragment and signature for acceptOwnersip\nconst functionFragment = hre.Diamond.interface.functions['acceptOwnership()'];\nconst signature = hre.ethers.utils.Interface.getSighash(functionFragment);\nconst OldOwnershipFacet = await hre.Diamond.facetAddress(signature);\nconst [NewOwnershipFacet, allOwnershipFacetSignatures] = await hre.deploy('DiamondStateFacet', {\n    deploymentName: 'DiamondStateFacet2'\n});\n// Only replace a single function, we could replace all of them\nconst Cut = {\n    facetAddress: NewOwnershipFacet.address,\n    action: _types.FacetCutAction.Replace,\n    functionSelectors: [\n        signature\n    ]\n};\n// We will set a correct owner with delegatecall into the Diamond itself with the cut transaction\nconst correctOwner = hre.addr.userOne;\nconst initData = await hre.Diamond.populateTransaction.transferOwnership(correctOwner);\nawait hre.Diamond.diamondCut([\n    Cut\n], initData.to, initData.data);\n// Ensure function exists and revert is for invalid address instead of missing function\nawait (0, _chai.expect)(hre.Diamond.connect(hre.users.notAdmin).acceptOwnership()).to.be.reverted;\n// Ensure one function is contained in the new facet\nconst functionsNewFacet = await hre.Diamond.facetFunctionSelectors(NewOwnershipFacet.address);\n(0, _chai.expect)(functionsNewFacet.length).to.equal(1);\n(0, _chai.expect)(functionsNewFacet).to.have.members([\n    signature\n]);\n// Ensure rest are in the previous one\nconst functionsOldFacet = await hre.Diamond.facetFunctionSelectors(OldOwnershipFacet);\n(0, _chai.expect)(functionsOldFacet).to.not.have.members([\n    signature\n]);\n(0, _chai.expect)(functionsOldFacet.length).to.equal(allOwnershipFacetSignatures.length - 1);\n// Ensure correct owner can now accept the ownership\n(0, _chai.expect)(hre.Diamond.connect(hre.users.userOne).acceptOwnership());\nconst currentOwner = await hre.Diamond.owner();\n(0, _chai.expect)(currentOwner).to.equal(correctOwner);",
                  "err": {},
                  "uuid": "9b95f1e6-e4cf-4199-bd77-3669a7923df5",
                  "parentUUID": "3f41feb0-b316-4dc5-9fa0-93da1ac7f929",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can upgrade state",
                  "fullTitle": "Diamond #upgrades can upgrade state",
                  "timedOut": false,
                  "duration": 871,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, _chai.expect)(await hre.Diamond.initialized()).to.equal(true);\nconst Factory = await _smock.smock.mock('SmockInit');\nconst SmockInit = await Factory.deploy();\nconst tx = await SmockInit.populateTransaction.upgradeState();\nawait hre.Diamond.executeInitializer(tx.to, tx.data);\n(0, _chai.expect)(await hre.Diamond.initialized()).to.equal(false);",
                  "err": {},
                  "uuid": "11682660-3294-48a6-86fe-3a51e37ce8bf",
                  "parentUUID": "3f41feb0-b316-4dc5-9fa0-93da1ac7f929",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can preserve old state when extending storage layout",
                  "fullTitle": "Diamond #upgrades can preserve old state when extending storage layout",
                  "timedOut": false,
                  "duration": 1860,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, _chai.expect)(await hre.Diamond.initialized()).to.equal(true);\n// Add the first facet\nconst Factory = await _smock.smock.mock('SmockFacet');\nconst SmockFacet = await Factory.deploy();\nconst [SmockInitializer] = await hre.deploy('SmockInit');\nconst signatures = hre.getSignatures([\n    ..._typechain.SmockFacet__factory.abi\n]);\nconst Cut = {\n    facetAddress: SmockFacet.address,\n    functionSelectors: signatures,\n    action: _types.FacetCutAction.Add\n};\nconst initData = await SmockInitializer.populateTransaction.initialize(hre.addr.userOne);\nawait hre.Diamond.diamondCut([\n    Cut\n], initData.to, initData.data);\nconst Diamond = await hre.ethers.getContractAt('SmockFacet', hre.Diamond.address);\nconst isInitialized = await Diamond.smockInitialized();\n(0, _chai.expect)(isInitialized).to.equal(true);\n// Add facet with extended state\n// Add the first facet\nconst Factory2 = await _smock.smock.mock('SmockFacet2');\nconst SmockFacet2 = await Factory2.deploy();\nconst signatures2 = hre.getSignatures([\n    ..._typechain.SmockFacet2__factory.abi\n]);\nconst Cut2 = {\n    facetAddress: SmockFacet2.address,\n    functionSelectors: signatures2,\n    action: _types.FacetCutAction.Add\n};\n// Initializer only sets the new extended value, does not touch old storage\nconst initData2 = await SmockFacet2.populateTransaction.initialize();\nawait hre.Diamond.diamondCut([\n    Cut2\n], initData2.to, initData2.data);\n// Here we have appended the storage layout with the `extended` bool property.\nconst DiamondExtended = await hre.ethers.getContractAt('SmockFacet2', hre.Diamond.address);\nconst initializedAfterExtend = await DiamondExtended.getOldStructValueFromExtended();\nconst extendedValue = await DiamondExtended.getNewStructValueFromExtended();\n// Old values remain\n(0, _chai.expect)(initializedAfterExtend).to.equal(true);\n// And we get new ones\n(0, _chai.expect)(extendedValue).to.equal(true);",
                  "err": {},
                  "uuid": "f1970d9a-1f2e-4dc9-9a54-8f6ac0b089cd",
                  "parentUUID": "3f41feb0-b316-4dc5-9fa0-93da1ac7f929",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "9710d655-9d6d-48d7-bcb1-169d64a14fd8",
                "b96ef108-8a37-4981-a770-1c499ce27575",
                "42cdc273-6a17-4b1e-a338-2065a0db2e48",
                "9b95f1e6-e4cf-4199-bd77-3669a7923df5",
                "11682660-3294-48a6-86fe-3a51e37ce8bf",
                "f1970d9a-1f2e-4dc9-9a54-8f6ac0b089cd"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 4277,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "77b7b76d-655d-42a3-a6af-3ce9d9b834fb",
          "title": "Diamond",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/diamond/03-protocol.ts",
          "file": "/src/test/diamond/03-protocol.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"Diamond\"",
              "fullTitle": "Diamond \"before each\" hook in \"Diamond\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "await (0, _fixtures.defaultFixture)();",
              "err": {},
              "uuid": "ac482e3d-b07d-4c2d-8d79-a841b0df640b",
              "parentUUID": "77b7b76d-655d-42a3-a6af-3ce9d9b834fb",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "f8505da8-1e2f-42b7-a69b-bc5d56a0722f",
              "title": "#protocol initialization",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/diamond/03-protocol.ts",
              "file": "/src/test/diamond/03-protocol.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "initialized all facets",
                  "fullTitle": "Diamond #protocol initialization initialized all facets",
                  "timedOut": false,
                  "duration": 52,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const facetsOnChain = (await hre.Diamond.facets()).map(([facetAddress, functionSelectors])=>({\n        facetAddress,\n        functionSelectors\n    }));\nconst expectedFacets = await Promise.all([\n    ..._deploy.diamondFacets,\n    ..._deploy.minterFacets,\n    ..._deploy.scdpFacets,\n    ..._deploy.commonFacets,\n    ..._deploy.peripheryFacets\n].map(async (name)=>{\n    const deployment = await hre.deployments.get(name);\n    return {\n        facetAddress: deployment.address,\n        functionSelectors: facetsOnChain.find((f)=>f.facetAddress === deployment.address).functionSelectors\n    };\n}));\n(0, _chai.expect)(facetsOnChain).to.have.deep.members(expectedFacets);",
                  "err": {},
                  "uuid": "9e30c64d-bf60-4f49-961f-1fdd11bcdcb3",
                  "parentUUID": "f8505da8-1e2f-42b7-a69b-bc5d56a0722f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "initialized correct state",
                  "fullTitle": "Diamond #protocol initialization initialized correct state",
                  "timedOut": false,
                  "duration": 25,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, _chai.expect)(await hre.Diamond.getStorageVersion()).to.equal(3);\nconst GatingManager = await hre.deployments.get('GatingManager');\nconst { args } = await (0, _deploy.getCommonInitializer)(hre, GatingManager.address);\nconst { args: minterArgs } = await (0, _deploy.getMinterInitializer)(hre);\nconst { args: scdpArgs } = await (0, _deploy.getSCDPInitializer)(hre);\n(0, _chai.expect)(await hre.Diamond.hasRole(_roles.Role.ADMIN, args.admin)).to.equal(true);\n(0, _chai.expect)(await hre.Diamond.hasRole(_roles.Role.SAFETY_COUNCIL, hre.Multisig.address)).to.equal(true);\n(0, _chai.expect)(await hre.Diamond.getFeeRecipient()).to.equal(args.treasury);\n(0, _chai.expect)(await hre.Diamond.getPythEndpoint()).to.equal(args.pythEp);\n(0, _chai.expect)(await hre.Diamond.getMinCollateralRatioMinter()).to.equal(minterArgs.minCollateralRatio);\n(0, _chai.expect)(await hre.Diamond.getLiquidationThresholdMinter()).to.equal(minterArgs.liquidationThreshold);\n(0, _chai.expect)(await hre.Diamond.getMinDebtValueMinter()).to.equal(minterArgs.minDebtValue);\n(0, _chai.expect)(await hre.Diamond.getMaxLiquidationRatioMinter()).to.equal(Number(minterArgs.liquidationThreshold) + 0.01e4);\nconst scdpParams = await hre.Diamond.getParametersSCDP();\n(0, _chai.expect)(scdpParams.minCollateralRatio).to.equal(scdpArgs.minCollateralRatio);\n(0, _chai.expect)(scdpParams.liquidationThreshold).to.equal(scdpArgs.liquidationThreshold);\n(0, _chai.expect)(await hre.Diamond.getOracleDeviationPct()).to.equal(args.maxPriceDeviationPct);",
                  "err": {},
                  "uuid": "bbe62692-a055-4647-8324-c1c192fbcc45",
                  "parentUUID": "f8505da8-1e2f-42b7-a69b-bc5d56a0722f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can modify configuration parameters",
                  "fullTitle": "Diamond #protocol initialization can modify configuration parameters",
                  "timedOut": false,
                  "duration": 35,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, _chai.expect)(hre.Diamond.setMaxPriceDeviationPct(0.05e4)).to.not.be.reverted;\nawait (0, _chai.expect)(hre.Diamond.setSequencerGracePeriod(1000)).to.not.be.reverted;\nawait (0, _chai.expect)(hre.Diamond.setDefaultOraclePrecision(9)).to.not.be.reverted;\nawait (0, _chai.expect)(hre.Diamond.setMinDebtValueMinter(20e8)).to.not.be.reverted;\n(0, _chai.expect)(await hre.Diamond.getMinDebtValueMinter()).to.equal(20e8);\n(0, _chai.expect)(await hre.Diamond.getDefaultOraclePrecision()).to.equal(9);\n(0, _chai.expect)(await hre.Diamond.getOracleDeviationPct()).to.equal(0.05e4);\n(0, _chai.expect)(await hre.Diamond.getSequencerGracePeriod()).to.equal(1000);",
                  "err": {},
                  "uuid": "1785736e-ef45-4787-9216-836eb20febf9",
                  "parentUUID": "f8505da8-1e2f-42b7-a69b-bc5d56a0722f",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "9e30c64d-bf60-4f49-961f-1fdd11bcdcb3",
                "bbe62692-a055-4647-8324-c1c192fbcc45",
                "1785736e-ef45-4787-9216-836eb20febf9"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 112,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "31911e19-0806-4b06-bb83-114f99f8d5b9",
          "title": "Forking",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/forking/00-setup.ts",
          "file": "/src/test/forking/00-setup.ts",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "e2f30e85-f204-415d-aaa1-179a06055e95",
              "title": "#setup",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/forking/00-setup.ts",
              "file": "/src/test/forking/00-setup.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should get Kresko from the companion network locally",
                  "fullTitle": "Forking #setup should get Kresko from the companion network locally",
                  "timedOut": false,
                  "duration": 0,
                  "state": "pending",
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": true,
                  "context": null,
                  "code": "",
                  "err": {},
                  "uuid": "07e133be-f674-41ae-ae55-757ea1cd907d",
                  "parentUUID": "e2f30e85-f204-415d-aaa1-179a06055e95",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [],
              "failures": [],
              "pending": [
                "07e133be-f674-41ae-ae55-757ea1cd907d"
              ],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            },
            {
              "uuid": "46e0611c-eafb-48b9-9bbc-15efba04d8ff",
              "title": "#rate-upgrade-11-04-2023",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/forking/00-setup.ts",
              "file": "/src/test/forking/00-setup.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should be able to deploy facets",
                  "fullTitle": "Forking #rate-upgrade-11-04-2023 should be able to deploy facets",
                  "timedOut": false,
                  "duration": 0,
                  "state": "pending",
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": true,
                  "context": null,
                  "code": "",
                  "err": {},
                  "uuid": "0aa33dc8-661c-41a4-b73f-4a2c816e6864",
                  "parentUUID": "46e0611c-eafb-48b9-9bbc-15efba04d8ff",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [],
              "failures": [],
              "pending": [
                "0aa33dc8-661c-41a4-b73f-4a2c816e6864"
              ],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "dacf6375-99b3-42cb-bdf6-433a4e2bade0",
          "title": "KreskoAsset",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/krasset/00-init.ts",
          "file": "/src/test/krasset/00-init.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"KreskoAsset\"",
              "fullTitle": "KreskoAsset \"before each\" hook in \"KreskoAsset\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "f = await (0, _fixtures.kreskoAssetFixture)({\n    name,\n    symbol,\n    underlyingToken: _viem.zeroAddress\n});",
              "err": {},
              "uuid": "e1eea2c7-4192-47cc-8f9a-50b861c471a2",
              "parentUUID": "dacf6375-99b3-42cb-bdf6-433a4e2bade0",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "f96509fb-0796-4812-9f38-ce5bbf377cf6",
              "title": "KreskoAsset",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/krasset/00-init.ts",
              "file": "/src/test/krasset/00-init.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "sets correct state",
                  "fullTitle": "KreskoAsset KreskoAsset sets correct state",
                  "timedOut": false,
                  "duration": 21,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, _chai.expect)(await f.KreskoAsset.name()).to.equal(name);\n(0, _chai.expect)(await f.KreskoAsset.symbol()).to.equal(symbol);\n(0, _chai.expect)(await f.KreskoAsset.kresko()).to.equal(hre.Diamond.address);\n(0, _chai.expect)(await f.KreskoAsset.hasRole(_roles.Role.ADMIN, hre.addr.deployer)).to.equal(true);\n(0, _chai.expect)(await f.KreskoAsset.hasRole(_roles.Role.OPERATOR, hre.Diamond.address)).to.equal(true);\n(0, _chai.expect)(await f.KreskoAsset.totalSupply()).to.equal(0);\n(0, _chai.expect)(await f.KreskoAsset.isRebased()).to.equal(false);\nconst rebaseInfo = await f.KreskoAsset.rebaseInfo();\n(0, _chai.expect)(rebaseInfo.denominator).to.equal(0);\n(0, _chai.expect)(rebaseInfo.positive).to.equal(false);",
                  "err": {},
                  "uuid": "0efbbed7-9d69-47a3-8f04-e425ebbc0f5c",
                  "parentUUID": "f96509fb-0796-4812-9f38-ce5bbf377cf6",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can reinitialize metadata",
                  "fullTitle": "KreskoAsset KreskoAsset can reinitialize metadata",
                  "timedOut": false,
                  "duration": 15,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const newName = 'foo';\nconst newSymbol = 'bar';\nawait (0, _chai.expect)(f.KreskoAsset.reinitializeERC20(newName, newSymbol, 2)).to.not.be.reverted;\n(0, _chai.expect)(await f.KreskoAsset.name()).to.equal(newName);\n(0, _chai.expect)(await f.KreskoAsset.symbol()).to.equal(newSymbol);",
                  "err": {},
                  "uuid": "bc3f2367-91a2-41f7-81ee-43d84adce973",
                  "parentUUID": "f96509fb-0796-4812-9f38-ce5bbf377cf6",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [
                {
                  "uuid": "db6364d5-02c9-434a-84d6-e5fbe45c9e70",
                  "title": "#initialization",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/krasset/00-init.ts",
                  "file": "/src/test/krasset/00-init.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "cant initialize twice",
                      "fullTitle": "KreskoAsset KreskoAsset #initialization cant initialize twice",
                      "timedOut": false,
                      "duration": 11,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, _chai.expect)(f.KreskoAsset.initialize(name, symbol, 18, hre.addr.deployer, hre.Diamond.address, hre.ethers.constants.AddressZero, hre.addr.deployer, 0, 0)).to.be.reverted;",
                      "err": {},
                      "uuid": "33ef3bfd-33b2-470d-ae63-2540ab65fc48",
                      "parentUUID": "db6364d5-02c9-434a-84d6-e5fbe45c9e70",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "cant initialize implementation",
                      "fullTitle": "KreskoAsset KreskoAsset #initialization cant initialize implementation",
                      "timedOut": false,
                      "duration": 0,
                      "state": "pending",
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": true,
                      "context": null,
                      "code": "",
                      "err": {},
                      "uuid": "1cc4fb4b-ace3-4d14-bb6c-2d2b1966f730",
                      "parentUUID": "db6364d5-02c9-434a-84d6-e5fbe45c9e70",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "sets correct state",
                      "fullTitle": "KreskoAsset KreskoAsset #initialization sets correct state",
                      "timedOut": false,
                      "duration": 27,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "(0, _chai.expect)(await f.KreskoAsset.name()).to.equal(name);\n(0, _chai.expect)(await f.KreskoAsset.symbol()).to.equal(symbol);\n(0, _chai.expect)(await f.KreskoAsset.kresko()).to.equal(hre.Diamond.address);\n(0, _chai.expect)(await f.KreskoAsset.hasRole(_roles.Role.DEFAULT_ADMIN, hre.addr.deployer)).to.equal(true);\n(0, _chai.expect)(await f.KreskoAsset.hasRole(_roles.Role.ADMIN, hre.addr.deployer)).to.equal(true);\n(0, _chai.expect)(await f.KreskoAsset.hasRole(_roles.Role.OPERATOR, hre.Diamond.address)).to.equal(true);\n(0, _chai.expect)(await f.KreskoAsset.totalSupply()).to.equal(0);\n(0, _chai.expect)(await f.KreskoAsset.isRebased()).to.equal(false);\nconst rebaseInfo = await f.KreskoAsset.rebaseInfo();\n(0, _chai.expect)(rebaseInfo.denominator).to.equal(0);\n(0, _chai.expect)(rebaseInfo.positive).to.equal(false);",
                      "err": {},
                      "uuid": "66fc25e0-0aa5-4929-98be-3dd283510f63",
                      "parentUUID": "db6364d5-02c9-434a-84d6-e5fbe45c9e70",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "can reinitialize metadata",
                      "fullTitle": "KreskoAsset KreskoAsset #initialization can reinitialize metadata",
                      "timedOut": false,
                      "duration": 17,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const newName = 'foo';\nconst newSymbol = 'bar';\nawait (0, _chai.expect)(f.KreskoAsset.reinitializeERC20(newName, newSymbol, 2)).to.not.be.reverted;\n(0, _chai.expect)(await f.KreskoAsset.name()).to.equal(newName);\n(0, _chai.expect)(await f.KreskoAsset.symbol()).to.equal(newSymbol);",
                      "err": {},
                      "uuid": "6391f098-5747-4b2e-8679-8b342c06231b",
                      "parentUUID": "db6364d5-02c9-434a-84d6-e5fbe45c9e70",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "33ef3bfd-33b2-470d-ae63-2540ab65fc48",
                    "66fc25e0-0aa5-4929-98be-3dd283510f63",
                    "6391f098-5747-4b2e-8679-8b342c06231b"
                  ],
                  "failures": [],
                  "pending": [
                    "1cc4fb4b-ace3-4d14-bb6c-2d2b1966f730"
                  ],
                  "skipped": [],
                  "duration": 55,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                }
              ],
              "passes": [
                "0efbbed7-9d69-47a3-8f04-e425ebbc0f5c",
                "bc3f2367-91a2-41f7-81ee-43d84adce973"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 36,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            },
            {
              "uuid": "da11ab01-fd28-4a30-883f-8711a5446537",
              "title": "#initialization - anchor",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/krasset/00-init.ts",
              "file": "/src/test/krasset/00-init.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "cant initialize twice",
                  "fullTitle": "KreskoAsset #initialization - anchor cant initialize twice",
                  "timedOut": false,
                  "duration": 6,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, _chai.expect)(f.KreskoAssetAnchor.initialize(f.KreskoAsset.address, name, symbol, hre.addr.deployer)).to.be.reverted;",
                  "err": {},
                  "uuid": "246ff467-4c9c-4a13-818c-a5b769f0fabf",
                  "parentUUID": "da11ab01-fd28-4a30-883f-8711a5446537",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "sets correct state",
                  "fullTitle": "KreskoAsset #initialization - anchor sets correct state",
                  "timedOut": false,
                  "duration": 26,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, _chai.expect)(await f.KreskoAssetAnchor.name()).to.equal(anchorName);\n(0, _chai.expect)(await f.KreskoAssetAnchor.symbol()).to.equal(anchorSymbol);\n(0, _chai.expect)(await f.KreskoAssetAnchor.asset()).to.equal(f.KreskoAsset.address);\n(0, _chai.expect)(await f.KreskoAssetAnchor.hasRole(_roles.Role.ADMIN, hre.addr.deployer)).to.equal(true);\n(0, _chai.expect)(await f.KreskoAssetAnchor.hasRole(_roles.Role.OPERATOR, hre.Diamond.address)).to.equal(true);\n(0, _chai.expect)(await f.KreskoAssetAnchor.totalSupply()).to.equal(0);\n(0, _chai.expect)(await f.KreskoAssetAnchor.totalAssets()).to.equal(await f.KreskoAsset.totalSupply());\nconst rebaseInfo = await f.KreskoAsset.rebaseInfo();\n(0, _chai.expect)(rebaseInfo.denominator).to.equal(0);\n(0, _chai.expect)(rebaseInfo.positive).to.equal(false);",
                  "err": {},
                  "uuid": "4adcc1bc-7421-4b3f-a5e2-00da259c9b0b",
                  "parentUUID": "da11ab01-fd28-4a30-883f-8711a5446537",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "cant initialize implementation",
                  "fullTitle": "KreskoAsset #initialization - anchor cant initialize implementation",
                  "timedOut": false,
                  "duration": 29,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const deployment = await hre.deployments.get(anchorSymbol);\nconst implementationAddress = deployment.implementation;\n(0, _chai.expect)(implementationAddress).to.not.equal(hre.ethers.constants.AddressZero);\nconst KreskoAssetAnchorImpl = await hre.ethers.getContractAt('KreskoAssetAnchor', implementationAddress);\nawait (0, _chai.expect)(KreskoAssetAnchorImpl.initialize(f.KreskoAsset.address, name, symbol, hre.addr.deployer)).to.be.reverted;",
                  "err": {},
                  "uuid": "6cbfed41-33f8-4fd5-ab33-08405a7580ad",
                  "parentUUID": "da11ab01-fd28-4a30-883f-8711a5446537",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can reinitialize metadata",
                  "fullTitle": "KreskoAsset #initialization - anchor can reinitialize metadata",
                  "timedOut": false,
                  "duration": 21,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const newName = 'foo';\nconst newSymbol = 'bar';\nawait (0, _chai.expect)(f.KreskoAssetAnchor.reinitializeERC20(newName, newSymbol, 2)).to.not.be.reverted;\n(0, _chai.expect)(await f.KreskoAssetAnchor.name()).to.equal(newName);\n(0, _chai.expect)(await f.KreskoAssetAnchor.symbol()).to.equal(newSymbol);\nawait f.KreskoAssetAnchor.reinitializeERC20(name, symbol, 3);",
                  "err": {},
                  "uuid": "5f60ac6b-5ba9-4430-86c5-f500ebc41b77",
                  "parentUUID": "da11ab01-fd28-4a30-883f-8711a5446537",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "246ff467-4c9c-4a13-818c-a5b769f0fabf",
                "4adcc1bc-7421-4b3f-a5e2-00da259c9b0b",
                "6cbfed41-33f8-4fd5-ab33-08405a7580ad",
                "5f60ac6b-5ba9-4430-86c5-f500ebc41b77"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 82,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "1614928a-54af-40fe-913e-0162fc0d6c28",
          "title": "KreskoAsset",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/krasset/01-erc20.ts",
          "file": "/src/test/krasset/01-erc20.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"KreskoAsset\"",
              "fullTitle": "KreskoAsset \"before each\" hook in \"KreskoAsset\"",
              "timedOut": false,
              "duration": 7,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "({ KreskoAsset } = await (0, _fixtures.kreskoAssetFixture)({\n    name: 'Ether',\n    symbol: 'krETH',\n    underlyingToken: _viem.zeroAddress\n}));\nthis.mintAmount = 125;\nthis.owner = hre.users.deployer;\nawait KreskoAsset.grantRole(_roles.Role.OPERATOR, this.owner.address);",
              "err": {},
              "uuid": "7c815770-b832-40f8-b887-6c8a798dd18a",
              "parentUUID": "1614928a-54af-40fe-913e-0162fc0d6c28",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "e4cb0360-41bb-4830-89c5-4f72b6ffde52",
              "title": "#mint",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/krasset/01-erc20.ts",
              "file": "/src/test/krasset/01-erc20.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should allow the owner to mint to their own address",
                  "fullTitle": "KreskoAsset #mint should allow the owner to mint to their own address",
                  "timedOut": false,
                  "duration": 18,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, _chai.expect)(await KreskoAsset.totalSupply()).to.equal(0);\n(0, _chai.expect)(await KreskoAsset.balanceOf(this.owner.address)).to.equal(0);\nawait KreskoAsset.connect(this.owner).mint(this.owner.address, this.mintAmount);\n// Check total supply and owner's balances increased\n(0, _chai.expect)(await KreskoAsset.totalSupply()).to.equal(this.mintAmount);\n(0, _chai.expect)(await KreskoAsset.balanceOf(this.owner.address)).to.equal(this.mintAmount);",
                  "err": {},
                  "uuid": "5bd5bc05-e9e9-46d5-9d97-68336d33eb45",
                  "parentUUID": "e4cb0360-41bb-4830-89c5-4f72b6ffde52",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should allow the asset owner to mint to another address",
                  "fullTitle": "KreskoAsset #mint should allow the asset owner to mint to another address",
                  "timedOut": false,
                  "duration": 16,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, _chai.expect)(await KreskoAsset.totalSupply()).to.equal(0);\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.users.userOne.address)).to.equal(0);\nawait KreskoAsset.connect(this.owner).mint(hre.users.userOne.address, this.mintAmount);\n// Check total supply and user's balances increased\n(0, _chai.expect)(await KreskoAsset.totalSupply()).to.equal(this.mintAmount);\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.users.userOne.address)).to.equal(this.mintAmount);",
                  "err": {},
                  "uuid": "7c158374-562d-4792-bec0-ec10017417f4",
                  "parentUUID": "e4cb0360-41bb-4830-89c5-4f72b6ffde52",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not allow non-owner addresses to mint tokens",
                  "fullTitle": "KreskoAsset #mint should not allow non-owner addresses to mint tokens",
                  "timedOut": false,
                  "duration": 18,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, _chai.expect)(await KreskoAsset.totalSupply()).to.equal(0);\n(0, _chai.expect)(await KreskoAsset.balanceOf(this.owner.address)).to.equal(0);\nawait (0, _chai.expect)(KreskoAsset.connect(hre.users.userOne).mint(this.owner.address, this.mintAmount)).to.be.reverted;\n// Check total supply and all account balances unchanged\n(0, _chai.expect)(await KreskoAsset.totalSupply()).to.equal(0);\n(0, _chai.expect)(await KreskoAsset.balanceOf(this.owner.address)).to.equal(0);\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.users.userOne.address)).to.equal(0);",
                  "err": {},
                  "uuid": "ae69d2d2-bf4d-43c0-93cc-5518a2f220d1",
                  "parentUUID": "e4cb0360-41bb-4830-89c5-4f72b6ffde52",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not allow admin to mint tokens",
                  "fullTitle": "KreskoAsset #mint should not allow admin to mint tokens",
                  "timedOut": false,
                  "duration": 9,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await KreskoAsset.renounceRole(_roles.Role.OPERATOR, this.owner.address);\nawait (0, _chai.expect)(KreskoAsset.connect(this.owner).mint(this.owner.address, this.mintAmount)).to.be.reverted;",
                  "err": {},
                  "uuid": "68f455f2-be64-4be1-a721-2362ce50e584",
                  "parentUUID": "e4cb0360-41bb-4830-89c5-4f72b6ffde52",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "5bd5bc05-e9e9-46d5-9d97-68336d33eb45",
                "7c158374-562d-4792-bec0-ec10017417f4",
                "ae69d2d2-bf4d-43c0-93cc-5518a2f220d1",
                "68f455f2-be64-4be1-a721-2362ce50e584"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 61,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            },
            {
              "uuid": "c91bd5c8-7878-41e0-8c62-56cea4f9a3e8",
              "title": "#burn",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/krasset/01-erc20.ts",
              "file": "/src/test/krasset/01-erc20.ts",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"#burn\"",
                  "fullTitle": "KreskoAsset #burn \"before each\" hook in \"#burn\"",
                  "timedOut": false,
                  "duration": 11,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await KreskoAsset.connect(this.owner).mint(hre.users.userOne.address, this.mintAmount);\nthis.owner = hre.users.deployer;\nthis.mintAmount = 125;\nawait KreskoAsset.grantRole(_roles.Role.OPERATOR, this.owner.address);",
                  "err": {},
                  "uuid": "6ed0d622-0c69-44e3-bbae-4faece0c62e5",
                  "parentUUID": "c91bd5c8-7878-41e0-8c62-56cea4f9a3e8",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should allow the owner to burn tokens from user's address (without token allowance)",
                  "fullTitle": "KreskoAsset #burn should allow the owner to burn tokens from user's address (without token allowance)",
                  "timedOut": false,
                  "duration": 15,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, _chai.expect)(await KreskoAsset.totalSupply()).to.equal(this.mintAmount);\nawait KreskoAsset.connect(this.owner).burn(hre.users.userOne.address, this.mintAmount);\n// Check total supply and user's balances decreased\n(0, _chai.expect)(await KreskoAsset.totalSupply()).to.equal(0);\n(0, _chai.expect)(await KreskoAsset.balanceOf(this.owner.address)).to.equal(0);\n// Confirm that owner doesn't hold any tokens\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.users.userOne.address)).to.equal(0);",
                  "err": {},
                  "uuid": "f83257d1-873b-45b9-a088-f9df9caa21e4",
                  "parentUUID": "c91bd5c8-7878-41e0-8c62-56cea4f9a3e8",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should allow the operator to burn tokens from user's address without changing existing allowances",
                  "fullTitle": "KreskoAsset #burn should allow the operator to burn tokens from user's address without changing existing allowances",
                  "timedOut": false,
                  "duration": 27,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await KreskoAsset.connect(this.owner).approve(hre.users.userOne.address, this.mintAmount);\n(0, _chai.expect)(await KreskoAsset.totalSupply()).to.equal(this.mintAmount);\n(0, _chai.expect)(await KreskoAsset.allowance(this.owner.address, hre.users.userOne.address)).to.equal(this.mintAmount);\nawait KreskoAsset.connect(this.owner).burn(hre.users.userOne.address, this.mintAmount);\n// Check total supply and user's balances decreased\n(0, _chai.expect)(await KreskoAsset.totalSupply()).to.equal(0);\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.users.userOne.address)).to.equal(0);\n// Confirm that owner doesn't hold any tokens\n(0, _chai.expect)(await KreskoAsset.balanceOf(this.owner.address)).to.equal(0);\n// Confirm that token allowances are unchanged\n(0, _chai.expect)(await KreskoAsset.allowance(this.owner.address, hre.users.userOne.address)).to.equal(this.mintAmount);",
                  "err": {},
                  "uuid": "75123b1a-c5fe-42eb-91ba-68cb590d8064",
                  "parentUUID": "c91bd5c8-7878-41e0-8c62-56cea4f9a3e8",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not allow the operator to burn more tokens than user holds",
                  "fullTitle": "KreskoAsset #burn should not allow the operator to burn more tokens than user holds",
                  "timedOut": false,
                  "duration": 11,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const userBalance = await KreskoAsset.balanceOf(hre.users.userOne.address);\nconst overUserBalance = Number(userBalance) + 1;\nawait (0, _chai.expect)(KreskoAsset.connect(this.owner).burn(hre.users.userOne.address, overUserBalance)).to.be.reverted;\n// Check total supply and user's balances are unchanged\n(0, _chai.expect)(await KreskoAsset.totalSupply()).to.equal(this.mintAmount);\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.users.userOne.address)).to.equal(this.mintAmount);",
                  "err": {},
                  "uuid": "d64ba3fc-2f02-4740-a420-3cfd7eceea3e",
                  "parentUUID": "c91bd5c8-7878-41e0-8c62-56cea4f9a3e8",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not allow non-operator addresses to burn tokens",
                  "fullTitle": "KreskoAsset #burn should not allow non-operator addresses to burn tokens",
                  "timedOut": false,
                  "duration": 11,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, _chai.expect)(KreskoAsset.connect(hre.users.userTwo).burn(hre.users.userOne.address, this.mintAmount)).to.be.revertedWithCustomError(KreskoAsset, 'AccessControlUnauthorizedAccount').withArgs(hre.users.userTwo.address, _roles.Role.OPERATOR);\n// Check total supply and user's balances unchanged\n(0, _chai.expect)(await KreskoAsset.totalSupply()).to.equal(this.mintAmount);\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.users.userOne.address)).to.equal(this.mintAmount);",
                  "err": {},
                  "uuid": "47b7094f-f735-46e9-8ee5-fa1139781f84",
                  "parentUUID": "c91bd5c8-7878-41e0-8c62-56cea4f9a3e8",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "f83257d1-873b-45b9-a088-f9df9caa21e4",
                "75123b1a-c5fe-42eb-91ba-68cb590d8064",
                "d64ba3fc-2f02-4740-a420-3cfd7eceea3e",
                "47b7094f-f735-46e9-8ee5-fa1139781f84"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 64,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "4b6f1764-586e-4a9f-9de4-a99e71caf830",
          "title": "KreskoAsset",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/krasset/02-krasset.ts",
          "file": "/src/test/krasset/02-krasset.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"KreskoAsset\"",
              "fullTitle": "KreskoAsset \"before each\" hook in \"KreskoAsset\"",
              "timedOut": false,
              "duration": 851,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const result = await hre.deployments.fixture('diamond-init');\nif (result.Diamond) {\n    hre.Diamond = await hre.getContractOrFork('Kresko');\n}\nKreskoAsset = (await (0, _createkrasset.createKrAsset)('krSYMBOL', 'Kresko Asset: SYMBOL', 18, _viem.zeroAddress)).KreskoAsset;\n// Grant minting rights for test deployer\nawait KreskoAsset.grantRole(_roles.Role.OPERATOR, hre.addr.deployer);",
              "err": {},
              "uuid": "eaaa963f-a862-44f2-a349-11449230d4bb",
              "parentUUID": "4b6f1764-586e-4a9f-9de4-a99e71caf830",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "c1f27476-6d92-464a-b1c7-6224dc6a415e",
              "title": "#rebase",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/krasset/02-krasset.ts",
              "file": "/src/test/krasset/02-krasset.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "can set a positive rebase",
                  "fullTitle": "KreskoAsset #rebase can set a positive rebase",
                  "timedOut": false,
                  "duration": 10,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const denominator = (0, _values.toBig)('1.525');\nconst positive = true;\nawait (0, _chai.expect)(KreskoAsset.rebase(denominator, positive, [])).to.not.be.reverted;\n(0, _chai.expect)(await KreskoAsset.isRebased()).to.equal(true);\nconst rebaseInfo = await KreskoAsset.rebaseInfo();\n(0, _chai.expect)(rebaseInfo.denominator).equal(denominator);\n(0, _chai.expect)(rebaseInfo.positive).equal(true);",
                  "err": {},
                  "uuid": "a9f68b9d-7417-4ffb-b9dc-2fcfe6bd6640",
                  "parentUUID": "c1f27476-6d92-464a-b1c7-6224dc6a415e",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can set a negative rebase",
                  "fullTitle": "KreskoAsset #rebase can set a negative rebase",
                  "timedOut": false,
                  "duration": 10,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const denominator = (0, _values.toBig)('1.525');\nconst positive = false;\nawait (0, _chai.expect)(KreskoAsset.rebase(denominator, positive, [])).to.not.be.reverted;\n(0, _chai.expect)(await KreskoAsset.isRebased()).to.equal(true);\nconst rebaseInfo = await KreskoAsset.rebaseInfo();\n(0, _chai.expect)(rebaseInfo.denominator).equal(denominator);\n(0, _chai.expect)(rebaseInfo.positive).equal(false);",
                  "err": {},
                  "uuid": "ed9159f5-5786-48a6-b96d-d4f29e89d23e",
                  "parentUUID": "c1f27476-6d92-464a-b1c7-6224dc6a415e",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can be disabled by setting the denominator to 1 ether",
                  "fullTitle": "KreskoAsset #rebase can be disabled by setting the denominator to 1 ether",
                  "timedOut": false,
                  "duration": 8,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const denominator = (0, _values.toBig)(1);\nconst positive = false;\nawait (0, _chai.expect)(KreskoAsset.rebase(denominator, positive, [])).to.not.be.reverted;\n(0, _chai.expect)(await KreskoAsset.isRebased()).to.equal(false);",
                  "err": {},
                  "uuid": "45036dcd-e429-4093-8f11-bff530ee7e98",
                  "parentUUID": "c1f27476-6d92-464a-b1c7-6224dc6a415e",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [
                {
                  "uuid": "fd488436-e92a-4068-9a32-0ccba5bd0561",
                  "title": "#balance + supply",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/krasset/02-krasset.ts",
                  "file": "/src/test/krasset/02-krasset.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "has no effect when not enabled",
                      "fullTitle": "KreskoAsset #rebase #balance + supply has no effect when not enabled",
                      "timedOut": false,
                      "duration": 10,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await KreskoAsset.mint(hre.addr.deployer, _mocks.defaultMintAmount);\n(0, _chai.expect)(await KreskoAsset.isRebased()).to.equal(false);\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.addr.deployer)).to.equal(_mocks.defaultMintAmount);",
                      "err": {},
                      "uuid": "a988020e-6a36-41d5-9721-acc2f7b2a953",
                      "parentUUID": "fd488436-e92a-4068-9a32-0ccba5bd0561",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "increases balance and supply with positive rebase @ 2",
                      "fullTitle": "KreskoAsset #rebase #balance + supply increases balance and supply with positive rebase @ 2",
                      "timedOut": false,
                      "duration": 14,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const denominator = 2;\nconst positive = true;\nawait KreskoAsset.mint(hre.addr.deployer, _mocks.defaultMintAmount);\nawait KreskoAsset.rebase((0, _values.toBig)(denominator), positive, []);\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.addr.deployer)).to.equal(_mocks.defaultMintAmount.mul(denominator));\n(0, _chai.expect)(await KreskoAsset.totalSupply()).to.equal(_mocks.defaultMintAmount.mul(denominator));",
                      "err": {},
                      "uuid": "66464447-0afd-46bd-91a9-ab93055d7d29",
                      "parentUUID": "fd488436-e92a-4068-9a32-0ccba5bd0561",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "increases balance and supply with positive rebase @ 3",
                      "fullTitle": "KreskoAsset #rebase #balance + supply increases balance and supply with positive rebase @ 3",
                      "timedOut": false,
                      "duration": 15,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const denominator = 3;\nconst positive = true;\nawait KreskoAsset.mint(hre.addr.deployer, _mocks.defaultMintAmount);\nawait KreskoAsset.rebase((0, _values.toBig)(denominator), positive, []);\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.addr.deployer)).to.equal(_mocks.defaultMintAmount.mul(denominator));\n(0, _chai.expect)(await KreskoAsset.totalSupply()).to.equal(_mocks.defaultMintAmount.mul(denominator));",
                      "err": {},
                      "uuid": "e53e6037-fa6f-4abe-a50a-c1f6b15ca0b9",
                      "parentUUID": "fd488436-e92a-4068-9a32-0ccba5bd0561",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "increases balance and supply with positive rebase  @ 100",
                      "fullTitle": "KreskoAsset #rebase #balance + supply increases balance and supply with positive rebase  @ 100",
                      "timedOut": false,
                      "duration": 14,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const denominator = 100;\nconst positive = true;\nawait KreskoAsset.mint(hre.addr.deployer, _mocks.defaultMintAmount);\nawait KreskoAsset.rebase((0, _values.toBig)(denominator), positive, []);\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.addr.deployer)).to.equal(_mocks.defaultMintAmount.mul(denominator));\n(0, _chai.expect)(await KreskoAsset.totalSupply()).to.equal(_mocks.defaultMintAmount.mul(denominator));",
                      "err": {},
                      "uuid": "d0597ddb-22a4-479e-9e09-7f51b2861289",
                      "parentUUID": "fd488436-e92a-4068-9a32-0ccba5bd0561",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "reduces balance and supply with negative rebase @ 2",
                      "fullTitle": "KreskoAsset #rebase #balance + supply reduces balance and supply with negative rebase @ 2",
                      "timedOut": false,
                      "duration": 15,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const denominator = 2;\nconst positive = false;\nawait KreskoAsset.mint(hre.addr.deployer, _mocks.defaultMintAmount);\nawait KreskoAsset.rebase((0, _values.toBig)(denominator), positive, []);\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.addr.deployer)).to.equal(_mocks.defaultMintAmount.div(denominator));\n(0, _chai.expect)(await KreskoAsset.totalSupply()).to.equal(_mocks.defaultMintAmount.div(denominator));",
                      "err": {},
                      "uuid": "ba3145fd-731b-47ef-97ce-1f2a4cca9ec1",
                      "parentUUID": "fd488436-e92a-4068-9a32-0ccba5bd0561",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "reduces balance and supply with negative rebase @ 3",
                      "fullTitle": "KreskoAsset #rebase #balance + supply reduces balance and supply with negative rebase @ 3",
                      "timedOut": false,
                      "duration": 14,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const denominator = 3;\nconst positive = false;\nawait KreskoAsset.mint(hre.addr.deployer, _mocks.defaultMintAmount);\nawait KreskoAsset.rebase((0, _values.toBig)(denominator), positive, []);\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.addr.deployer)).to.equal(_mocks.defaultMintAmount.div(denominator));\n(0, _chai.expect)(await KreskoAsset.totalSupply()).to.equal(_mocks.defaultMintAmount.div(denominator));",
                      "err": {},
                      "uuid": "d750d3fc-ff58-4590-999e-cbd6698c58be",
                      "parentUUID": "fd488436-e92a-4068-9a32-0ccba5bd0561",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "reduces balance and supply with negative rebase @ 100",
                      "fullTitle": "KreskoAsset #rebase #balance + supply reduces balance and supply with negative rebase @ 100",
                      "timedOut": false,
                      "duration": 14,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const denominator = 100;\nconst positive = false;\nawait KreskoAsset.mint(hre.addr.deployer, _mocks.defaultMintAmount);\nawait KreskoAsset.rebase((0, _values.toBig)(denominator), positive, []);\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.addr.deployer)).to.equal(_mocks.defaultMintAmount.div(denominator));\n(0, _chai.expect)(await KreskoAsset.totalSupply()).to.equal(_mocks.defaultMintAmount.div(denominator));",
                      "err": {},
                      "uuid": "e42b8b83-0e31-4f88-8761-c8069b3caa40",
                      "parentUUID": "fd488436-e92a-4068-9a32-0ccba5bd0561",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "a988020e-6a36-41d5-9721-acc2f7b2a953",
                    "66464447-0afd-46bd-91a9-ab93055d7d29",
                    "e53e6037-fa6f-4abe-a50a-c1f6b15ca0b9",
                    "d0597ddb-22a4-479e-9e09-7f51b2861289",
                    "ba3145fd-731b-47ef-97ce-1f2a4cca9ec1",
                    "d750d3fc-ff58-4590-999e-cbd6698c58be",
                    "e42b8b83-0e31-4f88-8761-c8069b3caa40"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 96,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                },
                {
                  "uuid": "dc0f42dc-f2c5-4207-b1a3-298b260eb9ca",
                  "title": "#transfer",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/krasset/02-krasset.ts",
                  "file": "/src/test/krasset/02-krasset.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "has default transfer behaviour after positive rebase",
                      "fullTitle": "KreskoAsset #rebase #transfer has default transfer behaviour after positive rebase",
                      "timedOut": false,
                      "duration": 24,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const transferAmount = (0, _values.toBig)(1);\nawait KreskoAsset.mint(hre.addr.deployer, _mocks.defaultMintAmount);\nawait KreskoAsset.mint(hre.addr.userOne, _mocks.defaultMintAmount);\nconst denominator = 2;\nconst positive = true;\nawait KreskoAsset.rebase((0, _values.toBig)(denominator), positive, []);\nconst rebaseInfodDefaultMintAMount = _mocks.defaultMintAmount.mul(denominator);\nawait KreskoAsset.transfer(hre.addr.userOne, transferAmount);\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.addr.userOne)).to.equal(rebaseInfodDefaultMintAMount.add(transferAmount));\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.addr.deployer)).to.equal(rebaseInfodDefaultMintAMount.sub(transferAmount));",
                      "err": {},
                      "uuid": "cef7e652-f462-438a-a2ba-ed21652e396f",
                      "parentUUID": "dc0f42dc-f2c5-4207-b1a3-298b260eb9ca",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "has default transfer behaviour after negative rebase",
                      "fullTitle": "KreskoAsset #rebase #transfer has default transfer behaviour after negative rebase",
                      "timedOut": false,
                      "duration": 23,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const transferAmount = (0, _values.toBig)(1);\nawait KreskoAsset.mint(hre.addr.deployer, _mocks.defaultMintAmount);\nawait KreskoAsset.mint(hre.addr.userOne, _mocks.defaultMintAmount);\nconst denominator = 2;\nconst positive = false;\nawait KreskoAsset.rebase((0, _values.toBig)(denominator), positive, []);\nconst rebaseInfodDefaultMintAMount = _mocks.defaultMintAmount.div(denominator);\nawait KreskoAsset.transfer(hre.addr.userOne, transferAmount);\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.addr.userOne)).to.equal(rebaseInfodDefaultMintAMount.add(transferAmount));\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.addr.deployer)).to.equal(rebaseInfodDefaultMintAMount.sub(transferAmount));",
                      "err": {},
                      "uuid": "a59e5174-7866-4d5d-9d18-7fb40a696b53",
                      "parentUUID": "dc0f42dc-f2c5-4207-b1a3-298b260eb9ca",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "has default transferFrom behaviour after positive rebase",
                      "fullTitle": "KreskoAsset #rebase #transfer has default transferFrom behaviour after positive rebase",
                      "timedOut": false,
                      "duration": 36,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const transferAmount = (0, _values.toBig)(1);\nawait KreskoAsset.mint(hre.addr.deployer, _mocks.defaultMintAmount);\nawait KreskoAsset.mint(hre.addr.userOne, _mocks.defaultMintAmount);\nconst denominator = 2;\nconst positive = true;\nawait KreskoAsset.rebase((0, _values.toBig)(denominator), positive, []);\nawait KreskoAsset.approve(hre.addr.userOne, transferAmount);\nconst rebaseInfodDefaultMintAMount = _mocks.defaultMintAmount.mul(denominator);\nawait KreskoAsset.connect(hre.users.userOne).transferFrom(hre.addr.deployer, hre.addr.userOne, transferAmount);\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.addr.userOne)).to.equal(rebaseInfodDefaultMintAMount.add(transferAmount));\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.addr.deployer)).to.equal(rebaseInfodDefaultMintAMount.sub(transferAmount));\nawait (0, _chai.expect)(KreskoAsset.connect(hre.users.userOne).transferFrom(hre.addr.deployer, hre.addr.userOne, transferAmount)).to.be.reverted;\n(0, _chai.expect)(await KreskoAsset.allowance(hre.addr.deployer, hre.addr.userOne)).to.equal(0);",
                      "err": {},
                      "uuid": "0ce4c940-8aa2-468f-9718-0b95a24210bb",
                      "parentUUID": "dc0f42dc-f2c5-4207-b1a3-298b260eb9ca",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "has default transferFrom behaviour after positive rebase @ 100",
                      "fullTitle": "KreskoAsset #rebase #transfer has default transferFrom behaviour after positive rebase @ 100",
                      "timedOut": false,
                      "duration": 38,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const transferAmount = (0, _values.toBig)(1);\nawait KreskoAsset.mint(hre.addr.deployer, _mocks.defaultMintAmount);\nawait KreskoAsset.mint(hre.addr.userOne, _mocks.defaultMintAmount);\nconst denominator = 100;\nconst positive = true;\nawait KreskoAsset.rebase((0, _values.toBig)(denominator), positive, []);\nawait KreskoAsset.approve(hre.addr.userOne, transferAmount);\nconst rebaseInfodDefaultMintAMount = _mocks.defaultMintAmount.mul(denominator);\nawait KreskoAsset.connect(hre.users.userOne).transferFrom(hre.addr.deployer, hre.addr.userOne, transferAmount);\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.addr.userOne)).to.equal(rebaseInfodDefaultMintAMount.add(transferAmount));\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.addr.deployer)).to.equal(rebaseInfodDefaultMintAMount.sub(transferAmount));\nawait (0, _chai.expect)(KreskoAsset.connect(hre.users.userOne).transferFrom(hre.addr.deployer, hre.addr.userOne, transferAmount)).to.be.reverted;\n(0, _chai.expect)(await KreskoAsset.allowance(hre.addr.deployer, hre.addr.userOne)).to.equal(0);",
                      "err": {},
                      "uuid": "7a383b81-0b1e-41ec-ab6b-8e463b1ab8de",
                      "parentUUID": "dc0f42dc-f2c5-4207-b1a3-298b260eb9ca",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "has default transferFrom behaviour after negative rebase",
                      "fullTitle": "KreskoAsset #rebase #transfer has default transferFrom behaviour after negative rebase",
                      "timedOut": false,
                      "duration": 36,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const transferAmount = (0, _values.toBig)(1);\nawait KreskoAsset.mint(hre.addr.deployer, _mocks.defaultMintAmount);\nawait KreskoAsset.mint(hre.addr.userOne, _mocks.defaultMintAmount);\nconst denominator = 2;\nconst positive = false;\nawait KreskoAsset.rebase((0, _values.toBig)(denominator), positive, []);\nawait KreskoAsset.approve(hre.addr.userOne, transferAmount);\nconst rebaseInfodDefaultMintAMount = _mocks.defaultMintAmount.div(denominator);\nawait KreskoAsset.connect(hre.users.userOne).transferFrom(hre.addr.deployer, hre.addr.userOne, transferAmount);\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.addr.userOne)).to.equal(rebaseInfodDefaultMintAMount.add(transferAmount));\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.addr.deployer)).to.equal(rebaseInfodDefaultMintAMount.sub(transferAmount));\nawait (0, _chai.expect)(KreskoAsset.connect(hre.users.userOne).transferFrom(hre.addr.deployer, hre.addr.userOne, transferAmount)).to.be.reverted;\n(0, _chai.expect)(await KreskoAsset.allowance(hre.addr.deployer, hre.addr.userOne)).to.equal(0);",
                      "err": {},
                      "uuid": "acd21c26-86ca-439c-bbbc-ab656d01dcc1",
                      "parentUUID": "dc0f42dc-f2c5-4207-b1a3-298b260eb9ca",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "has default transferFrom behaviour after negative rebase @ 100",
                      "fullTitle": "KreskoAsset #rebase #transfer has default transferFrom behaviour after negative rebase @ 100",
                      "timedOut": false,
                      "duration": 36,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const transferAmount = (0, _values.toBig)(1);\nawait KreskoAsset.mint(hre.addr.deployer, _mocks.defaultMintAmount);\nawait KreskoAsset.mint(hre.addr.userOne, _mocks.defaultMintAmount);\nconst denominator = 100;\nconst positive = false;\nawait KreskoAsset.rebase((0, _values.toBig)(denominator), positive, []);\nawait KreskoAsset.approve(hre.addr.userOne, transferAmount);\nconst rebaseInfodDefaultMintAMount = _mocks.defaultMintAmount.div(denominator);\nawait KreskoAsset.connect(hre.users.userOne).transferFrom(hre.addr.deployer, hre.addr.userOne, transferAmount);\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.addr.userOne)).to.equal(rebaseInfodDefaultMintAMount.add(transferAmount));\n(0, _chai.expect)(await KreskoAsset.balanceOf(hre.addr.deployer)).to.equal(rebaseInfodDefaultMintAMount.sub(transferAmount));\nawait (0, _chai.expect)(KreskoAsset.connect(hre.users.userOne).transferFrom(hre.addr.deployer, hre.addr.userOne, transferAmount)).to.be.reverted;\n(0, _chai.expect)(await KreskoAsset.allowance(hre.addr.deployer, hre.addr.userOne)).to.equal(0);",
                      "err": {},
                      "uuid": "2b130431-2a09-4216-87b9-3e977ec97c87",
                      "parentUUID": "dc0f42dc-f2c5-4207-b1a3-298b260eb9ca",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "cef7e652-f462-438a-a2ba-ed21652e396f",
                    "a59e5174-7866-4d5d-9d18-7fb40a696b53",
                    "0ce4c940-8aa2-468f-9718-0b95a24210bb",
                    "7a383b81-0b1e-41ec-ab6b-8e463b1ab8de",
                    "acd21c26-86ca-439c-bbbc-ab656d01dcc1",
                    "2b130431-2a09-4216-87b9-3e977ec97c87"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 193,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                }
              ],
              "passes": [
                "a9f68b9d-7417-4ffb-b9dc-2fcfe6bd6640",
                "ed9159f5-5786-48a6-b96d-d4f29e89d23e",
                "45036dcd-e429-4093-8f11-bff530ee7e98"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 28,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "82025c7a-2246-4cee-9747-10f94571619c",
          "title": "KreskoAssetAnchor",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/krasset/03-krasset-anchor.ts",
          "file": "/src/test/krasset/03-krasset-anchor.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"KreskoAssetAnchor\"",
              "fullTitle": "KreskoAssetAnchor \"before each\" hook in \"KreskoAssetAnchor\"",
              "timedOut": false,
              "duration": 752,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const result = await hre.deployments.fixture('diamond-init');\nif (result.Diamond) {\n    hre.Diamond = await hre.getContractOrFork('Kresko');\n}\nconst deployments = await (0, _createkrasset.createKrAsset)('krSYMBOL', 'Kresko Asset: SYMBOL', 18, _viem.zeroAddress);\nKreskoAsset = deployments.KreskoAsset;\nKreskoAssetAnchor = deployments.KreskoAssetAnchor;\n// Grant minting rights for test deployer\nawait KreskoAsset.grantRole(_roles.Role.OPERATOR, hre.addr.deployer);\n// Grant minting rights for test deployer\nawait Promise.all([\n    KreskoAsset.grantRole(_roles.Role.OPERATOR, hre.addr.deployer),\n    KreskoAssetAnchor.grantRole(_roles.Role.OPERATOR, hre.addr.deployer),\n    KreskoAsset.approve(KreskoAssetAnchor.address, hre.ethers.constants.MaxUint256)\n]);",
              "err": {},
              "uuid": "708d0011-9c84-41f2-972e-27871a93542c",
              "parentUUID": "82025c7a-2246-4cee-9747-10f94571619c",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "b8fe170d-c670-486e-8dc8-f8c8b4613842",
              "title": "#minting and burning",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/krasset/03-krasset-anchor.ts",
              "file": "/src/test/krasset/03-krasset-anchor.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "tracks the supply of underlying",
                  "fullTitle": "KreskoAssetAnchor #minting and burning tracks the supply of underlying",
                  "timedOut": false,
                  "duration": 19,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await KreskoAsset.mint(hre.addr.deployer, _mocks.defaultMintAmount);\n(0, _chai.expect)(await KreskoAssetAnchor.totalAssets()).to.equal(_mocks.defaultMintAmount);\n(0, _chai.expect)(await KreskoAssetAnchor.totalSupply()).to.equal(0);\nawait KreskoAsset.mint(hre.addr.deployer, _mocks.defaultMintAmount);\n(0, _chai.expect)(await KreskoAssetAnchor.totalAssets()).to.equal(_mocks.defaultMintAmount.add(_mocks.defaultMintAmount));\n(0, _chai.expect)(await KreskoAssetAnchor.totalSupply()).to.equal(0);",
                  "err": {},
                  "uuid": "c42e692d-b02b-42ee-8624-0eabaaa31eaa",
                  "parentUUID": "b8fe170d-c670-486e-8dc8-f8c8b4613842",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "mints 1:1 with no rebases",
                  "fullTitle": "KreskoAssetAnchor #minting and burning mints 1:1 with no rebases",
                  "timedOut": false,
                  "duration": 0,
                  "state": "pending",
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": true,
                  "context": null,
                  "code": "",
                  "err": {},
                  "uuid": "dad1c430-8d49-47c9-837c-3a88b7336a9f",
                  "parentUUID": "b8fe170d-c670-486e-8dc8-f8c8b4613842",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "deposits 1:1 with no rebases",
                  "fullTitle": "KreskoAssetAnchor #minting and burning deposits 1:1 with no rebases",
                  "timedOut": false,
                  "duration": 0,
                  "state": "pending",
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": true,
                  "context": null,
                  "code": "",
                  "err": {},
                  "uuid": "6e2a06f0-da34-4161-b037-e4d005c2e287",
                  "parentUUID": "b8fe170d-c670-486e-8dc8-f8c8b4613842",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "redeems 1:1 with no rebases",
                  "fullTitle": "KreskoAssetAnchor #minting and burning redeems 1:1 with no rebases",
                  "timedOut": false,
                  "duration": 0,
                  "state": "pending",
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": true,
                  "context": null,
                  "code": "",
                  "err": {},
                  "uuid": "b5a3a92c-71d5-4fdd-89a4-b820d5e24997",
                  "parentUUID": "b8fe170d-c670-486e-8dc8-f8c8b4613842",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "withdraws 1:1 with no rebases",
                  "fullTitle": "KreskoAssetAnchor #minting and burning withdraws 1:1 with no rebases",
                  "timedOut": false,
                  "duration": 0,
                  "state": "pending",
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": true,
                  "context": null,
                  "code": "",
                  "err": {},
                  "uuid": "db164180-2fef-4fbd-ae2c-b0f59d373319",
                  "parentUUID": "b8fe170d-c670-486e-8dc8-f8c8b4613842",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [
                {
                  "uuid": "cea2f8f4-1221-4a6b-b798-4e2bcd56a31e",
                  "title": "#rebases",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/krasset/03-krasset-anchor.ts",
                  "file": "/src/test/krasset/03-krasset-anchor.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [],
                  "suites": [
                    {
                      "uuid": "08cd8d46-ba10-4da2-9786-041f7a1c5e52",
                      "title": "#conversions",
                      "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/krasset/03-krasset-anchor.ts",
                      "file": "/src/test/krasset/03-krasset-anchor.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "mints 1:1 and redeems 1:2 after 1:2 rebase",
                          "fullTitle": "KreskoAssetAnchor #minting and burning #rebases #conversions mints 1:1 and redeems 1:2 after 1:2 rebase",
                          "timedOut": false,
                          "duration": 0,
                          "state": "pending",
                          "speed": null,
                          "pass": false,
                          "fail": false,
                          "pending": true,
                          "context": null,
                          "code": "",
                          "err": {},
                          "uuid": "6c8df56e-fc9a-460e-b84d-ce89b290d205",
                          "parentUUID": "08cd8d46-ba10-4da2-9786-041f7a1c5e52",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "deposits 1:1 and withdraws 1:2 after 1:2 rebase",
                          "fullTitle": "KreskoAssetAnchor #minting and burning #rebases #conversions deposits 1:1 and withdraws 1:2 after 1:2 rebase",
                          "timedOut": false,
                          "duration": 0,
                          "state": "pending",
                          "speed": null,
                          "pass": false,
                          "fail": false,
                          "pending": true,
                          "context": null,
                          "code": "",
                          "err": {},
                          "uuid": "e310e13d-68b8-4adb-9ace-5ca2a1e95996",
                          "parentUUID": "08cd8d46-ba10-4da2-9786-041f7a1c5e52",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "mints 1:1 and redeems 1:6 after 1:6 rebase",
                          "fullTitle": "KreskoAssetAnchor #minting and burning #rebases #conversions mints 1:1 and redeems 1:6 after 1:6 rebase",
                          "timedOut": false,
                          "duration": 0,
                          "state": "pending",
                          "speed": null,
                          "pass": false,
                          "fail": false,
                          "pending": true,
                          "context": null,
                          "code": "",
                          "err": {},
                          "uuid": "9263c52c-8a01-4180-9e7a-b9c2c8bcf029",
                          "parentUUID": "08cd8d46-ba10-4da2-9786-041f7a1c5e52",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "deposits 1:1 and withdraws 1:6 after 1:6 rebase",
                          "fullTitle": "KreskoAssetAnchor #minting and burning #rebases #conversions deposits 1:1 and withdraws 1:6 after 1:6 rebase",
                          "timedOut": false,
                          "duration": 0,
                          "state": "pending",
                          "speed": null,
                          "pass": false,
                          "fail": false,
                          "pending": true,
                          "context": null,
                          "code": "",
                          "err": {},
                          "uuid": "59075614-f346-4f30-af09-0471673ada92",
                          "parentUUID": "08cd8d46-ba10-4da2-9786-041f7a1c5e52",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "mints 1:1 and redeems 2:1 after 2:1 rebase",
                          "fullTitle": "KreskoAssetAnchor #minting and burning #rebases #conversions mints 1:1 and redeems 2:1 after 2:1 rebase",
                          "timedOut": false,
                          "duration": 0,
                          "state": "pending",
                          "speed": null,
                          "pass": false,
                          "fail": false,
                          "pending": true,
                          "context": null,
                          "code": "",
                          "err": {},
                          "uuid": "3be5fc32-1f42-4a9d-ab7c-4e1edc041344",
                          "parentUUID": "08cd8d46-ba10-4da2-9786-041f7a1c5e52",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "deposits 1:1 and withdraws 2:1 after 2:1 rebase",
                          "fullTitle": "KreskoAssetAnchor #minting and burning #rebases #conversions deposits 1:1 and withdraws 2:1 after 2:1 rebase",
                          "timedOut": false,
                          "duration": 0,
                          "state": "pending",
                          "speed": null,
                          "pass": false,
                          "fail": false,
                          "pending": true,
                          "context": null,
                          "code": "",
                          "err": {},
                          "uuid": "1a5cc1d9-9846-4856-bdb8-43a59a366f35",
                          "parentUUID": "08cd8d46-ba10-4da2-9786-041f7a1c5e52",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "mints 1:1 and redeems 6:1 after 6:1 rebase",
                          "fullTitle": "KreskoAssetAnchor #minting and burning #rebases #conversions mints 1:1 and redeems 6:1 after 6:1 rebase",
                          "timedOut": false,
                          "duration": 0,
                          "state": "pending",
                          "speed": null,
                          "pass": false,
                          "fail": false,
                          "pending": true,
                          "context": null,
                          "code": "",
                          "err": {},
                          "uuid": "41d61ea6-209f-4c7a-8cbf-40b5b33e1e44",
                          "parentUUID": "08cd8d46-ba10-4da2-9786-041f7a1c5e52",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "deposits 1:1 and withdraws 6:1 after 6:1 rebase",
                          "fullTitle": "KreskoAssetAnchor #minting and burning #rebases #conversions deposits 1:1 and withdraws 6:1 after 6:1 rebase",
                          "timedOut": false,
                          "duration": 0,
                          "state": "pending",
                          "speed": null,
                          "pass": false,
                          "fail": false,
                          "pending": true,
                          "context": null,
                          "code": "",
                          "err": {},
                          "uuid": "16b03bc1-e973-4ba9-aaa0-2c351609908d",
                          "parentUUID": "08cd8d46-ba10-4da2-9786-041f7a1c5e52",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [],
                      "failures": [],
                      "pending": [
                        "6c8df56e-fc9a-460e-b84d-ce89b290d205",
                        "e310e13d-68b8-4adb-9ace-5ca2a1e95996",
                        "9263c52c-8a01-4180-9e7a-b9c2c8bcf029",
                        "59075614-f346-4f30-af09-0471673ada92",
                        "3be5fc32-1f42-4a9d-ab7c-4e1edc041344",
                        "1a5cc1d9-9846-4856-bdb8-43a59a366f35",
                        "41d61ea6-209f-4c7a-8cbf-40b5b33e1e44",
                        "16b03bc1-e973-4ba9-aaa0-2c351609908d"
                      ],
                      "skipped": [],
                      "duration": 0,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 30000
                    }
                  ],
                  "passes": [],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 0,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                }
              ],
              "passes": [
                "c42e692d-b02b-42ee-8624-0eabaaa31eaa"
              ],
              "failures": [],
              "pending": [
                "dad1c430-8d49-47c9-837c-3a88b7336a9f",
                "6e2a06f0-da34-4161-b037-e4d005c2e287",
                "b5a3a92c-71d5-4fdd-89a4-b820d5e24997",
                "db164180-2fef-4fbd-ae2c-b0f59d373319"
              ],
              "skipped": [],
              "duration": 19,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "ca9b8fbf-2df9-4f06-9906-5f7c44e08bd7",
          "title": "Test KreskoAsset with Rebase and sync",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/krasset/04-krasset-sync-rebase.ts",
          "file": "/src/test/krasset/04-krasset-sync-rebase.ts",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "Rebases the asset with no sync of uniswap pools - Reserves not updated",
              "fullTitle": "Test KreskoAsset with Rebase and sync Rebases the asset with no sync of uniswap pools - Reserves not updated",
              "timedOut": false,
              "duration": 0,
              "state": "pending",
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": true,
              "context": null,
              "code": "",
              "err": {},
              "uuid": "7c9da07a-4f00-4275-b43c-1f88c8134fb4",
              "parentUUID": "ca9b8fbf-2df9-4f06-9906-5f7c44e08bd7",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "Rebases the asset with sync of uniswap pools - Reserve should be updated",
              "fullTitle": "Test KreskoAsset with Rebase and sync Rebases the asset with sync of uniswap pools - Reserve should be updated",
              "timedOut": false,
              "duration": 0,
              "state": "pending",
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": true,
              "context": null,
              "code": "",
              "err": {},
              "uuid": "466774eb-cb00-4ff0-a7c0-bd53c09ebcf2",
              "parentUUID": "ca9b8fbf-2df9-4f06-9906-5f7c44e08bd7",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [],
          "failures": [],
          "pending": [
            "7c9da07a-4f00-4275-b43c-1f88c8134fb4",
            "466774eb-cb00-4ff0-a7c0-bd53c09ebcf2"
          ],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "796746f5-594a-460a-8e13-c84331301ff4",
          "title": "KreskoAsset",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/krasset/05-krasset-wrap.ts",
          "file": "/src/test/krasset/05-krasset-wrap.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"KreskoAsset\"",
              "fullTitle": "KreskoAsset \"before each\" hook in \"KreskoAsset\"",
              "timedOut": false,
              "duration": 42,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "operator = hre.users.deployer;\nuser = hre.users.userOne;\ntreasury = hre.addr.treasury;\n({ KreskoAsset } = await (0, _fixtures.kreskoAssetFixture)({\n    name: 'Ether',\n    symbol: 'krETH'\n}));\n// Deploy WETH\nwNative = await hre.ethers.deployContract('WETH');\n// Give WETH to deployer\nawait wNative.connect(user).deposit({\n    value: (0, _values.toBig)(100)\n});\nawait KreskoAsset.connect(hre.users.deployer).grantRole(_roles.Role.OPERATOR, operator.address);\nawait KreskoAsset.connect(hre.users.deployer).setUnderlying(wNative.address);\n// Approve WETH for KreskoAsset\nawait wNative.connect(user).approve(KreskoAsset.address, hre.ethers.constants.MaxUint256);",
              "err": {},
              "uuid": "5a44e724-8955-4de9-baf3-e4dfe36a490b",
              "parentUUID": "796746f5-594a-460a-8e13-c84331301ff4",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "894dd939-e3e5-46a6-87f2-00f5ffc40f9e",
              "title": "Deposit / Wrap",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/krasset/05-krasset-wrap.ts",
              "file": "/src/test/krasset/05-krasset-wrap.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "cannot deposit when paused",
                  "fullTitle": "KreskoAsset Deposit / Wrap cannot deposit when paused",
                  "timedOut": false,
                  "duration": 14,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await KreskoAsset.connect(operator).pause();\nawait (0, _chai.expect)(KreskoAsset.wrap(user.address, (0, _values.toBig)(10))).to.be.revertedWithCustomError(KreskoAsset, 'EnforcedPause');\nawait KreskoAsset.connect(operator).unpause();",
                  "err": {},
                  "uuid": "a1ca698a-b549-4724-9606-c5a902d000d5",
                  "parentUUID": "894dd939-e3e5-46a6-87f2-00f5ffc40f9e",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can deposit with token",
                  "fullTitle": "KreskoAsset Deposit / Wrap can deposit with token",
                  "timedOut": false,
                  "duration": 12,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await KreskoAsset.connect(user).wrap(user.address, (0, _values.toBig)(10));\n(0, _chai.expect)(await KreskoAsset.balanceOf(user.address)).to.equal((0, _values.toBig)(10));",
                  "err": {},
                  "uuid": "ad89d440-787c-4e49-85b6-06a6e6b140ba",
                  "parentUUID": "894dd939-e3e5-46a6-87f2-00f5ffc40f9e",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "cannot deposit native token if not enabled",
                  "fullTitle": "KreskoAsset Deposit / Wrap cannot deposit native token if not enabled",
                  "timedOut": false,
                  "duration": 4,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, _chai.expect)(user.sendTransaction({\n    to: KreskoAsset.address,\n    value: (0, _values.toBig)(10)\n})).to.be.reverted;",
                  "err": {},
                  "uuid": "4589a71f-f950-4557-95b4-7d0df9ffca60",
                  "parentUUID": "894dd939-e3e5-46a6-87f2-00f5ffc40f9e",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can deposit native token if enabled",
                  "fullTitle": "KreskoAsset Deposit / Wrap can deposit native token if enabled",
                  "timedOut": false,
                  "duration": 67,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await KreskoAsset.connect(operator).enableNativeUnderlying(true);\nconst prevBalance = await KreskoAsset.balanceOf(user.address);\nawait user.sendTransaction({\n    to: KreskoAsset.address,\n    value: (0, _values.toBig)(10)\n});\nconst currentBalance = await KreskoAsset.balanceOf(user.address);\n(0, _chai.expect)(currentBalance.sub(prevBalance)).to.equal((0, _values.toBig)(10));",
                  "err": {},
                  "uuid": "926437cd-75bf-4bf2-a329-2c6ce803b5aa",
                  "parentUUID": "894dd939-e3e5-46a6-87f2-00f5ffc40f9e",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "transfers the correct fees to feeRecipient",
                  "fullTitle": "KreskoAsset Deposit / Wrap transfers the correct fees to feeRecipient",
                  "timedOut": false,
                  "duration": 115,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await KreskoAsset.connect(operator).setOpenFee(0.1e4);\nawait KreskoAsset.connect(operator).enableNativeUnderlying(true);\nlet prevBalanceDevOne = await KreskoAsset.balanceOf(user.address);\nconst treasuryWETHBal = await wNative.balanceOf(treasury);\nawait KreskoAsset.connect(user).wrap(user.address, (0, _values.toBig)(10));\nlet currentBalanceDevOne = await KreskoAsset.balanceOf(user.address);\nconst currentWETHBalanceTreasury = await wNative.balanceOf(treasury);\n(0, _chai.expect)(currentBalanceDevOne.sub(prevBalanceDevOne)).to.equal((0, _values.toBig)(9));\n(0, _chai.expect)(currentWETHBalanceTreasury.sub(treasuryWETHBal)).to.equal((0, _values.toBig)(1));\nprevBalanceDevOne = await KreskoAsset.balanceOf(user.address);\nconst prevBalanceTreasury = await hre.ethers.provider.getBalance(treasury);\nawait user.sendTransaction({\n    to: KreskoAsset.address,\n    value: (0, _values.toBig)(10)\n});\ncurrentBalanceDevOne = await KreskoAsset.balanceOf(user.address);\nconst currentBalanceTreasury = await hre.ethers.provider.getBalance(treasury);\n(0, _chai.expect)(currentBalanceDevOne.sub(prevBalanceDevOne)).to.equal((0, _values.toBig)(9));\n(0, _chai.expect)(currentBalanceTreasury.sub(prevBalanceTreasury)).to.equal((0, _values.toBig)(1));\n// Set openfee to 0\nawait KreskoAsset.connect(operator).setOpenFee(0);",
                  "err": {},
                  "uuid": "aa640f78-801c-4c1a-b095-2044a1538c17",
                  "parentUUID": "894dd939-e3e5-46a6-87f2-00f5ffc40f9e",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "a1ca698a-b549-4724-9606-c5a902d000d5",
                "ad89d440-787c-4e49-85b6-06a6e6b140ba",
                "4589a71f-f950-4557-95b4-7d0df9ffca60",
                "926437cd-75bf-4bf2-a329-2c6ce803b5aa",
                "aa640f78-801c-4c1a-b095-2044a1538c17"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 212,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            },
            {
              "uuid": "1b7e2020-9117-41c0-bd54-bd80ae4df98a",
              "title": "Withdraw / Unwrap",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/krasset/05-krasset-wrap.ts",
              "file": "/src/test/krasset/05-krasset-wrap.ts",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"Withdraw / Unwrap\"",
                  "fullTitle": "KreskoAsset Withdraw / Unwrap \"before each\" hook in \"Withdraw / Unwrap\"",
                  "timedOut": false,
                  "duration": 90,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Deposit some tokens here\nawait KreskoAsset.connect(user).wrap(user.address, (0, _values.toBig)(10));\nawait KreskoAsset.connect(operator).enableNativeUnderlying(true);\nawait user.sendTransaction({\n    to: KreskoAsset.address,\n    value: (0, _values.toBig)(100)\n});",
                  "err": {},
                  "uuid": "fcf0a3f4-4f40-47b9-a530-b64d4c2905d5",
                  "parentUUID": "1b7e2020-9117-41c0-bd54-bd80ae4df98a",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "cannot withdraw when paused",
                  "fullTitle": "KreskoAsset Withdraw / Unwrap cannot withdraw when paused",
                  "timedOut": false,
                  "duration": 11,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await KreskoAsset.connect(operator).pause();\nawait (0, _chai.expect)(KreskoAsset.connect(user).unwrap(user.address, (0, _values.toBig)(1), false)).to.be.revertedWithCustomError(KreskoAsset, 'EnforcedPause');\nawait KreskoAsset.connect(operator).unpause();",
                  "err": {},
                  "uuid": "a8fbe2df-9cb2-4702-a3b2-9a9716b58ea7",
                  "parentUUID": "1b7e2020-9117-41c0-bd54-bd80ae4df98a",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can withdraw",
                  "fullTitle": "KreskoAsset Withdraw / Unwrap can withdraw",
                  "timedOut": false,
                  "duration": 16,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const prevBalance = await wNative.balanceOf(user.address);\nawait KreskoAsset.connect(user).unwrap(user.address, (0, _values.toBig)(1), false);\nconst currentBalance = await wNative.balanceOf(user.address);\n(0, _chai.expect)(currentBalance).to.equal((0, _values.toBig)(1).add(prevBalance));",
                  "err": {},
                  "uuid": "62c9fb5d-ab80-4a91-9764-947f0b968e8b",
                  "parentUUID": "1b7e2020-9117-41c0-bd54-bd80ae4df98a",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can withdraw native token if enabled",
                  "fullTitle": "KreskoAsset Withdraw / Unwrap can withdraw native token if enabled",
                  "timedOut": false,
                  "duration": 19,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await KreskoAsset.connect(operator).enableNativeUnderlying(true);\nconst prevBalance = await KreskoAsset.balanceOf(user.address);\nawait KreskoAsset.connect(user).unwrap(user.address, (0, _values.toBig)(1), true);\nconst currentBalance = await KreskoAsset.balanceOf(user.address);\n(0, _chai.expect)(prevBalance.sub(currentBalance)).to.equal((0, _values.toBig)(1));",
                  "err": {},
                  "uuid": "57296b8e-6387-4fa6-a14d-90c198ed6d3f",
                  "parentUUID": "1b7e2020-9117-41c0-bd54-bd80ae4df98a",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "transfers the correct fees to feeRecipient",
                  "fullTitle": "KreskoAsset Withdraw / Unwrap transfers the correct fees to feeRecipient",
                  "timedOut": false,
                  "duration": 109,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// set close fee to 10%\nawait KreskoAsset.connect(operator).setCloseFee(0.1e4);\nconst prevBalanceDevOne = await wNative.balanceOf(user.address);\nlet prevBalanceTreasury = await wNative.balanceOf(treasury);\nawait KreskoAsset.connect(user).unwrap(user.address, (0, _values.toBig)(9), false);\nconst currentBalanceDevOne = await wNative.balanceOf(user.address);\nlet currentBalanceTreasury = await wNative.balanceOf(treasury);\n(0, _chai.expect)(currentBalanceDevOne.sub(prevBalanceDevOne)).to.equal((0, _values.toBig)(8.1));\n(0, _chai.expect)(currentBalanceTreasury.sub(prevBalanceTreasury)).to.equal((0, _values.toBig)(0.9));\n// Withdraw native token and check if fee is transferred\nawait user.sendTransaction({\n    to: KreskoAsset.address,\n    value: (0, _values.toBig)(10)\n});\nprevBalanceTreasury = await hre.ethers.provider.getBalance(treasury);\nawait KreskoAsset.connect(user).unwrap(user.address, (0, _values.toBig)(9), true);\ncurrentBalanceTreasury = await hre.ethers.provider.getBalance(treasury);\n(0, _chai.expect)(currentBalanceTreasury.sub(prevBalanceTreasury)).to.equal((0, _values.toBig)(0.9));",
                  "err": {},
                  "uuid": "3082003f-52fe-429b-9af5-1382d9a20349",
                  "parentUUID": "1b7e2020-9117-41c0-bd54-bd80ae4df98a",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "a8fbe2df-9cb2-4702-a3b2-9a9716b58ea7",
                "62c9fb5d-ab80-4a91-9764-947f0b968e8b",
                "57296b8e-6387-4fa6-a14d-90c198ed6d3f",
                "3082003f-52fe-429b-9af5-1382d9a20349"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 155,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "68f7d3a4-4fbb-4cda-968d-46bf4c4c719d",
          "title": "Minter - Configuration",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/01-configuration.ts",
          "file": "/src/test/minter/01-configuration.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"Minter - Configuration\"",
              "fullTitle": "Minter - Configuration \"before each\" hook in \"Minter - Configuration\"",
              "timedOut": false,
              "duration": 1,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "f = await (0, _fixtures.defaultFixture)();",
              "err": {},
              "uuid": "23c9fd00-dc77-4c06-a91d-8ac5626c57cc",
              "parentUUID": "68f7d3a4-4fbb-4cda-968d-46bf4c4c719d",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "971a6e81-9780-4fc5-af67-1108bef31d06",
              "title": "#configuration",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/01-configuration.ts",
              "file": "/src/test/minter/01-configuration.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "can modify all parameters",
                  "fullTitle": "Minter - Configuration #configuration can modify all parameters",
                  "timedOut": false,
                  "duration": 22,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const update = (0, _mocks.testMinterParams)(hre.users.treasury.address);\nawait (0, _chai.expect)(hre.Diamond.setMinCollateralRatioMinter(update.minCollateralRatio)).to.not.be.reverted;\nawait (0, _chai.expect)(hre.Diamond.setLiquidationThresholdMinter(update.liquidationThreshold)).to.not.be.reverted;\nawait (0, _chai.expect)(hre.Diamond.setMaxLiquidationRatioMinter(update.maxLiquidationRatio)).to.not.be.reverted;\nconst params = await hre.Diamond.getParametersMinter();\n(0, _chai.expect)(update.minCollateralRatio).to.equal(params.minCollateralRatio);\n(0, _chai.expect)(update.maxLiquidationRatio).to.equal(params.maxLiquidationRatio);\n(0, _chai.expect)(update.liquidationThreshold).to.equal(params.liquidationThreshold);",
                  "err": {},
                  "uuid": "4781b14e-3473-4256-a28b-9b9ca890c872",
                  "parentUUID": "971a6e81-9780-4fc5-af67-1108bef31d06",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can add a collateral asset",
                  "fullTitle": "Minter - Configuration #configuration can add a collateral asset",
                  "timedOut": false,
                  "duration": 1074,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const { contract } = await (0, _collaterals.addMockExtAsset)(_mocks.testCollateralConfig);\n(0, _chai.expect)(await hre.Diamond.getCollateralExists(contract.address)).to.equal(true);\nconst priceOfOne = await hre.Diamond.getValue(contract.address, (0, _values.toBig)(1));\n(0, _chai.expect)(Number(priceOfOne)).to.equal((0, _values.toBig)(_mocks.testCollateralConfig.price, 8));",
                  "err": {},
                  "uuid": "d86db285-c6d2-48ef-b999-b4c5a699bbb1",
                  "parentUUID": "971a6e81-9780-4fc5-af67-1108bef31d06",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can add a kresko asset",
                  "fullTitle": "Minter - Configuration #configuration can add a kresko asset",
                  "timedOut": false,
                  "duration": 1861,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const { contract, assetInfo } = await (0, _krassets.addMockKreskoAsset)({\n    ..._mocks.testKrAssetConfig,\n    name: 'Kresko Asset: 5',\n    symbol: 'KrAsset5',\n    ticker: 'KrAsset5'\n});\nconst values = await assetInfo();\nconst kreskoPriceAnswer = (0, _values.fromBig)(await hre.Diamond.getValue(contract.address, (0, _values.toBig)(1)), 8);\nconst config = _mocks.testKrAssetConfig.krAssetConfig;\n(0, _chai.expect)(values.isMinterMintable).to.equal(true);\n(0, _chai.expect)(values.kFactor).to.equal(config.kFactor);\n(0, _chai.expect)(kreskoPriceAnswer).to.equal(_mocks.testKrAssetConfig.price);\n(0, _chai.expect)(values.maxDebtMinter).to.equal(config.maxDebtMinter);\n(0, _chai.expect)(values.closeFee).to.equal(config.closeFee);\n(0, _chai.expect)(values.openFee).to.equal(config.openFee);",
                  "err": {},
                  "uuid": "4065f192-1d62-4182-ad7c-9764df1fa78f",
                  "parentUUID": "971a6e81-9780-4fc5-af67-1108bef31d06",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can update default oracle precision decimals",
                  "fullTitle": "Minter - Configuration #configuration can update default oracle precision decimals",
                  "timedOut": false,
                  "duration": 7,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const decimals = 8;\nawait hre.Diamond.setDefaultOraclePrecision(decimals);\n(0, _chai.expect)(await hre.Diamond.getDefaultOraclePrecision()).to.equal(decimals);",
                  "err": {},
                  "uuid": "f6fa5cfd-5521-455a-976b-59fea3d7339c",
                  "parentUUID": "971a6e81-9780-4fc5-af67-1108bef31d06",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can update minter max liquidation ratio",
                  "fullTitle": "Minter - Configuration #configuration can update minter max liquidation ratio",
                  "timedOut": false,
                  "duration": 12,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const currentMLM = await hre.Diamond.getMaxLiquidationRatioMinter();\nconst newMLR = 1.42e4;\n(0, _chai.expect)(currentMLM).to.not.eq(newMLR);\nawait (0, _chai.expect)(hre.Diamond.setMaxLiquidationRatioMinter(newMLR)).to.not.be.reverted;\n(0, _chai.expect)(await hre.Diamond.getMaxLiquidationRatioMinter()).to.eq(newMLR);",
                  "err": {},
                  "uuid": "4ac964d6-e8f9-48f7-8567-d57bd28641d5",
                  "parentUUID": "971a6e81-9780-4fc5-af67-1108bef31d06",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can update global oracle deviation pct",
                  "fullTitle": "Minter - Configuration #configuration can update global oracle deviation pct",
                  "timedOut": false,
                  "duration": 13,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const currentDeviationPct = await hre.Diamond.getOracleDeviationPct();\nconst newDeviationPct = 0.03e4;\n(0, _chai.expect)(currentDeviationPct).to.not.equal(newDeviationPct);\nawait (0, _chai.expect)(hre.Diamond.setMaxPriceDeviationPct(newDeviationPct)).to.not.be.reverted;\n(0, _chai.expect)(await hre.Diamond.getOracleDeviationPct()).to.equal(newDeviationPct);",
                  "err": {},
                  "uuid": "873c4d64-af49-4fe8-b893-7e382c705978",
                  "parentUUID": "971a6e81-9780-4fc5-af67-1108bef31d06",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can update kFactor of a kresko asset",
                  "fullTitle": "Minter - Configuration #configuration can update kFactor of a kresko asset",
                  "timedOut": false,
                  "duration": 19,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const oldRatio = (await hre.Diamond.getAsset(f.KrAsset.address)).kFactor;\nconst newRatio = 1.2e4;\n(0, _chai.expect)(oldRatio === newRatio).to.be.false;\nawait (0, _chai.expect)(hre.Diamond.setAssetKFactor(f.KrAsset.address, newRatio)).to.not.be.reverted;\n(0, _chai.expect)((await hre.Diamond.getAsset(f.KrAsset.address)).kFactor === newRatio).to.be.true;",
                  "err": {},
                  "uuid": "2d4e8fd2-c2fb-4ee7-8c93-d7a4921200d6",
                  "parentUUID": "971a6e81-9780-4fc5-af67-1108bef31d06",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can update cFactor of a collateral asset",
                  "fullTitle": "Minter - Configuration #configuration can update cFactor of a collateral asset",
                  "timedOut": false,
                  "duration": 17,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const oldRatio = (await hre.Diamond.getAsset(f.Collateral.address)).factor;\nconst newRatio = 0.9e4;\n(0, _chai.expect)(oldRatio === newRatio).to.be.false;\nawait (0, _chai.expect)(hre.Diamond.setAssetCFactor(f.Collateral.address, newRatio)).to.not.be.reverted;\n(0, _chai.expect)((await hre.Diamond.getAsset(f.Collateral.address)).factor === newRatio).to.be.true;",
                  "err": {},
                  "uuid": "1f10e521-6670-41d4-a02e-5dbb06971132",
                  "parentUUID": "971a6e81-9780-4fc5-af67-1108bef31d06",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can update configuration of an asset",
                  "fullTitle": "Minter - Configuration #configuration can update configuration of an asset",
                  "timedOut": false,
                  "duration": 220,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const oracleAnswer = (0, _values.fromBig)((await f.KrAsset.priceFeed.latestRoundData())[1], 8);\nconst priceOfOne = (0, _values.fromBig)(await hre.Diamond.getValue(f.KrAsset.address, (0, _values.toBig)(1)), 8);\n(0, _chai.expect)(oracleAnswer).to.equal(priceOfOne);\n(0, _chai.expect)(oracleAnswer).to.equal(_mocks.testKrAssetConfig.price);\nconst update = {\n    kFactor: 1.2e4,\n    maxDebtMinter: (0, _values.toBig)(12000),\n    closeFee: 0.03e4,\n    openFee: 0.03e4,\n    anchor: f.KrAsset.anchor.address\n};\nconst FakeFeed = await (0, _oracle.createOracles)(hre, f.KrAsset.pythId.toString(), 20);\nconst newConfig = await (0, _general.getAssetConfig)(f.KrAsset.contract, {\n    ..._mocks.testKrAssetConfig,\n    feed: FakeFeed.address,\n    price: 20,\n    krAssetConfig: update\n});\nawait hre.Diamond.setFeedsForTicker(newConfig.assetStruct.ticker, newConfig.feedConfig);\nawait hre.Diamond.connect(hre.users.deployer).updateAsset(f.KrAsset.address, newConfig.assetStruct);\nconst newValues = await hre.Diamond.getAsset(f.KrAsset.address);\nconst updatedOracleAnswer = (0, _values.fromBig)((await FakeFeed.latestRoundData())[1], 8);\nconst newPriceOfOne = (0, _values.fromBig)(await hre.Diamond.getValue(f.KrAsset.address, (0, _values.toBig)(1)), 8);\n(0, _chai.expect)(newValues.isMinterMintable).to.equal(true);\n(0, _chai.expect)(newValues.isMinterCollateral).to.equal(false);\n(0, _chai.expect)(newValues.kFactor).to.equal(update.kFactor);\n(0, _chai.expect)(newValues.maxDebtMinter).to.equal(update.maxDebtMinter);\n(0, _chai.expect)(updatedOracleAnswer).to.equal(newPriceOfOne);\n(0, _chai.expect)(updatedOracleAnswer).to.equal(20);\nconst update2 = {\n    ...await hre.Diamond.getAsset(f.KrAsset.address),\n    kFactor: 1.75e4,\n    maxDebtMinter: (0, _values.toBig)(12000),\n    closeFee: 0.052e4,\n    openFee: 0.052e4,\n    isSwapMintable: true,\n    swapInFeeSCDP: 0.052e4,\n    liqIncentiveSCDP: 1.1e4,\n    anchor: f.KrAsset.anchor.address\n};\nawait hre.Diamond.updateAsset(f.KrAsset.address, update2);\nconst newValues2 = await hre.Diamond.getAsset(f.KrAsset.address);\n(0, _chai.expect)(newValues2.isMinterMintable).to.equal(true);\n(0, _chai.expect)(newValues2.isSharedOrSwappedCollateral).to.equal(true);\n(0, _chai.expect)(newValues2.isSwapMintable).to.equal(true);\n(0, _chai.expect)(newValues2.isMinterCollateral).to.equal(false);\n(0, _chai.expect)(newValues2.isSharedCollateral).to.equal(false);\n(0, _chai.expect)(newValues2.isCoverAsset).to.equal(false);\n(0, _chai.expect)(newValues2.kFactor).to.equal(update2.kFactor);\n(0, _chai.expect)(newValues2.openFee).to.equal(update2.closeFee);\n(0, _chai.expect)(newValues2.closeFee).to.equal(update2.openFee);\n(0, _chai.expect)(newValues2.swapInFeeSCDP).to.equal(update2.swapInFeeSCDP);\n(0, _chai.expect)(newValues2.maxDebtMinter).to.equal(update2.maxDebtMinter);\nawait f.KrAsset.setPrice(10);",
                  "err": {},
                  "uuid": "e356aa8c-33ee-4396-afe6-394acfe5a133",
                  "parentUUID": "971a6e81-9780-4fc5-af67-1108bef31d06",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "4781b14e-3473-4256-a28b-9b9ca890c872",
                "d86db285-c6d2-48ef-b999-b4c5a699bbb1",
                "4065f192-1d62-4182-ad7c-9764df1fa78f",
                "f6fa5cfd-5521-455a-976b-59fea3d7339c",
                "4ac964d6-e8f9-48f7-8567-d57bd28641d5",
                "873c4d64-af49-4fe8-b893-7e382c705978",
                "2d4e8fd2-c2fb-4ee7-8c93-d7a4921200d6",
                "1f10e521-6670-41d4-a02e-5dbb06971132",
                "e356aa8c-33ee-4396-afe6-394acfe5a133"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 3245,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "289bad20-41b2-4802-841a-8a5080931dfc",
          "title": "Minter - Deposit Withdraw",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
          "file": "/src/test/minter/02-deposit-withdraw.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"Minter - Deposit Withdraw\"",
              "fullTitle": "Minter - Deposit Withdraw \"before each\" hook in \"Minter - Deposit Withdraw\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "f = await (0, _fixtures.depositWithdrawFixture)();",
              "err": {},
              "uuid": "a61285a8-2682-43da-a0f4-da73cc55027a",
              "parentUUID": "289bad20-41b2-4802-841a-8a5080931dfc",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "578aaf06-8faf-4f9d-a2b3-a69c1ff427af",
              "title": "#collateral",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
              "file": "/src/test/minter/02-deposit-withdraw.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [],
              "suites": [
                {
                  "uuid": "aa5bdbb0-ab6e-4216-aee2-0f01b8cf92a2",
                  "title": "#deposit",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                  "file": "/src/test/minter/02-deposit-withdraw.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "reverts withdraws of krAsset collateral when deposits go below MIN_KRASSET_COLLATERAL_AMOUNT",
                      "fullTitle": "Minter - Deposit Withdraw #collateral #deposit reverts withdraws of krAsset collateral when deposits go below MIN_KRASSET_COLLATERAL_AMOUNT",
                      "timedOut": false,
                      "duration": 80,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const collateralAmount = (0, _values.toBig)(100);\nawait f.KrAssetCollateral.setBalance(f.user, collateralAmount, _hardhat.default.Diamond.address);\nconst depositAmount = collateralAmount.div(2);\nawait f.User.depositCollateral(f.user.address, f.KrAssetCollateral.address, depositAmount);\n// Rebase the asset according to params\nconst denominator = 4;\nconst positive = true;\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\nconst rebasedDepositAmount = depositAmount.mul(denominator);\nconst withdrawAmount = rebasedDepositAmount.sub(9e11.toString());\n(0, _chai.expect)(await _hardhat.default.Diamond.getAccountCollateralAssets(f.user.address)).to.include(f.KrAssetCollateral.address);\nawait (0, _chai.expect)(f.User.withdrawCollateral({\n    account: f.user.address,\n    asset: f.KrAssetCollateral.address,\n    amount: withdrawAmount,\n    collateralIndex: 0,\n    receiver: f.user.address\n}, await _hardhat.default.updateData())).to.be.revertedWithCustomError((0, _errors.Errors)(_hardhat.default), 'COLLATERAL_AMOUNT_LOW').withArgs(f.KrAssetCollateral.errorId, 9e11, 1e12);",
                      "err": {},
                      "uuid": "7c4e9e9e-e169-4a73-b958-9ab14ba14029",
                      "parentUUID": "aa5bdbb0-ab6e-4216-aee2-0f01b8cf92a2",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "reverts deposits of krAsset collateral for less than MIN_KRASSET_COLLATERAL_AMOUNT",
                      "fullTitle": "Minter - Deposit Withdraw #collateral #deposit reverts deposits of krAsset collateral for less than MIN_KRASSET_COLLATERAL_AMOUNT",
                      "timedOut": false,
                      "duration": 16,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const collateralAmount = (0, _values.toBig)(100);\nawait f.KrAssetCollateral.setBalance(f.user, collateralAmount, _hardhat.default.Diamond.address);\nawait (0, _chai.expect)(f.User.depositCollateral(f.user.address, f.KrAssetCollateral.address, 9e11.toString())).to.be.revertedWithCustomError((0, _errors.Errors)(_hardhat.default), 'COLLATERAL_AMOUNT_LOW').withArgs(f.KrAssetCollateral.errorId, 9e11, 1e12);",
                      "err": {},
                      "uuid": "a63978ee-37ad-4c9a-9a25-0f05337479f9",
                      "parentUUID": "aa5bdbb0-ab6e-4216-aee2-0f01b8cf92a2",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow an account to deposit whitelisted collateral",
                      "fullTitle": "Minter - Deposit Withdraw #collateral #deposit should allow an account to deposit whitelisted collateral",
                      "timedOut": false,
                      "duration": 17,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, _chai.expect)(f.Depositor.depositCollateral(f.depositor.address, f.Collateral.address, f.initialDeposits)).not.to.be.reverted;\n// Account has deposit entry\nconst depositedCollateralAssetsAfter = await _hardhat.default.Diamond.getAccountCollateralAssets(f.depositor.address);\n(0, _chai.expect)(depositedCollateralAssetsAfter).to.deep.equal([\n    f.Collateral.address\n]);\n// Account's collateral deposit balances have increased\n(0, _chai.expect)(await _hardhat.default.Diamond.getAccountCollateralAmount(f.depositor.address, f.Collateral.address)).to.equal(f.initialDeposits);\n// Kresko's balance has increased\n(0, _chai.expect)(await f.Collateral.balanceOf(_hardhat.default.Diamond.address)).to.equal(f.initialDeposits.add(f.initialDeposits));\n// Account's balance has decreased\n(0, _chai.expect)((0, _values.fromBig)(await f.Collateral.balanceOf(f.depositor.address))).to.equal((0, _values.fromBig)(f.initialBalance) - (0, _values.fromBig)(f.initialDeposits));",
                      "err": {},
                      "uuid": "54a8f487-04d1-4f13-aa1d-26395612c1e8",
                      "parentUUID": "aa5bdbb0-ab6e-4216-aee2-0f01b8cf92a2",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow an arbitrary account to deposit whitelisted collateral on behalf of another account",
                      "fullTitle": "Minter - Deposit Withdraw #collateral #deposit should allow an arbitrary account to deposit whitelisted collateral on behalf of another account",
                      "timedOut": false,
                      "duration": 23,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Initially, the array of the f.user's deposited collateral assets should be empty.\nconst depositedCollateralAssetsBefore = await _hardhat.default.Diamond.getAccountCollateralAssets(f.user.address);\n(0, _chai.expect)(depositedCollateralAssetsBefore).to.deep.equal([]);\n// Deposit collateral, from f.depositor -> f.user.\nawait (0, _chai.expect)(f.Depositor.depositCollateral(f.user.address, f.Collateral.address, f.initialDeposits)).not.to.be.reverted;\n// Confirm the array of the f.user's deposited collateral assets has been pushed to.\nconst depositedCollateralAssetsAfter = await _hardhat.default.Diamond.getAccountCollateralAssets(f.user.address);\n(0, _chai.expect)(depositedCollateralAssetsAfter).to.deep.equal([\n    f.Collateral.address\n]);\n// Confirm the amount deposited is recorded for the f.user.\nconst amountDeposited = await _hardhat.default.Diamond.getAccountCollateralAmount(f.user.address, f.Collateral.address);\n(0, _chai.expect)(amountDeposited).to.equal(f.initialDeposits);\n// Confirm the amount as been transferred from the f.user into Kresko.sol\nconst kreskoBalance = await f.Collateral.balanceOf(_hardhat.default.Diamond.address);\n(0, _chai.expect)(kreskoBalance).to.equal(f.initialDeposits.add(f.initialDeposits));\n// Confirm the f.depositor's wallet balance has been adjusted accordingly\nconst depositorBalanceAfter = await f.Collateral.balanceOf(f.depositor.address);\n(0, _chai.expect)((0, _values.fromBig)(depositorBalanceAfter)).to.equal((0, _values.fromBig)(f.initialBalance) - (0, _values.fromBig)(f.initialDeposits));",
                      "err": {},
                      "uuid": "1f06694d-1a0a-41af-8aa6-903dde43da35",
                      "parentUUID": "aa5bdbb0-ab6e-4216-aee2-0f01b8cf92a2",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow an account to deposit more collateral to an existing deposit",
                      "fullTitle": "Minter - Deposit Withdraw #collateral #deposit should allow an account to deposit more collateral to an existing deposit",
                      "timedOut": false,
                      "duration": 28,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Deposit first batch of collateral\nawait (0, _chai.expect)(f.Depositor.depositCollateral(f.depositor.address, f.Collateral.address, f.initialDeposits)).not.to.be.reverted;\n// Deposit second batch of collateral\nawait (0, _chai.expect)(f.Depositor.depositCollateral(f.depositor.address, f.Collateral.address, f.initialDeposits)).not.to.be.reverted;\n// Confirm the array of the f.user's deposited collateral assets hasn't been double-pushed to.\nconst depositedCollateralAssetsAfter = await _hardhat.default.Diamond.getAccountCollateralAssets(f.depositor.address);\n(0, _chai.expect)(depositedCollateralAssetsAfter).to.deep.equal([\n    f.Collateral.address\n]);\n// Confirm the amount deposited is recorded for the f.user.\nconst amountDeposited = await _hardhat.default.Diamond.getAccountCollateralAmount(f.depositor.address, f.Collateral.address);\n(0, _chai.expect)(amountDeposited).to.equal(f.initialDeposits.add(f.initialDeposits));",
                      "err": {},
                      "uuid": "417aad44-9d9e-48d9-b21c-625efca02ac6",
                      "parentUUID": "aa5bdbb0-ab6e-4216-aee2-0f01b8cf92a2",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow an account to have deposited multiple collateral assets",
                      "fullTitle": "Minter - Deposit Withdraw #collateral #deposit should allow an account to have deposited multiple collateral assets",
                      "timedOut": false,
                      "duration": 26,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Load f.user account with a different type of collateral\nawait f.Collateral2.setBalance(f.depositor, f.initialBalance, _hardhat.default.Diamond.address);\n// Deposit batch of first collateral type\nawait (0, _chai.expect)(f.Depositor.depositCollateral(f.depositor.address, f.Collateral.address, f.initialDeposits)).not.to.be.reverted;\n// Deposit batch of second collateral type\nawait (0, _chai.expect)(f.Depositor.depositCollateral(f.depositor.address, f.Collateral2.address, f.initialDeposits)).not.to.be.reverted;\n// Confirm the array of the f.user's deposited collateral assets contains both collateral assets\nconst depositedCollateralAssetsAfter = await _hardhat.default.Diamond.getAccountCollateralAssets(f.depositor.address);\n(0, _chai.expect)(depositedCollateralAssetsAfter).to.deep.equal([\n    f.Collateral.address,\n    f.Collateral2.address\n]);",
                      "err": {},
                      "uuid": "1d683c30-7888-4970-be18-5a2418e0973e",
                      "parentUUID": "aa5bdbb0-ab6e-4216-aee2-0f01b8cf92a2",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should emit CollateralDeposited event",
                      "fullTitle": "Minter - Deposit Withdraw #collateral #deposit should emit CollateralDeposited event",
                      "timedOut": false,
                      "duration": 12,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const tx = await f.Depositor.depositCollateral(f.depositor.address, f.Collateral.address, f.initialDeposits);\nconst event = await (0, _events.getInternalEvent)(tx, _hardhat.default.Diamond, 'CollateralDeposited');\n(0, _chai.expect)(event.account).to.equal(f.depositor.address);\n(0, _chai.expect)(event.collateralAsset).to.equal(f.Collateral.address);\n(0, _chai.expect)(event.amount).to.equal(f.initialDeposits);",
                      "err": {},
                      "uuid": "8873ffb6-e281-4c85-9e50-d04dc314dbf5",
                      "parentUUID": "aa5bdbb0-ab6e-4216-aee2-0f01b8cf92a2",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should revert if depositing collateral that has not been whitelisted",
                      "fullTitle": "Minter - Deposit Withdraw #collateral #deposit should revert if depositing collateral that has not been whitelisted",
                      "timedOut": false,
                      "duration": 7,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, _chai.expect)(f.Depositor.depositCollateral(f.depositor.address, '0x0000000000000000000000000000000000000001', f.initialDeposits)).to.be.revertedWithCustomError((0, _errors.Errors)(_hardhat.default), 'ASSET_NOT_MINTER_COLLATERAL').withArgs([\n    '',\n    '0x0000000000000000000000000000000000000001'\n]);",
                      "err": {},
                      "uuid": "e75013cf-2cbd-435c-b819-92af6d91cb77",
                      "parentUUID": "aa5bdbb0-ab6e-4216-aee2-0f01b8cf92a2",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should revert if depositing an amount of 0",
                      "fullTitle": "Minter - Deposit Withdraw #collateral #deposit should revert if depositing an amount of 0",
                      "timedOut": false,
                      "duration": 11,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, _chai.expect)(f.Depositor.depositCollateral(f.depositor.address, f.Collateral.address, 0)).to.be.revertedWithCustomError((0, _errors.Errors)(_hardhat.default), 'ZERO_DEPOSIT').withArgs(f.Collateral.errorId);",
                      "err": {},
                      "uuid": "c05974a9-dd68-493d-b9a0-3673a5dcd15e",
                      "parentUUID": "aa5bdbb0-ab6e-4216-aee2-0f01b8cf92a2",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should revert if collateral is not depositable",
                      "fullTitle": "Minter - Deposit Withdraw #collateral #deposit should revert if collateral is not depositable",
                      "timedOut": false,
                      "duration": 46,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const { deployer, devOne, extOne } = await _hardhat.default.ethers.getNamedSigners();\nawait (0, _execution.executeContractCallWithSigners)(_hardhat.default.Multisig, _hardhat.default.Diamond, 'toggleAssetsPaused', [\n    [\n        f.Collateral.address\n    ],\n    _types.Action.DEPOSIT,\n    true,\n    0\n], [\n    deployer,\n    devOne,\n    extOne\n]);\nconst isDepositPaused = await _hardhat.default.Diamond.assetActionPaused(_types.Action.DEPOSIT.toString(), f.Collateral.address);\n(0, _chai.expect)(isDepositPaused).to.equal(true);\nawait (0, _chai.expect)(_hardhat.default.Diamond.connect(f.depositor).depositCollateral(f.depositor.address, f.Collateral.contract.address, 0)).to.be.revertedWithCustomError((0, _errors.Errors)(_hardhat.default), 'ASSET_PAUSED_FOR_THIS_ACTION').withArgs(f.Collateral.errorId, _types.Action.DEPOSIT);",
                      "err": {},
                      "uuid": "d747a06f-cf48-4e00-adfd-603c4d2fded4",
                      "parentUUID": "aa5bdbb0-ab6e-4216-aee2-0f01b8cf92a2",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "7c4e9e9e-e169-4a73-b958-9ab14ba14029",
                    "a63978ee-37ad-4c9a-9a25-0f05337479f9",
                    "54a8f487-04d1-4f13-aa1d-26395612c1e8",
                    "1f06694d-1a0a-41af-8aa6-903dde43da35",
                    "417aad44-9d9e-48d9-b21c-625efca02ac6",
                    "1d683c30-7888-4970-be18-5a2418e0973e",
                    "8873ffb6-e281-4c85-9e50-d04dc314dbf5",
                    "e75013cf-2cbd-435c-b819-92af6d91cb77",
                    "c05974a9-dd68-493d-b9a0-3673a5dcd15e",
                    "d747a06f-cf48-4e00-adfd-603c4d2fded4"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 266,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                },
                {
                  "uuid": "16bc3dc7-cd8a-47fa-81db-6a56c2a1c0e6",
                  "title": "#withdraw",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                  "file": "/src/test/minter/02-deposit-withdraw.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [],
                  "suites": [
                    {
                      "uuid": "8b491694-01a8-409d-9bc7-860a1227fc8c",
                      "title": "when the account's minimum collateral value is 0",
                      "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                      "file": "/src/test/minter/02-deposit-withdraw.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "should allow an account to withdraw their entire deposit",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw when the account's minimum collateral value is 0 should allow an account to withdraw their entire deposit",
                          "timedOut": false,
                          "duration": 57,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const depositedCollateralAssets = await _hardhat.default.Diamond.getAccountCollateralAssets(f.withdrawer.address);\n(0, _chai.expect)(depositedCollateralAssets).to.deep.equal([\n    f.Collateral.address\n]);\nawait f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.Collateral.address,\n    amount: f.initialDeposits,\n    collateralIndex: 0,\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\n// Ensure that the collateral asset is removed from the account's deposited collateral\n// assets array.\nconst depositedCollateralAssetsPostWithdraw = await _hardhat.default.Diamond.getAccountCollateralAssets(f.withdrawer.address);\n(0, _chai.expect)(depositedCollateralAssetsPostWithdraw).to.deep.equal([]);\n// Ensure the change in the f.user's deposit is recorded.\nconst amountDeposited = await _hardhat.default.Diamond.getAccountCollateralAmount(f.withdrawer.address, f.Collateral.address);\n(0, _chai.expect)(amountDeposited).to.equal(0);\n// Ensure the amount transferred is correct\nconst kreskoBalance = await f.Collateral.balanceOf(_hardhat.default.Diamond.address);\n(0, _chai.expect)(kreskoBalance).to.equal(0);\nconst userOneBalance = await f.Collateral.balanceOf(f.withdrawer.address);\n(0, _chai.expect)(userOneBalance).to.equal(f.initialDeposits);",
                          "err": {},
                          "uuid": "de1af7fb-6795-478c-8778-5a70050e73fe",
                          "parentUUID": "8b491694-01a8-409d-9bc7-860a1227fc8c",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "should allow an account to withdraw a portion of their deposit",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw when the account's minimum collateral value is 0 should allow an account to withdraw a portion of their deposit",
                          "timedOut": false,
                          "duration": 59,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const withdrawAmount = f.initialDeposits.div(2);\nawait f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.Collateral.address,\n    amount: withdrawAmount,\n    collateralIndex: 0,\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\n// Ensure the change in the f.user's deposit is recorded.\nconst amountDeposited = await _hardhat.default.Diamond.getAccountCollateralAmount(f.withdrawer.address, f.Collateral.address);\n(0, _chai.expect)(amountDeposited).to.equal(f.initialDeposits.sub(withdrawAmount));\n// Ensure that the collateral asset is still in the account's deposited collateral\n// assets array.\nconst depositedCollateralAssets = await _hardhat.default.Diamond.getAccountCollateralAssets(f.withdrawer.address);\n(0, _chai.expect)(depositedCollateralAssets).to.deep.equal([\n    f.Collateral.address\n]);\nconst kreskoBalance = await f.Collateral.balanceOf(_hardhat.default.Diamond.address);\n(0, _chai.expect)(kreskoBalance).to.equal(f.initialDeposits.sub(withdrawAmount));\nconst userOneBalance = await f.Collateral.balanceOf(f.withdrawer.address);\n(0, _chai.expect)(userOneBalance).to.equal(f.initialDeposits.sub(amountDeposited));",
                          "err": {},
                          "uuid": "b46acd05-1972-48ca-b361-15352f063cb6",
                          "parentUUID": "8b491694-01a8-409d-9bc7-860a1227fc8c",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "should allow trusted address to withdraw another accounts deposit",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw when the account's minimum collateral value is 0 should allow trusted address to withdraw another accounts deposit",
                          "timedOut": false,
                          "duration": 63,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Grant userThree the MANAGER role\nawait _hardhat.default.Diamond.grantRole(_roles.Role.MANAGER, f.user.address);\n(0, _chai.expect)(await _hardhat.default.Diamond.hasRole(_roles.Role.MANAGER, f.user.address)).to.equal(true);\nconst collateralBefore = await _hardhat.default.Diamond.getAccountCollateralAmount(f.withdrawer.address, f.Collateral.address);\nawait (0, _chai.expect)(f.User.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.Collateral.address,\n    amount: f.initialDeposits,\n    collateralIndex: 0,\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData())).to.not.be.reverted;\nconst collateralAfter = await _hardhat.default.Diamond.getAccountCollateralAmount(f.withdrawer.address, f.Collateral.address);\n// Ensure that collateral was withdrawn\n(0, _chai.expect)(collateralAfter).to.equal(collateralBefore.sub(f.initialDeposits));",
                          "err": {},
                          "uuid": "05ecd37e-4095-4645-9694-c864e899137f",
                          "parentUUID": "8b491694-01a8-409d-9bc7-860a1227fc8c",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "should emit CollateralWithdrawn event",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw when the account's minimum collateral value is 0 should emit CollateralWithdrawn event",
                          "timedOut": false,
                          "duration": 47,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const tx = await f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.Collateral.address,\n    amount: f.initialDeposits,\n    collateralIndex: 0,\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\nconst event = await (0, _events.getInternalEvent)(tx, _hardhat.default.Diamond, 'CollateralWithdrawn');\n(0, _chai.expect)(event.account).to.equal(f.withdrawer.address);\n(0, _chai.expect)(event.collateralAsset).to.equal(f.Collateral.address);\n(0, _chai.expect)(event.amount).to.equal(f.initialDeposits);",
                          "err": {},
                          "uuid": "cca62a97-007c-49dc-8af9-0d555fa42c7a",
                          "parentUUID": "8b491694-01a8-409d-9bc7-860a1227fc8c",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "should not allow untrusted address to withdraw another accounts deposit",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw when the account's minimum collateral value is 0 should not allow untrusted address to withdraw another accounts deposit",
                          "timedOut": false,
                          "duration": 44,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "await (0, _chai.expect)(f.User.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.Collateral.address,\n    amount: f.initialBalance,\n    collateralIndex: 0,\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData())).to.be.revertedWith(`AccessControl: account ${f.user.address.toLowerCase()} is missing role 0x46925e0f0cc76e485772167edccb8dc449d43b23b55fc4e756b063f49099e6a0`);",
                          "err": {},
                          "uuid": "68f7a102-3548-4a4a-a28b-7ab0209cd715",
                          "parentUUID": "8b491694-01a8-409d-9bc7-860a1227fc8c",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [
                        {
                          "uuid": "37f416cf-9328-41f2-b431-4690ee635313",
                          "title": "when the account's minimum collateral value is > 0",
                          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                          "file": "/src/test/minter/02-deposit-withdraw.ts",
                          "beforeHooks": [
                            {
                              "title": "\"before each\" hook in \"when the account's minimum collateral value is > 0\"",
                              "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw when the account's minimum collateral value is 0 when the account's minimum collateral value is > 0 \"before each\" hook in \"when the account's minimum collateral value is > 0\"",
                              "timedOut": false,
                              "duration": 76,
                              "state": null,
                              "speed": null,
                              "pass": false,
                              "fail": false,
                              "pending": false,
                              "context": null,
                              "code": "// userOne mints some kr assets\nthis.mintAmount = (0, _values.toBig)(100);\nawait f.Withdrawer.mintKreskoAsset({\n    account: f.withdrawer.address,\n    krAsset: f.KrAsset.address,\n    amount: this.mintAmount,\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\n// Mint amount differs from deposited amount due to open fee\nconst amountDeposited = await _optimizations.default.getAccountCollateralAmount(f.withdrawer.address, f.Collateral.address);\nthis.initialUserOneDeposited = amountDeposited;\nthis.mcr = await _optimizations.default.getMinCollateralRatioMinter();",
                              "err": {},
                              "uuid": "5e229ff8-a360-49a8-883c-4ccc75f4458d",
                              "parentUUID": "37f416cf-9328-41f2-b431-4690ee635313",
                              "isHook": true,
                              "skipped": false
                            }
                          ],
                          "afterHooks": [],
                          "tests": [
                            {
                              "title": "should allow an account to withdraw their deposit if it does not violate the health factor",
                              "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw when the account's minimum collateral value is 0 when the account's minimum collateral value is > 0 should allow an account to withdraw their deposit if it does not violate the health factor",
                              "timedOut": false,
                              "duration": 116,
                              "state": "passed",
                              "speed": "fast",
                              "pass": true,
                              "fail": false,
                              "pending": false,
                              "context": null,
                              "code": "const withdrawAmount = (0, _values.toBig)(10);\n// Ensure that the withdrawal would not put the account's collateral value\n// less than the account's minimum collateral value:\nconst [accMinCollateralValue, accCollateralValue, withdrawnCollateralValue] = await Promise.all([\n    _hardhat.default.Diamond.getAccountMinCollateralAtRatio(f.withdrawer.address, this.mcr),\n    _hardhat.default.Diamond.getAccountTotalCollateralValue(f.withdrawer.address),\n    _hardhat.default.Diamond.getValue(f.Collateral.address, withdrawAmount)\n]);\n(0, _chai.expect)(accCollateralValue.sub(withdrawnCollateralValue).gte(accMinCollateralValue)).to.be.true;\nawait f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.Collateral.address,\n    amount: withdrawAmount,\n    collateralIndex: 0,\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\n// Ensure that the collateral asset is still in the account's deposited collateral\n// assets array.\nconst depositedCollateralAssets = await _hardhat.default.Diamond.getAccountCollateralAssets(f.withdrawer.address);\n(0, _chai.expect)(depositedCollateralAssets).to.deep.equal([\n    f.Collateral.address\n]);\n// Ensure the change in the f.user's deposit is recorded.\nconst amountDeposited = await _hardhat.default.Diamond.getAccountCollateralAmount(f.withdrawer.address, f.Collateral.address);\n(0, _chai.expect)(amountDeposited).to.equal(f.initialDeposits.sub(withdrawAmount));\n// Check the balances of the contract and f.user\nconst kreskoBalance = await f.Collateral.balanceOf(_hardhat.default.Diamond.address);\n(0, _chai.expect)(kreskoBalance).to.equal(f.initialDeposits.sub(withdrawAmount));\nconst withdrawerBalance = await f.Collateral.balanceOf(f.withdrawer.address);\n(0, _chai.expect)(withdrawerBalance).to.equal(withdrawAmount);\n// Ensure the account's minimum collateral value is <= the account collateral value\nconst accountMinCollateralValueAfter = await _hardhat.default.Diamond.getAccountMinCollateralAtRatio(f.withdrawer.address, this.mcr);\nconst accountCollateralValueAfter = await _hardhat.default.Diamond.getAccountTotalCollateralValue(f.withdrawer.address);\n(0, _chai.expect)(accountMinCollateralValueAfter.lte(accountCollateralValueAfter)).to.be.true;",
                              "err": {},
                              "uuid": "d6e1ddff-5968-4657-92ad-33947ffa0df4",
                              "parentUUID": "37f416cf-9328-41f2-b431-4690ee635313",
                              "isHook": false,
                              "skipped": false
                            },
                            {
                              "title": "should allow withdraws that exceed deposits and only send the user total deposit available",
                              "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw when the account's minimum collateral value is 0 when the account's minimum collateral value is > 0 should allow withdraws that exceed deposits and only send the user total deposit available",
                              "timedOut": false,
                              "duration": 65,
                              "state": "passed",
                              "speed": "fast",
                              "pass": true,
                              "fail": false,
                              "pending": false,
                              "context": null,
                              "code": "const randomUser = _hardhat.default.users.userFour;\nawait f.Collateral.setBalance(randomUser, (0, _values.toBig)(0));\nawait f.Collateral.setBalance(randomUser, (0, _values.toBig)(1000));\nawait f.Collateral.contract.connect(randomUser).approve(_hardhat.default.Diamond.address, _hardhat.default.ethers.constants.MaxUint256);\nawait (0, _collaterals.depositCollateral)({\n    asset: f.Collateral,\n    amount: (0, _values.toBig)(1000),\n    user: randomUser\n});\nawait (0, _collaterals.withdrawCollateral)({\n    asset: f.Collateral,\n    amount: (0, _values.toBig)(1010),\n    user: randomUser\n}, await _hardhat.default.updateData());\n(0, _chai.expect)(await f.Collateral.balanceOf(randomUser.address)).to.equal((0, _values.toBig)(1000));",
                              "err": {},
                              "uuid": "2f92e1ad-1850-443d-b482-12de3e519cdf",
                              "parentUUID": "37f416cf-9328-41f2-b431-4690ee635313",
                              "isHook": false,
                              "skipped": false
                            },
                            {
                              "title": "should revert if withdrawing an amount of 0",
                              "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw when the account's minimum collateral value is 0 when the account's minimum collateral value is > 0 should revert if withdrawing an amount of 0",
                              "timedOut": false,
                              "duration": 46,
                              "state": "passed",
                              "speed": "fast",
                              "pass": true,
                              "fail": false,
                              "pending": false,
                              "context": null,
                              "code": "const withdrawAmount = 0;\nawait (0, _chai.expect)(f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.Collateral.address,\n    amount: withdrawAmount,\n    collateralIndex: 0,\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData())).to.be.revertedWithCustomError((0, _errors.Errors)(_hardhat.default), 'ZERO_AMOUNT').withArgs(f.Collateral.errorId);",
                              "err": {},
                              "uuid": "0995574e-1f5d-478c-8628-41f2f028dd1a",
                              "parentUUID": "37f416cf-9328-41f2-b431-4690ee635313",
                              "isHook": false,
                              "skipped": false
                            },
                            {
                              "title": "should revert if the withdrawal violates the health factor",
                              "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw when the account's minimum collateral value is 0 when the account's minimum collateral value is > 0 should revert if the withdrawal violates the health factor",
                              "timedOut": false,
                              "duration": 88,
                              "state": "passed",
                              "speed": "fast",
                              "pass": true,
                              "fail": false,
                              "pending": false,
                              "context": null,
                              "code": "// userOne has a debt position, so attempting to withdraw the entire collateral deposit should be impossible\nconst withdrawAmount = f.initialBalance;\n// Ensure that the withdrawal would in fact put the account's collateral value\n// less than the account's minimum collateral value:\nconst accountMinCollateralValue = await _hardhat.default.Diamond.getAccountMinCollateralAtRatio(f.withdrawer.address, this.mcr);\nconst accountCollateralValue = await _hardhat.default.Diamond.getAccountTotalCollateralValue(f.withdrawer.address);\nconst withdrawnCollateralValue = await _hardhat.default.Diamond.getValue(f.Collateral.address, withdrawAmount);\n(0, _chai.expect)(accountCollateralValue.sub(withdrawnCollateralValue).lt(accountMinCollateralValue)).to.be.true;\nawait (0, _chai.expect)(f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.Collateral.address,\n    amount: withdrawAmount,\n    collateralIndex: 0,\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData())).to.be.revertedWithCustomError((0, _errors.Errors)(_hardhat.default), 'ACCOUNT_COLLATERAL_VALUE_LESS_THAN_REQUIRED').withArgs(f.withdrawer.address, 0, 150000000000, await _hardhat.default.Diamond.getMinCollateralRatioMinter());",
                              "err": {},
                              "uuid": "f7c0c05b-43ee-456d-9cf8-b52a8c75643f",
                              "parentUUID": "37f416cf-9328-41f2-b431-4690ee635313",
                              "isHook": false,
                              "skipped": false
                            },
                            {
                              "title": "should revert if the depositIndex is incorrect",
                              "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw when the account's minimum collateral value is 0 when the account's minimum collateral value is > 0 should revert if the depositIndex is incorrect",
                              "timedOut": false,
                              "duration": 45,
                              "state": "passed",
                              "speed": "fast",
                              "pass": true,
                              "fail": false,
                              "pending": false,
                              "context": null,
                              "code": "const withdrawAmount = f.initialDeposits.div(2);\nawait (0, _chai.expect)(f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.Collateral.address,\n    amount: withdrawAmount,\n    collateralIndex: 1,\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData())).to.be.revertedWithCustomError((0, _errors.Errors)(_hardhat.default), 'ARRAY_INDEX_OUT_OF_BOUNDS').withArgs(f.Collateral.errorId, 1, [\n    f.Collateral.address\n]);",
                              "err": {},
                              "uuid": "0f0630a5-b11d-4b2f-bbb4-d6fb700770ac",
                              "parentUUID": "37f416cf-9328-41f2-b431-4690ee635313",
                              "isHook": false,
                              "skipped": false
                            }
                          ],
                          "suites": [],
                          "passes": [
                            "d6e1ddff-5968-4657-92ad-33947ffa0df4",
                            "2f92e1ad-1850-443d-b482-12de3e519cdf",
                            "0995574e-1f5d-478c-8628-41f2f028dd1a",
                            "f7c0c05b-43ee-456d-9cf8-b52a8c75643f",
                            "0f0630a5-b11d-4b2f-bbb4-d6fb700770ac"
                          ],
                          "failures": [],
                          "pending": [],
                          "skipped": [],
                          "duration": 360,
                          "root": false,
                          "rootEmpty": false,
                          "_timeout": 30000
                        }
                      ],
                      "passes": [
                        "de1af7fb-6795-478c-8778-5a70050e73fe",
                        "b46acd05-1972-48ca-b361-15352f063cb6",
                        "05ecd37e-4095-4645-9694-c864e899137f",
                        "cca62a97-007c-49dc-8af9-0d555fa42c7a",
                        "68f7a102-3548-4a4a-a28b-7ab0209cd715"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 270,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 30000
                    }
                  ],
                  "passes": [],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 0,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                },
                {
                  "uuid": "ca6bc61b-ddb4-459f-a5d5-d3da20b09163",
                  "title": "#deposit - rebase",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                  "file": "/src/test/minter/02-deposit-withdraw.ts",
                  "beforeHooks": [
                    {
                      "title": "\"before each\" hook in \"#deposit - rebase\"",
                      "fullTitle": "Minter - Deposit Withdraw #collateral #deposit - rebase \"before each\" hook in \"#deposit - rebase\"",
                      "timedOut": false,
                      "duration": 85,
                      "state": null,
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await f.Collateral.setBalance(f.user, f.initialBalance, _hardhat.default.Diamond.address);\n// Add krAsset as a collateral with anchor and cFactor of 1\n// Allowance for Kresko\nawait f.KrAssetCollateral.contract.setVariable('_allowances', {\n    [f.user.address]: {\n        [_hardhat.default.Diamond.address]: _hardhat.default.ethers.constants.MaxInt256\n    }\n});\n// Deposit some collateral\nawait f.User.depositCollateral(f.user.address, f.Collateral.address, f.initialDeposits);\n// Mint some krAssets\nawait f.User.mintKreskoAsset({\n    account: f.user.address,\n    krAsset: f.KrAssetCollateral.address,\n    amount: mintAmount,\n    receiver: f.user.address\n}, await _hardhat.default.updateData());\n// Deposit all debt on tests\nthis.krAssetCollateralAmount = await f.User.getAccountDebtAmount(f.user.address, f.KrAssetCollateral.address);",
                      "err": {},
                      "uuid": "e7174297-a56d-42b9-97ab-7752e12bf1c3",
                      "parentUUID": "ca6bc61b-ddb4-459f-a5d5-d3da20b09163",
                      "isHook": true,
                      "skipped": false
                    }
                  ],
                  "afterHooks": [],
                  "tests": [],
                  "suites": [
                    {
                      "uuid": "094e4872-2f7f-45a2-aa29-22030e370094",
                      "title": "deposit amounts are calculated correctly",
                      "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                      "file": "/src/test/minter/02-deposit-withdraw.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "when deposit is made before positive rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #deposit - rebase deposit amounts are calculated correctly when deposit is made before positive rebase",
                          "timedOut": false,
                          "duration": 33,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "await f.User.depositCollateral(f.user.address, f.KrAssetCollateral.address, this.krAssetCollateralAmount);\n// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst expectedDepositsAfter = this.krAssetCollateralAmount.mul(denominator);\nconst depositsBefore = await _hardhat.default.Diamond.getAccountCollateralAmount(f.user.address, f.KrAssetCollateral.address);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\nconst finalDeposits = await _hardhat.default.Diamond.getAccountCollateralAmount(f.user.address, f.KrAssetCollateral.address);\n// Ensure that the collateral balance is adjusted by the rebase\n(0, _chai.expect)(depositsBefore).to.not.equal(finalDeposits);\n(0, _chai.expect)(finalDeposits).to.equal(expectedDepositsAfter);\n(0, _chai.expect)(await f.KrAssetCollateral.balanceOf(f.user.address)).to.equal(0);",
                          "err": {},
                          "uuid": "9b18c59a-e035-4389-9b53-92cba659695f",
                          "parentUUID": "094e4872-2f7f-45a2-aa29-22030e370094",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made before negative rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #deposit - rebase deposit amounts are calculated correctly when deposit is made before negative rebase",
                          "timedOut": false,
                          "duration": 33,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst depositAmountAfterRebase = this.krAssetCollateralAmount.div(denominator);\n// Deposit\nawait f.User.depositCollateral(f.user.address, f.KrAssetCollateral.address, this.krAssetCollateralAmount);\nconst depositsBefore = await _hardhat.default.Diamond.getAccountCollateralAmount(f.user.address, f.KrAssetCollateral.address);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\nconst finalDeposits = await _hardhat.default.Diamond.getAccountCollateralAmount(f.user.address, f.KrAssetCollateral.address);\n// Ensure that the collateral balance is adjusted by the rebase\n(0, _chai.expect)(depositsBefore).to.not.equal(finalDeposits);\n(0, _chai.expect)(finalDeposits).to.equal(depositAmountAfterRebase);\n(0, _chai.expect)(await f.KrAssetCollateral.balanceOf(f.user.address)).to.equal(0);",
                          "err": {},
                          "uuid": "a2001612-85d4-42fa-b4b3-15a6d4689c5e",
                          "parentUUID": "094e4872-2f7f-45a2-aa29-22030e370094",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made after an positiveing rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #deposit - rebase deposit amounts are calculated correctly when deposit is made after an positiveing rebase",
                          "timedOut": false,
                          "duration": 29,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst depositAmount = this.krAssetCollateralAmount.mul(denominator);\nconst depositsBefore = await _hardhat.default.Diamond.getAccountCollateralAmount(f.user.address, f.KrAssetCollateral.address);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Deposit after the rebase\nawait f.User.depositCollateral(f.user.address, f.KrAssetCollateral.address, depositAmount);\n// Get collateral deposits after\nconst finalDeposits = await _hardhat.default.Diamond.getAccountCollateralAmount(f.user.address, f.KrAssetCollateral.address);\n// Ensure that the collateral balance is what was deposited as no rebases occured after\n(0, _chai.expect)(depositsBefore).to.not.equal(finalDeposits);\n(0, _chai.expect)(finalDeposits).to.equal(depositAmount);\n(0, _chai.expect)(await f.KrAssetCollateral.balanceOf(f.user.address)).to.equal(0);",
                          "err": {},
                          "uuid": "0dbd4850-d540-465d-8d53-cfd3fc112e89",
                          "parentUUID": "094e4872-2f7f-45a2-aa29-22030e370094",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made after an negative rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #deposit - rebase deposit amounts are calculated correctly when deposit is made after an negative rebase",
                          "timedOut": false,
                          "duration": 31,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst depositAmount = this.krAssetCollateralAmount.div(denominator);\nconst depositsBefore = await _hardhat.default.Diamond.getAccountCollateralAmount(f.user.address, f.KrAssetCollateral.address);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Deposit after the rebase\nawait f.User.depositCollateral(f.user.address, f.KrAssetCollateral.address, depositAmount);\n// Get collateral deposits after\nconst finalDeposits = await _hardhat.default.Diamond.getAccountCollateralAmount(f.user.address, f.KrAssetCollateral.address);\n// Ensure that the collateral balance is what was deposited as no rebases occured after\n(0, _chai.expect)(depositsBefore).to.not.equal(finalDeposits);\n(0, _chai.expect)(finalDeposits).to.equal(depositAmount);\n(0, _chai.expect)(await f.KrAssetCollateral.balanceOf(f.user.address)).to.equal(0);",
                          "err": {},
                          "uuid": "61064c36-a937-40d4-a46a-3954b7f7eda0",
                          "parentUUID": "094e4872-2f7f-45a2-aa29-22030e370094",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made before and after a positiveing rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #deposit - rebase deposit amounts are calculated correctly when deposit is made before and after a positiveing rebase",
                          "timedOut": false,
                          "duration": 47,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\n// Deposit half before, half after\nconst halfDepositBeforeRebase = this.krAssetCollateralAmount.div(2);\nconst halfDepositAfterRebase = this.krAssetCollateralAmount.div(2).mul(denominator);\nconst fullDepositAmount = this.krAssetCollateralAmount.mul(denominator);\nawait f.User.depositCollateral(f.user.address, f.KrAssetCollateral.address, halfDepositBeforeRebase);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Get deposits after\nconst depositsAfter = await _hardhat.default.Diamond.getAccountCollateralAmount(f.user.address, f.KrAssetCollateral.address);\n// Ensure that the collateral balance is adjusted by the rebase\n(0, _chai.expect)(depositsAfter).to.equal(halfDepositAfterRebase);\n// Deposit second time\nawait f.User.depositCollateral(f.user.address, f.KrAssetCollateral.address, halfDepositAfterRebase);\n// Get deposits after\nconst finalDeposits = await _hardhat.default.Diamond.getAccountCollateralAmount(f.user.address, f.KrAssetCollateral.address);\n(0, _chai.expect)(finalDeposits).to.equal(fullDepositAmount);\n(0, _chai.expect)(await f.KrAssetCollateral.balanceOf(f.user.address)).to.equal(0);",
                          "err": {},
                          "uuid": "6ed0789e-602a-4f3a-a8d7-46c88131c1af",
                          "parentUUID": "094e4872-2f7f-45a2-aa29-22030e370094",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made before and after a negative rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #deposit - rebase deposit amounts are calculated correctly when deposit is made before and after a negative rebase",
                          "timedOut": false,
                          "duration": 47,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\n// Deposit half before, half after\nconst halfDepositBeforeRebase = this.krAssetCollateralAmount.div(2);\nconst halfDepositAfterRebase = this.krAssetCollateralAmount.div(2).div(denominator);\nconst fullDepositAmount = this.krAssetCollateralAmount.div(denominator);\nawait f.User.depositCollateral(f.user.address, f.KrAssetCollateral.address, halfDepositBeforeRebase);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Get deposits after\nconst depositsAfterRebase = await _hardhat.default.Diamond.getAccountCollateralAmount(f.user.address, f.KrAssetCollateral.address);\n// Ensure that the collateral balance is adjusted by the rebase\n(0, _chai.expect)(depositsAfterRebase).to.equal(halfDepositAfterRebase);\n// Deposit second time\nawait f.User.depositCollateral(f.user.address, f.KrAssetCollateral.address, halfDepositAfterRebase);\n// Get deposits after\nconst finalDeposits = await _hardhat.default.Diamond.getAccountCollateralAmount(f.user.address, f.KrAssetCollateral.address);\n(0, _chai.expect)(finalDeposits).to.equal(fullDepositAmount);\n(0, _chai.expect)(await f.KrAssetCollateral.balanceOf(f.user.address)).to.equal(0);",
                          "err": {},
                          "uuid": "02096880-f898-4e8c-8e21-d9bf5d42f963",
                          "parentUUID": "094e4872-2f7f-45a2-aa29-22030e370094",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "9b18c59a-e035-4389-9b53-92cba659695f",
                        "a2001612-85d4-42fa-b4b3-15a6d4689c5e",
                        "0dbd4850-d540-465d-8d53-cfd3fc112e89",
                        "61064c36-a937-40d4-a46a-3954b7f7eda0",
                        "6ed0789e-602a-4f3a-a8d7-46c88131c1af",
                        "02096880-f898-4e8c-8e21-d9bf5d42f963"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 220,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 30000
                    },
                    {
                      "uuid": "186272c7-faf0-4919-ad57-e374122401f6",
                      "title": "deposit usd values are calculated correctly",
                      "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                      "file": "/src/test/minter/02-deposit-withdraw.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "when deposit is made before positiveing rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #deposit - rebase deposit usd values are calculated correctly when deposit is made before positiveing rebase",
                          "timedOut": false,
                          "duration": 105,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "await f.User.depositCollateral(f.user.address, f.KrAssetCollateral.address, this.krAssetCollateralAmount);\nconst valueBefore = await _hardhat.default.Diamond.getAccountTotalCollateralValue(f.user.address);\n// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst newPrice = (0, _values.fromBig)((await f.KrAssetCollateral.getPrice()).pyth, 8) / denominator;\nawait f.KrAssetCollateral.setPrice(newPrice);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Get collateral value of account after\nconst valueAfter = await _hardhat.default.Diamond.getAccountTotalCollateralValue(f.user.address);\n// Ensure that the collateral value stays the same\n(0, _chai.expect)(valueBefore).to.equal(valueAfter);",
                          "err": {},
                          "uuid": "5027aa70-19c2-48bd-b6cd-a2dd91a3fce4",
                          "parentUUID": "186272c7-faf0-4919-ad57-e374122401f6",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made before negative rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #deposit - rebase deposit usd values are calculated correctly when deposit is made before negative rebase",
                          "timedOut": false,
                          "duration": 102,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "await f.User.depositCollateral(f.user.address, f.KrAssetCollateral.address, this.krAssetCollateralAmount);\nconst valueBefore = await _hardhat.default.Diamond.getAccountTotalCollateralValue(f.user.address);\n// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst newPrice = (0, _values.fromBig)((await f.KrAssetCollateral.getPrice()).pyth, 8) * denominator;\nawait f.KrAssetCollateral.setPrice(newPrice);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Get collateral value of account after\nconst valueAfter = await _hardhat.default.Diamond.getAccountTotalCollateralValue(f.user.address);\n// Ensure that the collateral value stays the same\n(0, _chai.expect)(valueBefore).to.equal(valueAfter);",
                          "err": {},
                          "uuid": "4976bd12-42aa-4354-bf23-b0303e9c3403",
                          "parentUUID": "186272c7-faf0-4919-ad57-e374122401f6",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made after an positiveing rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #deposit - rebase deposit usd values are calculated correctly when deposit is made after an positiveing rebase",
                          "timedOut": false,
                          "duration": 83,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst newPrice = (0, _values.fromBig)((await f.KrAssetCollateral.getPrice()).pyth, 8) / denominator;\n// Get expected value before rebase and deposit\nconst expectedValue = await _hardhat.default.Diamond.getValue(f.KrAssetCollateral.address, this.krAssetCollateralAmount);\nconst depositAmount = this.krAssetCollateralAmount.mul(denominator);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.setPrice(newPrice);\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Deposit rebased amount after\nawait f.User.depositCollateral(f.user.address, f.KrAssetCollateral.address, depositAmount);\n// Get collateral value of account after\nconst valueAfter = await _hardhat.default.Diamond.getValue(f.KrAssetCollateral.address, depositAmount);\n// Ensure that the collateral value stays the same\n(0, _chai.expect)(expectedValue).to.equal(valueAfter);",
                          "err": {},
                          "uuid": "ea3756eb-57f7-4a09-b0f1-8819e3525f68",
                          "parentUUID": "186272c7-faf0-4919-ad57-e374122401f6",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made after an negative rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #deposit - rebase deposit usd values are calculated correctly when deposit is made after an negative rebase",
                          "timedOut": false,
                          "duration": 83,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst newPrice = (0, _values.fromBig)((await f.KrAssetCollateral.getPrice()).pyth, 8) * denominator;\n// Get expected value before rebase and deposit\nconst expectedValue = await _hardhat.default.Diamond.getValue(f.KrAssetCollateral.address, this.krAssetCollateralAmount);\nconst depositAmount = this.krAssetCollateralAmount.div(denominator);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.setPrice(newPrice);\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Deposit rebased amount after\nawait f.User.depositCollateral(f.user.address, f.KrAssetCollateral.address, depositAmount);\n// Get collateral value of account after\nconst valueAfter = await _hardhat.default.Diamond.getValue(f.KrAssetCollateral.address, depositAmount);\n// Ensure that the collateral value stays the same\n(0, _chai.expect)(expectedValue).to.equal(valueAfter);",
                          "err": {},
                          "uuid": "85d7fa80-8331-4217-b4a0-a1f549811d70",
                          "parentUUID": "186272c7-faf0-4919-ad57-e374122401f6",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made before and after a positiveing rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #deposit - rebase deposit usd values are calculated correctly when deposit is made before and after a positiveing rebase",
                          "timedOut": false,
                          "duration": 119,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst newPrice = (0, _values.fromBig)((await f.KrAssetCollateral.getPrice()).pyth, 8) / denominator;\n// Deposit half before, half after\nconst halfDepositBeforeRebase = this.krAssetCollateralAmount.div(2);\nconst halfDepositAfterRebase = this.krAssetCollateralAmount.div(2).mul(denominator);\nconst fullDepositAmount = this.krAssetCollateralAmount.mul(denominator);\nawait f.User.depositCollateral(f.user.address, f.KrAssetCollateral.address, halfDepositBeforeRebase);\nconst expectedValue = await _hardhat.default.Diamond.getValue(f.KrAssetCollateral.address, halfDepositBeforeRebase);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.setPrice(newPrice);\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Get value after\nconst valueAfterRebase = await _hardhat.default.Diamond.getValue(f.KrAssetCollateral.address, halfDepositAfterRebase);\n// Ensure that the collateral value stays the same\n(0, _chai.expect)(expectedValue).to.equal(valueAfterRebase);\n// Calculate added value since price adjusted in the rebase\nconst expectedValueAfterSecondDeposit = await _hardhat.default.Diamond.getValue(f.KrAssetCollateral.address, fullDepositAmount);\n// Deposit more\nawait f.User.depositCollateral(f.user.address, f.KrAssetCollateral.address, halfDepositAfterRebase);\n// Get value\nconst [finalValue] = await _hardhat.default.Diamond.getAccountCollateralValues(f.user.address, f.KrAssetCollateral.address);\n// Ensure that the collateral value stays the same\n(0, _chai.expect)(finalValue).to.equal(expectedValueAfterSecondDeposit);",
                          "err": {},
                          "uuid": "405ce0f9-37cf-48ef-a9df-1669307c38db",
                          "parentUUID": "186272c7-faf0-4919-ad57-e374122401f6",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made before and after a negative rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #deposit - rebase deposit usd values are calculated correctly when deposit is made before and after a negative rebase",
                          "timedOut": false,
                          "duration": 119,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst newPrice = (0, _values.fromBig)((await f.KrAssetCollateral.getPrice()).pyth, 8) * denominator;\n// Deposit half before, half after\nconst halfDepositBeforeRebase = this.krAssetCollateralAmount.div(2);\nconst halfDepositAfterRebase = this.krAssetCollateralAmount.div(2).div(denominator);\nconst fullDepositAmount = this.krAssetCollateralAmount.div(denominator);\nawait f.User.depositCollateral(f.user.address, f.KrAssetCollateral.address, halfDepositBeforeRebase);\nconst expectedValue = await _hardhat.default.Diamond.getValue(f.KrAssetCollateral.address, halfDepositBeforeRebase);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.setPrice(newPrice);\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Get value after\nconst valueAfterRebase = await _hardhat.default.Diamond.getValue(f.KrAssetCollateral.address, halfDepositAfterRebase);\n// Ensure that the collateral value stays the same\n(0, _chai.expect)(expectedValue).to.equal(valueAfterRebase);\n// Calculate added value since price adjusted in the rebase\nconst expectedValueAfterSecondDeposit = await _hardhat.default.Diamond.getValue(f.KrAssetCollateral.address, fullDepositAmount);\n// Deposit more\nawait f.User.depositCollateral(f.user.address, f.KrAssetCollateral.address, halfDepositAfterRebase);\n// Get deposits after\nconst [finalValue] = await _hardhat.default.Diamond.getAccountCollateralValues(f.user.address, f.KrAssetCollateral.address);\n// Ensure that the collateral value stays the same\n(0, _chai.expect)(finalValue).to.equal(expectedValueAfterSecondDeposit);",
                          "err": {},
                          "uuid": "ba5f0098-5620-48b8-a121-5a48ea629f5c",
                          "parentUUID": "186272c7-faf0-4919-ad57-e374122401f6",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "5027aa70-19c2-48bd-b6cd-a2dd91a3fce4",
                        "4976bd12-42aa-4354-bf23-b0303e9c3403",
                        "ea3756eb-57f7-4a09-b0f1-8819e3525f68",
                        "85d7fa80-8331-4217-b4a0-a1f549811d70",
                        "405ce0f9-37cf-48ef-a9df-1669307c38db",
                        "ba5f0098-5620-48b8-a121-5a48ea629f5c"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 611,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 30000
                    }
                  ],
                  "passes": [],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 0,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                },
                {
                  "uuid": "d456c31f-0ea8-4fa0-803a-3d7e5a071151",
                  "title": "#withdraw - rebase",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                  "file": "/src/test/minter/02-deposit-withdraw.ts",
                  "beforeHooks": [
                    {
                      "title": "\"before each\" hook in \"#withdraw - rebase\"",
                      "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw - rebase \"before each\" hook in \"#withdraw - rebase\"",
                      "timedOut": false,
                      "duration": 77,
                      "state": null,
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await f.Withdrawer.mintKreskoAsset({\n    account: f.withdrawer.address,\n    krAsset: f.KrAssetCollateral.address,\n    amount: mintAmount,\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\n// Deposit all debt on tests\nthis.krAssetCollateralAmount = await _optimizations.default.getAccountDebtAmount(f.withdrawer.address, f.KrAssetCollateral);",
                      "err": {},
                      "uuid": "f0753deb-5714-4a49-aea9-4a526752970f",
                      "parentUUID": "d456c31f-0ea8-4fa0-803a-3d7e5a071151",
                      "isHook": true,
                      "skipped": false
                    }
                  ],
                  "afterHooks": [],
                  "tests": [],
                  "suites": [
                    {
                      "uuid": "4678de8a-4cc4-4188-8540-91a46fe786e9",
                      "title": "withdraw amounts are calculated correctly",
                      "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                      "file": "/src/test/minter/02-deposit-withdraw.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "when withdrawing a deposit made before positive rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw - rebase withdraw amounts are calculated correctly when withdrawing a deposit made before positive rebase",
                          "timedOut": false,
                          "duration": 100,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst rebasedDepositAmount = this.krAssetCollateralAmount.mul(denominator);\n// Deposit collateral before rebase\nawait f.Withdrawer.depositCollateral(f.withdrawer.address, f.KrAssetCollateral.address, this.krAssetCollateralAmount);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\nconst depositsAfter = await _hardhat.default.Diamond.getAccountCollateralAmount(f.withdrawer.address, f.KrAssetCollateral.address);\n// Ensure that the collateral balance is adjusted by the rebase\n(0, _chai.expect)(depositsAfter).to.equal(rebasedDepositAmount);\n// Withdraw rebased amount\nawait f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.KrAssetCollateral.address,\n    amount: rebasedDepositAmount,\n    collateralIndex: _optimizations.default.getAccountDepositIndex(f.withdrawer.address, f.KrAssetCollateral.address),\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\nconst finalDeposits = await _hardhat.default.Diamond.getAccountCollateralAmount(f.withdrawer.address, f.KrAssetCollateral.address);\nconst finalBalance = await f.KrAssetCollateral.contract.balanceOf(f.withdrawer.address);\n(0, _chai.expect)(finalDeposits).to.equal(0);\n(0, _chai.expect)(finalBalance).to.equal(rebasedDepositAmount);",
                          "err": {},
                          "uuid": "ea172378-8323-4281-9d2d-7a723ce47b08",
                          "parentUUID": "4678de8a-4cc4-4188-8540-91a46fe786e9",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a deposit made before negative rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw - rebase withdraw amounts are calculated correctly when withdrawing a deposit made before negative rebase",
                          "timedOut": false,
                          "duration": 96,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst rebasedDepositAmount = this.krAssetCollateralAmount.div(denominator);\n// Deposit collateral before rebase\nawait f.Withdrawer.depositCollateral(f.withdrawer.address, f.KrAssetCollateral.address, this.krAssetCollateralAmount);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\nconst depositsAfter = await _hardhat.default.Diamond.getAccountCollateralAmount(f.withdrawer.address, f.KrAssetCollateral.address);\n// Ensure that the collateral balance is adjusted by the rebase\n(0, _chai.expect)(depositsAfter).to.equal(rebasedDepositAmount);\n// Withdraw rebased amount\nawait f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.KrAssetCollateral.address,\n    amount: rebasedDepositAmount,\n    collateralIndex: _optimizations.default.getAccountDepositIndex(f.withdrawer.address, f.KrAssetCollateral.address),\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\nconst finalDeposits = await _hardhat.default.Diamond.getAccountCollateralAmount(f.withdrawer.address, f.KrAssetCollateral.address);\nconst finalBalance = await f.KrAssetCollateral.contract.balanceOf(f.withdrawer.address);\n(0, _chai.expect)(finalDeposits).to.equal(0);\n(0, _chai.expect)(finalBalance).to.equal(rebasedDepositAmount);",
                          "err": {},
                          "uuid": "b8ef6435-42f6-43f5-86dc-4758d95b28be",
                          "parentUUID": "4678de8a-4cc4-4188-8540-91a46fe786e9",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a deposit made after an positive rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw - rebase withdraw amounts are calculated correctly when withdrawing a deposit made after an positive rebase",
                          "timedOut": false,
                          "duration": 95,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst rebasedDepositAmount = this.krAssetCollateralAmount.mul(denominator);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Deposit after the rebase\nawait f.Withdrawer.depositCollateral(f.withdrawer.address, f.KrAssetCollateral.address, rebasedDepositAmount);\n// Get collateral deposits after\nconst depositsAfter = await _hardhat.default.Diamond.getAccountCollateralAmount(f.withdrawer.address, f.KrAssetCollateral.address);\n// Ensure that the collateral balance is what was deposited as no rebases occured after\n(0, _chai.expect)(depositsAfter).to.equal(rebasedDepositAmount);\n// Withdraw rebased amount\nawait f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.KrAssetCollateral.address,\n    amount: rebasedDepositAmount,\n    collateralIndex: _optimizations.default.getAccountDepositIndex(f.withdrawer.address, f.KrAssetCollateral.address),\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\nconst finalDeposits = await _hardhat.default.Diamond.getAccountCollateralAmount(f.withdrawer.address, f.KrAssetCollateral.address);\nconst finalBalance = await f.KrAssetCollateral.contract.balanceOf(f.withdrawer.address);\n(0, _chai.expect)(finalDeposits).to.equal(0);\n(0, _chai.expect)(finalBalance).to.equal(rebasedDepositAmount);",
                          "err": {},
                          "uuid": "877ae6bd-ad7f-499e-8242-120a4f049d37",
                          "parentUUID": "4678de8a-4cc4-4188-8540-91a46fe786e9",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a deposit made after a negative rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw - rebase withdraw amounts are calculated correctly when withdrawing a deposit made after a negative rebase",
                          "timedOut": false,
                          "duration": 106,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst rebasedDepositAmount = this.krAssetCollateralAmount.div(denominator);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Deposit after the rebase\nawait f.Withdrawer.depositCollateral(f.withdrawer.address, f.KrAssetCollateral.address, rebasedDepositAmount);\n// Get collateral deposits after\nconst depositsAfter = await _hardhat.default.Diamond.getAccountCollateralAmount(f.withdrawer.address, f.KrAssetCollateral.address);\n// Ensure that the collateral balance is what was deposited as no rebases occured after\n(0, _chai.expect)(depositsAfter).to.equal(rebasedDepositAmount);\n// Withdraw rebased amount\nawait f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.KrAssetCollateral.address,\n    amount: rebasedDepositAmount,\n    collateralIndex: _optimizations.default.getAccountDepositIndex(f.withdrawer.address, f.KrAssetCollateral.address),\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\nconst finalDeposits = await _hardhat.default.Diamond.getAccountCollateralAmount(f.withdrawer.address, f.KrAssetCollateral.address);\nconst finalBalance = await f.KrAssetCollateral.contract.balanceOf(f.withdrawer.address);\n(0, _chai.expect)(finalDeposits).to.equal(0);\n(0, _chai.expect)(finalBalance).to.equal(rebasedDepositAmount);",
                          "err": {},
                          "uuid": "0765fd92-dd68-4e6f-95d1-4a96e04cb2a9",
                          "parentUUID": "4678de8a-4cc4-4188-8540-91a46fe786e9",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a deposit made before and after a positive rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw - rebase withdraw amounts are calculated correctly when withdrawing a deposit made before and after a positive rebase",
                          "timedOut": false,
                          "duration": 117,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\n// Deposit half before, half (rebase adjusted) after\nconst firstDepositAmount = this.krAssetCollateralAmount.div(2);\nconst secondDepositAmount = this.krAssetCollateralAmount.div(2).mul(denominator);\nconst fullDepositAmount = this.krAssetCollateralAmount.mul(denominator);\n// Deposit before the rebase\nawait f.Withdrawer.depositCollateral(f.withdrawer.address, f.KrAssetCollateral.address, firstDepositAmount);\n// Get deposits before\nconst depositsFirst = await _hardhat.default.Diamond.getAccountCollateralAmount(f.withdrawer.address, f.KrAssetCollateral.address);\n(0, _chai.expect)(depositsFirst).to.equal(firstDepositAmount);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Deposit after the rebase\nawait f.Withdrawer.depositCollateral(f.withdrawer.address, f.KrAssetCollateral.address, secondDepositAmount);\n// Get collateral deposits after\nconst depositsAfter = await _hardhat.default.Diamond.getAccountCollateralAmount(f.withdrawer.address, f.KrAssetCollateral.address);\n// Ensure deposit balance matches expected\n(0, _chai.expect)(depositsAfter).to.equal(fullDepositAmount);\n// Withdraw rebased amount\nawait f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.KrAssetCollateral.address,\n    amount: fullDepositAmount,\n    collateralIndex: _optimizations.default.getAccountDepositIndex(f.withdrawer.address, f.KrAssetCollateral.address),\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\nconst finalDeposits = await _hardhat.default.Diamond.getAccountCollateralAmount(f.withdrawer.address, f.KrAssetCollateral.address);\nconst finalBalance = await f.KrAssetCollateral.contract.balanceOf(f.withdrawer.address);\n(0, _chai.expect)(finalDeposits).to.equal(0);\n(0, _chai.expect)(finalBalance).to.equal(fullDepositAmount);",
                          "err": {},
                          "uuid": "739212fb-972e-41b3-9c67-962573ba0f8c",
                          "parentUUID": "4678de8a-4cc4-4188-8540-91a46fe786e9",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a deposit made before and after a negative rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw - rebase withdraw amounts are calculated correctly when withdrawing a deposit made before and after a negative rebase",
                          "timedOut": false,
                          "duration": 118,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\n// Deposit half before, half (rebase adjusted) after\nconst firstDepositAmount = this.krAssetCollateralAmount.div(2);\nconst secondDepositAmount = this.krAssetCollateralAmount.div(2).div(denominator);\nconst fullDepositAmount = this.krAssetCollateralAmount.div(denominator);\n// Deposit before the rebase\nawait f.Withdrawer.depositCollateral(f.withdrawer.address, f.KrAssetCollateral.address, firstDepositAmount);\n// Get deposits before\nconst depositsFirst = await _hardhat.default.Diamond.getAccountCollateralAmount(f.withdrawer.address, f.KrAssetCollateral.address);\n(0, _chai.expect)(depositsFirst).to.equal(firstDepositAmount);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Deposit after the rebase\nawait f.Withdrawer.depositCollateral(f.withdrawer.address, f.KrAssetCollateral.address, secondDepositAmount);\n// Get collateral deposits after\nconst depositsAfter = await _hardhat.default.Diamond.getAccountCollateralAmount(f.withdrawer.address, f.KrAssetCollateral.address);\n// Ensure deposit balance matches expected\n(0, _chai.expect)(depositsAfter).to.equal(fullDepositAmount);\n// Withdraw rebased amount\nawait f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.KrAssetCollateral.address,\n    amount: fullDepositAmount,\n    collateralIndex: _optimizations.default.getAccountDepositIndex(f.withdrawer.address, f.KrAssetCollateral.address),\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\nconst finalDeposits = await _hardhat.default.Diamond.getAccountCollateralAmount(f.withdrawer.address, f.KrAssetCollateral.address);\nconst finalBalance = await f.KrAssetCollateral.contract.balanceOf(f.withdrawer.address);\n(0, _chai.expect)(finalDeposits).to.equal(0);\n(0, _chai.expect)(finalBalance).to.equal(fullDepositAmount);",
                          "err": {},
                          "uuid": "51abaf09-9ccb-48a2-a717-ece1fb5d685b",
                          "parentUUID": "4678de8a-4cc4-4188-8540-91a46fe786e9",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a non-rebased collateral after a rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw - rebase withdraw amounts are calculated correctly when withdrawing a non-rebased collateral after a rebase",
                          "timedOut": false,
                          "duration": 139,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst newPrice = (0, _values.fromBig)((await f.KrAssetCollateral.getPrice()).pyth, 8) / denominator;\nconst withdrawAmount = (0, _values.toBig)(10);\nawait f.Withdrawer.depositCollateral(f.withdrawer.address, f.KrAssetCollateral.address, this.krAssetCollateralAmount);\nconst nrcBalanceBefore = await f.Collateral.contract.balanceOf(f.withdrawer.address);\nconst expectedNrcBalanceAfter = nrcBalanceBefore.add(withdrawAmount);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.setPrice(newPrice);\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\nawait f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.Collateral.address,\n    amount: withdrawAmount,\n    collateralIndex: _optimizations.default.getAccountDepositIndex(f.withdrawer.address, f.Collateral.address),\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\n(0, _chai.expect)(await f.Collateral.contract.balanceOf(f.withdrawer.address)).to.equal(expectedNrcBalanceAfter);",
                          "err": {},
                          "uuid": "6268f7f0-1b0c-4168-ad6a-fe246641c2a8",
                          "parentUUID": "4678de8a-4cc4-4188-8540-91a46fe786e9",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "ea172378-8323-4281-9d2d-7a723ce47b08",
                        "b8ef6435-42f6-43f5-86dc-4758d95b28be",
                        "877ae6bd-ad7f-499e-8242-120a4f049d37",
                        "0765fd92-dd68-4e6f-95d1-4a96e04cb2a9",
                        "739212fb-972e-41b3-9c67-962573ba0f8c",
                        "51abaf09-9ccb-48a2-a717-ece1fb5d685b",
                        "6268f7f0-1b0c-4168-ad6a-fe246641c2a8"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 771,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 30000
                    },
                    {
                      "uuid": "8fc36b35-3a9e-44d1-90a8-6042c7d5367c",
                      "title": "withdraw usd values are calculated correctly",
                      "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                      "file": "/src/test/minter/02-deposit-withdraw.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "when withdrawing a deposit made before positive rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw - rebase withdraw usd values are calculated correctly when withdrawing a deposit made before positive rebase",
                          "timedOut": false,
                          "duration": 146,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst newPrice = (0, _values.fromBig)((await f.KrAssetCollateral.getPrice()).pyth, 8) / denominator;\nconst rebasedDepositAmount = this.krAssetCollateralAmount.mul(denominator);\nawait f.Withdrawer.depositCollateral(f.withdrawer.address, f.KrAssetCollateral.address, this.krAssetCollateralAmount);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.setPrice(newPrice);\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\nawait f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.KrAssetCollateral.address,\n    amount: rebasedDepositAmount,\n    collateralIndex: _optimizations.default.getAccountDepositIndex(f.withdrawer.address, f.KrAssetCollateral.address),\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\nconst [finalValue] = await _hardhat.default.Diamond.getAccountCollateralValues(f.withdrawer.address, f.KrAssetCollateral.address);\n(0, _chai.expect)(finalValue).to.equal(0);\n(0, _chai.expect)(await f.KrAssetCollateral.contract.balanceOf(f.withdrawer.address)).to.equal(rebasedDepositAmount);",
                          "err": {},
                          "uuid": "71f2ae26-3e2f-4f10-80bf-f753239b19d0",
                          "parentUUID": "8fc36b35-3a9e-44d1-90a8-6042c7d5367c",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a deposit made before negative rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw - rebase withdraw usd values are calculated correctly when withdrawing a deposit made before negative rebase",
                          "timedOut": false,
                          "duration": 143,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst newPrice = (0, _values.fromBig)((await f.KrAssetCollateral.getPrice()).pyth, 8) * denominator;\nconst rebasedDepositAmount = this.krAssetCollateralAmount.div(denominator);\n// Deposit\nawait f.Withdrawer.depositCollateral(f.withdrawer.address, f.KrAssetCollateral.address, this.krAssetCollateralAmount);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.setPrice(newPrice);\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Withdraw the full rebased amount\nawait f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.KrAssetCollateral.address,\n    amount: rebasedDepositAmount,\n    collateralIndex: _optimizations.default.getAccountDepositIndex(f.withdrawer.address, f.KrAssetCollateral.address),\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\n// Get value\nconst [finalValue] = await _hardhat.default.Diamond.getAccountCollateralValues(f.withdrawer.address, f.KrAssetCollateral.address);\n(0, _chai.expect)(finalValue).to.equal(0);\n(0, _chai.expect)(await f.KrAssetCollateral.contract.balanceOf(f.withdrawer.address)).to.equal(rebasedDepositAmount);",
                          "err": {},
                          "uuid": "4569b5f8-9cdc-4039-882d-5db58fa37a38",
                          "parentUUID": "8fc36b35-3a9e-44d1-90a8-6042c7d5367c",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrwaing a deposit made after an positiveing rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw - rebase withdraw usd values are calculated correctly when withdrwaing a deposit made after an positiveing rebase",
                          "timedOut": false,
                          "duration": 148,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst newPrice = (0, _values.fromBig)((await f.KrAssetCollateral.getPrice()).pyth, 8) / denominator;\nconst depositAmount = this.krAssetCollateralAmount.mul(denominator);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.setPrice(newPrice);\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Deposit rebased amount after\nawait f.Withdrawer.depositCollateral(f.withdrawer.address, f.KrAssetCollateral.address, depositAmount);\n// Withdraw the full rebased amount\nawait f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.KrAssetCollateral.address,\n    amount: depositAmount,\n    collateralIndex: _optimizations.default.getAccountDepositIndex(f.withdrawer.address, f.KrAssetCollateral.address),\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\n// Get value\nconst [finalValue] = await _hardhat.default.Diamond.getAccountCollateralValues(f.withdrawer.address, f.KrAssetCollateral.address);\n(0, _chai.expect)(finalValue).to.equal(0);\n(0, _chai.expect)(await f.KrAssetCollateral.contract.balanceOf(f.withdrawer.address)).to.equal(depositAmount);",
                          "err": {},
                          "uuid": "642269f1-f03a-424a-a21f-41c7be068153",
                          "parentUUID": "8fc36b35-3a9e-44d1-90a8-6042c7d5367c",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a deposit made after an negative rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw - rebase withdraw usd values are calculated correctly when withdrawing a deposit made after an negative rebase",
                          "timedOut": false,
                          "duration": 148,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst newPrice = (0, _values.fromBig)((await f.KrAssetCollateral.getPrice()).pyth, 8) * denominator;\nconst depositAmount = this.krAssetCollateralAmount.div(denominator);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.setPrice(newPrice);\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Deposit rebased amount after\nawait f.Withdrawer.depositCollateral(f.withdrawer.address, f.KrAssetCollateral.address, depositAmount);\n// Withdraw the full rebased amount\nawait f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.KrAssetCollateral.address,\n    amount: depositAmount,\n    collateralIndex: _optimizations.default.getAccountDepositIndex(f.withdrawer.address, f.KrAssetCollateral.address),\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\n// Get value\nconst [finalValue] = await _hardhat.default.Diamond.getAccountCollateralValues(f.withdrawer.address, f.KrAssetCollateral.address);\n(0, _chai.expect)(finalValue).to.equal(0);\n(0, _chai.expect)(await f.KrAssetCollateral.contract.balanceOf(f.withdrawer.address)).to.equal(depositAmount);",
                          "err": {},
                          "uuid": "4d0364b6-226d-4634-82bf-639c795a328c",
                          "parentUUID": "8fc36b35-3a9e-44d1-90a8-6042c7d5367c",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a deposit made before and after a positive rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw - rebase withdraw usd values are calculated correctly when withdrawing a deposit made before and after a positive rebase",
                          "timedOut": false,
                          "duration": 187,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst newPrice = (0, _values.fromBig)((await f.KrAssetCollateral.getPrice()).pyth, 8) / denominator;\n// Deposit half before, half after\nconst firstDepositAmount = this.krAssetCollateralAmount.div(2);\nconst secondDepositAmount = this.krAssetCollateralAmount.div(2).mul(denominator);\nconst fullDepositAmount = this.krAssetCollateralAmount.mul(denominator);\nawait f.Withdrawer.depositCollateral(f.withdrawer.address, f.KrAssetCollateral.address, firstDepositAmount);\nconst [expectedValue] = await _hardhat.default.Diamond.getAccountCollateralValues(f.withdrawer.address, f.KrAssetCollateral.address);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.setPrice(newPrice);\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Get value after\nconst [valueAfterRebase] = await _hardhat.default.Diamond.getAccountCollateralValues(f.withdrawer.address, f.KrAssetCollateral.address);\n// Ensure that the collateral value stays the same\n(0, _chai.expect)(expectedValue).to.equal(valueAfterRebase);\n// Deposit more\nawait f.Withdrawer.depositCollateral(f.withdrawer.address, f.KrAssetCollateral.address, secondDepositAmount);\n// Withdraw the full rebased amount\nawait f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.KrAssetCollateral.address,\n    amount: fullDepositAmount,\n    collateralIndex: _optimizations.default.getAccountDepositIndex(f.withdrawer.address, f.KrAssetCollateral.address),\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\n// Get value\nconst [finalValue] = await _hardhat.default.Diamond.getAccountCollateralValues(f.withdrawer.address, f.KrAssetCollateral.address);\n(0, _chai.expect)(finalValue).to.equal(0);\n(0, _chai.expect)(await f.KrAssetCollateral.contract.balanceOf(f.withdrawer.address)).to.equal(fullDepositAmount);",
                          "err": {},
                          "uuid": "71675641-4861-4210-a818-3500efe8c88e",
                          "parentUUID": "8fc36b35-3a9e-44d1-90a8-6042c7d5367c",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a deposit made before and after a negative rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw - rebase withdraw usd values are calculated correctly when withdrawing a deposit made before and after a negative rebase",
                          "timedOut": false,
                          "duration": 194,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst newPrice = (0, _values.fromBig)((await f.KrAssetCollateral.getPrice()).pyth, 8) * denominator;\n// Deposit half before, half after\nconst firstDepositAmount = this.krAssetCollateralAmount.div(2);\nconst secondDepositAmount = this.krAssetCollateralAmount.div(denominator).div(2);\nconst fullDepositAmount = this.krAssetCollateralAmount.div(denominator);\nawait f.Withdrawer.depositCollateral(f.withdrawer.address, f.KrAssetCollateral.address, firstDepositAmount);\nconst [expectedValue] = await _hardhat.default.Diamond.getAccountCollateralValues(f.withdrawer.address, f.KrAssetCollateral.address);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.setPrice(newPrice);\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Get value after\nconst [valueAfterRebase] = await _hardhat.default.Diamond.getAccountCollateralValues(f.withdrawer.address, f.KrAssetCollateral.address);\n// Ensure that the collateral value stays the same\n(0, _chai.expect)(expectedValue).to.equal(valueAfterRebase);\n// Deposit more\nawait f.Withdrawer.depositCollateral(f.withdrawer.address, f.KrAssetCollateral.address, secondDepositAmount);\n// Withdraw the full rebased amount\nawait f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.KrAssetCollateral.address,\n    amount: fullDepositAmount,\n    collateralIndex: _optimizations.default.getAccountDepositIndex(f.withdrawer.address, f.KrAssetCollateral.address),\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\n// Get value\nconst [finalValue] = await _hardhat.default.Diamond.getAccountCollateralValues(f.withdrawer.address, f.KrAssetCollateral.address);\n(0, _chai.expect)(finalValue).to.equal(0);\n(0, _chai.expect)(await f.KrAssetCollateral.contract.balanceOf(f.withdrawer.address)).to.equal(fullDepositAmount);",
                          "err": {},
                          "uuid": "ffdd3da0-7162-4f39-8e11-965d85b4bb93",
                          "parentUUID": "8fc36b35-3a9e-44d1-90a8-6042c7d5367c",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a non-rebased collateral after a rebase",
                          "fullTitle": "Minter - Deposit Withdraw #collateral #withdraw - rebase withdraw usd values are calculated correctly when withdrawing a non-rebased collateral after a rebase",
                          "timedOut": false,
                          "duration": 204,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst newPrice = (0, _values.fromBig)((await f.KrAssetCollateral.getPrice()).pyth, 8) / denominator;\nconst withdrawAmount = (0, _values.toBig)(10);\nawait f.Withdrawer.depositCollateral(f.withdrawer.address, f.KrAssetCollateral.address, this.krAssetCollateralAmount);\nconst accountValueBefore = await _hardhat.default.Diamond.getAccountTotalCollateralValue(f.withdrawer.address);\nconst [nrcValueBefore] = await _hardhat.default.Diamond.getAccountCollateralValues(f.withdrawer.address, f.Collateral.address);\nconst withdrawValue = await _hardhat.default.Diamond.getValue(f.Collateral.address, withdrawAmount);\nconst expectedNrcValueAfter = nrcValueBefore.sub(withdrawValue);\n// Rebase the asset according to params\nawait f.KrAssetCollateral.setPrice(newPrice);\nawait f.KrAssetCollateral.contract.rebase((0, _values.toBig)(denominator), positive, []);\nawait f.Withdrawer.withdrawCollateral({\n    account: f.withdrawer.address,\n    asset: f.Collateral.address,\n    amount: withdrawAmount,\n    collateralIndex: _optimizations.default.getAccountDepositIndex(f.withdrawer.address, f.KrAssetCollateral.address),\n    receiver: f.withdrawer.address\n}, await _hardhat.default.updateData());\nconst finalAccountValue = await _hardhat.default.Diamond.getAccountTotalCollateralValue(f.withdrawer.address);\nconst [finalValue] = await _hardhat.default.Diamond.getAccountCollateralValues(f.withdrawer.address, f.Collateral.address);\n(0, _chai.expect)(finalValue).to.equal(expectedNrcValueAfter);\n(0, _chai.expect)(finalAccountValue).to.equal(accountValueBefore.sub(withdrawValue));",
                          "err": {},
                          "uuid": "4e26b4f3-b0ab-4c5d-b72a-fae81b2cda6f",
                          "parentUUID": "8fc36b35-3a9e-44d1-90a8-6042c7d5367c",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "71f2ae26-3e2f-4f10-80bf-f753239b19d0",
                        "4569b5f8-9cdc-4039-882d-5db58fa37a38",
                        "642269f1-f03a-424a-a21f-41c7be068153",
                        "4d0364b6-226d-4634-82bf-639c795a328c",
                        "71675641-4861-4210-a818-3500efe8c88e",
                        "ffdd3da0-7162-4f39-8e11-965d85b4bb93",
                        "4e26b4f3-b0ab-4c5d-b72a-fae81b2cda6f"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 1170,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 30000
                    }
                  ],
                  "passes": [],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 0,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                }
              ],
              "passes": [],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "291937c2-0c0c-4160-b3df-95dec19661cf",
          "title": "Minter - Liquidations",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/03-liquidation.ts",
          "file": "/src/test/minter/03-liquidation.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"Minter - Liquidations\"",
              "fullTitle": "Minter - Liquidations \"before each\" hook in \"Minter - Liquidations\"",
              "timedOut": false,
              "duration": 229,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "f = await (0, _fixtures.liquidationsFixture)();\nawait f.reset();",
              "err": {},
              "uuid": "3a88bf4d-a866-4135-a33c-d07450134434",
              "parentUUID": "291937c2-0c0c-4160-b3df-95dec19661cf",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "af8bb75a-417a-45ff-9f42-e8abeae79d64",
              "title": "#isAccountLiquidatable",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/03-liquidation.ts",
              "file": "/src/test/minter/03-liquidation.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should identify accounts below their liquidation threshold",
                  "fullTitle": "Minter - Liquidations #isAccountLiquidatable should identify accounts below their liquidation threshold",
                  "timedOut": false,
                  "duration": 116,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const [cr, minCollateralUSD, initialCanLiquidate] = await Promise.all([\n    hre.Diamond.getAccountCollateralRatio(f.user1.address),\n    hre.Diamond.getAccountMinCollateralAtRatio(f.user1.address, hre.Diamond.getLiquidationThresholdMinter()),\n    hre.Diamond.getAccountLiquidatable(f.user1.address)\n]);\n(0, _chai.expect)(cr).to.be.equal(1.5e4);\n(0, _chai.expect)(f.initialDeposits.mul(10).gt(minCollateralUSD));\n(0, _chai.expect)(initialCanLiquidate).to.equal(false);\nawait f.Collateral.setPrice(7.5);\n(0, _chai.expect)(await hre.Diamond.getAccountLiquidatable(f.user1.address)).to.equal(true);",
                  "err": {},
                  "uuid": "c2acbd00-2c29-4684-9c3b-430358cb0019",
                  "parentUUID": "af8bb75a-417a-45ff-9f42-e8abeae79d64",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "c2acbd00-2c29-4684-9c3b-430358cb0019"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 116,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            },
            {
              "uuid": "3bf5b97d-91eb-4132-bb43-e532c4aa11bb",
              "title": "#maxLiquidatableValue",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/03-liquidation.ts",
              "file": "/src/test/minter/03-liquidation.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "calculates correct MLV when kFactor = 1, cFactor = 0.25",
                  "fullTitle": "Minter - Liquidations #maxLiquidatableValue calculates correct MLV when kFactor = 1, cFactor = 0.25",
                  "timedOut": false,
                  "duration": 220,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const MLVBeforeC1 = await hre.Diamond.getMaxLiqValue(f.user1.address, f.KrAsset.address, f.Collateral.address);\nconst MLVBeforeC2 = await hre.Diamond.getMaxLiqValue(f.user1.address, f.KrAsset.address, f.Collateral2.address);\n(0, _chai.expect)(MLVBeforeC1.repayValue).to.be.closeTo(MLVBeforeC2.repayValue, USD_DELTA);\nawait hre.Diamond.setAssetCFactor(f.Collateral.address, 0.25e4);\nawait (0, _collaterals.depositMockCollateral)({\n    user: f.user1,\n    amount: f.initialDeposits.div(2),\n    asset: f.Collateral2\n});\nconst expectedCR = 1.125e4;\nconst [crAfter, isLiquidatableAfter, MLVAfterC1, MLVAfterC2] = await Promise.all([\n    hre.Diamond.getAccountCollateralRatio(f.user1.address),\n    hre.Diamond.getAccountLiquidatable(f.user1.address),\n    hre.Diamond.getMaxLiqValue(f.user1.address, f.KrAsset.address, f.Collateral.address),\n    hre.Diamond.getMaxLiqValue(f.user1.address, f.KrAsset.address, f.Collateral2.address)\n]);\n(0, _chai.expect)(isLiquidatableAfter).to.be.true;\n(0, _chai.expect)(crAfter).to.be.closeTo(expectedCR, 1);\n(0, _chai.expect)(MLVAfterC1.repayValue).to.gt(MLVBeforeC1.repayValue);\n(0, _chai.expect)(MLVAfterC2.repayValue).to.gt(MLVBeforeC2.repayValue);\n(0, _chai.expect)(MLVAfterC2.repayValue.gt(MLVAfterC1.repayValue)).to.be.true;",
                  "err": {},
                  "uuid": "f74af6e7-9a52-4e5e-8a5d-f1848663d871",
                  "parentUUID": "3bf5b97d-91eb-4132-bb43-e532c4aa11bb",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "calculates correct MLV with multiple cdps",
                  "fullTitle": "Minter - Liquidations #maxLiquidatableValue calculates correct MLV with multiple cdps",
                  "timedOut": false,
                  "duration": 163,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, _collaterals.depositMockCollateral)({\n    user: f.user1,\n    amount: (0, _values.toBig)(0.1, 8),\n    asset: f.Collateral8Dec\n});\nawait f.Collateral.setPrice(7.5);\n(0, _chai.expect)(await hre.Diamond.getAccountLiquidatable(f.user1.address)).to.be.true;\nconst [maxLiq, maxLiq8Dec] = await Promise.all([\n    hre.Diamond.getMaxLiqValue(f.user1.address, f.KrAsset.address, f.Collateral.address),\n    hre.Diamond.getMaxLiqValue(f.user1.address, f.KrAsset.address, f.Collateral8Dec.address)\n]);\n(0, _chai.expect)(maxLiq.repayValue).gt(0);\n(0, _chai.expect)(maxLiq8Dec.repayValue).gt(0);\n(0, _chai.expect)(maxLiq.repayValue).gt(maxLiq8Dec.repayValue);",
                  "err": {},
                  "uuid": "0c42d0c0-2db2-4b20-963d-f7cd61f8371d",
                  "parentUUID": "3bf5b97d-91eb-4132-bb43-e532c4aa11bb",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "f74af6e7-9a52-4e5e-8a5d-f1848663d871",
                "0c42d0c0-2db2-4b20-963d-f7cd61f8371d"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 383,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            },
            {
              "uuid": "c98c4910-cc3d-4ee5-a24f-4fc976503195",
              "title": "#liquidation",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/03-liquidation.ts",
              "file": "/src/test/minter/03-liquidation.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [],
              "suites": [
                {
                  "uuid": "b4bdcdf9-b2d8-4874-aa14-49c87e027df7",
                  "title": "#liquidate",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/03-liquidation.ts",
                  "file": "/src/test/minter/03-liquidation.ts",
                  "beforeHooks": [
                    {
                      "title": "\"before each\" hook in \"#liquidate\"",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate \"before each\" hook in \"#liquidate\"",
                      "timedOut": false,
                      "duration": 43,
                      "state": null,
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await f.Collateral.setPrice(7.5);",
                      "err": {},
                      "uuid": "73f05f8a-6b45-4671-8677-14dcc864e539",
                      "parentUUID": "b4bdcdf9-b2d8-4874-aa14-49c87e027df7",
                      "isHook": true,
                      "skipped": false
                    }
                  ],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should allow unhealthy accounts to be liquidated",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate should allow unhealthy accounts to be liquidated",
                      "timedOut": false,
                      "duration": 134,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Fetch pre-liquidation state for users and contracts\nconst beforeUserOneCollateralAmount = await _optimizations.default.getAccountCollateralAmount(f.user1.address, f.Collateral);\nconst userOneDebtBefore = await _optimizations.default.getAccountDebtAmount(f.user1.address, f.KrAsset);\nconst liquidatorBalanceBefore = await f.Collateral.balanceOf(f.liquidator.address);\nconst liquidatorBalanceKrBefore = await f.KrAsset.balanceOf(f.liquidator.address);\nconst kreskoBalanceBefore = await f.Collateral.balanceOf(hre.Diamond.address);\n// Liquidate userOne\nconst maxRepayAmount = f.userOneMaxLiqPrecalc.wadDiv((0, _values.toBig)(11, 8));\nawait f.Liquidator.liquidate({\n    account: f.user1.address,\n    repayAssetAddr: f.KrAsset.address,\n    repayAmount: maxRepayAmount,\n    seizeAssetAddr: f.Collateral.address,\n    repayAssetIndex: _optimizations.default.getAccountMintIndex(f.user1.address, f.KrAsset.address),\n    seizeAssetIndex: _optimizations.default.getAccountDepositIndex(f.user1.address, f.Collateral.address),\n    prices: await hre.updateData()\n});\n// Confirm that the liquidated user's debt amount has decreased by the repaid amount\nconst userOneDebtAfterLiquidation = await _optimizations.default.getAccountDebtAmount(f.user1.address, f.KrAsset);\n(0, _chai.expect)(userOneDebtAfterLiquidation.eq(userOneDebtBefore.sub(maxRepayAmount)));\n// Confirm that some of the liquidated user's collateral has been seized\nconst userOneCollateralAfterLiquidation = await _optimizations.default.getAccountCollateralAmount(f.user1.address, f.Collateral);\n(0, _chai.expect)(userOneCollateralAfterLiquidation.lt(beforeUserOneCollateralAmount));\n// Confirm that userTwo's kresko asset balance has decreased by the repaid amount\n(0, _chai.expect)(await f.KrAsset.balanceOf(f.liquidator.address)).eq(liquidatorBalanceKrBefore.sub(maxRepayAmount));\n// Confirm that userTwo has received some collateral from the contract\n(0, _chai.expect)(await f.Collateral.balanceOf(f.liquidator.address)).gt(liquidatorBalanceBefore);\n// Confirm that Kresko contract's collateral balance has decreased.\n(0, _chai.expect)(await f.Collateral.balanceOf(hre.Diamond.address)).lt(kreskoBalanceBefore);",
                      "err": {},
                      "uuid": "6393d5f8-3357-47d8-ba89-4220f6c5736b",
                      "parentUUID": "b4bdcdf9-b2d8-4874-aa14-49c87e027df7",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should liquidate up to MLR with a single CDP",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate should liquidate up to MLR with a single CDP",
                      "timedOut": false,
                      "duration": 193,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await hre.Diamond.setAssetCFactor(f.Collateral.address, 0.99e4);\nawait hre.Diamond.setAssetKFactor(f.KrAsset.address, 1.02e4);\nconst maxLiq = await hre.Diamond.getMaxLiqValue(f.user1.address, f.KrAsset.address, f.Collateral.address);\nawait f.Liquidator.liquidate({\n    account: f.user1.address,\n    repayAssetAddr: f.KrAsset.address,\n    repayAmount: maxLiq.repayAmount.add((0, _values.toBig)(1222, 27)),\n    seizeAssetAddr: f.Collateral.address,\n    repayAssetIndex: maxLiq.repayAssetIndex,\n    seizeAssetIndex: maxLiq.seizeAssetIndex,\n    prices: await hre.updateData()\n});\n(0, _chai.expect)(await hre.Diamond.getAccountCollateralRatio(f.user1.address)).to.be.eq(await _optimizations.default.getMaxLiquidationRatioMinter());\n(0, _chai.expect)(await hre.Diamond.getAccountLiquidatable(f.user1.address)).to.be.false;",
                      "err": {},
                      "uuid": "fe486700-c283-452a-a760-a64f2da2988b",
                      "parentUUID": "b4bdcdf9-b2d8-4874-aa14-49c87e027df7",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should liquidate up to MLR with multiple CDPs",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate should liquidate up to MLR with multiple CDPs",
                      "timedOut": false,
                      "duration": 406,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, _collaterals.depositMockCollateral)({\n    user: f.user1,\n    amount: (0, _values.toBig)(10, 8),\n    asset: f.Collateral8Dec\n});\nawait f.Collateral.setPrice(5.5);\nawait f.Collateral8Dec.setPrice(6);\nawait hre.Diamond.setAssetCFactor(f.Collateral.address, 0.9754e4);\nawait hre.Diamond.setAssetKFactor(f.KrAsset.address, 1.05e4);\nawait (0, _liquidations.liquidate)(f.user1, f.KrAsset, f.Collateral8Dec);\nconst [crAfter, isLiquidatableAfter] = await Promise.all([\n    hre.Diamond.getAccountCollateralRatio(f.user1.address),\n    hre.Diamond.getAccountLiquidatable(f.user1.address)\n]);\n(0, _chai.expect)(isLiquidatableAfter).to.be.false;\n(0, _chai.expect)(crAfter).to.be.eq(await _optimizations.default.getMaxLiquidationRatioMinter());",
                      "err": {},
                      "uuid": "21ebf2c0-8ed8-4d28-a970-e79cd0d84e1c",
                      "parentUUID": "b4bdcdf9-b2d8-4874-aa14-49c87e027df7",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should emit LiquidationOccurred event",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate should emit LiquidationOccurred event",
                      "timedOut": false,
                      "duration": 109,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const repayAmount = f.userOneMaxLiqPrecalc.wadDiv((0, _values.toBig)(11));\nconst tx = await f.Liquidator.liquidate({\n    account: f.user1.address,\n    repayAssetAddr: f.KrAsset.address,\n    repayAmount: repayAmount,\n    seizeAssetAddr: f.Collateral.address,\n    repayAssetIndex: _optimizations.default.getAccountMintIndex(f.user1.address, f.KrAsset.address),\n    seizeAssetIndex: _optimizations.default.getAccountDepositIndex(f.user1.address, f.Collateral.address),\n    prices: await hre.updateData()\n});\nconst event = await (0, _events.getNamedEvent)(tx, 'LiquidationOccurred');\n(0, _chai.expect)(event.args.account).to.equal(f.user1.address);\n(0, _chai.expect)(event.args.liquidator).to.equal(f.liquidator.address);\n(0, _chai.expect)(event.args.repayKreskoAsset).to.equal(f.KrAsset.address);\n(0, _chai.expect)(event.args.repayAmount).to.equal(repayAmount);\n(0, _chai.expect)(event.args.seizedCollateralAsset).to.equal(f.Collateral.address);",
                      "err": {},
                      "uuid": "aad5d33a-79a5-48d2-a66c-77be17d0ef20",
                      "parentUUID": "b4bdcdf9-b2d8-4874-aa14-49c87e027df7",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow liquidations of healthy accounts",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate should not allow liquidations of healthy accounts",
                      "timedOut": false,
                      "duration": 108,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await f.Collateral.setPrice(10);\nconst repayAmount = 10;\nconst mintedKreskoAssetIndex = 0;\nconst depositedCollateralAssetIndex = 0;\nawait (0, _chai.expect)(f.Liquidator.liquidate({\n    account: f.user1.address,\n    repayAssetAddr: f.KrAsset.address,\n    repayAmount: repayAmount,\n    seizeAssetAddr: f.Collateral.address,\n    repayAssetIndex: mintedKreskoAssetIndex,\n    seizeAssetIndex: depositedCollateralAssetIndex,\n    prices: await hre.updateData()\n})).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'CANNOT_LIQUIDATE_HEALTHY_ACCOUNT').withArgs(f.user1.address, 16500000000, 15400000000, await hre.Diamond.getLiquidationThresholdMinter());",
                      "err": {},
                      "uuid": "720d4f68-0679-4ed3-bba5-35d667fb0c23",
                      "parentUUID": "b4bdcdf9-b2d8-4874-aa14-49c87e027df7",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow liquidations if repayment amount is 0",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate should not allow liquidations if repayment amount is 0",
                      "timedOut": false,
                      "duration": 85,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Liquidation should fail\nconst repayAmount = 0;\nawait (0, _chai.expect)(f.LiquidatorTwo.liquidate({\n    account: f.user1.address,\n    repayAssetAddr: f.KrAsset.address,\n    repayAmount: repayAmount,\n    seizeAssetAddr: f.Collateral.address,\n    repayAssetIndex: 0,\n    seizeAssetIndex: 0,\n    prices: await hre.updateData()\n})).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'LIQUIDATION_VALUE_IS_ZERO').withArgs(f.KrAsset.errorId, f.Collateral.errorId);",
                      "err": {},
                      "uuid": "b948312e-8d19-42e4-8b86-fe6edba32814",
                      "parentUUID": "b4bdcdf9-b2d8-4874-aa14-49c87e027df7",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should clamp liquidations if repay value/amount exceeds debt",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate should clamp liquidations if repay value/amount exceeds debt",
                      "timedOut": false,
                      "duration": 180,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Get user's debt for this kresko asset\nconst krAssetDebtUserOne = await _optimizations.default.getAccountDebtAmount(f.user1.address, f.KrAsset);\n// Ensure we are repaying more than debt\nconst repayAmount = krAssetDebtUserOne.add((0, _values.toBig)(10));\nawait f.KrAsset.setBalance(f.liquidatorTwo, repayAmount, hre.Diamond.address);\n// Liquidation should fail\nconst liquidatorBalanceBefore = await f.KrAsset.balanceOf(f.liquidatorTwo.address);\nconst maxLiq = await hre.Diamond.getMaxLiqValue(f.user1.address, f.KrAsset.address, f.Collateral.address);\n(0, _chai.expect)(maxLiq.repayAmount).to.be.lt(repayAmount);\nconst tx = await f.LiquidatorTwo.liquidate({\n    account: f.user1.address,\n    repayAssetAddr: f.KrAsset.address,\n    repayAmount,\n    seizeAssetAddr: f.Collateral.address,\n    repayAssetIndex: 0,\n    seizeAssetIndex: 0,\n    prices: await hre.updateData()\n});\nconst event = await (0, _events.getNamedEvent)(tx, 'LiquidationOccurred');\nconst liquidatorBalanceAfter = await f.KrAsset.balanceOf(f.liquidatorTwo.address);\n(0, _chai.expect)(event.args.account).to.equal(f.user1.address);\n(0, _chai.expect)(event.args.liquidator).to.equal(f.liquidatorTwo.address);\n(0, _chai.expect)(event.args.repayKreskoAsset).to.equal(f.KrAsset.address);\n(0, _chai.expect)(event.args.seizedCollateralAsset).to.equal(f.Collateral.address);\n(0, _chai.expect)(event.args.repayAmount).to.not.equal(repayAmount);\n(0, _chai.expect)(event.args.repayAmount).to.equal(maxLiq.repayAmount);\n(0, _chai.expect)(event.args.collateralSent).to.be.equal(maxLiq.seizeAmount);\n(0, _chai.expect)(liquidatorBalanceAfter.add(repayAmount)).to.not.equal(liquidatorBalanceBefore);\n(0, _chai.expect)(liquidatorBalanceAfter.add(maxLiq.repayAmount)).to.equal(liquidatorBalanceBefore);\n(0, _chai.expect)(await hre.Diamond.getAccountCollateralRatio(f.user1.address)).to.be.eq(await hre.Diamond.getMaxLiquidationRatioMinter());",
                      "err": {},
                      "uuid": "44fd6fdf-e7bb-40d4-9ef8-05e1c81d538e",
                      "parentUUID": "b4bdcdf9-b2d8-4874-aa14-49c87e027df7",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow liquidations when account is under MCR but not under liquidation threshold",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate should not allow liquidations when account is under MCR but not under liquidation threshold",
                      "timedOut": false,
                      "duration": 172,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await f.Collateral.setPrice(f.Collateral.config.args.price);\n(0, _chai.expect)(await hre.Diamond.getAccountLiquidatable(f.user1.address)).to.be.false;\nconst minCollateralUSD = await hre.Diamond.getAccountMinCollateralAtRatio(f.user1.address, _optimizations.default.getMinCollateralRatioMinter());\nconst liquidationThresholdUSD = await hre.Diamond.getAccountMinCollateralAtRatio(f.user1.address, _optimizations.default.getLiquidationThresholdMinter());\nawait f.Collateral.setPrice(9.9);\nconst accountCollateralValue = await hre.Diamond.getAccountTotalCollateralValue(f.user1.address);\n(0, _chai.expect)(accountCollateralValue.lt(minCollateralUSD)).to.be.true;\n(0, _chai.expect)(accountCollateralValue.gt(liquidationThresholdUSD)).to.be.true;\n(0, _chai.expect)(await hre.Diamond.getAccountLiquidatable(f.user1.address)).to.be.false;",
                      "err": {},
                      "uuid": "fd2a2568-a270-4f42-9807-7ba060bac1bc",
                      "parentUUID": "b4bdcdf9-b2d8-4874-aa14-49c87e027df7",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow liquidations without f.liquidator token approval for Kresko Assets",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate should allow liquidations without f.liquidator token approval for Kresko Assets",
                      "timedOut": false,
                      "duration": 118,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Check that f.liquidator's token approval to Kresko.sol contract is 0\n(0, _chai.expect)(await f.KrAsset.contract.allowance(f.liquidatorTwo.address, hre.Diamond.address)).to.equal(0);\nconst repayAmount = (0, _values.toBig)(0.5);\nawait f.KrAsset.setBalance(f.liquidatorTwo, repayAmount);\nawait f.LiquidatorTwo.liquidate({\n    account: f.user1.address,\n    repayAssetAddr: f.KrAsset.address,\n    repayAmount: repayAmount,\n    seizeAssetAddr: f.Collateral.address,\n    repayAssetIndex: 0,\n    seizeAssetIndex: 0,\n    prices: await hre.updateData()\n});\n// Confirm that f.liquidator's token approval is still 0\n(0, _chai.expect)(await f.KrAsset.contract.allowance(f.user2.address, hre.Diamond.address)).to.equal(0);",
                      "err": {},
                      "uuid": "e7bb1c6c-653e-49de-b5ef-e309c6099ed5",
                      "parentUUID": "b4bdcdf9-b2d8-4874-aa14-49c87e027df7",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not change f.liquidator's existing token approvals during a successful liquidation",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate should not change f.liquidator's existing token approvals during a successful liquidation",
                      "timedOut": false,
                      "duration": 116,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const repayAmount = (0, _values.toBig)(0.5);\nawait f.KrAsset.setBalance(f.liquidatorTwo, repayAmount);\nawait f.KrAsset.contract.setVariable('_allowances', {\n    [f.liquidatorTwo.address]: {\n        [hre.Diamond.address]: repayAmount\n    }\n});\nawait (0, _chai.expect)(f.LiquidatorTwo.liquidate({\n    account: f.user1.address,\n    repayAssetAddr: f.KrAsset.address,\n    repayAmount: repayAmount,\n    seizeAssetAddr: f.Collateral.address,\n    repayAssetIndex: 0,\n    seizeAssetIndex: 0,\n    prices: await hre.updateData()\n})).not.to.be.reverted;\n// Confirm that f.liquidator's token approval is unchanged\n(0, _chai.expect)(await f.KrAsset.contract.allowance(f.liquidatorTwo.address, hre.Diamond.address)).to.equal(repayAmount);",
                      "err": {},
                      "uuid": "14c0f7a3-3a2d-4f1f-8bab-9dc2b54b46ea",
                      "parentUUID": "b4bdcdf9-b2d8-4874-aa14-49c87e027df7",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow borrowers to liquidate themselves",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate should not allow borrowers to liquidate themselves",
                      "timedOut": false,
                      "duration": 40,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Liquidation should fail\nconst repayAmount = 5;\nawait (0, _chai.expect)(f.User.liquidate({\n    account: f.user1.address,\n    repayAssetAddr: f.KrAsset.address,\n    repayAmount: repayAmount,\n    seizeAssetAddr: f.Collateral.address,\n    repayAssetIndex: 0,\n    seizeAssetIndex: 0,\n    prices: await hre.updateData()\n})).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'CANNOT_LIQUIDATE_SELF');",
                      "err": {},
                      "uuid": "06193528-d900-46cf-a206-a0c32ad4160a",
                      "parentUUID": "b4bdcdf9-b2d8-4874-aa14-49c87e027df7",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should error on seize underflow",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate should error on seize underflow",
                      "timedOut": false,
                      "duration": 0,
                      "state": "pending",
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": true,
                      "context": null,
                      "code": "",
                      "err": {},
                      "uuid": "dc1b5419-ea3b-4679-b626-f763c05123ec",
                      "parentUUID": "b4bdcdf9-b2d8-4874-aa14-49c87e027df7",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "6393d5f8-3357-47d8-ba89-4220f6c5736b",
                    "fe486700-c283-452a-a760-a64f2da2988b",
                    "21ebf2c0-8ed8-4d28-a970-e79cd0d84e1c",
                    "aad5d33a-79a5-48d2-a66c-77be17d0ef20",
                    "720d4f68-0679-4ed3-bba5-35d667fb0c23",
                    "b948312e-8d19-42e4-8b86-fe6edba32814",
                    "44fd6fdf-e7bb-40d4-9ef8-05e1c81d538e",
                    "fd2a2568-a270-4f42-9807-7ba060bac1bc",
                    "e7bb1c6c-653e-49de-b5ef-e309c6099ed5",
                    "14c0f7a3-3a2d-4f1f-8bab-9dc2b54b46ea",
                    "06193528-d900-46cf-a206-a0c32ad4160a"
                  ],
                  "failures": [],
                  "pending": [
                    "dc1b5419-ea3b-4679-b626-f763c05123ec"
                  ],
                  "skipped": [],
                  "duration": 1661,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                },
                {
                  "uuid": "0cc9b451-be44-41c8-b5f0-bdb7a2735c6e",
                  "title": "#liquidate - rebasing events",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/03-liquidation.ts",
                  "file": "/src/test/minter/03-liquidation.ts",
                  "beforeHooks": [
                    {
                      "title": "\"before each\" hook in \"#liquidate - rebasing events\"",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate - rebasing events \"before each\" hook in \"#liquidate - rebasing events\"",
                      "timedOut": false,
                      "duration": 88,
                      "state": null,
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await f.resetRebasing();",
                      "err": {},
                      "uuid": "dbe82c6b-09d3-4ef6-b059-4286e0a4bb73",
                      "parentUUID": "0cc9b451-be44-41c8-b5f0-bdb7a2735c6e",
                      "isHook": true,
                      "skipped": false
                    }
                  ],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should setup correct",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate - rebasing events should setup correct",
                      "timedOut": false,
                      "duration": 75,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const [mcr, cr, cr2, liquidatable] = await Promise.all([\n    _optimizations.default.getMinCollateralRatioMinter(),\n    hre.Diamond.getAccountCollateralRatio(f.user3.address),\n    hre.Diamond.getAccountCollateralRatio(f.user4.address),\n    hre.Diamond.getAccountLiquidatable(f.user3.address)\n]);\n(0, _chai.expect)(cr).to.closeTo(mcr, 8);\n(0, _chai.expect)(cr2).to.closeTo(mcr, 1);\n(0, _chai.expect)(liquidatable).to.be.false;",
                      "err": {},
                      "uuid": "dcf8ffbd-ce28-4ef0-b7a6-9914494c28e4",
                      "parentUUID": "0cc9b451-be44-41c8-b5f0-bdb7a2735c6e",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow liquidation of healthy accounts after a positive rebase",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate - rebasing events should not allow liquidation of healthy accounts after a positive rebase",
                      "timedOut": false,
                      "duration": 111,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst rebasePrice = 1 / denominator;\nawait f.KrAsset.setPrice(rebasePrice);\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\nawait (0, _chai.expect)(f.Liquidator.liquidate({\n    account: f.user4.address,\n    repayAssetAddr: f.KrAsset.address,\n    repayAmount: 100,\n    seizeAssetAddr: f.Collateral.address,\n    repayAssetIndex: _optimizations.default.getAccountMintIndex(f.user4.address, f.KrAsset.address),\n    seizeAssetIndex: _optimizations.default.getAccountDepositIndex(f.user4.address, f.Collateral.address),\n    prices: await hre.updateData()\n})).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'CANNOT_LIQUIDATE_HEALTHY_ACCOUNT').withArgs(f.user4.address, 1000000000000, 933333332400, await hre.Diamond.getLiquidationThresholdMinter());",
                      "err": {},
                      "uuid": "bfd68269-c628-4406-84c9-31a59a9c9ee4",
                      "parentUUID": "0cc9b451-be44-41c8-b5f0-bdb7a2735c6e",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow liquidation of healthy accounts after a negative rebase",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate - rebasing events should not allow liquidation of healthy accounts after a negative rebase",
                      "timedOut": false,
                      "duration": 114,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const denominator = 4;\nconst positive = false;\nconst rebasePrice = 1 * denominator;\nawait f.KrAsset.setPrice(rebasePrice);\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\nawait (0, _chai.expect)(f.Liquidator.liquidate({\n    account: f.user4.address,\n    repayAssetAddr: f.KrAsset.address,\n    repayAmount: 100,\n    seizeAssetAddr: f.Collateral.address,\n    repayAssetIndex: _optimizations.default.getAccountMintIndex(f.user4.address, f.KrAsset.address),\n    seizeAssetIndex: _optimizations.default.getAccountDepositIndex(f.user4.address, f.Collateral.address),\n    prices: await hre.updateData()\n})).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'CANNOT_LIQUIDATE_HEALTHY_ACCOUNT').withArgs(f.user4.address, 1000000000000, 933333332400, await hre.Diamond.getLiquidationThresholdMinter());",
                      "err": {},
                      "uuid": "db8fb2c5-0183-44af-b624-a06ea78619ec",
                      "parentUUID": "0cc9b451-be44-41c8-b5f0-bdb7a2735c6e",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow liquidations of unhealthy accounts after a positive rebase",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate - rebasing events should allow liquidations of unhealthy accounts after a positive rebase",
                      "timedOut": false,
                      "duration": 446,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const denominator = 4;\nconst positive = true;\nconst rebasePrice = 1 / denominator;\nawait f.KrAsset.setPrice(rebasePrice);\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\n(0, _chai.expect)(await hre.Diamond.getAccountLiquidatable(f.user4.address)).to.be.false;\nawait f.Collateral.setPrice(7.5);\n(0, _chai.expect)(await hre.Diamond.getAccountLiquidatable(f.user4.address)).to.be.true;\nawait (0, _liquidations.liquidate)(f.user4, f.KrAsset, f.Collateral, true);\nawait (0, _chai.expect)((0, _liquidations.liquidate)(f.user4, f.KrAsset, f.Collateral, true)).to.not.be.reverted;",
                      "err": {},
                      "uuid": "140ebea6-883b-4065-ae85-b2bb1c1210f0",
                      "parentUUID": "0cc9b451-be44-41c8-b5f0-bdb7a2735c6e",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow liquidations of unhealthy accounts after a negative rebase",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate - rebasing events should allow liquidations of unhealthy accounts after a negative rebase",
                      "timedOut": false,
                      "duration": 302,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const denominator = 4;\nconst positive = false;\nconst rebasePrice = 1 * denominator;\nawait f.KrAsset.setPrice(rebasePrice);\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\n(0, _chai.expect)(await hre.Diamond.getAccountLiquidatable(f.user4.address)).to.be.false;\nawait f.KrAsset.setPrice(rebasePrice + 1);\n(0, _chai.expect)(await hre.Diamond.getAccountLiquidatable(f.user4.address)).to.be.true;\nawait (0, _chai.expect)((0, _liquidations.liquidate)(f.user4, f.KrAsset, f.Collateral, true)).to.not.be.reverted;",
                      "err": {},
                      "uuid": "e55bac97-af3c-457a-9c53-e764d917efaf",
                      "parentUUID": "0cc9b451-be44-41c8-b5f0-bdb7a2735c6e",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should liquidate krAsset collaterals up to min amount",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate - rebasing events should liquidate krAsset collaterals up to min amount",
                      "timedOut": false,
                      "duration": 243,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await f.KrAssetCollateral.setPrice(100);\nawait hre.Diamond.setAssetCFactor(f.KrAssetCollateral.address, 0.99e4);\nawait hre.Diamond.setAssetKFactor(f.KrAssetCollateral.address, 1e4);\nconst maxLiq = await hre.Diamond.getMaxLiqValue(f.user3.address, f.KrAssetCollateral.address, f.KrAssetCollateral.address);\nawait f.KrAssetCollateral.setBalance(f.liquidator, maxLiq.repayAmount, hre.Diamond.address);\nawait f.Liquidator.liquidate({\n    account: f.user3.address,\n    repayAssetAddr: f.KrAssetCollateral.address,\n    repayAmount: maxLiq.repayAmount.sub(1e9),\n    seizeAssetAddr: f.KrAssetCollateral.address,\n    repayAssetIndex: maxLiq.repayAssetIndex,\n    seizeAssetIndex: maxLiq.seizeAssetIndex,\n    prices: await hre.updateData()\n});\nconst depositsAfter = await hre.Diamond.getAccountCollateralAmount(f.user3.address, f.KrAssetCollateral.address);\n(0, _chai.expect)(depositsAfter).to.equal(1e12.toString());",
                      "err": {},
                      "uuid": "19e2d2fe-1673-4320-8918-5d8d4a318cb2",
                      "parentUUID": "0cc9b451-be44-41c8-b5f0-bdb7a2735c6e",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should liquidate to 0",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate - rebasing events should liquidate to 0",
                      "timedOut": false,
                      "duration": 236,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await f.KrAssetCollateral.setPrice(100);\nawait hre.Diamond.setAssetCFactor(f.KrAssetCollateral.address, 1e4);\nawait hre.Diamond.setAssetKFactor(f.KrAssetCollateral.address, 1e4);\nconst maxLiq = await hre.Diamond.getMaxLiqValue(f.user3.address, f.KrAssetCollateral.address, f.KrAssetCollateral.address);\nconst liquidationAmount = maxLiq.repayAmount.add((0, _values.toBig)(20, 27));\nawait f.KrAssetCollateral.setBalance(hre.users.liquidator, liquidationAmount, hre.Diamond.address);\nawait f.Liquidator.liquidate({\n    account: f.user3.address,\n    repayAssetAddr: f.KrAssetCollateral.address,\n    repayAmount: liquidationAmount,\n    seizeAssetAddr: f.KrAssetCollateral.address,\n    repayAssetIndex: maxLiq.repayAssetIndex,\n    seizeAssetIndex: maxLiq.seizeAssetIndex,\n    prices: await hre.updateData()\n});\nconst depositsAfter = await hre.Diamond.getAccountCollateralAmount(f.user3.address, f.KrAssetCollateral.address);\n(0, _chai.expect)(depositsAfter).to.equal(0);",
                      "err": {},
                      "uuid": "d7297f76-a0f6-4b54-926b-ed2b9b23cc69",
                      "parentUUID": "0cc9b451-be44-41c8-b5f0-bdb7a2735c6e",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should liquidate correct amount of krAssets after a positive rebase",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate - rebasing events should liquidate correct amount of krAssets after a positive rebase",
                      "timedOut": false,
                      "duration": 667,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const newPrice = 1.2;\nawait f.KrAsset.setPrice(newPrice);\nconst results = {\n    collateralSeized: 0,\n    debtRepaid: 0,\n    userOneValueAfter: 0,\n    userOneHFAfter: 0,\n    collateralSeizedRebase: 0,\n    debtRepaidRebase: 0,\n    userTwoValueAfter: 0,\n    userTwoHFAfter: 0\n};\n// Get values for a liquidation that happens before rebase\nwhile(await hre.Diamond.getAccountLiquidatable(f.user4.address)){\n    const values = await (0, _liquidations.liquidate)(f.user4, f.KrAsset, f.Collateral);\n    results.collateralSeized += values.collateralSeized;\n    results.debtRepaid += values.debtRepaid;\n}\nresults.userOneValueAfter = (0, _values.fromBig)(await hre.Diamond.getAccountTotalCollateralValue(f.user4.address), 8);\nresults.userOneHFAfter = (await hre.Diamond.getAccountCollateralRatio(f.user4.address)).toNumber();\n// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst rebasePrice = newPrice / denominator;\n// Rebase\nawait f.KrAsset.setPrice(rebasePrice);\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\n(0, _chai.expect)(await hre.Diamond.getAccountLiquidatable(f.user5.address)).to.be.true;\n// Get values for a liquidation that happens after a rebase\nwhile(await hre.Diamond.getAccountLiquidatable(f.user5.address)){\n    const values = await (0, _liquidations.liquidate)(f.user5, f.KrAsset, f.Collateral);\n    results.collateralSeizedRebase += values.collateralSeized;\n    results.debtRepaidRebase += values.debtRepaid;\n}\nresults.userTwoValueAfter = (0, _values.fromBig)(await hre.Diamond.getAccountTotalCollateralValue(f.user5.address), 8);\nresults.userTwoHFAfter = (await hre.Diamond.getAccountCollateralRatio(f.user5.address)).toNumber();\n(0, _chai.expect)(results.userTwoHFAfter).to.equal(results.userOneHFAfter);\n(0, _chai.expect)(results.collateralSeized).to.equal(results.collateralSeizedRebase);\n(0, _chai.expect)(results.debtRepaid * denominator).to.equal(results.debtRepaidRebase);\n(0, _chai.expect)(results.userOneValueAfter).to.equal(results.userTwoValueAfter);",
                      "err": {},
                      "uuid": "f37ab7a7-9821-47a9-84e6-3e95f640bd00",
                      "parentUUID": "0cc9b451-be44-41c8-b5f0-bdb7a2735c6e",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should liquidate correct amount of assets after a negative rebase",
                      "fullTitle": "Minter - Liquidations #liquidation #liquidate - rebasing events should liquidate correct amount of assets after a negative rebase",
                      "timedOut": false,
                      "duration": 600,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const newPrice = 1.2;\nawait f.KrAsset.setPrice(newPrice);\nconst results = {\n    collateralSeized: 0,\n    debtRepaid: 0,\n    userOneValueAfter: 0,\n    userOneHFAfter: 0,\n    collateralSeizedRebase: 0,\n    debtRepaidRebase: 0,\n    userTwoValueAfter: 0,\n    userTwoHFAfter: 0\n};\n// Get values for a liquidation that happens before rebase\nwhile(await hre.Diamond.getAccountLiquidatable(f.user4.address)){\n    const values = await (0, _liquidations.liquidate)(f.user4, f.KrAsset, f.Collateral);\n    results.collateralSeized += values.collateralSeized;\n    results.debtRepaid += values.debtRepaid;\n}\nresults.userOneValueAfter = (0, _values.fromBig)(await hre.Diamond.getAccountTotalCollateralValue(f.user4.address), 8);\nresults.userOneHFAfter = (await hre.Diamond.getAccountCollateralRatio(f.user4.address)).toNumber();\n// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst rebasePrice = newPrice * denominator;\n// Rebase\nawait f.KrAsset.setPrice(rebasePrice);\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\n(0, _chai.expect)(await hre.Diamond.getAccountLiquidatable(f.user5.address)).to.be.true;\n// Get values for a liquidation that happens after a rebase\nwhile(await hre.Diamond.getAccountLiquidatable(f.user5.address)){\n    const values = await (0, _liquidations.liquidate)(f.user5, f.KrAsset, f.Collateral);\n    results.collateralSeizedRebase += values.collateralSeized;\n    results.debtRepaidRebase += values.debtRepaid;\n}\nresults.userTwoValueAfter = (0, _values.fromBig)(await hre.Diamond.getAccountTotalCollateralValue(f.user5.address), 8);\nresults.userTwoHFAfter = (await hre.Diamond.getAccountCollateralRatio(f.user5.address)).toNumber();\n(0, _chai.expect)(results.userTwoHFAfter).to.equal(results.userOneHFAfter);\n(0, _chai.expect)(results.collateralSeized).to.equal(results.collateralSeizedRebase);\n(0, _chai.expect)(results.debtRepaid / denominator).to.equal(results.debtRepaidRebase);\n(0, _chai.expect)(results.userOneValueAfter).to.equal(results.userTwoValueAfter);",
                      "err": {},
                      "uuid": "b4de2f48-4c2c-4b03-b576-a4ad2d874b02",
                      "parentUUID": "0cc9b451-be44-41c8-b5f0-bdb7a2735c6e",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "dcf8ffbd-ce28-4ef0-b7a6-9914494c28e4",
                    "bfd68269-c628-4406-84c9-31a59a9c9ee4",
                    "db8fb2c5-0183-44af-b624-a06ea78619ec",
                    "140ebea6-883b-4065-ae85-b2bb1c1210f0",
                    "e55bac97-af3c-457a-9c53-e764d917efaf",
                    "19e2d2fe-1673-4320-8918-5d8d4a318cb2",
                    "d7297f76-a0f6-4b54-926b-ed2b9b23cc69",
                    "f37ab7a7-9821-47a9-84e6-3e95f640bd00",
                    "b4de2f48-4c2c-4b03-b576-a4ad2d874b02"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 2794,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                }
              ],
              "passes": [],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "da58f393-f4ce-4ca0-a7d1-86518171d4c1",
          "title": "Minter",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
          "file": "/src/test/minter/04-mint-repay.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"Minter\"",
              "fullTitle": "Minter \"before each\" hook in \"Minter\"",
              "timedOut": false,
              "duration": 95,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "f = await (0, _fixtures.mintRepayFixture)();\nawait f.reset();",
              "err": {},
              "uuid": "a668c600-7918-4a0a-904e-273025d32a5d",
              "parentUUID": "da58f393-f4ce-4ca0-a7d1-86518171d4c1",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "b7118253-e2e3-43d4-8b36-2f83d9eb397e",
              "title": "#mint+burn",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
              "file": "/src/test/minter/04-mint-repay.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [],
              "suites": [
                {
                  "uuid": "e84b061b-5b6a-4f9a-870c-7f70e1597f47",
                  "title": "#mint",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                  "file": "/src/test/minter/04-mint-repay.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should allow users to mint whitelisted Kresko assets backed by collateral",
                      "fullTitle": "Minter #mint+burn #mint should allow users to mint whitelisted Kresko assets backed by collateral",
                      "timedOut": false,
                      "duration": 95,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const kreskoAssetTotalSupplyBefore = await f.KrAsset.contract.totalSupply();\n(0, _chai.expect)(kreskoAssetTotalSupplyBefore).to.equal(f.initialMintAmount);\n// Initially, the array of the user's minted kresko assets should be empty.\nconst mintedKreskoAssetsBefore = await hre.Diamond.getAccountMintedAssets(f.user1.address);\n(0, _chai.expect)(mintedKreskoAssetsBefore).to.deep.equal([]);\n// Mint Kresko asset\nconst mintAmount = (0, _values.toBig)(10);\nawait f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: mintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());\n// Confirm the array of the user's minted Kresko assets has been pushed to.\nconst mintedKreskoAssetsAfter = await hre.Diamond.getAccountMintedAssets(f.user1.address);\n(0, _chai.expect)(mintedKreskoAssetsAfter).to.deep.equal([\n    f.KrAsset.address\n]);\n// Confirm the amount minted is recorded for the user.\nconst amountMinted = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\n(0, _chai.expect)(amountMinted).to.equal(mintAmount);\n// Confirm the user's Kresko asset balance has increased\nconst userBalance = await f.KrAsset.contract.balanceOf(f.user1.address);\n(0, _chai.expect)(userBalance).to.equal(mintAmount);\n// Confirm that the Kresko asset's total supply increased as expected\nconst kreskoAssetTotalSupplyAfter = await f.KrAsset.contract.totalSupply();\n(0, _chai.expect)(kreskoAssetTotalSupplyAfter.eq(kreskoAssetTotalSupplyBefore.add(mintAmount)));",
                      "err": {},
                      "uuid": "9f06b394-dd00-436e-be0e-24eea47614b5",
                      "parentUUID": "e84b061b-5b6a-4f9a-870c-7f70e1597f47",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow successive, valid mints of the same Kresko asset",
                      "fullTitle": "Minter #mint+burn #mint should allow successive, valid mints of the same Kresko asset",
                      "timedOut": false,
                      "duration": 172,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Mint Kresko asset\nconst firstMintAmount = (0, _values.toBig)(50);\nawait f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: firstMintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());\n// Confirm the array of the user's minted Kresko assets has been pushed to.\nconst mintedKreskoAssetsAfter = await hre.Diamond.getAccountMintedAssets(f.user1.address);\n(0, _chai.expect)(mintedKreskoAssetsAfter).to.deep.equal([\n    f.KrAsset.address\n]);\n// Confirm the amount minted is recorded for the user.\nconst amountMintedAfter = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\n(0, _chai.expect)(amountMintedAfter).to.equal(firstMintAmount);\n// Confirm the Kresko Asset as been minted to the user from Kresko.sol\nconst userBalanceAfter = await f.KrAsset.contract.balanceOf(f.user1.address);\n(0, _chai.expect)(userBalanceAfter).to.equal(amountMintedAfter);\n// Confirm that the Kresko asset's total supply increased as expected\nconst kreskoAssetTotalSupplyAfter = await f.KrAsset.contract.totalSupply();\n(0, _chai.expect)(kreskoAssetTotalSupplyAfter).to.equal(f.initialMintAmount.add(firstMintAmount));\n// ------------------------ Second mint ------------------------\n// Mint Kresko asset\nconst secondMintAmount = (0, _values.toBig)(50);\nawait f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: secondMintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());\n// Confirm the array of the user's minted Kresko assets is unchanged\nconst mintedKreskoAssetsFinal = await hre.Diamond.getAccountMintedAssets(f.user1.address);\n(0, _chai.expect)(mintedKreskoAssetsFinal).to.deep.equal([\n    f.KrAsset.address\n]);\n// Confirm the second mint amount is recorded for the user\nconst amountMintedFinal = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\n(0, _chai.expect)(amountMintedFinal).to.closeTo(firstMintAmount.add(secondMintAmount), INTEREST_RATE_DELTA);\n// Confirm the Kresko Asset as been minted to the user from Kresko.sol\nconst userBalanceFinal = await f.KrAsset.contract.balanceOf(f.user1.address);\n(0, _chai.expect)(userBalanceFinal).to.closeTo(amountMintedFinal, INTEREST_RATE_DELTA);\n// Confirm that the Kresko asset's total supply increased as expected\nconst kreskoAssetTotalSupplyFinal = await f.KrAsset.contract.totalSupply();\n(0, _chai.expect)(kreskoAssetTotalSupplyFinal).to.closeTo(kreskoAssetTotalSupplyAfter.add(secondMintAmount), INTEREST_RATE_DELTA);",
                      "err": {},
                      "uuid": "f22a85b2-65cc-4611-a3bb-6c50e2de9e25",
                      "parentUUID": "e84b061b-5b6a-4f9a-870c-7f70e1597f47",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow users to mint multiple different Kresko assets",
                      "fullTitle": "Minter #mint+burn #mint should allow users to mint multiple different Kresko assets",
                      "timedOut": false,
                      "duration": 172,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Initially, the array of the user's minted kresko assets should be empty.\nconst mintedKreskoAssetsInitial = await _optimizations.default.getAccountMintedAssets(f.user1.address);\n(0, _chai.expect)(mintedKreskoAssetsInitial).to.deep.equal([]);\n// Mint Kresko asset\nconst firstMintAmount = (0, _values.toBig)(10);\nawait f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: firstMintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());\n// Confirm the array of the user's minted Kresko assets has been pushed to.\nconst mintedKreskoAssetsAfter = await _optimizations.default.getAccountMintedAssets(f.user1.address);\n(0, _chai.expect)(mintedKreskoAssetsAfter).to.deep.equal([\n    f.KrAsset.address\n]);\n// Confirm the amount minted is recorded for the user.\nconst amountMintedAfter = await _optimizations.default.getAccountDebtAmount(f.user1.address, f.KrAsset);\n(0, _chai.expect)(amountMintedAfter).to.equal(firstMintAmount);\n// Confirm the Kresko Asset as been minted to the user from Kresko.sol\nconst userBalanceAfter = await f.KrAsset.balanceOf(f.user1.address);\n(0, _chai.expect)(userBalanceAfter).to.equal(amountMintedAfter);\n// Confirm that the Kresko asset's total supply increased as expected\nconst kreskoAssetTotalSupplyAfter = await f.KrAsset.contract.totalSupply();\n(0, _chai.expect)(kreskoAssetTotalSupplyAfter).to.equal(f.initialMintAmount.add(firstMintAmount));\n// ------------------------ Second mint ------------------------\n// Mint Kresko asset\nconst secondMintAmount = (0, _values.toBig)(20);\nawait f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset2.address,\n    amount: secondMintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());\n// Confirm that the second address has been pushed to the array of the user's minted Kresko assets\nconst mintedKreskoAssetsFinal = await _optimizations.default.getAccountMintedAssets(f.user1.address);\n(0, _chai.expect)(mintedKreskoAssetsFinal).to.deep.equal([\n    f.KrAsset.address,\n    f.KrAsset2.address\n]);\n// Confirm the second mint amount is recorded for the user\nconst amountMintedAssetTwo = await _optimizations.default.getAccountDebtAmount(f.user1.address, f.KrAsset2);\n(0, _chai.expect)(amountMintedAssetTwo).to.equal(secondMintAmount);\n// Confirm the Kresko Asset as been minted to the user from Kresko.sol\nconst userBalanceFinal = await f.KrAsset2.balanceOf(f.user1.address);\n(0, _chai.expect)(userBalanceFinal).to.equal(amountMintedAssetTwo);\n// Confirm that the Kresko asset's total supply increased as expected\nconst secondKreskoAssetTotalSupply = await f.KrAsset2.contract.totalSupply();\n(0, _chai.expect)(secondKreskoAssetTotalSupply).to.equal(secondMintAmount);",
                      "err": {},
                      "uuid": "b1b9b074-c96c-458b-913e-36352d21cf72",
                      "parentUUID": "e84b061b-5b6a-4f9a-870c-7f70e1597f47",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow users to mint Kresko assets with USD value equal to the minimum debt value",
                      "fullTitle": "Minter #mint+burn #mint should allow users to mint Kresko assets with USD value equal to the minimum debt value",
                      "timedOut": false,
                      "duration": 99,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Confirm that the mint amount's USD value is equal to the contract's current minimum debt value\nconst mintAmount = (0, _values.toBig)(1) // 1 * $10 = $10\n;\nconst mintAmountUSDValue = await hre.Diamond.getValue(f.KrAsset.address, mintAmount);\nconst currMinimumDebtValue = await hre.Diamond.getMinDebtValueMinter();\n(0, _chai.expect)(mintAmountUSDValue).to.equal(currMinimumDebtValue);\nawait f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: mintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());\n// Confirm that the mint was successful and user's balances have increased\nconst finalKreskoAssetDebt = await _optimizations.default.getAccountDebtAmount(f.user1.address, f.KrAsset);\n(0, _chai.expect)(finalKreskoAssetDebt).to.equal(mintAmount);",
                      "err": {},
                      "uuid": "87902699-f54f-4bc4-b5b5-d561eaac9f50",
                      "parentUUID": "e84b061b-5b6a-4f9a-870c-7f70e1597f47",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow a trusted address to mint Kresko assets on behalf of another user",
                      "fullTitle": "Minter #mint+burn #mint should allow a trusted address to mint Kresko assets on behalf of another user",
                      "timedOut": false,
                      "duration": 97,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await hre.Diamond.grantRole(_roles.Role.MANAGER, f.user2.address);\n// Initially, the array of the user's minted kresko assets should be empty.\nconst mintedKreskoAssetsBefore = await _optimizations.default.getAccountMintedAssets(f.user1.address);\n(0, _chai.expect)(mintedKreskoAssetsBefore).to.deep.equal([]);\n// userThree (trusted contract) mints Kresko asset for userOne\nconst mintAmount = (0, _values.toBig)(1);\nawait f.User2.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: mintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());\n// Check that debt exists now for userOne\nconst userTwoBalanceAfter = await _optimizations.default.getAccountDebtAmount(f.user1.address, f.KrAsset);\n(0, _chai.expect)(userTwoBalanceAfter).to.equal(mintAmount);\n// Initially, the array of the user's minted kresko assets should be empty.\nconst mintedKreskoAssetsAfter = await _optimizations.default.getAccountMintedAssets(f.user1.address);\n(0, _chai.expect)(mintedKreskoAssetsAfter).to.deep.equal([\n    f.KrAsset.address\n]);",
                      "err": {},
                      "uuid": "783b7b87-4eca-4210-a26a-857bf3796779",
                      "parentUUID": "e84b061b-5b6a-4f9a-870c-7f70e1597f47",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should emit KreskoAssetMinted event",
                      "fullTitle": "Minter #mint+burn #mint should emit KreskoAssetMinted event",
                      "timedOut": false,
                      "duration": 75,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const tx = await f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: f.initialMintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());\nconst event = await (0, _events.getInternalEvent)(tx, hre.Diamond, 'KreskoAssetMinted');\n(0, _chai.expect)(event.account).to.equal(f.user1.address);\n(0, _chai.expect)(event.kreskoAsset).to.equal(f.KrAsset.address);\n(0, _chai.expect)(event.amount).to.equal(f.initialMintAmount);",
                      "err": {},
                      "uuid": "6a25e29c-405f-4124-925f-3c761ec6f454",
                      "parentUUID": "e84b061b-5b6a-4f9a-870c-7f70e1597f47",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow untrusted account to mint Kresko assets on behalf of another user",
                      "fullTitle": "Minter #mint+burn #mint should not allow untrusted account to mint Kresko assets on behalf of another user",
                      "timedOut": false,
                      "duration": 43,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, _chai.expect)(f.User1.mintKreskoAsset({\n    account: f.user2.address,\n    krAsset: f.KrAsset.address,\n    amount: (0, _values.toBig)(1),\n    receiver: f.user2.address\n}, await hre.updateData())).to.be.revertedWith(`AccessControl: account ${f.user1.address.toLowerCase()} is missing role 0x46925e0f0cc76e485772167edccb8dc449d43b23b55fc4e756b063f49099e6a0`);",
                      "err": {},
                      "uuid": "a57e6ccc-6ca0-4d9a-875a-a70b844d1df5",
                      "parentUUID": "e84b061b-5b6a-4f9a-870c-7f70e1597f47",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow users to mint Kresko assets if the resulting position's USD value is less than the minimum debt value",
                      "fullTitle": "Minter #mint+burn #mint should not allow users to mint Kresko assets if the resulting position's USD value is less than the minimum debt value",
                      "timedOut": false,
                      "duration": 58,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const currMinimumDebtValue = await _optimizations.default.getMinDebtValue();\nconst mintAmount = currMinimumDebtValue.wadDiv(_mocks.TEN_USD.ebn(8)).sub(1e9);\nawait (0, _chai.expect)(f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: mintAmount,\n    receiver: f.user1.address\n}, await hre.updateData())).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'MINT_VALUE_LESS_THAN_MIN_DEBT_VALUE').withArgs(f.KrAsset.errorId, 10e8 - 1, currMinimumDebtValue);",
                      "err": {},
                      "uuid": "4963659f-a3e3-48a5-a5b5-7c910d80d5bd",
                      "parentUUID": "e84b061b-5b6a-4f9a-870c-7f70e1597f47",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow users to mint non-whitelisted Kresko assets",
                      "fullTitle": "Minter #mint+burn #mint should not allow users to mint non-whitelisted Kresko assets",
                      "timedOut": false,
                      "duration": 45,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Attempt to mint a non-deployed, non-whitelisted Kresko asset\nawait (0, _chai.expect)(f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: '0x0000000000000000000000000000000000000002',\n    amount: (0, _values.toBig)(1),\n    receiver: f.user1.address\n}, await hre.updateData())).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'ASSET_NOT_MINTABLE_FROM_MINTER').withArgs([\n    '',\n    '0x0000000000000000000000000000000000000002'\n]);",
                      "err": {},
                      "uuid": "3c2561e9-273f-46fe-b485-ada0a077a3bb",
                      "parentUUID": "e84b061b-5b6a-4f9a-870c-7f70e1597f47",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow users to mint Kresko assets over their collateralization ratio limit",
                      "fullTitle": "Minter #mint+burn #mint should not allow users to mint Kresko assets over their collateralization ratio limit",
                      "timedOut": false,
                      "duration": 97,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const collateralAmountDeposited = await _optimizations.default.getAccountCollateralAmount(f.user1.address, f.Collateral.address);\nconst MCR = await hre.Diamond.getMinCollateralRatioMinter();\nconst mcrAmount = collateralAmountDeposited.percentMul(MCR);\nconst mintAmount = mcrAmount.add(1);\nconst mintValue = await hre.Diamond.getValue(f.KrAsset.address, mintAmount);\nconst userState = await hre.Diamond.getAccountState(f.user1.address);\nawait (0, _chai.expect)(f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: mintAmount,\n    receiver: f.user1.address\n}, await hre.updateData())).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'ACCOUNT_COLLATERAL_VALUE_LESS_THAN_REQUIRED').withArgs(f.user1.address, userState.totalCollateralValue, mintValue.percentMul(MCR), MCR);",
                      "err": {},
                      "uuid": "b01c6f5f-175e-476e-b940-a7d11ebc2f74",
                      "parentUUID": "e84b061b-5b6a-4f9a-870c-7f70e1597f47",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow the minting of any Kresko asset amount over its maximum limit",
                      "fullTitle": "Minter #mint+burn #mint should not allow the minting of any Kresko asset amount over its maximum limit",
                      "timedOut": false,
                      "duration": 130,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// User deposits another 10,000 collateral tokens, enabling mints of up to 20,000/1.5 = ~13,333 kresko asset tokens\nawait f.Collateral.setBalance(f.user1, (0, _values.toBig)(100000000));\nawait (0, _chai.expect)(f.User1.depositCollateral(f.user1.address, f.Collateral.address, (0, _values.toBig)(10000))).not.to.be.reverted;\nconst assetSupplyLimit = (0, _values.toBig)(1);\nconst mintAmount = (0, _values.toBig)(2);\nawait f.KrAsset.update({\n    maxDebtMinter: assetSupplyLimit\n});\nawait (0, _chai.expect)(f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: mintAmount,\n    receiver: f.user1.address\n}, await hre.updateData())).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'EXCEEDS_ASSET_MINTING_LIMIT').withArgs(f.KrAsset.errorId, (await f.KrAsset.contract.totalSupply()).add(mintAmount), assetSupplyLimit);\nawait f.KrAsset.update({\n    maxDebtMinter: assetSupplyLimit\n});",
                      "err": {},
                      "uuid": "7ff0f375-0935-4250-ad29-1cc294248372",
                      "parentUUID": "e84b061b-5b6a-4f9a-870c-7f70e1597f47",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow the minting of kreskoAssets if the market is closed",
                      "fullTitle": "Minter #mint+burn #mint should not allow the minting of kreskoAssets if the market is closed",
                      "timedOut": false,
                      "duration": 0,
                      "state": "pending",
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": true,
                      "context": null,
                      "code": "",
                      "err": {},
                      "uuid": "9bdeb5a7-700b-4a46-9b10-053e92dbe3d8",
                      "parentUUID": "e84b061b-5b6a-4f9a-870c-7f70e1597f47",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "9f06b394-dd00-436e-be0e-24eea47614b5",
                    "f22a85b2-65cc-4611-a3bb-6c50e2de9e25",
                    "b1b9b074-c96c-458b-913e-36352d21cf72",
                    "87902699-f54f-4bc4-b5b5-d561eaac9f50",
                    "783b7b87-4eca-4210-a26a-857bf3796779",
                    "6a25e29c-405f-4124-925f-3c761ec6f454",
                    "a57e6ccc-6ca0-4d9a-875a-a70b844d1df5",
                    "4963659f-a3e3-48a5-a5b5-7c910d80d5bd",
                    "3c2561e9-273f-46fe-b485-ada0a077a3bb",
                    "b01c6f5f-175e-476e-b940-a7d11ebc2f74",
                    "7ff0f375-0935-4250-ad29-1cc294248372"
                  ],
                  "failures": [],
                  "pending": [
                    "9bdeb5a7-700b-4a46-9b10-053e92dbe3d8"
                  ],
                  "skipped": [],
                  "duration": 1083,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                },
                {
                  "uuid": "4e2ad8b3-d812-4c2d-a213-e7cc50f6f937",
                  "title": "#mint - rebase",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                  "file": "/src/test/minter/04-mint-repay.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [],
                  "suites": [
                    {
                      "uuid": "78cc368b-5e6a-4dde-ad1f-499a88b02d1b",
                      "title": "debt amounts are calculated correctly",
                      "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                      "file": "/src/test/minter/04-mint-repay.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "when minted before positive rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase debt amounts are calculated correctly when minted before positive rebase",
                          "timedOut": false,
                          "duration": 85,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\n// Mint before rebase\nawait f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: mintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());\nconst balanceBefore = await f.KrAsset.balanceOf(f.user1.address);\n// Rebase the asset according to params\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Ensure that the minted balance is adjusted by the rebase\nconst [balanceAfter, balanceAfterAdjusted] = await (0, _krassets.getDebtIndexAdjustedBalance)(f.user1, f.KrAsset);\n(0, _chai.expect)(balanceAfter).to.equal(mintAmount.mul(denominator));\n(0, _chai.expect)(balanceBefore).to.not.equal(balanceAfter);\n// Ensure that debt amount is also adjsuted by the rebase\nconst debtAmount = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\n(0, _chai.expect)(balanceAfterAdjusted).to.equal(debtAmount);",
                          "err": {},
                          "uuid": "e9986ef7-4695-4c6f-b6f1-a079448822a5",
                          "parentUUID": "78cc368b-5e6a-4dde-ad1f-499a88b02d1b",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when minted before negative rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase debt amounts are calculated correctly when minted before negative rebase",
                          "timedOut": false,
                          "duration": 87,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\n// Mint before rebase\nawait f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: mintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());\nconst balanceBefore = await f.KrAsset.balanceOf(f.user1.address);\n// Rebase the asset according to params\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Ensure that the minted balance is adjusted by the rebase\nconst [balanceAfter, balanceAfterAdjusted] = await (0, _krassets.getDebtIndexAdjustedBalance)(f.user1, f.KrAsset);\n(0, _chai.expect)(balanceAfter).to.equal(mintAmount.div(denominator));\n(0, _chai.expect)(balanceBefore).to.not.equal(balanceAfter);\n// Ensure that debt amount is also adjsuted by the rebase\nconst debtAmount = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\n(0, _chai.expect)(balanceAfterAdjusted).to.equal(debtAmount);",
                          "err": {},
                          "uuid": "0e38b96f-75c4-446c-803e-a7c02a72f5de",
                          "parentUUID": "78cc368b-5e6a-4dde-ad1f-499a88b02d1b",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when minted after positive rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase debt amounts are calculated correctly when minted after positive rebase",
                          "timedOut": false,
                          "duration": 97,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\n// Mint before rebase\nawait f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: mintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());\nconst balanceBefore = await f.KrAsset.balanceOf(f.user1.address);\n// Rebase the asset according to params\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Ensure that the minted balance is adjusted by the rebase\nconst [balanceAfter, balanceAfterAdjusted] = await (0, _krassets.getDebtIndexAdjustedBalance)(f.user1, f.KrAsset);\n(0, _chai.expect)(balanceAfter).to.equal(mintAmount.mul(denominator));\n(0, _chai.expect)(balanceBefore).to.not.equal(balanceAfter);\n// Ensure that debt amount is also adjusted by the rebase\nconst debtAmount = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\n(0, _chai.expect)(balanceAfterAdjusted).to.equal(debtAmount);",
                          "err": {},
                          "uuid": "3c598e87-f9ff-4461-a493-2cced7331491",
                          "parentUUID": "78cc368b-5e6a-4dde-ad1f-499a88b02d1b",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when minted after negative rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase debt amounts are calculated correctly when minted after negative rebase",
                          "timedOut": false,
                          "duration": 94,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\n// Mint before rebase\nawait f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: mintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());\nconst balanceBefore = await f.KrAsset.balanceOf(f.user1.address);\n// Rebase the asset according to params\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Ensure that the minted balance is adjusted by the rebase\nconst [balanceAfter, balanceAfterAdjusted] = await (0, _krassets.getDebtIndexAdjustedBalance)(f.user1, f.KrAsset);\n(0, _chai.expect)(balanceAfter).to.equal(mintAmount.div(denominator));\n(0, _chai.expect)(balanceBefore).to.not.equal(balanceAfter);\n// Ensure that debt amount is also adjusted by the rebase\nconst debtAmount = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\n(0, _chai.expect)(balanceAfterAdjusted).to.equal(debtAmount);",
                          "err": {},
                          "uuid": "ed2913fd-6004-4a2e-a1bf-2410e2ef84dc",
                          "parentUUID": "78cc368b-5e6a-4dde-ad1f-499a88b02d1b",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "e9986ef7-4695-4c6f-b6f1-a079448822a5",
                        "0e38b96f-75c4-446c-803e-a7c02a72f5de",
                        "3c598e87-f9ff-4461-a493-2cced7331491",
                        "ed2913fd-6004-4a2e-a1bf-2410e2ef84dc"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 363,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 30000
                    },
                    {
                      "uuid": "6f0613c9-59a5-4a06-8d53-ea8cbec0626c",
                      "title": "debt values are calculated correctly",
                      "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                      "file": "/src/test/minter/04-mint-repay.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "when mint is made before positive rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase debt values are calculated correctly when mint is made before positive rebase",
                          "timedOut": false,
                          "duration": 168,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\n// Mint before rebase\nawait f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: mintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());\nconst valueBeforeRebase = await hre.Diamond.getAccountTotalDebtValue(f.user1.address);\n// Adjust price accordingly\nconst { pyth: assetPrice } = await f.KrAsset.getPrice();\nawait f.KrAsset.setPrice((0, _values.fromBig)(assetPrice.div(denominator), 8));\n// Rebase the asset according to params\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Ensure that the value inside protocol matches the value before rebase\nconst valueAfterRebase = await hre.Diamond.getAccountTotalDebtValue(f.user1.address);\n(0, _chai.expect)(valueAfterRebase).to.equal(valueBeforeRebase);",
                          "err": {},
                          "uuid": "74f2c658-6cb8-40f0-aae9-4ac86df0df18",
                          "parentUUID": "6f0613c9-59a5-4a06-8d53-ea8cbec0626c",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when mint is made before negative rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase debt values are calculated correctly when mint is made before negative rebase",
                          "timedOut": false,
                          "duration": 153,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\n// Mint before rebase\nawait f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: mintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());\nconst valueBeforeRebase = await hre.Diamond.getAccountTotalDebtValue(f.user1.address);\n// Adjust price accordingly\nconst { pyth: assetPrice } = await f.KrAsset.getPrice();\nawait f.KrAsset.setPrice((0, _values.fromBig)(assetPrice.mul(denominator), 8));\n// Rebase the asset according to params\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Ensure that the value inside protocol matches the value before rebase\nconst valueAfterRebase = await hre.Diamond.getAccountTotalDebtValue(f.user1.address);\n(0, _chai.expect)(valueAfterRebase).to.equal(valueBeforeRebase);",
                          "err": {},
                          "uuid": "01339fe7-6904-408c-93eb-d3b42ebc2689",
                          "parentUUID": "6f0613c9-59a5-4a06-8d53-ea8cbec0626c",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when minted after positive rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase debt values are calculated correctly when minted after positive rebase",
                          "timedOut": false,
                          "duration": 158,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\n// Equal value after rebase\nconst equalMintAmount = mintAmount.mul(denominator);\nconst { pyth: assetPrice } = await f.KrAsset.getPrice();\n// Get value of the future mint before rebase\nconst valueBeforeRebase = await hre.Diamond.getValue(f.KrAsset.address, mintAmount);\n// Adjust price accordingly\nawait f.KrAsset.setPrice((0, _values.fromBig)(assetPrice, 8) / denominator);\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\nawait f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: equalMintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());\n// Ensure that value after mint matches what is expected\nconst valueAfterRebase = await hre.Diamond.getAccountTotalDebtValue(f.user1.address);\n(0, _chai.expect)(valueAfterRebase).to.equal(valueBeforeRebase);",
                          "err": {},
                          "uuid": "b095d167-70f4-4847-8cde-4c727bdbe138",
                          "parentUUID": "6f0613c9-59a5-4a06-8d53-ea8cbec0626c",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when minted after negative rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase debt values are calculated correctly when minted after negative rebase",
                          "timedOut": false,
                          "duration": 149,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\n// Equal value after rebase\nconst equalMintAmount = mintAmount.div(denominator);\nconst { pyth: assetPrice } = await f.KrAsset.getPrice();\n// Get value of the future mint before rebase\nconst valueBeforeRebase = await hre.Diamond.getValue(f.KrAsset.address, mintAmount);\n// Adjust price accordingly\nawait f.KrAsset.setPrice((0, _values.fromBig)(assetPrice.mul(denominator), 8));\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\nawait f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: equalMintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());\n// Ensure that value after mint matches what is expected\nconst valueAfterRebase = await hre.Diamond.getAccountTotalDebtValue(f.user1.address);\n(0, _chai.expect)(valueAfterRebase).to.equal(valueBeforeRebase);",
                          "err": {},
                          "uuid": "b889036c-d3d2-48fc-bbf2-bf53e1e9b85f",
                          "parentUUID": "6f0613c9-59a5-4a06-8d53-ea8cbec0626c",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "74f2c658-6cb8-40f0-aae9-4ac86df0df18",
                        "01339fe7-6904-408c-93eb-d3b42ebc2689",
                        "b095d167-70f4-4847-8cde-4c727bdbe138",
                        "b889036c-d3d2-48fc-bbf2-bf53e1e9b85f"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 628,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 30000
                    },
                    {
                      "uuid": "b79d409f-e889-4db7-84da-1b221531a4a7",
                      "title": "debt values and amounts are calculated correctly",
                      "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                      "file": "/src/test/minter/04-mint-repay.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "when minted before and after a positive rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase debt values and amounts are calculated correctly when minted before and after a positive rebase",
                          "timedOut": false,
                          "duration": 275,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const { pyth: assetPrice } = await f.KrAsset.getPrice();\n// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst mintAmountAfterRebase = mintAmount.mul(denominator);\nconst assetPriceRebase = assetPrice.div(denominator);\n// Get value of the future mint\nconst valueBeforeRebase = await hre.Diamond.getValue(f.KrAsset.address, mintAmount);\n// Mint before rebase\nawait f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: mintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());\n// Get results\nconst balanceAfterFirstMint = await f.KrAsset.contract.balanceOf(f.user1.address);\nconst debtAmountAfterFirstMint = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\nconst debtValueAfterFirstMint = await hre.Diamond.getAccountTotalDebtValue(f.user1.address);\n// Assert\n(0, _chai.expect)(balanceAfterFirstMint).to.equal(debtAmountAfterFirstMint);\n(0, _chai.expect)(valueBeforeRebase).to.equal(debtValueAfterFirstMint);\n// Adjust price and rebase\nawait f.KrAsset.setPrice((0, _values.fromBig)(assetPriceRebase, 8));\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Ensure debt amounts and balances match\nconst [balanceAfterFirstRebase, balanceAfterFirstRebaseAdjusted] = await (0, _krassets.getDebtIndexAdjustedBalance)(f.user1, f.KrAsset);\nconst debtAmountAfterFirstRebase = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\n(0, _chai.expect)(balanceAfterFirstRebase).to.equal(mintAmountAfterRebase);\n(0, _chai.expect)(balanceAfterFirstRebaseAdjusted).to.equal(debtAmountAfterFirstRebase);\n// Ensure debt usd values match\nconst debtValueAfterFirstRebase = await hre.Diamond.getAccountTotalDebtValue(f.user1.address);\n(0, _chai.expect)(await (0, _calculations.fromScaledAmount)(debtValueAfterFirstRebase, f.KrAsset)).to.equal(debtValueAfterFirstMint);\n(0, _chai.expect)(await (0, _calculations.fromScaledAmount)(debtValueAfterFirstRebase, f.KrAsset)).to.equal(valueBeforeRebase);\n// Mint after rebase\nawait f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: mintAmountAfterRebase,\n    receiver: f.user1.address\n}, await hre.updateData());\n// Ensure debt amounts and balances match\nconst balanceAfterSecondMint = await f.KrAsset.contract.balanceOf(f.user1.address);\n// Ensure balance matches\nconst expectedBalanceAfterSecondMint = balanceAfterFirstRebase.add(mintAmountAfterRebase);\n(0, _chai.expect)(balanceAfterSecondMint).to.equal(expectedBalanceAfterSecondMint);\n// Ensure debt usd values match\nconst debtValueAfterSecondMint = await hre.Diamond.getAccountTotalDebtValue(f.user1.address);\n(0, _chai.expect)(await (0, _calculations.fromScaledAmount)(debtValueAfterSecondMint, f.KrAsset)).to.closeTo(debtValueAfterFirstMint.mul(2), INTEREST_RATE_PRICE_DELTA);\n(0, _chai.expect)(debtValueAfterSecondMint).to.closeTo(valueBeforeRebase.mul(2), INTEREST_RATE_PRICE_DELTA);",
                          "err": {},
                          "uuid": "8ed74dac-9e6a-423a-8310-274a2dc90c2c",
                          "parentUUID": "b79d409f-e889-4db7-84da-1b221531a4a7",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when minted before and after a negative rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase debt values and amounts are calculated correctly when minted before and after a negative rebase",
                          "timedOut": false,
                          "duration": 264,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const { pyth: assetPrice } = await f.KrAsset.getPrice();\n// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst mintAmountAfterRebase = mintAmount.div(denominator);\nconst assetPriceRebase = assetPrice.mul(denominator);\n// Get value of the future mint\nconst valueBeforeRebase = await hre.Diamond.getValue(f.KrAsset.address, mintAmount);\n// Mint before rebase\nawait f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: mintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());\n// Get results\nconst balanceAfterFirstMint = await f.KrAsset.contract.balanceOf(f.user1.address);\nconst debtAmountAfterFirstMint = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\nconst debtValueAfterFirstMint = await hre.Diamond.getAccountTotalDebtValue(f.user1.address);\n// Assert\n(0, _chai.expect)(balanceAfterFirstMint).to.equal(debtAmountAfterFirstMint);\n(0, _chai.expect)(valueBeforeRebase).to.equal(debtValueAfterFirstMint);\n// Adjust price and rebase\nawait f.KrAsset.setPrice((0, _values.fromBig)(assetPriceRebase, 8));\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Ensure debt amounts and balances match\nconst [balanceAfterFirstRebase, balanceAfterFirstRebaseAdjusted] = await (0, _krassets.getDebtIndexAdjustedBalance)(f.user1, f.KrAsset);\nconst debtAmountAfterFirstRebase = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\n(0, _chai.expect)(balanceAfterFirstRebase).to.equal(mintAmountAfterRebase);\n(0, _chai.expect)(balanceAfterFirstRebaseAdjusted).to.equal(debtAmountAfterFirstRebase);\n// Ensure debt usd values match\nconst debtValueAfterFirstRebase = await hre.Diamond.getAccountTotalDebtValue(f.user1.address);\n(0, _chai.expect)(debtValueAfterFirstRebase).to.equal(await (0, _calculations.toScaledAmount)(debtValueAfterFirstMint, f.KrAsset));\n(0, _chai.expect)(debtValueAfterFirstRebase).to.equal(await (0, _calculations.toScaledAmount)(valueBeforeRebase, f.KrAsset));\n// Mint after rebase\nawait f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: mintAmountAfterRebase,\n    receiver: f.user1.address\n}, await hre.updateData());\n// Ensure debt usd values match\nconst debtValueAfterSecondMint = await hre.Diamond.getAccountTotalDebtValue(f.user1.address);\n(0, _chai.expect)(debtValueAfterSecondMint).to.closeTo(await (0, _calculations.toScaledAmount)(debtValueAfterFirstMint.mul(2), f.KrAsset), INTEREST_RATE_PRICE_DELTA);\n(0, _chai.expect)(debtValueAfterSecondMint).to.closeTo(await (0, _calculations.toScaledAmount)(valueBeforeRebase.mul(2), f.KrAsset), INTEREST_RATE_PRICE_DELTA);",
                          "err": {},
                          "uuid": "6f6a1b75-40aa-4fde-ab71-1363819cc2e0",
                          "parentUUID": "b79d409f-e889-4db7-84da-1b221531a4a7",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "8ed74dac-9e6a-423a-8310-274a2dc90c2c",
                        "6f6a1b75-40aa-4fde-ab71-1363819cc2e0"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 539,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 30000
                    }
                  ],
                  "passes": [],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 0,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                },
                {
                  "uuid": "f038aeba-ee92-44ec-8d9f-83c19cde31a0",
                  "title": "#burn",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                  "file": "/src/test/minter/04-mint-repay.ts",
                  "beforeHooks": [
                    {
                      "title": "\"before each\" hook in \"#burn\"",
                      "fullTitle": "Minter #mint+burn #burn \"before each\" hook in \"#burn\"",
                      "timedOut": false,
                      "duration": 75,
                      "state": null,
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: f.initialMintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());",
                      "err": {},
                      "uuid": "07ad0826-1cc4-4f6e-b988-54f62246d332",
                      "parentUUID": "f038aeba-ee92-44ec-8d9f-83c19cde31a0",
                      "isHook": true,
                      "skipped": false
                    }
                  ],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should allow users to burn some of their Kresko asset balances",
                      "fullTitle": "Minter #mint+burn #burn should allow users to burn some of their Kresko asset balances",
                      "timedOut": false,
                      "duration": 85,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const kreskoAssetTotalSupplyBefore = await f.KrAsset.contract.totalSupply();\n// Burn Kresko asset\nconst burnAmount = (0, _values.toBig)(1);\nconst kreskoAssetIndex = 0;\nawait f.User1.burnKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: burnAmount,\n    mintIndex: kreskoAssetIndex,\n    repayee: f.user1.address\n}, await hre.updateData());\n// Confirm the user no long holds the burned Kresko asset amount\nconst userBalance = await f.KrAsset.balanceOf(f.user1.address);\n(0, _chai.expect)(userBalance).to.equal(f.initialMintAmount.sub(burnAmount));\n// Confirm that the Kresko asset's total supply decreased as expected\nconst kreskoAssetTotalSupplyAfter = await f.KrAsset.contract.totalSupply();\n(0, _chai.expect)(kreskoAssetTotalSupplyAfter).to.equal(kreskoAssetTotalSupplyBefore.sub(burnAmount));\n// Confirm the array of the user's minted Kresko assets still contains the asset's address\nconst mintedKreskoAssetsAfter = await _optimizations.default.getAccountMintedAssets(f.user1.address);\n(0, _chai.expect)(mintedKreskoAssetsAfter).to.deep.equal([\n    f.KrAsset.address\n]);\n// Confirm the user's minted kresko asset amount has been updated\nconst userDebt = await _optimizations.default.getAccountDebtAmount(f.user1.address, f.KrAsset);\n(0, _chai.expect)(userDebt).to.closeTo(f.initialMintAmount.sub(burnAmount), INTEREST_RATE_DELTA);",
                      "err": {},
                      "uuid": "549a6e1d-9789-4ef6-8a8b-ea9e778aaa7a",
                      "parentUUID": "f038aeba-ee92-44ec-8d9f-83c19cde31a0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow trusted address to burn its own Kresko asset balances on behalf of another user",
                      "fullTitle": "Minter #mint+burn #burn should allow trusted address to burn its own Kresko asset balances on behalf of another user",
                      "timedOut": false,
                      "duration": 94,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await hre.Diamond.grantRole(_roles.Role.MANAGER, f.user2.address);\nconst kreskoAssetTotalSupplyBefore = await f.KrAsset.contract.totalSupply();\n// Burn Kresko asset\nconst burnAmount = (0, _values.toBig)(1);\nconst kreskoAssetIndex = 0;\nconst userOneBalanceBefore = await f.KrAsset.balanceOf(f.user1.address);\n// User three burns it's KreskoAsset to reduce userOnes debt\nawait f.User2.burnKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: burnAmount,\n    mintIndex: kreskoAssetIndex,\n    repayee: f.user2.address\n}, await hre.updateData());\n// await expect(f.User2.burnKreskoAsset(f.user1.address, f.KrAsset.address, burnAmount, kreskoAssetIndex)).to.not.be\n//   .reverted;\n// Confirm the userOne had no effect on it's kreskoAsset balance\nconst userOneBalance = await f.KrAsset.balanceOf(f.user1.address);\n(0, _chai.expect)(userOneBalance).to.equal(userOneBalanceBefore, 'userOneBalance');\n// Confirm the userThree no long holds the burned Kresko asset amount\nconst userThreeBalance = await f.KrAsset.balanceOf(f.user2.address);\n(0, _chai.expect)(userThreeBalance).to.equal(f.initialMintAmount.sub(burnAmount), 'userThreeBalance');\n// Confirm that the Kresko asset's total supply decreased as expected\nconst kreskoAssetTotalSupplyAfter = await f.KrAsset.contract.totalSupply();\n(0, _chai.expect)(kreskoAssetTotalSupplyAfter).to.equal(kreskoAssetTotalSupplyBefore.sub(burnAmount), 'totalSupplyAfter');\n// Confirm the array of the user's minted Kresko assets still contains the asset's address\nconst mintedKreskoAssetsAfter = await _optimizations.default.getAccountMintedAssets(f.user2.address);\n(0, _chai.expect)(mintedKreskoAssetsAfter).to.deep.equal([\n    f.KrAsset.address\n], 'mintedKreskoAssetsAfter');\n// Confirm the user's minted kresko asset amount has been updated\nconst userOneDebt = await _optimizations.default.getAccountDebtAmount(f.user1.address, f.KrAsset);\n(0, _chai.expect)(userOneDebt).to.equal(f.initialMintAmount.sub(burnAmount));",
                      "err": {},
                      "uuid": "b82be7d7-97e9-44d8-8048-b682086bafff",
                      "parentUUID": "f038aeba-ee92-44ec-8d9f-83c19cde31a0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow trusted address to burn the full balance of its Kresko asset on behalf another user",
                      "fullTitle": "Minter #mint+burn #burn should allow trusted address to burn the full balance of its Kresko asset on behalf another user",
                      "timedOut": false,
                      "duration": 0,
                      "state": "pending",
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": true,
                      "context": null,
                      "code": "",
                      "err": {},
                      "uuid": "7289bd6e-10a1-4e9e-80b0-f05d7cb4b1cf",
                      "parentUUID": "f038aeba-ee92-44ec-8d9f-83c19cde31a0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should burn up to the minimum debt position amount if the requested burn would result in a position under the minimum debt value",
                      "fullTitle": "Minter #mint+burn #burn should burn up to the minimum debt position amount if the requested burn would result in a position under the minimum debt value",
                      "timedOut": false,
                      "duration": 94,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const userBalanceBefore = await f.KrAsset.balanceOf(f.user1.address);\nconst kreskoAssetTotalSupplyBefore = await f.KrAsset.contract.totalSupply();\n// Calculate actual burn amount\nconst userOneDebt = await _optimizations.default.getAccountDebtAmount(f.user1.address, f.KrAsset);\nconst minDebtValue = (0, _values.fromBig)(await _optimizations.default.getMinDebtValue(), 8);\nconst oraclePrice = f.KrAsset.config.args.price;\nconst burnAmount = (0, _values.toBig)((0, _values.fromBig)(userOneDebt) - minDebtValue / oraclePrice);\n// Burn Kresko asset\nconst kreskoAssetIndex = 0;\nawait f.User1.burnKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: burnAmount,\n    mintIndex: kreskoAssetIndex,\n    repayee: f.user1.address\n}, await hre.updateData());\n// Confirm the user holds the expected Kresko asset amount\nconst userBalance = await f.KrAsset.balanceOf(f.user1.address);\n// expect(fromBig(userBalance)).to.equal(fromBig(userBalanceBefore.sub(burnAmount)));\n(0, _chai.expect)(userBalance).eq(userBalanceBefore.sub(burnAmount));\n// Confirm that the Kresko asset's total supply decreased as expected\nconst kreskoAssetTotalSupplyAfter = await f.KrAsset.contract.totalSupply();\n(0, _chai.expect)(kreskoAssetTotalSupplyAfter).eq(kreskoAssetTotalSupplyBefore.sub(burnAmount));\n// Confirm the array of the user's minted Kresko assets still contains the asset's address\nconst mintedKreskoAssetsAfter = await _optimizations.default.getAccountMintedAssets(f.user1.address);\n(0, _chai.expect)(mintedKreskoAssetsAfter).to.deep.equal([\n    f.KrAsset.address\n]);\n// Confirm the user's minted kresko asset amount has been updated\nconst newUserDebt = await _optimizations.default.getAccountDebtAmount(f.user1.address, f.KrAsset);\n(0, _chai.expect)(newUserDebt).to.be.equal(userOneDebt.sub(burnAmount));",
                      "err": {},
                      "uuid": "78ea9cf3-fb0a-4830-9600-63e97bec8ca4",
                      "parentUUID": "f038aeba-ee92-44ec-8d9f-83c19cde31a0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should emit KreskoAssetBurned event",
                      "fullTitle": "Minter #mint+burn #burn should emit KreskoAssetBurned event",
                      "timedOut": false,
                      "duration": 81,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const kreskoAssetIndex = 0;\nconst tx = await f.User1.burnKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: f.initialMintAmount.div(5),\n    mintIndex: kreskoAssetIndex,\n    repayee: f.user1.address\n}, await hre.updateData());\nconst event = await (0, _events.getInternalEvent)(tx, hre.Diamond, 'KreskoAssetBurned');\n(0, _chai.expect)(event.account).to.equal(f.user1.address);\n(0, _chai.expect)(event.kreskoAsset).to.equal(f.KrAsset.address);\n(0, _chai.expect)(event.amount).to.equal(f.initialMintAmount.div(5));",
                      "err": {},
                      "uuid": "c1c1c2cb-f22b-4df1-b340-a62ac5adb0bf",
                      "parentUUID": "f038aeba-ee92-44ec-8d9f-83c19cde31a0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow users to burn Kresko assets without giving token approval to Kresko.sol contract",
                      "fullTitle": "Minter #mint+burn #burn should allow users to burn Kresko assets without giving token approval to Kresko.sol contract",
                      "timedOut": false,
                      "duration": 142,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const secondMintAmount = 1;\nconst burnAmount = f.initialMintAmount.add(secondMintAmount);\nawait (0, _chai.expect)(f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: secondMintAmount,\n    receiver: f.user1.address\n}, await hre.updateData())).to.not.be.reverted;\nconst kreskoAssetIndex = 0;\nawait (0, _chai.expect)(f.User1.burnKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: burnAmount,\n    mintIndex: kreskoAssetIndex,\n    repayee: f.user1.address\n}, await hre.updateData())).to.not.be.reverted;",
                      "err": {},
                      "uuid": "ff1a6c56-c497-4da8-a15c-90e5ca5942d6",
                      "parentUUID": "f038aeba-ee92-44ec-8d9f-83c19cde31a0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow users to burn an amount of 0",
                      "fullTitle": "Minter #mint+burn #burn should not allow users to burn an amount of 0",
                      "timedOut": false,
                      "duration": 45,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const kreskoAssetIndex = 0;\nawait (0, _chai.expect)(f.User1.burnKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: 0,\n    mintIndex: kreskoAssetIndex,\n    repayee: f.user1.address\n}, await hre.updateData())).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'ZERO_BURN');",
                      "err": {},
                      "uuid": "5e4885d3-4fa9-4cf1-ad39-0e40f5228f63",
                      "parentUUID": "f038aeba-ee92-44ec-8d9f-83c19cde31a0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow untrusted address to burn any kresko assets on behalf of another user",
                      "fullTitle": "Minter #mint+burn #burn should not allow untrusted address to burn any kresko assets on behalf of another user",
                      "timedOut": false,
                      "duration": 42,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const kreskoAssetIndex = 0;\nawait (0, _chai.expect)(f.User2.burnKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: 100,\n    mintIndex: kreskoAssetIndex,\n    repayee: f.user1.address\n}, await hre.updateData())).to.be.revertedWith(`AccessControl: account ${f.user2.address.toLowerCase()} is missing role 0x46925e0f0cc76e485772167edccb8dc449d43b23b55fc4e756b063f49099e6a0`);",
                      "err": {},
                      "uuid": "22a78576-6996-4a3c-b3be-4842d75b7820",
                      "parentUUID": "f038aeba-ee92-44ec-8d9f-83c19cde31a0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow untrusted address to use another repayee to burn kresko assets",
                      "fullTitle": "Minter #mint+burn #burn should not allow untrusted address to use another repayee to burn kresko assets",
                      "timedOut": false,
                      "duration": 42,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const kreskoAssetIndex = 0;\nawait (0, _chai.expect)(f.User1.burnKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: 100,\n    mintIndex: kreskoAssetIndex,\n    repayee: f.user2.address\n}, await hre.updateData())).to.be.revertedWith(`AccessControl: account ${f.user1.address.toLowerCase()} is missing role 0x46925e0f0cc76e485772167edccb8dc449d43b23b55fc4e756b063f49099e6a0`);",
                      "err": {},
                      "uuid": "1f924c69-c59f-40d4-8d71-35aea18559a3",
                      "parentUUID": "f038aeba-ee92-44ec-8d9f-83c19cde31a0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow users to burn more kresko assets than they hold as debt",
                      "fullTitle": "Minter #mint+burn #burn should not allow users to burn more kresko assets than they hold as debt",
                      "timedOut": false,
                      "duration": 53,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const kreskoAssetIndex = 0;\nconst debt = await _optimizations.default.getAccountDebtAmount(f.user1.address, f.KrAsset);\nconst burnAmount = debt.add((0, _values.toBig)(1));\nawait (0, _chai.expect)(f.User1.burnKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: burnAmount,\n    mintIndex: kreskoAssetIndex,\n    repayee: f.user1.address\n}, await hre.updateData())).to.be.reverted;",
                      "err": {},
                      "uuid": "ff7fd141-9dca-4e3a-bf82-7c3c3343c230",
                      "parentUUID": "f038aeba-ee92-44ec-8d9f-83c19cde31a0",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [
                    {
                      "uuid": "28b5f314-e046-44f5-9cc1-f35dd3650085",
                      "title": "Protocol open fee",
                      "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                      "file": "/src/test/minter/04-mint-repay.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "should charge the protocol open fee with a single collateral asset if the deposit amount is sufficient and emit FeePaid event",
                          "fullTitle": "Minter #mint+burn #burn Protocol open fee should charge the protocol open fee with a single collateral asset if the deposit amount is sufficient and emit FeePaid event",
                          "timedOut": false,
                          "duration": 149,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const openFee = 0.01e4;\nawait f.KrAsset.update({\n    openFee,\n    maxDebtMinter: _values.MaxUint128\n});\nconst mintAmount = (0, _values.toBig)(1);\nconst mintValue = mintAmount.wadMul(_mocks.TEN_USD.ebn(8));\nconst expectedFeeValue = mintValue.percentMul(openFee);\nconst expectedCollateralFeeAmount = expectedFeeValue.wadDiv(_mocks.TEN_USD.ebn(8));\n// Get the balances prior to the fee being charged.\nconst feeRecipient = await hre.Diamond.getFeeRecipient();\nconst kreskoCollateralAssetBalanceBefore = await f.Collateral.balanceOf(hre.Diamond.address);\nconst feeRecipientCollateralBalanceBefore = await f.Collateral.balanceOf(feeRecipient);\n// Mint Kresko asset\nconst tx = await f.User1.mintKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: mintAmount,\n    receiver: f.user1.address\n}, await hre.updateData());\n// Get the balances after the fees have been charged.\nconst kreskoCollateralAssetBalanceAfter = await f.Collateral.balanceOf(hre.Diamond.address);\nconst feeRecipientCollateralBalanceAfter = await f.Collateral.balanceOf(feeRecipient);\n// Ensure the amount gained / lost by the kresko contract and the fee recipient are as expected\nconst feeRecipientBalanceIncrease = feeRecipientCollateralBalanceAfter.sub(feeRecipientCollateralBalanceBefore);\n(0, _chai.expect)(kreskoCollateralAssetBalanceBefore.sub(kreskoCollateralAssetBalanceAfter)).to.equal(feeRecipientBalanceIncrease);\n// Normalize expected amount because protocol closeFee has 10**18 decimals\n(0, _chai.expect)(feeRecipientBalanceIncrease).to.equal(expectedCollateralFeeAmount);\n// Ensure the emitted event is as expected.\nconst event = await (0, _events.getInternalEvent)(tx, hre.Diamond, 'FeePaid');\n(0, _chai.expect)(event.account).to.equal(f.user1.address);\n(0, _chai.expect)(event.paymentCollateralAsset).to.equal(f.Collateral.address);\n(0, _chai.expect)(event.paymentAmount).to.equal(expectedCollateralFeeAmount);\n(0, _chai.expect)(event.paymentValue).to.equal(expectedFeeValue);\n(0, _chai.expect)(event.feeType).to.equal(_types.MinterFee.OPEN);\n// Now verify that calcExpectedFee function returns accurate fee amount\nconst [, values] = await hre.Diamond.previewFee(f.user1.address, f.KrAsset.address, mintAmount, _types.MinterFee.OPEN);\n(0, _chai.expect)(values[0]).eq(expectedCollateralFeeAmount);",
                          "err": {},
                          "uuid": "26ec6532-fcf5-4286-a81b-13a8b3e76484",
                          "parentUUID": "28b5f314-e046-44f5-9cc1-f35dd3650085",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "26ec6532-fcf5-4286-a81b-13a8b3e76484"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 149,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 30000
                    },
                    {
                      "uuid": "11dacad7-1756-461a-8de6-4c697ab948a3",
                      "title": "Protocol Close Fee",
                      "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                      "file": "/src/test/minter/04-mint-repay.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "should charge the protocol close fee with a single collateral asset if the deposit amount is sufficient and emit FeePaid event",
                          "fullTitle": "Minter #mint+burn #burn Protocol Close Fee should charge the protocol close fee with a single collateral asset if the deposit amount is sufficient and emit FeePaid event",
                          "timedOut": false,
                          "duration": 83,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const burnAmount = (0, _values.toBig)(1);\nconst burnValue = burnAmount.wadMul(_mocks.TEN_USD.ebn(8));\nconst closeFee = f.KrAsset.config.args.krAssetConfig.closeFee // use toBig() to emulate closeFee's 18 decimals on contract\n;\nconst expectedFeeValue = burnValue.percentMul(closeFee);\nconst expectedCollateralFeeAmount = expectedFeeValue.wadDiv(f.Collateral.config.args.price.ebn(8));\nconst feeRecipient = await hre.Diamond.getFeeRecipient();\n// Get the balances prior to the fee being charged.\nconst kreskoCollateralAssetBalanceBefore = await f.Collateral.balanceOf(hre.Diamond.address);\nconst feeRecipientCollateralBalanceBefore = await f.Collateral.balanceOf(feeRecipient);\n// Burn Kresko asset\nconst kreskoAssetIndex = 0;\nconst tx = await f.User1.burnKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: burnAmount,\n    mintIndex: kreskoAssetIndex,\n    repayee: f.user1.address\n}, await hre.updateData());\n// Get the balances after the fees have been charged.\nconst kreskoCollateralAssetBalanceAfter = await f.Collateral.balanceOf(hre.Diamond.address);\nconst feeRecipientCollateralBalanceAfter = await f.Collateral.balanceOf(feeRecipient);\n// Ensure the amount gained / lost by the kresko contract and the fee recipient are as expected\nconst feeRecipientBalanceIncrease = feeRecipientCollateralBalanceAfter.sub(feeRecipientCollateralBalanceBefore);\n(0, _chai.expect)(kreskoCollateralAssetBalanceBefore.sub(kreskoCollateralAssetBalanceAfter)).to.equal(feeRecipientBalanceIncrease);\n// Normalize expected amount because protocol closeFee has 10**18 decimals\n(0, _chai.expect)(feeRecipientBalanceIncrease).to.equal(expectedCollateralFeeAmount);\n// Ensure the emitted event is as expected.\nconst event = await (0, _events.getInternalEvent)(tx, hre.Diamond, 'FeePaid');\n(0, _chai.expect)(event.account).to.equal(f.user1.address);\n(0, _chai.expect)(event.paymentCollateralAsset).to.equal(f.Collateral.address);\n(0, _chai.expect)(event.paymentAmount).to.equal(expectedCollateralFeeAmount);\n(0, _chai.expect)(event.paymentValue).to.equal(expectedFeeValue);\n(0, _chai.expect)(event.feeType).to.equal(_types.MinterFee.CLOSE);",
                          "err": {},
                          "uuid": "3436d9a8-f6c6-4152-a0d3-c98fe47c25e5",
                          "parentUUID": "11dacad7-1756-461a-8de6-4c697ab948a3",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "should charge correct protocol close fee after a positive rebase",
                          "fullTitle": "Minter #mint+burn #burn Protocol Close Fee should charge correct protocol close fee after a positive rebase",
                          "timedOut": false,
                          "duration": 278,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const wAmount = 1;\nconst burnAmount = (0, _values.toBig)(1);\nconst expectedFeeAmount = burnAmount.percentMul(f.KrAsset.config.args.krAssetConfig.closeFee);\nconst expectedFeeValue = expectedFeeAmount.wadMul((0, _values.toBig)(_mocks.TEN_USD, 8));\nconst event = await (0, _events.getInternalEvent)(await (0, _krassets.burnKrAsset)({\n    user: f.user2,\n    asset: f.KrAsset,\n    amount: burnAmount\n}), hre.Diamond, 'FeePaid');\n(0, _chai.expect)(event.paymentAmount).to.equal(expectedFeeAmount);\n(0, _chai.expect)(event.paymentValue).to.equal(expectedFeeValue);\n(0, _chai.expect)(event.feeType).to.equal(_types.MinterFee.CLOSE);\n// rebase params\nconst denominator = 4;\nconst positive = true;\nawait f.KrAsset.setPrice(_mocks.TEN_USD / denominator);\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\nconst burnAmountRebase = burnAmount.mul(denominator);\nawait (0, _collaterals.withdrawCollateral)({\n    user: f.user2,\n    asset: f.Collateral,\n    amount: (0, _values.toBig)(wAmount)\n}, await hre.updateData());\nconst eventAfterRebase = await (0, _events.getInternalEvent)(await (0, _krassets.burnKrAsset)({\n    user: f.user2,\n    asset: f.KrAsset,\n    amount: burnAmountRebase\n}), hre.Diamond, 'FeePaid');\n(0, _chai.expect)(eventAfterRebase.paymentCollateralAsset).to.equal(event.paymentCollateralAsset);\n(0, _chai.expect)(eventAfterRebase.paymentAmount).to.equal(expectedFeeAmount);\n(0, _chai.expect)(eventAfterRebase.paymentValue).to.equal(expectedFeeValue);",
                          "err": {},
                          "uuid": "52ed4842-fe1d-4fd7-b7fd-43692e849aae",
                          "parentUUID": "11dacad7-1756-461a-8de6-4c697ab948a3",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "should charge correct protocol close fee after a negative rebase",
                          "fullTitle": "Minter #mint+burn #burn Protocol Close Fee should charge correct protocol close fee after a negative rebase",
                          "timedOut": false,
                          "duration": 275,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const wAmount = 1;\nconst burnAmount = (0, _values.toBig)(1);\nconst expectedFeeAmount = burnAmount.percentMul(f.KrAsset.config.args.krAssetConfig.closeFee);\nconst expectedFeeValue = expectedFeeAmount.wadMul((0, _values.toBig)(_mocks.TEN_USD, 8));\nconst event = await (0, _events.getInternalEvent)(await (0, _krassets.burnKrAsset)({\n    user: f.user2,\n    asset: f.KrAsset,\n    amount: burnAmount\n}), hre.Diamond, 'FeePaid');\n(0, _chai.expect)(event.paymentAmount).to.equal(expectedFeeAmount);\n(0, _chai.expect)(event.paymentValue).to.equal(expectedFeeValue);\n(0, _chai.expect)(event.feeType).to.equal(_types.MinterFee.CLOSE);\n// rebase params\nconst denominator = 4;\nconst positive = false;\nconst priceAfter = (0, _values.fromBig)((await f.KrAsset.getPrice()).pyth, 8) * denominator;\nawait f.KrAsset.setPrice(priceAfter);\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\nconst burnAmountRebase = burnAmount.div(denominator);\nawait (0, _collaterals.withdrawCollateral)({\n    user: f.user2,\n    asset: f.Collateral,\n    amount: (0, _values.toBig)(wAmount)\n}, await hre.updateData());\nconst eventAfterRebase = await (0, _events.getInternalEvent)(await (0, _krassets.burnKrAsset)({\n    user: f.user2,\n    asset: f.KrAsset,\n    amount: burnAmountRebase\n}), hre.Diamond, 'FeePaid');\n(0, _chai.expect)(eventAfterRebase.paymentCollateralAsset).to.equal(event.paymentCollateralAsset);\n(0, _chai.expect)(eventAfterRebase.paymentAmount).to.equal(expectedFeeAmount);\n(0, _chai.expect)(eventAfterRebase.paymentValue).to.equal(expectedFeeValue);",
                          "err": {},
                          "uuid": "35d0262d-f3f4-4e27-9942-90f01da5baea",
                          "parentUUID": "11dacad7-1756-461a-8de6-4c697ab948a3",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "3436d9a8-f6c6-4152-a0d3-c98fe47c25e5",
                        "52ed4842-fe1d-4fd7-b7fd-43692e849aae",
                        "35d0262d-f3f4-4e27-9942-90f01da5baea"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 636,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 30000
                    }
                  ],
                  "passes": [
                    "549a6e1d-9789-4ef6-8a8b-ea9e778aaa7a",
                    "b82be7d7-97e9-44d8-8048-b682086bafff",
                    "78ea9cf3-fb0a-4830-9600-63e97bec8ca4",
                    "c1c1c2cb-f22b-4df1-b340-a62ac5adb0bf",
                    "ff1a6c56-c497-4da8-a15c-90e5ca5942d6",
                    "5e4885d3-4fa9-4cf1-ad39-0e40f5228f63",
                    "22a78576-6996-4a3c-b3be-4842d75b7820",
                    "1f924c69-c59f-40d4-8d71-35aea18559a3",
                    "ff7fd141-9dca-4e3a-bf82-7c3c3343c230"
                  ],
                  "failures": [],
                  "pending": [
                    "7289bd6e-10a1-4e9e-80b0-f05d7cb4b1cf"
                  ],
                  "skipped": [],
                  "duration": 678,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                },
                {
                  "uuid": "b8f66ed6-76a4-487a-8a61-a7018f22b7d8",
                  "title": "#burn - rebase",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                  "file": "/src/test/minter/04-mint-repay.ts",
                  "beforeHooks": [
                    {
                      "title": "\"before each\" hook in \"#burn - rebase\"",
                      "fullTitle": "Minter #mint+burn #burn - rebase \"before each\" hook in \"#burn - rebase\"",
                      "timedOut": false,
                      "duration": 77,
                      "state": null,
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, _krassets.mintKrAsset)({\n    asset: f.KrAsset,\n    amount: mintAmount,\n    user: f.user1\n});",
                      "err": {},
                      "uuid": "27b330e4-ea1b-4a4e-9e18-0e39b86fc1df",
                      "parentUUID": "b8f66ed6-76a4-487a-8a61-a7018f22b7d8",
                      "isHook": true,
                      "skipped": false
                    }
                  ],
                  "afterHooks": [],
                  "tests": [],
                  "suites": [
                    {
                      "uuid": "bd67b630-a7c7-4deb-b1f8-9261560d4905",
                      "title": "debt amounts are calculated correctly",
                      "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                      "file": "/src/test/minter/04-mint-repay.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "when repaying all debt after a positive rebase",
                          "fullTitle": "Minter #mint+burn #burn - rebase debt amounts are calculated correctly when repaying all debt after a positive rebase",
                          "timedOut": false,
                          "duration": 133,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\n// Adjust price according to rebase params\nawait f.KrAsset.setPrice(_mocks.TEN_USD / denominator);\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Pay half of debt\nconst debt = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\nconst repayAmount = debt;\nawait f.User1.burnKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: repayAmount,\n    mintIndex: 0,\n    repayee: f.user1.address\n}, await hre.updateData());\n// Debt value after half repayment\nconst debtAfter = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\n(0, _chai.expect)(debtAfter).to.equal(0);\nconst balanceAfterBurn = await f.KrAsset.contract.balanceOf(f.user1.address);\n(0, _chai.expect)(balanceAfterBurn).to.equal(0);\n// Anchor krAssets should equal balance * denominator\nconst wkrAssetBalanceKresko = await f.KrAsset.anchor.balanceOf(hre.Diamond.address);\n(0, _chai.expect)(wkrAssetBalanceKresko).to.equal(f.initialMintAmount) // WEI\n;",
                          "err": {},
                          "uuid": "2a61dacb-d82f-4dfc-85f6-009f8d9a1f3c",
                          "parentUUID": "bd67b630-a7c7-4deb-b1f8-9261560d4905",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when repaying partial debt after a positive rebase",
                          "fullTitle": "Minter #mint+burn #burn - rebase debt amounts are calculated correctly when repaying partial debt after a positive rebase",
                          "timedOut": false,
                          "duration": 141,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\n// Adjust price according to rebase params\nawait f.KrAsset.setPrice(_mocks.TEN_USD / denominator);\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Pay half of debt\nconst debt = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\nconst repayAmount = debt.div(2);\nawait f.User1.burnKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: repayAmount,\n    mintIndex: 0,\n    repayee: f.user1.address\n}, await hre.updateData());\n// Debt value after half repayment\nconst debtAfter = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\n// Calc expected value with last update\nconst expectedDebt = mintAmount.div(2).mul(denominator);\n(0, _chai.expect)(debtAfter).to.equal(expectedDebt);\n// Should be all burned\nconst expectedBalanceAfter = mintAmount.mul(denominator).sub(repayAmount);\nconst balanceAfterBurn = await f.KrAsset.contract.balanceOf(f.user1.address);\n(0, _chai.expect)(balanceAfterBurn).to.equal(expectedBalanceAfter);\n// All wkrAssets should be burned\nconst expectedwkrBalance = mintAmount.sub(repayAmount.div(denominator)).add(f.initialMintAmount);\nconst wkrAssetBalanceKresko = await f.KrAsset.anchor.balanceOf(hre.Diamond.address);\n(0, _chai.expect)(wkrAssetBalanceKresko).to.equal(expectedwkrBalance);",
                          "err": {},
                          "uuid": "8b1bb296-f65a-4a19-af9b-2f139e84d49f",
                          "parentUUID": "bd67b630-a7c7-4deb-b1f8-9261560d4905",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when repaying all debt after a negative rebase",
                          "fullTitle": "Minter #mint+burn #burn - rebase debt amounts are calculated correctly when repaying all debt after a negative rebase",
                          "timedOut": false,
                          "duration": 131,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\n// Adjust price according to rebase params\nawait f.KrAsset.setPrice(_mocks.TEN_USD * denominator);\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Pay half of debt\nconst debt = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\nconst repayAmount = debt;\nawait f.User1.burnKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: repayAmount,\n    mintIndex: 0,\n    repayee: f.user1.address\n}, await hre.updateData());\n// Debt value after half repayment\nconst debtAfter = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\n// Calc expected value with last update\nconst expectedDebt = 0;\n(0, _chai.expect)(debtAfter).to.equal(expectedDebt);\nconst expectedBalanceAfterBurn = 0;\nconst balanceAfterBurn = (0, _values.fromBig)(await f.KrAsset.contract.balanceOf(f.user1.address));\n(0, _chai.expect)(balanceAfterBurn).to.equal(expectedBalanceAfterBurn);\n// Anchor krAssets should equal balance * denominator\nconst wkrAssetBalanceKresko = await f.KrAsset.anchor.balanceOf(hre.Diamond.address);\n(0, _chai.expect)(wkrAssetBalanceKresko).to.equal((0, _values.toBig)(expectedBalanceAfterBurn * denominator).add(f.initialMintAmount));",
                          "err": {},
                          "uuid": "dbf303a5-3fbc-4628-8b82-84341280a91c",
                          "parentUUID": "bd67b630-a7c7-4deb-b1f8-9261560d4905",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when repaying partial debt after a negative rebase",
                          "fullTitle": "Minter #mint+burn #burn - rebase debt amounts are calculated correctly when repaying partial debt after a negative rebase",
                          "timedOut": false,
                          "duration": 150,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\n// Adjust price according to rebase params\nawait f.KrAsset.setPrice(_mocks.TEN_USD * denominator);\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Pay half of debt\nconst debt = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\nconst repayAmount = debt.div(2);\nawait f.User1.burnKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: repayAmount,\n    mintIndex: 0,\n    repayee: f.user1.address\n}, await hre.updateData());\n// Debt value after half repayment\nconst debtAfter = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\n// Calc expected value with last update\nconst expectedDebt = mintAmount.div(2).div(denominator);\n(0, _chai.expect)(debtAfter).to.equal(expectedDebt);\n// Should be all burned\nconst expectedBalanceAfter = mintAmount.div(denominator).sub(repayAmount);\nconst balanceAfterBurn = await f.KrAsset.contract.balanceOf(f.user1.address);\n(0, _chai.expect)(balanceAfterBurn).to.equal(expectedBalanceAfter);\n// All wkrAssets should be burned\nconst expectedwkrBalance = mintAmount.sub(repayAmount.mul(denominator)).add(f.initialMintAmount);\nconst wkrAssetBalanceKresko = await f.KrAsset.anchor.balanceOf(hre.Diamond.address);\n(0, _chai.expect)(wkrAssetBalanceKresko).to.equal(expectedwkrBalance);",
                          "err": {},
                          "uuid": "9ef0f79b-29ac-43d0-8c4f-7f277e5c2068",
                          "parentUUID": "bd67b630-a7c7-4deb-b1f8-9261560d4905",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "2a61dacb-d82f-4dfc-85f6-009f8d9a1f3c",
                        "8b1bb296-f65a-4a19-af9b-2f139e84d49f",
                        "dbf303a5-3fbc-4628-8b82-84341280a91c",
                        "9ef0f79b-29ac-43d0-8c4f-7f277e5c2068"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 555,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 30000
                    },
                    {
                      "uuid": "6a387bb6-5cde-4cdb-9f46-f5cd7e663f5b",
                      "title": "debt value and mintedKreskoAssets book-keeping is calculated correctly",
                      "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                      "file": "/src/test/minter/04-mint-repay.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "when repaying all debt after a positive rebase",
                          "fullTitle": "Minter #mint+burn #burn - rebase debt value and mintedKreskoAssets book-keeping is calculated correctly when repaying all debt after a positive rebase",
                          "timedOut": false,
                          "duration": 124,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst fullRepayAmount = mintAmount.mul(denominator);\n// Adjust price according to rebase params\nawait f.KrAsset.setPrice(_mocks.TEN_USD / denominator);\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\nawait f.User1.burnKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: fullRepayAmount,\n    mintIndex: 0,\n    repayee: f.user1.address\n}, await hre.updateData());\n// Debt value after half repayment\nconst debtAfter = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\nconst debtValueAfter = await hre.Diamond.getValue(f.KrAsset.address, debtAfter);\n(0, _chai.expect)(debtValueAfter).to.equal(0);",
                          "err": {},
                          "uuid": "9d1ab73d-df86-497c-b5e0-b94ffb48af87",
                          "parentUUID": "6a387bb6-5cde-4cdb-9f46-f5cd7e663f5b",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when repaying partial debt after a positive rebase",
                          "fullTitle": "Minter #mint+burn #burn - rebase debt value and mintedKreskoAssets book-keeping is calculated correctly when repaying partial debt after a positive rebase",
                          "timedOut": false,
                          "duration": 164,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst mintValue = await hre.Diamond.getValue(f.KrAsset.address, mintAmount);\n// Adjust price according to rebase params\nawait f.KrAsset.setPrice(_mocks.TEN_USD / denominator);\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Should contain minted krAsset\nconst mintedKreskoAssetsBeforeBurn = await _optimizations.default.getAccountMintedAssets(f.user1.address);\n(0, _chai.expect)(mintedKreskoAssetsBeforeBurn).to.contain(f.KrAsset.address);\n// Burn assets\n// Pay half of debt\nconst debt = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\nawait f.User1.burnKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: debt.div(2),\n    mintIndex: 0,\n    repayee: f.user1.address\n}, await hre.updateData());\n// Debt value after half repayment\nconst debtAfter = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\nconst debtValueAfter = await hre.Diamond.getValue(f.KrAsset.address, debtAfter);\n// Calc expected value with last update\nconst expectedValue = mintValue.div(2);\n(0, _chai.expect)(debtValueAfter).to.equal(expectedValue);\n// Should still contain minted krAsset\nconst mintedKreskoAssetsAfterBurn = await _optimizations.default.getAccountMintedAssets(f.user1.address);\n(0, _chai.expect)(mintedKreskoAssetsAfterBurn).to.contain(f.KrAsset.address);",
                          "err": {},
                          "uuid": "bf39fc6f-4d3e-4d8c-8802-1543430083c0",
                          "parentUUID": "6a387bb6-5cde-4cdb-9f46-f5cd7e663f5b",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when repaying all debt after a negative rebase",
                          "fullTitle": "Minter #mint+burn #burn - rebase debt value and mintedKreskoAssets book-keeping is calculated correctly when repaying all debt after a negative rebase",
                          "timedOut": false,
                          "duration": 125,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst fullRepayAmount = mintAmount.div(denominator);\n// Adjust price according to rebase params\nawait f.KrAsset.setPrice(_mocks.TEN_USD * denominator);\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\nawait f.User1.burnKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: fullRepayAmount,\n    mintIndex: 0,\n    repayee: f.user1.address\n}, await hre.updateData());\n// Debt value after half repayment\nconst debtAfter = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\nconst debtValueAfter = await hre.Diamond.getValue(f.KrAsset.address, debtAfter);\n(0, _chai.expect)(debtValueAfter).to.equal(0);",
                          "err": {},
                          "uuid": "df369c72-16c7-4c16-9215-89ebbdfa67f0",
                          "parentUUID": "6a387bb6-5cde-4cdb-9f46-f5cd7e663f5b",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when repaying partial debt after a negative rebase",
                          "fullTitle": "Minter #mint+burn #burn - rebase debt value and mintedKreskoAssets book-keeping is calculated correctly when repaying partial debt after a negative rebase",
                          "timedOut": false,
                          "duration": 359,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst mintValue = await hre.Diamond.getValue(f.KrAsset.address, mintAmount);\nawait f.KrAsset.setPrice(_mocks.TEN_USD * denominator);\nawait f.KrAsset.contract.rebase((0, _values.toBig)(denominator), positive, []);\n// Pay half of debt\nconst debt = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\nawait f.User1.burnKreskoAsset({\n    account: f.user1.address,\n    krAsset: f.KrAsset.address,\n    amount: debt.div(2),\n    mintIndex: 0,\n    repayee: f.user1.address\n}, await hre.updateData());\n// Debt value after half repayment\nconst debtAfter = await hre.Diamond.getAccountDebtAmount(f.user1.address, f.KrAsset.address);\nconst debtValueAfter = await hre.Diamond.getValue(f.KrAsset.address, debtAfter);\n// Calc expected value with last update\nconst expectedValue = mintValue.div(2);\n(0, _chai.expect)(debtValueAfter).to.equal(expectedValue);\n// Should still contain minted krAsset\nconst mintedKreskoAssetsAfterBurn = await hre.Diamond.getAccountMintedAssets(f.user1.address);\n(0, _chai.expect)(mintedKreskoAssetsAfterBurn).to.contain(f.KrAsset.address);",
                          "err": {},
                          "uuid": "ab037090-a1f8-41bf-b8bb-83aba751f3a7",
                          "parentUUID": "6a387bb6-5cde-4cdb-9f46-f5cd7e663f5b",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "9d1ab73d-df86-497c-b5e0-b94ffb48af87",
                        "bf39fc6f-4d3e-4d8c-8802-1543430083c0",
                        "df369c72-16c7-4c16-9215-89ebbdfa67f0",
                        "ab037090-a1f8-41bf-b8bb-83aba751f3a7"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 772,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 30000
                    }
                  ],
                  "passes": [],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 0,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                }
              ],
              "passes": [],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "b7a7e4e4-cc9b-446a-92a1-94475a42a645",
          "title": "CollateralReceiver - UncheckedCollateralWithdraw",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/05-collateral-receiver.ts",
          "file": "/src/test/minter/05-collateral-receiver.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"CollateralReceiver - UncheckedCollateralWithdraw\"",
              "fullTitle": "CollateralReceiver - UncheckedCollateralWithdraw \"before each\" hook in \"CollateralReceiver - UncheckedCollateralWithdraw\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "f = await (0, _fixtures.defaultFixture)();\n[, , [user]] = f.users;",
              "err": {},
              "uuid": "a2763328-7aa0-4abe-8aed-e920dbc0a9be",
              "parentUUID": "b7a7e4e4-cc9b-446a-92a1-94475a42a645",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "ea3ba5c5-446c-4fcd-95d5-438c4df20114",
              "title": "#unchecked-collateral-withdrawal",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/05-collateral-receiver.ts",
              "file": "/src/test/minter/05-collateral-receiver.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [],
              "suites": [
                {
                  "uuid": "1034454a-bca9-4ee1-96b4-6f657272734b",
                  "title": "#unchecked-withdraw",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/05-collateral-receiver.ts",
                  "file": "/src/test/minter/05-collateral-receiver.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "withdraw correct amount",
                      "fullTitle": "CollateralReceiver - UncheckedCollateralWithdraw #unchecked-collateral-withdrawal #unchecked-withdraw withdraw correct amount",
                      "timedOut": false,
                      "duration": 81,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const withdrawalAmount = 42069;\nawait (0, _chai.expect)(f.Receiver.testWithdrawalAmount(f.Collateral.address, withdrawalAmount, await hre.updateData())).to.not.be.revertedWith('wrong amount received');\n(0, _chai.expect)(await f.Collateral.balanceOf(f.Receiver.address)).to.equal(withdrawalAmount);",
                      "err": {},
                      "uuid": "0d83517d-4c83-4cce-8393-97618426129e",
                      "parentUUID": "1034454a-bca9-4ee1-96b4-6f657272734b",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should send correct values to the callback",
                      "fullTitle": "CollateralReceiver - UncheckedCollateralWithdraw #unchecked-collateral-withdrawal #unchecked-withdraw should send correct values to the callback",
                      "timedOut": false,
                      "duration": 85,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const Receiver = f.Receiver;\nconst balKreskoBefore = await f.Collateral.contract.balanceOf(hre.Diamond.address);\nawait Receiver.test(f.Collateral.address, 1, await hre.updateData());\n(0, _chai.expect)(await Receiver.collateralAsset()).to.equal(f.Collateral.address);\n(0, _chai.expect)(await Receiver.account()).to.equal(user.address);\n(0, _chai.expect)((await Receiver.userData()).val).to.equal(1);\n(0, _chai.expect)(await Receiver.withdrawalAmountRequested()).to.equal(1);\n(0, _chai.expect)(await Receiver.withdrawalAmountReceived()).to.equal(1);\nconst balKreskoAfter = await f.Collateral.contract.balanceOf(hre.Diamond.address);\n(0, _chai.expect)(balKreskoBefore.sub(balKreskoAfter)).to.equal(1);\n(0, _chai.expect)(await f.Collateral.contract.balanceOf(Receiver.address)).to.equal(1);",
                      "err": {},
                      "uuid": "a0f513a9-2bfa-47f0-aa19-910815840d16",
                      "parentUUID": "1034454a-bca9-4ee1-96b4-6f657272734b",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should be able to withdraw collateral up to MRC without returning it",
                      "fullTitle": "CollateralReceiver - UncheckedCollateralWithdraw #unchecked-collateral-withdrawal #unchecked-withdraw should be able to withdraw collateral up to MRC without returning it",
                      "timedOut": false,
                      "duration": 199,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const Receiver = f.Receiver;\nconst { maxWithdrawAmount } = await (0, _collaterals.getMaxWithdrawal)(user.address, f.Collateral);\n(0, _chai.expect)(maxWithdrawAmount.gt(0)).to.be.true;\nawait Receiver.test(f.Collateral.address, maxWithdrawAmount, await hre.updateData());\n(0, _chai.expect)((await Receiver.userData()).val).to.equal(maxWithdrawAmount);\n(0, _chai.expect)(await Receiver.withdrawalAmountRequested()).to.equal(maxWithdrawAmount);\n(0, _chai.expect)(await Receiver.withdrawalAmountReceived()).to.equal(maxWithdrawAmount);\n(0, _chai.expect)(await f.Collateral.contract.balanceOf(Receiver.address)).to.equal(maxWithdrawAmount);\n(0, _chai.expect)(await hre.Diamond.getAccountCollateralRatio(user.address)).to.be.eq(1.5e4);\nawait (0, _chai.expect)(Receiver.test(f.Collateral.address, 10e15.toString(), await hre.updateData())).to.be.reverted;",
                      "err": {},
                      "uuid": "4a5943b6-ea69-4078-960a-f6c4dfc48118",
                      "parentUUID": "1034454a-bca9-4ee1-96b4-6f657272734b",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should be able to withdraw full collateral and return it",
                      "fullTitle": "CollateralReceiver - UncheckedCollateralWithdraw #unchecked-collateral-withdrawal #unchecked-withdraw should be able to withdraw full collateral and return it",
                      "timedOut": false,
                      "duration": 96,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const Receiver = f.Receiver;\nconst deposits = await _optimizations.default.getAccountCollateralAmount(user.address, f.Collateral.address);\n(0, _chai.expect)(deposits.gt(0)).to.be.true;\nconst balKreskoBefore = await f.Collateral.balanceOf(hre.Diamond.address);\nawait Receiver.testRedeposit(f.Collateral.address, deposits, await hre.updateData());\n(0, _chai.expect)(await Receiver.withdrawalAmountRequested()).to.equal(deposits);\n(0, _chai.expect)(await Receiver.withdrawalAmountReceived()).to.equal(deposits);\n(0, _chai.expect)(await f.Collateral.balanceOf(Receiver.address)).to.equal(0);\nconst balKreskoAfter = await f.Collateral.balanceOf(hre.Diamond.address);\n(0, _chai.expect)(balKreskoBefore).to.equal(balKreskoAfter);",
                      "err": {},
                      "uuid": "16947bae-d379-4888-8d73-18ba1f7f237e",
                      "parentUUID": "1034454a-bca9-4ee1-96b4-6f657272734b",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should be able to withdraw full collateral and deposit another asset in its place",
                      "fullTitle": "CollateralReceiver - UncheckedCollateralWithdraw #unchecked-collateral-withdrawal #unchecked-withdraw should be able to withdraw full collateral and deposit another asset in its place",
                      "timedOut": false,
                      "duration": 135,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const Receiver = f.Receiver;\nconst deposits = await _optimizations.default.getAccountCollateralAmount(user.address, f.Collateral.address);\n(0, _chai.expect)(deposits.gt(0)).to.be.true;\n// set second collateral price to half of the first and balance to twice that\nawait f.Collateral2.setPrice(10);\nawait f.Collateral2.setBalance(user, f.depositAmount);\nawait f.Collateral2.contract.setVariable('_allowances', {\n    [user.address]: {\n        [hre.Diamond.address]: f.depositAmount,\n        [Receiver.address]: f.depositAmount\n    }\n});\nawait Receiver.testDepositAlternate(f.Collateral.address, deposits, f.Collateral2.address, await hre.updateData());\nconst secondCollateralDeposits = await _optimizations.default.getAccountCollateralAmount(user.address, f.Collateral2.address);\n(0, _chai.expect)(secondCollateralDeposits.eq(deposits)).to.be.true;",
                      "err": {},
                      "uuid": "61c227b3-6a66-40fd-931c-2e3f926bf946",
                      "parentUUID": "1034454a-bca9-4ee1-96b4-6f657272734b",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "0d83517d-4c83-4cce-8393-97618426129e",
                    "a0f513a9-2bfa-47f0-aa19-910815840d16",
                    "4a5943b6-ea69-4078-960a-f6c4dfc48118",
                    "16947bae-d379-4888-8d73-18ba1f7f237e",
                    "61c227b3-6a66-40fd-931c-2e3f926bf946"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 596,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                },
                {
                  "uuid": "3d55e1af-b780-49ff-ac43-046a1e11261a",
                  "title": "#unchecked-withdraw-reverts",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/05-collateral-receiver.ts",
                  "file": "/src/test/minter/05-collateral-receiver.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should revert on zero withdrawal",
                      "fullTitle": "CollateralReceiver - UncheckedCollateralWithdraw #unchecked-collateral-withdrawal #unchecked-withdraw-reverts should revert on zero withdrawal",
                      "timedOut": false,
                      "duration": 50,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, _chai.expect)(f.Receiver.test(f.Collateral.address, 0, await hre.updateData())).to.be.reverted;\n            // await expect(f.Receiver.test(f.Collateral.address, 0)).to.be.revertedWith(Error.ZERO_WITHDRAW);",
                      "err": {},
                      "uuid": "f3af2b96-b1e6-43a6-a5a5-dc0e8f5d612c",
                      "parentUUID": "3d55e1af-b780-49ff-ac43-046a1e11261a",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should revert with no manager role",
                      "fullTitle": "CollateralReceiver - UncheckedCollateralWithdraw #unchecked-collateral-withdrawal #unchecked-withdraw-reverts should revert with no manager role",
                      "timedOut": false,
                      "duration": 55,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await hre.Diamond.revokeRole(_roles.Role.MANAGER, f.Receiver.address);\nawait (0, _chai.expect)(f.Receiver.test(f.Collateral.address, 10000, await hre.updateData())).to.be.reverted;\n            // await expect(f.Receiver.test(f.Collateral.address, 10000)).to.be.revertedWith(\n            //     `AccessControl: account ${f.Receiver.address.toLowerCase()} is missing role 0x46925e0f0cc76e485772167edccb8dc449d43b23b55fc4e756b063f49099e6a0`,\n            // );",
                      "err": {},
                      "uuid": "1c80380d-798c-4f1e-815e-4cd4332c31a2",
                      "parentUUID": "3d55e1af-b780-49ff-ac43-046a1e11261a",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should revert if under MCR after withdrawal",
                      "fullTitle": "CollateralReceiver - UncheckedCollateralWithdraw #unchecked-collateral-withdrawal #unchecked-withdraw-reverts should revert if under MCR after withdrawal",
                      "timedOut": false,
                      "duration": 100,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const { maxWithdrawAmount } = await (0, _collaterals.getMaxWithdrawal)(user.address, f.Collateral);\n(0, _chai.expect)(maxWithdrawAmount.gt(0)).to.be.true;\nawait (0, _chai.expect)(f.Receiver.test(f.Collateral.address, maxWithdrawAmount.add(0.5e18.toString()), await hre.updateData())).to.be.reverted;",
                      "err": {},
                      "uuid": "161fbdfc-b969-4d01-9878-9d2355d5add1",
                      "parentUUID": "3d55e1af-b780-49ff-ac43-046a1e11261a",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should revert if under MCR after redeposit",
                      "fullTitle": "CollateralReceiver - UncheckedCollateralWithdraw #unchecked-collateral-withdrawal #unchecked-withdraw-reverts should revert if under MCR after redeposit",
                      "timedOut": false,
                      "duration": 103,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const Receiver = f.Receiver;\nconst { maxWithdrawAmount } = await (0, _collaterals.getMaxWithdrawal)(user.address, f.Collateral);\n(0, _chai.expect)(maxWithdrawAmount.gt(0)).to.be.true;\nawait (0, _chai.expect)(Receiver.testInsufficientRedeposit(f.Collateral.address, maxWithdrawAmount.add(0.5e18.toString()), await hre.updateData())).to.be.reverted;",
                      "err": {},
                      "uuid": "f774e39c-a55f-47a6-8b81-f6097e8d69c2",
                      "parentUUID": "3d55e1af-b780-49ff-ac43-046a1e11261a",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "f3af2b96-b1e6-43a6-a5a5-dc0e8f5d612c",
                    "1c80380d-798c-4f1e-815e-4cd4332c31a2",
                    "161fbdfc-b969-4d01-9878-9d2355d5add1",
                    "f774e39c-a55f-47a6-8b81-f6097e8d69c2"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 308,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                }
              ],
              "passes": [],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "0ea12330-f6f3-47e4-ba07-41d0dcfca830",
          "title": "Gating",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/minter/06-gating.ts",
          "file": "/src/test/minter/06-gating.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"Gating\"",
              "fullTitle": "Gating \"before each\" hook in \"Gating\"",
              "timedOut": false,
              "duration": 128,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "f = await (0, _fixtures.defaultFixture)();\n[nft] = await hre.deploy('MockERC1155', {\n    args: [\n        'MockERC1155_1',\n        'MockERC1155_1',\n        'https://mock.com/{id}.json',\n        'https://mock.com/contract.json'\n    ],\n    deploymentName: 'MockERC1155_1',\n    from: hre.users.deployer.address\n});\n[nft2] = await hre.deploy('MockERC1155', {\n    args: [\n        'MockERC1155_2',\n        'MockERC1155_2',\n        'https://mock2.com/{id}.json',\n        'https://mock2.com/contract2.json'\n    ],\n    deploymentName: 'MockERC1155_2',\n    from: hre.users.deployer.address\n});\n[this.GatingManager] = await hre.deploy('GatingManager', {\n    args: [\n        hre.users.deployer.address,\n        nft.address,\n        nft2.address,\n        1\n    ],\n    from: hre.users.deployer.address\n});\nawait hre.Diamond.setGatingManager(this.GatingManager.address);\n// setup collateral for userOne and userTwo\nthis.initialBalance = (0, _values.toBig)(100000);\nawait f.Collateral.setBalance(hre.users.userOne, this.initialBalance, hre.Diamond.address);\nawait f.Collateral.setBalance(hre.users.userTwo, this.initialBalance, hre.Diamond.address);\nthis.depositArgsOne = {\n    user: hre.users.userOne,\n    asset: f.Collateral,\n    amount: (0, _values.toBig)(10000)\n};\nthis.depositArgsTwo = {\n    user: hre.users.userTwo,\n    asset: f.Collateral,\n    amount: (0, _values.toBig)(10000)\n};",
              "err": {},
              "uuid": "68b1bcad-afd5-4d20-9f75-85908fc05fc8",
              "parentUUID": "0ea12330-f6f3-47e4-ba07-41d0dcfca830",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [
            {
              "title": "should not allow users to access phase 1 without nfts",
              "fullTitle": "Gating should not allow users to access phase 1 without nfts",
              "timedOut": false,
              "duration": 38,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "await (0, _chai.expect)(hre.Diamond.connect(this.depositArgsOne.user).depositCollateral(this.depositArgsOne.user.address, f.Collateral.address, this.depositArgsOne.amount)).to.be.reverted;\nawait nft['mint(address,uint256,uint256)'](this.depositArgsOne.user.address, 0, 1);\nawait nft2['mint(address,uint256,uint256)'](this.depositArgsOne.user.address, 0, 1);\nawait nft2['mint(address,uint256,uint256)'](this.depositArgsOne.user.address, 1, 1);\nawait nft2['mint(address,uint256,uint256)'](this.depositArgsOne.user.address, 2, 1);\nawait (0, _chai.expect)(hre.Diamond.connect(this.depositArgsOne.user).depositCollateral(this.depositArgsOne.user.address, f.Collateral.address, this.depositArgsOne.amount)).to.be.reverted;",
              "err": {},
              "uuid": "814b1830-24f7-4b33-8b21-5995183413ae",
              "parentUUID": "0ea12330-f6f3-47e4-ba07-41d0dcfca830",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "should allow users to access in phase 1",
              "fullTitle": "Gating should allow users to access in phase 1",
              "timedOut": false,
              "duration": 38,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "await nft['mint(address,uint256,uint256)'](this.depositArgsOne.user.address, 0, 1);\nawait nft2['mint(address,uint256,uint256)'](this.depositArgsOne.user.address, 0, 1);\nawait nft2['mint(address,uint256,uint256)'](this.depositArgsOne.user.address, 1, 1);\nawait nft2['mint(address,uint256,uint256)'](this.depositArgsOne.user.address, 2, 1);\nawait nft2['mint(address,uint256,uint256)'](this.depositArgsOne.user.address, 3, 1);\nawait (0, _chai.expect)(hre.Diamond.connect(this.depositArgsOne.user).depositCollateral(this.depositArgsOne.user.address, f.Collateral.address, this.depositArgsOne.amount)).not.to.be.reverted;",
              "err": {},
              "uuid": "4e9a920b-4ce4-4cd8-9042-41cff4001c12",
              "parentUUID": "0ea12330-f6f3-47e4-ba07-41d0dcfca830",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "should not allow users to access phase 2 without nfts",
              "fullTitle": "Gating should not allow users to access phase 2 without nfts",
              "timedOut": false,
              "duration": 27,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "await this.GatingManager.setPhase(2);\nawait (0, _chai.expect)(hre.Diamond.connect(this.depositArgsOne.user).depositCollateral(this.depositArgsOne.user.address, f.Collateral.address, this.depositArgsOne.amount)).to.be.reverted;\nawait nft['mint(address,uint256,uint256)'](this.depositArgsOne.user.address, 0, 1);\nawait (0, _chai.expect)(hre.Diamond.connect(this.depositArgsOne.user).depositCollateral(this.depositArgsOne.user.address, f.Collateral.address, this.depositArgsOne.amount)).to.be.reverted;",
              "err": {},
              "uuid": "163d2a49-5ef8-4662-8a68-cc01385dd3ab",
              "parentUUID": "0ea12330-f6f3-47e4-ba07-41d0dcfca830",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "should allow users to access in phase 2",
              "fullTitle": "Gating should allow users to access in phase 2",
              "timedOut": false,
              "duration": 25,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "await this.GatingManager.setPhase(2);\nawait nft['mint(address,uint256,uint256)'](this.depositArgsOne.user.address, 0, 1);\nawait nft2['mint(address,uint256,uint256)'](this.depositArgsOne.user.address, 0, 1);\nawait (0, _chai.expect)(hre.Diamond.connect(this.depositArgsOne.user).depositCollateral(this.depositArgsOne.user.address, f.Collateral.address, this.depositArgsOne.amount)).not.to.be.reverted;",
              "err": {},
              "uuid": "df9c53af-ab3c-49be-906b-000f74e34e59",
              "parentUUID": "0ea12330-f6f3-47e4-ba07-41d0dcfca830",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "should not allow users to access phase 3 without nfts",
              "fullTitle": "Gating should not allow users to access phase 3 without nfts",
              "timedOut": false,
              "duration": 12,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "await this.GatingManager.setPhase(3);\nawait (0, _chai.expect)(hre.Diamond.connect(this.depositArgsOne.user).depositCollateral(this.depositArgsOne.user.address, f.Collateral.address, this.depositArgsOne.amount)).to.be.reverted;",
              "err": {},
              "uuid": "d6495145-36a7-4001-8b16-cf154e73c5aa",
              "parentUUID": "0ea12330-f6f3-47e4-ba07-41d0dcfca830",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "should allow users to access in phase 3",
              "fullTitle": "Gating should allow users to access in phase 3",
              "timedOut": false,
              "duration": 23,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "await this.GatingManager.setPhase(3);\nawait nft['mint(address,uint256,uint256)'](this.depositArgsOne.user.address, 0, 1);\nawait (0, _chai.expect)(hre.Diamond.connect(this.depositArgsOne.user).depositCollateral(this.depositArgsOne.user.address, f.Collateral.address, this.depositArgsOne.amount)).not.to.be.reverted;",
              "err": {},
              "uuid": "cacee908-58c5-4d00-afa5-87f8805c72b0",
              "parentUUID": "0ea12330-f6f3-47e4-ba07-41d0dcfca830",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "After all the phases anyone should be able to deposit collateral",
              "fullTitle": "Gating After all the phases anyone should be able to deposit collateral",
              "timedOut": false,
              "duration": 18,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "await this.GatingManager.setPhase(0);\n// Anyone should be able to deposit collateral\nawait (0, _chai.expect)(hre.Diamond.connect(this.depositArgsTwo.user).depositCollateral(this.depositArgsTwo.user.address, f.Collateral.address, this.depositArgsTwo.amount)).not.to.be.reverted;",
              "err": {},
              "uuid": "746dd479-7d76-45dd-901a-fdb30b91c6da",
              "parentUUID": "0ea12330-f6f3-47e4-ba07-41d0dcfca830",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "814b1830-24f7-4b33-8b21-5995183413ae",
            "4e9a920b-4ce4-4cd8-9042-41cff4001c12",
            "163d2a49-5ef8-4662-8a68-cc01385dd3ab",
            "df9c53af-ab3c-49be-906b-000f74e34e59",
            "d6495145-36a7-4001-8b16-cf154e73c5aa",
            "cacee908-58c5-4d00-afa5-87f8805c72b0",
            "746dd479-7d76-45dd-901a-fdb30b91c6da"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 181,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "30938287-e5eb-4fa3-a2f1-5a1df76b5f96",
          "title": "Oracles",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/oracle/00-oracles.ts",
          "file": "/src/test/oracle/00-oracles.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"Oracles\"",
              "fullTitle": "Oracles \"before each\" hook in \"Oracles\"",
              "timedOut": false,
              "duration": 60,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "f = await (0, _fixtures.defaultFixture)();\n[, [user]] = f.users;\nthis.deployer = await hre.ethers.getNamedSigner('deployer');\nthis.userOne = await hre.ethers.getNamedSigner('userOne');\nawait f.Collateral.setPrice(10);\nmockPyth = await hre.getContractOrFork('MockPyth');",
              "err": {},
              "uuid": "b9dad3c0-1ae7-4e50-a7dc-3dc7b2aeae90",
              "parentUUID": "30938287-e5eb-4fa3-a2f1-5a1df76b5f96",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "5193688f-0590-4f19-8381-dd287701ee14",
              "title": "Redstone",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/oracle/00-oracles.ts",
              "file": "/src/test/oracle/00-oracles.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should have correct setup",
                  "fullTitle": "Oracles Redstone should have correct setup",
                  "timedOut": false,
                  "duration": 13,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// check initial conditions\n(0, _chai.expect)(await hre.Diamond.getAccountTotalCollateralValue(user.address)).to.equal((0, _values.toBig)(10000, 8), 'collateral value should be $10');",
                  "err": {},
                  "uuid": "bcc5344d-d950-46de-a26e-1642a776553a",
                  "parentUUID": "5193688f-0590-4f19-8381-dd287701ee14",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should get primary price when price +- maxPriceDeviationPct of reference price ",
                  "fullTitle": "Oracles Redstone should get primary price when price +- maxPriceDeviationPct of reference price ",
                  "timedOut": false,
                  "duration": 84,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await f.Collateral.setOracleOrder([\n    _types.OracleType.Pyth,\n    _types.OracleType.Chainlink\n]);\n/// set chainlink price to 12\nawait f.Collateral.setPrice(12);\n/// set price to 11\nconst pythPrice = 11;\nawait mockPyth.updatePriceFeeds(await (0, _oracle.mapToUpdateData)(mockPyth, [\n    [\n        f.Collateral.pythId,\n        pythPrice\n    ]\n]));\n(0, _chai.expect)(await hre.Diamond.getAccountTotalCollateralValue(user.address)).to.equal(f.depositAmount.wadMul((0, _values.toBig)(pythPrice, 8)), 'collateral value should be $11');",
                  "err": {},
                  "uuid": "d902f74c-0537-4cef-addf-155b28ad43ec",
                  "parentUUID": "5193688f-0590-4f19-8381-dd287701ee14",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should revert if price deviates too much",
                  "fullTitle": "Oracles Redstone should revert if price deviates too much",
                  "timedOut": false,
                  "duration": 111,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "/// set chainlink price to 20\nawait f.Collateral.setPrice(20);\nconst pythPrice = 10;\nawait mockPyth.updatePriceFeeds(await (0, _oracle.mapToUpdateData)(mockPyth, [\n    [\n        f.Collateral.pythId,\n        pythPrice\n    ]\n]));\n// should revert if price deviates more than maxPriceDeviationPct\nawait (0, _chai.expect)(hre.Diamond.getAccountTotalCollateralValue(user.address)).to.be.reverted;\nawait f.Collateral.setPrice(10);",
                  "err": {},
                  "uuid": "95d23bee-923c-41c8-8f18-3c903d66d435",
                  "parentUUID": "5193688f-0590-4f19-8381-dd287701ee14",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "bcc5344d-d950-46de-a26e-1642a776553a",
                "d902f74c-0537-4cef-addf-155b28ad43ec",
                "95d23bee-923c-41c8-8f18-3c903d66d435"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 208,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "1a65bcb9-2b28-419b-a30a-7762d004091a",
          "title": "Safety Council",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/safety/00-council.ts",
          "file": "/src/test/safety/00-council.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"Safety Council\"",
              "fullTitle": "Safety Council \"before each\" hook in \"Safety Council\"",
              "timedOut": false,
              "duration": 4,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "f = await (0, _fixtures.defaultFixture)();\n// These are the 5 signers on the SafetyCouncil multisig\nconst { deployer, devOne, userOne, extOne, extTwo } = await hre.ethers.getNamedSigners();\nthis.deployer = deployer;\nthis.devOne = devOne;\nthis.userOne = userOne;\nthis.extOne = extOne;\nthis.extTwo = extTwo;",
              "err": {},
              "uuid": "e27c244e-5d8d-42cb-93e6-2f069844e33b",
              "parentUUID": "1a65bcb9-2b28-419b-a30a-7762d004091a",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "c0a9656a-38b1-40c6-9819-15d94ec0c097",
              "title": "#setSafetyStateSet",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/safety/00-council.ts",
              "file": "/src/test/safety/00-council.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "correctly sets the safety state",
                  "fullTitle": "Safety Council #setSafetyStateSet correctly sets the safety state",
                  "timedOut": false,
                  "duration": 30,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const beforeSafetyState = await hre.Diamond.safetyStateSet();\n(0, _chai.expect)(beforeSafetyState).to.equal(false);\nawait (0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'setSafetyStateSet', [\n    true\n], [\n    this.deployer,\n    this.devOne,\n    this.userOne\n]);\nconst safetyState = await hre.Diamond.safetyStateSet();\n(0, _chai.expect)(safetyState).to.equal(true);",
                  "err": {},
                  "uuid": "659bd63f-c549-406d-9326-4b0c9cb64a31",
                  "parentUUID": "c0a9656a-38b1-40c6-9819-15d94ec0c097",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "659bd63f-c549-406d-9326-4b0c9cb64a31"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 30,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            },
            {
              "uuid": "0136fcaa-bb65-4f16-b74a-ba78df18bfa6",
              "title": "#toggleAssetsPaused",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/safety/00-council.ts",
              "file": "/src/test/safety/00-council.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [],
              "suites": [
                {
                  "uuid": "118c1fdc-12ed-41ee-8a3e-943c61766921",
                  "title": "multisig signature threshold",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/safety/00-council.ts",
                  "file": "/src/test/safety/00-council.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "multisig transacts successfully with majority of signers (3/5)",
                      "fullTitle": "Safety Council #toggleAssetsPaused multisig signature threshold multisig transacts successfully with majority of signers (3/5)",
                      "timedOut": false,
                      "duration": 30,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'toggleAssetsPaused', [\n    [\n        f.Collateral.address\n    ],\n    _types.Action.DEPOSIT,\n    false,\n    0\n], [\n    this.deployer,\n    this.devOne,\n    this.userOne\n]);\nconst isPaused = await hre.Diamond.assetActionPaused(_types.Action.DEPOSIT.toString(), f.Collateral.address);\n(0, _chai.expect)(isPaused).to.equal(true);",
                      "err": {},
                      "uuid": "6103fcc5-1d51-472d-acab-5c7746691fe4",
                      "parentUUID": "118c1fdc-12ed-41ee-8a3e-943c61766921",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "multisig transacts successfully with super-majority of signers (4/5)",
                      "fullTitle": "Safety Council #toggleAssetsPaused multisig signature threshold multisig transacts successfully with super-majority of signers (4/5)",
                      "timedOut": false,
                      "duration": 29,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'toggleAssetsPaused', [\n    [\n        f.Collateral.address\n    ],\n    _types.Action.DEPOSIT,\n    false,\n    0\n], [\n    this.deployer,\n    this.devOne,\n    this.userOne,\n    this.extOne\n]);\nconst isPaused = await hre.Diamond.assetActionPaused(_types.Action.DEPOSIT.toString(), f.Collateral.address);\n(0, _chai.expect)(isPaused).to.equal(true);",
                      "err": {},
                      "uuid": "9b6276cf-a73a-467a-98fe-152f54479462",
                      "parentUUID": "118c1fdc-12ed-41ee-8a3e-943c61766921",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "multisig transacts successfully with all signers (5/5)",
                      "fullTitle": "Safety Council #toggleAssetsPaused multisig signature threshold multisig transacts successfully with all signers (5/5)",
                      "timedOut": false,
                      "duration": 32,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'toggleAssetsPaused', [\n    [\n        f.Collateral.address\n    ],\n    _types.Action.DEPOSIT,\n    false,\n    0\n], [\n    this.deployer,\n    this.devOne,\n    this.userOne,\n    this.extOne,\n    this.extTwo\n]);\nconst isPaused = await hre.Diamond.assetActionPaused(_types.Action.DEPOSIT.toString(), f.Collateral.address);\n(0, _chai.expect)(isPaused).to.equal(true);",
                      "err": {},
                      "uuid": "739f2119-5f7b-41a6-8109-33866e169d5e",
                      "parentUUID": "118c1fdc-12ed-41ee-8a3e-943c61766921",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "multisig should reject transactions signed by a minority of signers (2/5)",
                      "fullTitle": "Safety Council #toggleAssetsPaused multisig signature threshold multisig should reject transactions signed by a minority of signers (2/5)",
                      "timedOut": false,
                      "duration": 16,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, _chai.expect)((0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'toggleAssetsPaused', [\n    [\n        f.Collateral.address\n    ],\n    _types.Action.DEPOSIT,\n    false,\n    0\n], [\n    this.deployer\n])).to.be.reverted;\nconst isPaused = await hre.Diamond.assetActionPaused(_types.Action.DEPOSIT.toString(), f.Collateral.address);\n(0, _chai.expect)(isPaused).to.equal(false);",
                      "err": {},
                      "uuid": "7e42be65-1555-43c6-a5f1-4fc19fdcb2ca",
                      "parentUUID": "118c1fdc-12ed-41ee-8a3e-943c61766921",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "6103fcc5-1d51-472d-acab-5c7746691fe4",
                    "9b6276cf-a73a-467a-98fe-152f54479462",
                    "739f2119-5f7b-41a6-8109-33866e169d5e",
                    "7e42be65-1555-43c6-a5f1-4fc19fdcb2ca"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 107,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                },
                {
                  "uuid": "1c907996-077f-4d1f-8155-3c1666bbd776",
                  "title": "toggle actions only for listed assets",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/safety/00-council.ts",
                  "file": "/src/test/safety/00-council.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "can toggle actions for listed collateral assets",
                      "fullTitle": "Safety Council #toggleAssetsPaused toggle actions only for listed assets can toggle actions for listed collateral assets",
                      "timedOut": false,
                      "duration": 30,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'toggleAssetsPaused', [\n    [\n        f.Collateral.address\n    ],\n    _types.Action.DEPOSIT,\n    false,\n    0\n], [\n    this.deployer,\n    this.devOne,\n    this.userOne\n]);\nconst isPaused = await hre.Diamond.assetActionPaused(_types.Action.DEPOSIT.toString(), f.Collateral.address);\n(0, _chai.expect)(isPaused).to.equal(true);",
                      "err": {},
                      "uuid": "27806832-0845-44cd-b6d5-8e0e48fe952e",
                      "parentUUID": "1c907996-077f-4d1f-8155-3c1666bbd776",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "can toggle actions for listed krAssets",
                      "fullTitle": "Safety Council #toggleAssetsPaused toggle actions only for listed assets can toggle actions for listed krAssets",
                      "timedOut": false,
                      "duration": 28,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'toggleAssetsPaused', [\n    [\n        f.KrAsset.address\n    ],\n    _types.Action.REPAY,\n    false,\n    0\n], [\n    this.deployer,\n    this.devOne,\n    this.userOne\n]);\nconst isPaused = await hre.Diamond.assetActionPaused(_types.Action.REPAY.toString(), f.KrAsset.address);\n(0, _chai.expect)(isPaused).to.equal(true);",
                      "err": {},
                      "uuid": "cb2867f8-dcab-4ce2-aedf-b7a4c21e23ff",
                      "parentUUID": "1c907996-077f-4d1f-8155-3c1666bbd776",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "cannot toggle actions for addresses that are not listed collateral assets or krAssets",
                      "fullTitle": "Safety Council #toggleAssetsPaused toggle actions only for listed assets cannot toggle actions for addresses that are not listed collateral assets or krAssets",
                      "timedOut": false,
                      "duration": 26,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const randomAddr = hre.ethers.utils.computeAddress('0xb976778317b23a1285ec2d483eda6904d9319135b89f1d8eee9f6d2593e2665d');\nawait (0, _chai.expect)((0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'toggleAssetsPaused', [\n    [\n        randomAddr\n    ],\n    _types.Action.DEPOSIT,\n    false,\n    0\n], [\n    this.deployer,\n    this.devOne,\n    this.userOne\n])).to.be.reverted;\nconst isPaused = await hre.Diamond.assetActionPaused(_types.Action.DEPOSIT.toString(), randomAddr);\n(0, _chai.expect)(isPaused).to.equal(false);",
                      "err": {},
                      "uuid": "10957929-5c57-4777-bddb-5df0fa79187b",
                      "parentUUID": "1c907996-077f-4d1f-8155-3c1666bbd776",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "27806832-0845-44cd-b6d5-8e0e48fe952e",
                    "cb2867f8-dcab-4ce2-aedf-b7a4c21e23ff",
                    "10957929-5c57-4777-bddb-5df0fa79187b"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 84,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                },
                {
                  "uuid": "e2e59d92-1437-4f49-bbe8-be5320158496",
                  "title": "duration based pausing",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/safety/00-council.ts",
                  "file": "/src/test/safety/00-council.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "can optionally set a timeout on a given pause command",
                      "fullTitle": "Safety Council #toggleAssetsPaused duration based pausing can optionally set a timeout on a given pause command",
                      "timedOut": false,
                      "duration": 28,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const duration = 100000000;\nawait (0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'toggleAssetsPaused', [\n    [\n        f.Collateral.address\n    ],\n    _types.Action.DEPOSIT,\n    true,\n    duration\n], [\n    this.deployer,\n    this.devOne,\n    this.userOne\n]);\nconst depositSafetyState = await hre.Diamond.safetyStateFor(f.Collateral.address, _types.Action.DEPOSIT);\n(0, _chai.expect)(depositSafetyState.length).to.equal(1);\n// Blocktime timestamp + duration should be equal to final timestamp\n(0, _chai.expect)(depositSafetyState[0].timestamp0.add(duration)).eq(depositSafetyState[0].timestamp1);",
                      "err": {},
                      "uuid": "f4410f18-9026-429c-b306-cac87d0b9f89",
                      "parentUUID": "e2e59d92-1437-4f49-bbe8-be5320158496",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "duration based pause functionality should expire after the duration has passed",
                      "fullTitle": "Safety Council #toggleAssetsPaused duration based pausing duration based pause functionality should expire after the duration has passed",
                      "timedOut": false,
                      "duration": 0,
                      "state": "pending",
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": true,
                      "context": null,
                      "code": "",
                      "err": {},
                      "uuid": "6f3e2e1b-fe62-409f-a631-f26aa7bd38f0",
                      "parentUUID": "e2e59d92-1437-4f49-bbe8-be5320158496",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "f4410f18-9026-429c-b306-cac87d0b9f89"
                  ],
                  "failures": [],
                  "pending": [
                    "6f3e2e1b-fe62-409f-a631-f26aa7bd38f0"
                  ],
                  "skipped": [],
                  "duration": 28,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                },
                {
                  "uuid": "ff40232b-af1b-471b-9a73-6e67edfcbcbf",
                  "title": "toggle all possible actions: DEPOSIT, WITHDRAW, REPAY, BORROW, LIQUIDATION",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/safety/00-council.ts",
                  "file": "/src/test/safety/00-council.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "can toggle action DEPOSIT pause status on and off",
                      "fullTitle": "Safety Council #toggleAssetsPaused toggle all possible actions: DEPOSIT, WITHDRAW, REPAY, BORROW, LIQUIDATION can toggle action DEPOSIT pause status on and off",
                      "timedOut": false,
                      "duration": 55,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'toggleAssetsPaused', [\n    [\n        f.Collateral.address\n    ],\n    _types.Action.DEPOSIT,\n    false,\n    0\n], [\n    this.deployer,\n    this.devOne,\n    this.extOne\n]);\nlet isPaused = await hre.Diamond.assetActionPaused(_types.Action.DEPOSIT.toString(), f.Collateral.address);\n(0, _chai.expect)(isPaused).to.equal(true);\nawait (0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'toggleAssetsPaused', [\n    [\n        f.Collateral.address\n    ],\n    _types.Action.DEPOSIT,\n    false,\n    0\n], [\n    this.deployer,\n    this.devOne,\n    this.extOne\n]);\nisPaused = await hre.Diamond.assetActionPaused(_types.Action.DEPOSIT.toString(), f.Collateral.address);\n(0, _chai.expect)(isPaused).to.equal(false);",
                      "err": {},
                      "uuid": "4918ad8d-74a0-4001-bc8d-34a057056cb1",
                      "parentUUID": "ff40232b-af1b-471b-9a73-6e67edfcbcbf",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "can toggle action WITHDRAW pause status on and off",
                      "fullTitle": "Safety Council #toggleAssetsPaused toggle all possible actions: DEPOSIT, WITHDRAW, REPAY, BORROW, LIQUIDATION can toggle action WITHDRAW pause status on and off",
                      "timedOut": false,
                      "duration": 57,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'toggleAssetsPaused', [\n    [\n        f.Collateral.address\n    ],\n    _types.Action.WITHDRAW,\n    false,\n    0\n], [\n    this.deployer,\n    this.devOne,\n    this.extOne\n]);\nlet isPaused = await hre.Diamond.assetActionPaused(_types.Action.WITHDRAW.toString(), f.Collateral.address);\n(0, _chai.expect)(isPaused).to.equal(true);\nawait (0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'toggleAssetsPaused', [\n    [\n        f.Collateral.address\n    ],\n    _types.Action.WITHDRAW,\n    false,\n    0\n], [\n    this.deployer,\n    this.devOne,\n    this.extOne\n]);\nisPaused = await hre.Diamond.assetActionPaused(_types.Action.WITHDRAW.toString(), f.Collateral.address);\n(0, _chai.expect)(isPaused).to.equal(false);",
                      "err": {},
                      "uuid": "14533a8d-f454-4965-8cd0-50c9ac5a09ce",
                      "parentUUID": "ff40232b-af1b-471b-9a73-6e67edfcbcbf",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "can toggle action REPAY pause status on and off",
                      "fullTitle": "Safety Council #toggleAssetsPaused toggle all possible actions: DEPOSIT, WITHDRAW, REPAY, BORROW, LIQUIDATION can toggle action REPAY pause status on and off",
                      "timedOut": false,
                      "duration": 57,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'toggleAssetsPaused', [\n    [\n        f.Collateral.address\n    ],\n    _types.Action.REPAY,\n    false,\n    0\n], [\n    this.deployer,\n    this.devOne,\n    this.extOne\n]);\nlet isPaused = await hre.Diamond.assetActionPaused(_types.Action.REPAY.toString(), f.Collateral.address);\n(0, _chai.expect)(isPaused).to.equal(true);\nawait (0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'toggleAssetsPaused', [\n    [\n        f.Collateral.address\n    ],\n    _types.Action.REPAY,\n    false,\n    0\n], [\n    this.deployer,\n    this.devOne,\n    this.extOne\n]);\nisPaused = await hre.Diamond.assetActionPaused(_types.Action.REPAY.toString(), f.Collateral.address);\n(0, _chai.expect)(isPaused).to.equal(false);",
                      "err": {},
                      "uuid": "341ecf58-a40f-4cea-b180-bf110967f0dc",
                      "parentUUID": "ff40232b-af1b-471b-9a73-6e67edfcbcbf",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "can toggle action BORROW pause status on and off",
                      "fullTitle": "Safety Council #toggleAssetsPaused toggle all possible actions: DEPOSIT, WITHDRAW, REPAY, BORROW, LIQUIDATION can toggle action BORROW pause status on and off",
                      "timedOut": false,
                      "duration": 59,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'toggleAssetsPaused', [\n    [\n        f.Collateral.address\n    ],\n    _types.Action.BORROW,\n    false,\n    0\n], [\n    this.deployer,\n    this.devOne,\n    this.extOne\n]);\nlet isPaused = await hre.Diamond.assetActionPaused(_types.Action.BORROW.toString(), f.Collateral.address);\n(0, _chai.expect)(isPaused).to.equal(true);\nawait (0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'toggleAssetsPaused', [\n    [\n        f.Collateral.address\n    ],\n    _types.Action.BORROW,\n    false,\n    0\n], [\n    this.deployer,\n    this.devOne,\n    this.extOne\n]);\nisPaused = await hre.Diamond.assetActionPaused(_types.Action.BORROW.toString(), f.Collateral.address);\n(0, _chai.expect)(isPaused).to.equal(false);",
                      "err": {},
                      "uuid": "55ea2163-1364-4c13-8b59-16a670e8331f",
                      "parentUUID": "ff40232b-af1b-471b-9a73-6e67edfcbcbf",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "can toggle action LIQUIDATION pause status on and off",
                      "fullTitle": "Safety Council #toggleAssetsPaused toggle all possible actions: DEPOSIT, WITHDRAW, REPAY, BORROW, LIQUIDATION can toggle action LIQUIDATION pause status on and off",
                      "timedOut": false,
                      "duration": 61,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'toggleAssetsPaused', [\n    [\n        f.Collateral.address\n    ],\n    _types.Action.LIQUIDATION,\n    false,\n    0\n], [\n    this.deployer,\n    this.devOne,\n    this.extOne\n]);\nlet isPaused = await hre.Diamond.assetActionPaused(_types.Action.LIQUIDATION.toString(), f.Collateral.address);\n(0, _chai.expect)(isPaused).to.equal(true);\nawait (0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'toggleAssetsPaused', [\n    [\n        f.Collateral.address\n    ],\n    _types.Action.LIQUIDATION,\n    false,\n    0\n], [\n    this.deployer,\n    this.devOne,\n    this.extOne\n]);\nisPaused = await hre.Diamond.assetActionPaused(_types.Action.LIQUIDATION.toString(), f.Collateral.address);\n(0, _chai.expect)(isPaused).to.equal(false);",
                      "err": {},
                      "uuid": "ddc53531-5b02-4f85-b619-651f1772d721",
                      "parentUUID": "ff40232b-af1b-471b-9a73-6e67edfcbcbf",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "4918ad8d-74a0-4001-bc8d-34a057056cb1",
                    "14533a8d-f454-4965-8cd0-50c9ac5a09ce",
                    "341ecf58-a40f-4cea-b180-bf110967f0dc",
                    "55ea2163-1364-4c13-8b59-16a670e8331f",
                    "ddc53531-5b02-4f85-b619-651f1772d721"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 289,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                },
                {
                  "uuid": "d14a2ca6-077d-4db2-96f8-a0e03cbcad04",
                  "title": "event emission",
                  "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/safety/00-council.ts",
                  "file": "/src/test/safety/00-council.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should emit event MinterEvent.SafetyStateChange on action changed containing action, asset, and description",
                      "fullTitle": "Safety Council #toggleAssetsPaused event emission should emit event MinterEvent.SafetyStateChange on action changed containing action, asset, and description",
                      "timedOut": false,
                      "duration": 25,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const tx = await (0, _execution.executeContractCallWithSigners)(hre.Multisig, hre.Diamond, 'toggleAssetsPaused', [\n    [\n        f.Collateral.address\n    ],\n    _types.Action.DEPOSIT,\n    false,\n    0\n], [\n    this.deployer,\n    this.devOne,\n    this.extOne\n]);\nconst event = await (0, _events.getInternalEvent)(tx, hre.Diamond, 'SafetyStateChange');\n(0, _chai.expect)(event.action).to.equal(_types.Action.DEPOSIT);\n(0, _chai.expect)(event.asset).to.equal(f.Collateral.address);\n(0, _chai.expect)(event.description).to.equal('paused');",
                      "err": {},
                      "uuid": "a2e6388a-10e1-4f53-95cb-43f331ab59f6",
                      "parentUUID": "d14a2ca6-077d-4db2-96f8-a0e03cbcad04",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "a2e6388a-10e1-4f53-95cb-43f331ab59f6"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 25,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 30000
                }
              ],
              "passes": [],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        },
        {
          "uuid": "6e138a26-27b3-485a-9655-63d72ae013ad",
          "title": "SCDP",
          "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/scdp/00-scdp.ts",
          "file": "/src/test/scdp/00-scdp.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"SCDP\"",
              "fullTitle": "SCDP \"before each\" hook in \"SCDP\"",
              "timedOut": false,
              "duration": 233,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "f = await (0, _fixtures.scdpFixture)();\nawait f.reset();",
              "err": {},
              "uuid": "db2709ac-2da1-4d17-b1b4-8da1b439d709",
              "parentUUID": "6e138a26-27b3-485a-9655-63d72ae013ad",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "d46f586e-3070-43b0-bb72-e8178c08998f",
              "title": "#Configuration",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/scdp/00-scdp.ts",
              "file": "/src/test/scdp/00-scdp.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should be initialized correctly",
                  "fullTitle": "SCDP #Configuration should be initialized correctly",
                  "timedOut": false,
                  "duration": 28,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const { args } = await (0, _deploy.getSCDPInitializer)(hre);\nconst configuration = await hre.Diamond.getParametersSCDP();\n(0, _chai.expect)(configuration.liquidationThreshold).to.equal(args.liquidationThreshold);\n(0, _chai.expect)(configuration.minCollateralRatio).to.equal(args.minCollateralRatio);\n(0, _chai.expect)(configuration.maxLiquidationRatio).to.equal(Number(args.liquidationThreshold) + 0.01e4);\nconst collaterals = await hre.Diamond.getCollateralsSCDP();\n(0, _chai.expect)(collaterals).to.include.members([\n    f.Collateral.address,\n    f.Collateral8Dec.address,\n    f.KrAsset.address,\n    f.KrAsset2.address,\n    f.KISS.address\n]);\nconst krAssets = await hre.Diamond.getKreskoAssetsSCDP();\n(0, _chai.expect)(krAssets).to.include.members([\n    f.KrAsset.address,\n    f.KrAsset2.address,\n    f.KISS.address\n]);\nconst depositsEnabled = await Promise.all([\n    hre.Diamond.getDepositEnabledSCDP(f.Collateral.address),\n    hre.Diamond.getDepositEnabledSCDP(f.Collateral8Dec.address),\n    hre.Diamond.getDepositEnabledSCDP(f.KrAsset.address),\n    hre.Diamond.getDepositEnabledSCDP(f.KrAsset2.address),\n    hre.Diamond.getDepositEnabledSCDP(f.KISS.address)\n]);\n(0, _chai.expect)(depositsEnabled).to.deep.equal([\n    true,\n    true,\n    false,\n    false,\n    true\n]);\nconst depositAssets = await hre.Diamond.viewSCDPDepositAssets();\n(0, _chai.expect)(depositAssets).to.include.members([\n    f.Collateral.address,\n    f.Collateral8Dec.address,\n    f.KISS.address\n]);",
                  "err": {},
                  "uuid": "400254dc-1291-47ac-b11d-810babbe068e",
                  "parentUUID": "d46f586e-3070-43b0-bb72-e8178c08998f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should be able to whitelist new deposit asset",
                  "fullTitle": "SCDP #Configuration should be able to whitelist new deposit asset",
                  "timedOut": false,
                  "duration": 56,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const assetInfoBefore = await hre.Diamond.getAsset(f.KrAsset2.address);\n(0, _chai.expect)(assetInfoBefore.isSharedCollateral).to.equal(false);\nawait hre.Diamond.updateAsset(f.KrAsset2.address, {\n    ...assetInfoBefore,\n    isSharedCollateral: true,\n    depositLimitSCDP: 1\n});\nconst assetInfoAfter = await hre.Diamond.getAsset(f.KrAsset2.address);\n(0, _chai.expect)(assetInfoAfter.decimals).to.equal(await f.KrAsset2.contract.decimals());\n(0, _chai.expect)(assetInfoAfter.depositLimitSCDP).to.equal(1);\nconst indicesAfter = await hre.Diamond.getAssetIndexesSCDP(f.KrAsset2.address);\n(0, _chai.expect)(indicesAfter.currLiqIndex).to.equal(_values.RAY);\n(0, _chai.expect)(indicesAfter.currFeeIndex).to.equal(_values.RAY);\n(0, _chai.expect)(await hre.Diamond.getDepositEnabledSCDP(f.KrAsset2.address)).to.equal(true);",
                  "err": {},
                  "uuid": "29a69838-10fc-4789-8e33-526b3461367a",
                  "parentUUID": "d46f586e-3070-43b0-bb72-e8178c08998f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should be able to update deposit limit of asset",
                  "fullTitle": "SCDP #Configuration should be able to update deposit limit of asset",
                  "timedOut": false,
                  "duration": 16,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await hre.Diamond.setDepositLimitSCDP(f.Collateral.address, 1);\nconst collateral = await hre.Diamond.getAsset(f.Collateral.address);\n(0, _chai.expect)(collateral.decimals).to.equal(await f.Collateral.contract.decimals());\n(0, _chai.expect)(collateral.depositLimitSCDP).to.equal(1);\nconst indicesAfter = await hre.Diamond.getAssetIndexesSCDP(f.Collateral.address);\n(0, _chai.expect)(indicesAfter.currLiqIndex).to.equal(_values.RAY);\n(0, _chai.expect)(indicesAfter.currFeeIndex).to.equal(_values.RAY);",
                  "err": {},
                  "uuid": "6f8e3215-21dd-4099-8ad9-1bc7d2fe48e0",
                  "parentUUID": "d46f586e-3070-43b0-bb72-e8178c08998f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should be able to disable a deposit asset",
                  "fullTitle": "SCDP #Configuration should be able to disable a deposit asset",
                  "timedOut": false,
                  "duration": 17,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await hre.Diamond.setAssetIsSharedCollateralSCDP(f.Collateral.address, false);\nconst collaterals = await hre.Diamond.getCollateralsSCDP();\n(0, _chai.expect)(collaterals).to.include(f.Collateral.address);\nconst depositAssets = await hre.Diamond.viewSCDPDepositAssets();\n(0, _chai.expect)(depositAssets).to.not.include(f.Collateral.address);\n(0, _chai.expect)(await hre.Diamond.getDepositEnabledSCDP(f.Collateral.address)).to.equal(false);",
                  "err": {},
                  "uuid": "05956bea-1929-42bc-b180-866cf1d630ea",
                  "parentUUID": "d46f586e-3070-43b0-bb72-e8178c08998f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should be able to disable and enable a collateral asset",
                  "fullTitle": "SCDP #Configuration should be able to disable and enable a collateral asset",
                  "timedOut": false,
                  "duration": 56,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await hre.Diamond.setAssetIsSharedOrSwappedCollateralSCDP(f.Collateral.address, false);\n(0, _chai.expect)(await hre.Diamond.getCollateralsSCDP()).to.not.include(f.Collateral.address);\n(0, _chai.expect)(await hre.Diamond.viewSCDPDepositAssets()).to.not.include(f.Collateral.address);\n(0, _chai.expect)(await hre.Diamond.getDepositEnabledSCDP(f.Collateral.address)).to.equal(true);\nawait hre.Diamond.setAssetIsSharedCollateralSCDP(f.Collateral.address, false);\n(0, _chai.expect)(await hre.Diamond.getDepositEnabledSCDP(f.Collateral.address)).to.equal(false);\nawait hre.Diamond.setAssetIsSharedOrSwappedCollateralSCDP(f.Collateral.address, true);\n(0, _chai.expect)(await hre.Diamond.getCollateralsSCDP()).to.include(f.Collateral.address);\n(0, _chai.expect)(await hre.Diamond.viewSCDPDepositAssets()).to.not.include(f.Collateral.address);\n(0, _chai.expect)(await hre.Diamond.getDepositEnabledSCDP(f.Collateral.address)).to.equal(false);\nawait hre.Diamond.setAssetIsSharedCollateralSCDP(f.Collateral.address, true);\n(0, _chai.expect)(await hre.Diamond.getDepositEnabledSCDP(f.Collateral.address)).to.equal(true);\n(0, _chai.expect)(await hre.Diamond.viewSCDPDepositAssets()).to.include(f.Collateral.address);",
                  "err": {},
                  "uuid": "e9f4d8b9-b6ee-47da-9a25-8f1253ccf186",
                  "parentUUID": "d46f586e-3070-43b0-bb72-e8178c08998f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should be able to add whitelisted kresko asset",
                  "fullTitle": "SCDP #Configuration should be able to add whitelisted kresko asset",
                  "timedOut": false,
                  "duration": 8,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const assetInfo = await hre.Diamond.getAsset(f.KrAsset.address);\n(0, _chai.expect)(assetInfo.swapInFeeSCDP).to.equal(f.swapKrAssetConfig.swapInFeeSCDP);\n(0, _chai.expect)(assetInfo.swapOutFeeSCDP).to.equal(f.swapKrAssetConfig.swapOutFeeSCDP);\n(0, _chai.expect)(assetInfo.liqIncentiveSCDP).to.equal(f.swapKrAssetConfig.liqIncentiveSCDP);\n(0, _chai.expect)(assetInfo.protocolFeeShareSCDP).to.equal(f.swapKrAssetConfig.protocolFeeShareSCDP);",
                  "err": {},
                  "uuid": "1dd859b9-aa35-45fd-b260-d9494a8c4cbd",
                  "parentUUID": "d46f586e-3070-43b0-bb72-e8178c08998f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should be able to update a whitelisted kresko asset",
                  "fullTitle": "SCDP #Configuration should be able to update a whitelisted kresko asset",
                  "timedOut": false,
                  "duration": 50,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const update = {\n    ...f.KrAsset.config.assetStruct,\n    swapInFeeSCDP: 0.05e4,\n    swapOutFeeSCDP: 0.05e4,\n    liqIncentiveSCDP: 1.06e4,\n    protocolFeeShareSCDP: 0.4e4\n};\nawait hre.Diamond.updateAsset(f.KrAsset.address, update);\nconst assetInfo = await hre.Diamond.getAsset(f.KrAsset.address);\n(0, _chai.expect)(assetInfo.swapInFeeSCDP).to.equal(update.swapInFeeSCDP);\n(0, _chai.expect)(assetInfo.swapOutFeeSCDP).to.equal(update.swapOutFeeSCDP);\n(0, _chai.expect)(assetInfo.protocolFeeShareSCDP).to.equal(update.protocolFeeShareSCDP);\n(0, _chai.expect)(assetInfo.liqIncentiveSCDP).to.equal(update.liqIncentiveSCDP);\nconst krAssets = await hre.Diamond.getKreskoAssetsSCDP();\n(0, _chai.expect)(krAssets).to.include(f.KrAsset.address);\nconst collaterals = await hre.Diamond.getCollateralsSCDP();\n(0, _chai.expect)(collaterals).to.include(f.KrAsset.address);\n(0, _chai.expect)(await hre.Diamond.getDepositEnabledSCDP(f.KrAsset.address)).to.equal(false);",
                  "err": {},
                  "uuid": "7cb7c2a5-9de2-4496-8219-380fc78a4dfe",
                  "parentUUID": "d46f586e-3070-43b0-bb72-e8178c08998f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should be able to remove a whitelisted kresko asset",
                  "fullTitle": "SCDP #Configuration should be able to remove a whitelisted kresko asset",
                  "timedOut": false,
                  "duration": 14,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await hre.Diamond.setAssetIsSwapMintableSCDP(f.KrAsset.address, false);\nconst krAssets = await hre.Diamond.getKreskoAssetsSCDP();\n(0, _chai.expect)(krAssets).to.not.include(f.KrAsset.address);\n(0, _chai.expect)(await hre.Diamond.getDepositEnabledSCDP(f.KrAsset.address)).to.equal(false);",
                  "err": {},
                  "uuid": "6b9880d4-f360-4eb6-bb83-695b3ab8b4a9",
                  "parentUUID": "d46f586e-3070-43b0-bb72-e8178c08998f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should be able to enable and disable swap pairs",
                  "fullTitle": "SCDP #Configuration should be able to enable and disable swap pairs",
                  "timedOut": false,
                  "duration": 25,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const swapPairsEnabled = [\n    {\n        assetIn: f.Collateral.address,\n        assetOut: f.KrAsset.address,\n        enabled: true\n    }\n];\nawait hre.Diamond.setSwapRoutesSCDP(swapPairsEnabled);\n(0, _chai.expect)(await hre.Diamond.getSwapEnabledSCDP(f.Collateral.address, f.KrAsset.address)).to.equal(true);\n(0, _chai.expect)(await hre.Diamond.getSwapEnabledSCDP(f.KrAsset.address, f.Collateral.address)).to.equal(true);\nconst swapPairsDisabled = [\n    {\n        assetIn: f.Collateral.address,\n        assetOut: f.KrAsset.address,\n        enabled: false\n    }\n];\nawait hre.Diamond.setSwapRoutesSCDP(swapPairsDisabled);\n(0, _chai.expect)(await hre.Diamond.getSwapEnabledSCDP(f.Collateral.address, f.KrAsset.address)).to.equal(false);\n(0, _chai.expect)(await hre.Diamond.getSwapEnabledSCDP(f.KrAsset.address, f.Collateral.address)).to.equal(false);",
                  "err": {},
                  "uuid": "becce7b3-a1ff-441a-89d1-0ef7fbdbb8c6",
                  "parentUUID": "d46f586e-3070-43b0-bb72-e8178c08998f",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "400254dc-1291-47ac-b11d-810babbe068e",
                "29a69838-10fc-4789-8e33-526b3461367a",
                "6f8e3215-21dd-4099-8ad9-1bc7d2fe48e0",
                "05956bea-1929-42bc-b180-866cf1d630ea",
                "e9f4d8b9-b6ee-47da-9a25-8f1253ccf186",
                "1dd859b9-aa35-45fd-b260-d9494a8c4cbd",
                "7cb7c2a5-9de2-4496-8219-380fc78a4dfe",
                "6b9880d4-f360-4eb6-bb83-695b3ab8b4a9",
                "becce7b3-a1ff-441a-89d1-0ef7fbdbb8c6"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 270,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            },
            {
              "uuid": "b32ed566-9bd3-473f-9357-ddd64b51521e",
              "title": "#Deposit",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/scdp/00-scdp.ts",
              "file": "/src/test/scdp/00-scdp.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should be able to deposit collateral, calculate correct deposit values",
                  "fullTitle": "SCDP #Deposit should be able to deposit collateral, calculate correct deposit values",
                  "timedOut": false,
                  "duration": 496,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const expectedValueUnadjusted = (0, _values.toBig)(f.CollateralPrice.num(8) * depositAmount, 8);\nconst expectedValueAdjusted = (f.CollateralPrice.num(8) * depositAmount).ebn(8) // cfactor = 1\n;\nawait hre.Diamond.setFeeAssetSCDP(f.Collateral.address);\nawait Promise.all(f.usersArr.map((user)=>{\n    return hre.Diamond.connect(user).depositSCDP(user.address, f.Collateral.address, depositAmount18Dec);\n}));\nconst prices = hre.viewData();\nconst [userInfos, { scdp }, [assetInfo]] = await Promise.all([\n    hre.Diamond.viewSCDPAccounts(prices, f.usersArr.map((user)=>user.address), [\n        f.Collateral.address\n    ]),\n    hre.Diamond.viewProtocolData(prices),\n    hre.Diamond.viewSCDPAssets(prices, [\n        f.Collateral.address\n    ])\n]);\nfor (const userInfo of userInfos){\n    const balance = await f.Collateral.balanceOf(userInfo.addr);\n    (0, _chai.expect)(balance).to.equal(0);\n    (0, _chai.expect)(userInfo.deposits[0].amountFees).to.equal(0);\n    (0, _chai.expect)(userInfo.deposits[0].amount).to.equal(depositAmount18Dec);\n    (0, _chai.expect)(userInfo.totals.valColl).to.equal(expectedValueUnadjusted);\n    (0, _chai.expect)(userInfo.totals.valFees).to.equal(0);\n    (0, _chai.expect)(userInfo.deposits[0].val).to.equal(expectedValueUnadjusted);\n    (0, _chai.expect)(userInfo.deposits[0].valFees).to.equal(0);\n}\n(0, _chai.expect)(await f.Collateral.balanceOf(hre.Diamond.address)).to.equal(depositAmount18Dec.mul(f.usersArr.length));\n(0, _chai.expect)(assetInfo.amountColl).to.equal(depositAmount18Dec.mul(f.usersArr.length));\n(0, _chai.expect)(assetInfo.valColl).to.equal(expectedValueUnadjusted.mul(f.usersArr.length));\n(0, _chai.expect)(scdp.totals.valColl).to.equal(expectedValueUnadjusted.mul(f.usersArr.length));\n(0, _chai.expect)(scdp.totals.valDebt).to.equal(0);\n// Adjusted\n(0, _chai.expect)(assetInfo.valCollAdj).to.equal(expectedValueAdjusted.mul(f.usersArr.length));\n(0, _chai.expect)(scdp.totals.valCollAdj).to.equal(expectedValueUnadjusted.mul(f.usersArr.length));\n(0, _chai.expect)(scdp.totals.valDebtOgAdj).to.equal(0);\n(0, _chai.expect)(scdp.totals.valDebt).to.equal(0);\n(0, _chai.expect)(scdp.totals.crOgAdj).to.equal(_viem.maxUint256);\n(0, _chai.expect)(scdp.totals.crOg).to.equal(_viem.maxUint256);\n(0, _chai.expect)(scdp.totals.cr).to.equal(_viem.maxUint256);",
                  "err": {},
                  "uuid": "a565f10f-f945-4a15-b453-c3b83826d40a",
                  "parentUUID": "b32ed566-9bd3-473f-9357-ddd64b51521e",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should be able to deposit multiple collaterals, calculate correct deposit values",
                  "fullTitle": "SCDP #Deposit should be able to deposit multiple collaterals, calculate correct deposit values",
                  "timedOut": false,
                  "duration": 534,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const expectedValueUnadjusted = (0, _values.toBig)(f.CollateralPrice.num(8) * depositAmount, 8);\nconst expectedValueAdjusted = (0, _values.toBig)(f.CollateralPrice.num(8) / 1 * depositAmount, 8) // cfactor = 1\n;\nconst expectedValueUnadjusted8Dec = (0, _values.toBig)(f.CollateralPrice.num(8) * depositAmount, 8);\nconst expectedValueAdjusted8Dec = (0, _values.toBig)(f.CollateralPrice.num(8) * 0.8 * depositAmount, 8) // cfactor = 0.8\n;\nawait Promise.all(f.usersArr.map(async (user)=>{\n    const User = hre.Diamond.connect(user);\n    await hre.Diamond.setFeeAssetSCDP(f.Collateral.address);\n    await User.depositSCDP(user.address, f.Collateral.address, depositAmount18Dec);\n    await hre.Diamond.setFeeAssetSCDP(f.Collateral8Dec.address);\n    await User.depositSCDP(user.address, f.Collateral8Dec.address, depositAmount8Dec);\n}));\nconst prices = hre.viewData();\nconst [userInfos, assetInfos, { scdp }] = await Promise.all([\n    hre.Diamond.viewSCDPAccounts(prices, f.usersArr.map((u)=>u.address), [\n        f.Collateral.address,\n        f.Collateral8Dec.address\n    ]),\n    hre.Diamond.viewSCDPAssets(prices, [\n        f.Collateral.address,\n        f.Collateral8Dec.address\n    ]),\n    hre.Diamond.viewProtocolData(prices)\n]);\nfor (const userInfo of userInfos){\n    (0, _chai.expect)(userInfo.deposits[0].amount).to.equal(depositAmount18Dec);\n    (0, _chai.expect)(userInfo.deposits[0].val).to.equal(expectedValueUnadjusted);\n    (0, _chai.expect)(userInfo.deposits[1].amount).to.equal(depositAmount8Dec);\n    (0, _chai.expect)(userInfo.deposits[1].val).to.equal(expectedValueUnadjusted8Dec);\n    (0, _chai.expect)(userInfo.totals.valColl).to.equal(expectedValueUnadjusted.add(expectedValueUnadjusted8Dec));\n}\n(0, _chai.expect)(assetInfos[0].amountColl).to.equal(depositAmount18Dec.mul(f.usersArr.length));\n(0, _chai.expect)(assetInfos[1].amountColl).to.equal(depositAmount8Dec.mul(f.usersArr.length));\n// WITH_FACTORS global\nconst valueTotalAdjusted = expectedValueAdjusted.mul(f.usersArr.length);\nconst valueTotalAdjusted8Dec = expectedValueAdjusted8Dec.mul(f.usersArr.length);\nconst valueAdjusted = valueTotalAdjusted.add(valueTotalAdjusted8Dec);\n(0, _chai.expect)(assetInfos[0].valColl).to.equal(valueTotalAdjusted);\n(0, _chai.expect)(assetInfos[1].valCollAdj).to.equal(valueTotalAdjusted8Dec);\n(0, _chai.expect)(scdp.totals.valCollAdj).to.equal(valueAdjusted);\n(0, _chai.expect)(scdp.totals.valDebt).to.equal(0);\n(0, _chai.expect)(scdp.totals.cr).to.equal(_viem.maxUint256);\n// WITHOUT_FACTORS global\nconst valueTotalUnadjusted = expectedValueUnadjusted.mul(f.usersArr.length);\nconst valueTotalUnadjusted8Dec = expectedValueUnadjusted8Dec.mul(f.usersArr.length);\nconst valueUnadjusted = valueTotalUnadjusted.add(valueTotalUnadjusted8Dec);\n(0, _chai.expect)(assetInfos[0].valColl).to.equal(valueTotalUnadjusted);\n(0, _chai.expect)(assetInfos[1].valColl).to.equal(valueTotalUnadjusted8Dec);\n(0, _chai.expect)(scdp.totals.valColl).to.equal(valueUnadjusted);\n(0, _chai.expect)(scdp.totals.valDebt).to.equal(0);\n(0, _chai.expect)(scdp.totals.cr).to.equal(_viem.maxUint256);",
                  "err": {},
                  "uuid": "3b14d727-c377-4a56-906c-afb99aa2eb2f",
                  "parentUUID": "b32ed566-9bd3-473f-9357-ddd64b51521e",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "a565f10f-f945-4a15-b453-c3b83826d40a",
                "3b14d727-c377-4a56-906c-afb99aa2eb2f"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 1030,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            },
            {
              "uuid": "b3bf7447-7637-4e08-b40e-13ecd3db9d4b",
              "title": "#Withdraw",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/scdp/00-scdp.ts",
              "file": "/src/test/scdp/00-scdp.ts",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"#Withdraw\"",
                  "fullTitle": "SCDP #Withdraw \"before each\" hook in \"#Withdraw\"",
                  "timedOut": false,
                  "duration": 92,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await Promise.all(f.usersArr.map(async (user)=>{\n    const UserKresko = hre.Diamond.connect(user);\n    await hre.Diamond.setFeeAssetSCDP(f.Collateral.address);\n    await UserKresko.depositSCDP(user.address, f.Collateral.address, depositAmount18Dec);\n    await hre.Diamond.setFeeAssetSCDP(f.Collateral8Dec.address);\n    await UserKresko.depositSCDP(user.address, f.Collateral8Dec.address, depositAmount8Dec);\n}));",
                  "err": {},
                  "uuid": "6cc421b0-abdb-4a49-a68c-64f4448b281d",
                  "parentUUID": "b3bf7447-7637-4e08-b40e-13ecd3db9d4b",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should be able to withdraw full collateral of multiple assets",
                  "fullTitle": "SCDP #Withdraw should be able to withdraw full collateral of multiple assets",
                  "timedOut": false,
                  "duration": 825,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await Promise.all(f.usersArr.map(async (user)=>{\n    const UserKresko = hre.Diamond.connect(user);\n    return Promise.all([\n        UserKresko.withdrawSCDP({\n            account: user.address,\n            asset: f.Collateral.address,\n            amount: depositAmount18Dec,\n            receiver: user.address\n        }, await hre.updateData()),\n        UserKresko.withdrawSCDP({\n            account: user.address,\n            asset: f.Collateral8Dec.address,\n            amount: depositAmount8Dec,\n            receiver: user.address\n        }, await hre.updateData())\n    ]);\n}));\n(0, _chai.expect)(await f.Collateral.balanceOf(hre.Diamond.address)).to.equal(0);\nconst prices = hre.viewData();\nconst [userInfos, assetInfos, { scdp }] = await Promise.all([\n    hre.Diamond.viewSCDPAccounts(prices, f.usersArr.map((u)=>u.address), [\n        f.Collateral.address,\n        f.Collateral8Dec.address\n    ]),\n    hre.Diamond.viewSCDPAssets(prices, [\n        f.Collateral.address,\n        f.Collateral8Dec.address\n    ]),\n    hre.Diamond.viewProtocolData(prices)\n]);\nfor (const userInfo of userInfos){\n    (0, _chai.expect)(await f.Collateral.balanceOf(userInfo.addr)).to.equal(depositAmount18Dec);\n    (0, _chai.expect)(userInfo.deposits[0].amount).to.equal(0);\n    (0, _chai.expect)(userInfo.deposits[0].amountFees).to.equal(0);\n    (0, _chai.expect)(userInfo.deposits[1].amount).to.equal(0);\n    (0, _chai.expect)(userInfo.deposits[1].amountFees).to.equal(0);\n    (0, _chai.expect)(userInfo.totals.valColl).to.equal(0);\n}\nfor (const assetInfo of assetInfos){\n    (0, _chai.expect)(assetInfo.valColl).to.equal(0);\n    (0, _chai.expect)(assetInfo.amountColl).to.equal(0);\n    (0, _chai.expect)(assetInfo.amountSwapDeposit).to.equal(0);\n}\n(0, _chai.expect)(scdp.totals.valColl).to.equal(0);\n(0, _chai.expect)(scdp.totals.valDebt).to.equal(0);\n(0, _chai.expect)(scdp.totals.cr).to.equal(0);",
                  "err": {},
                  "uuid": "c864031c-cb17-439c-9000-677324e169ba",
                  "parentUUID": "b3bf7447-7637-4e08-b40e-13ecd3db9d4b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should be able to withdraw partial collateral of multiple assets",
                  "fullTitle": "SCDP #Withdraw should be able to withdraw partial collateral of multiple assets",
                  "timedOut": false,
                  "duration": 853,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const partialWithdraw = depositAmount18Dec.div(f.usersArr.length);\nconst partialWithdraw8Dec = depositAmount8Dec.div(f.usersArr.length);\nconst expectedValueUnadjusted = (0, _values.toBig)(f.CollateralPrice.num(8) * depositAmount, 8).mul(200).div(300);\nconst expectedValueAdjusted = (0, _values.toBig)(f.CollateralPrice.num(8) * 1 * depositAmount, 8).mul(200).div(300) // cfactor = 1\n;\nconst expectedValueUnadjusted8Dec = (0, _values.toBig)(f.CollateralPrice.num(8) * depositAmount, 8).mul(200).div(300);\nconst expectedValueAdjusted8Dec = (0, _values.toBig)(f.CollateralPrice.num(8) * 0.8 * depositAmount, 8).mul(200).div(300) // cfactor = 0.8\n;\nawait Promise.all(f.usersArr.map(async (user)=>{\n    const UserKresko = hre.Diamond.connect(user);\n    return Promise.all([\n        UserKresko.withdrawSCDP({\n            account: user.address,\n            asset: f.Collateral.address,\n            amount: partialWithdraw,\n            receiver: user.address\n        }, await hre.updateData()),\n        UserKresko.withdrawSCDP({\n            account: user.address,\n            asset: f.Collateral8Dec.address,\n            amount: partialWithdraw8Dec,\n            receiver: user.address\n        }, await hre.updateData())\n    ]);\n}));\nconst [collateralBalanceAfter, collateral8DecBalanceAfter, { scdp }, assetInfos, userInfos] = await Promise.all([\n    f.Collateral.balanceOf(hre.Diamond.address),\n    f.Collateral8Dec.balanceOf(hre.Diamond.address),\n    hre.Diamond.viewProtocolData(hre.viewData()),\n    hre.Diamond.viewSCDPAssets(hre.viewData(), [\n        f.Collateral.address,\n        f.Collateral8Dec.address\n    ]),\n    hre.Diamond.viewSCDPAccounts(hre.viewData(), f.usersArr.map((u)=>u.address), [\n        f.Collateral.address,\n        f.Collateral8Dec.address\n    ])\n]);\nfor (const userInfo of userInfos){\n    const [balance18Dec, balance8Dec] = await Promise.all([\n        f.Collateral.balanceOf(userInfo.addr),\n        f.Collateral8Dec.balanceOf(userInfo.addr)\n    ]);\n    (0, _chai.expect)(balance18Dec).to.equal(partialWithdraw);\n    (0, _chai.expect)(balance8Dec).to.equal(partialWithdraw8Dec);\n    (0, _chai.expect)(userInfo.deposits[0].amount).to.equal(depositAmount18Dec.sub(partialWithdraw));\n    (0, _chai.expect)(userInfo.deposits[0].amountFees).to.equal(0);\n    (0, _chai.expect)(userInfo.deposits[1].amount).to.equal(depositAmount8Dec.sub(partialWithdraw8Dec));\n    (0, _chai.expect)(userInfo.deposits[1].amountFees).to.equal(0);\n    (0, _chai.expect)(userInfo.totals.valColl).to.closeTo(expectedValueUnadjusted.add(expectedValueUnadjusted8Dec), (0, _values.toBig)(0.00001, 8));\n}\n(0, _chai.expect)(collateralBalanceAfter).to.closeTo((0, _values.toBig)(2000), 1);\n(0, _chai.expect)(collateral8DecBalanceAfter).to.closeTo((0, _values.toBig)(2000, 8), 1);\n(0, _chai.expect)(assetInfos[0].amountColl).to.closeTo((0, _values.toBig)(2000), 1);\n(0, _chai.expect)(assetInfos[1].amountColl).to.closeTo((0, _values.toBig)(2000, 8), 1);\n(0, _chai.expect)(assetInfos[0].valColl).to.closeTo(expectedValueUnadjusted.mul(f.usersArr.length), 20);\n(0, _chai.expect)(assetInfos[0].valCollAdj).to.closeTo(expectedValueAdjusted.mul(f.usersArr.length), 20);\n(0, _chai.expect)(assetInfos[1].valColl).to.closeTo(expectedValueUnadjusted8Dec.mul(f.usersArr.length), 20);\n(0, _chai.expect)(assetInfos[1].valCollAdj).to.closeTo(expectedValueAdjusted8Dec.mul(f.usersArr.length), 20);\nconst totalValueRemaining = expectedValueUnadjusted8Dec.mul(f.usersArr.length).add(expectedValueUnadjusted.mul(f.usersArr.length));\n(0, _chai.expect)(scdp.totals.valColl).to.closeTo(totalValueRemaining, 20);\n(0, _chai.expect)(scdp.totals.valDebt).to.equal(0);\n(0, _chai.expect)(scdp.totals.cr).to.equal(_viem.maxUint256);",
                  "err": {},
                  "uuid": "b3c58373-a5a6-4dc4-a40f-50a520835000",
                  "parentUUID": "b3bf7447-7637-4e08-b40e-13ecd3db9d4b",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "c864031c-cb17-439c-9000-677324e169ba",
                "b3c58373-a5a6-4dc4-a40f-50a520835000"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 1678,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            },
            {
              "uuid": "a81d597c-1dcc-49a9-b1bd-7a455f811a1c",
              "title": "#Fee Distribution",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/scdp/00-scdp.ts",
              "file": "/src/test/scdp/00-scdp.ts",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"#Fee Distribution\"",
                  "fullTitle": "SCDP #Fee Distribution \"before each\" hook in \"#Fee Distribution\"",
                  "timedOut": false,
                  "duration": 1,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "incomeCumulator = hre.users.deployer;\nIncomeCumulator = hre.Diamond.connect(incomeCumulator);\nawait f.Collateral.setBalance(incomeCumulator, depositAmount18Dec.mul(f.usersArr.length), hre.Diamond.address);",
                  "err": {},
                  "uuid": "404b7398-e350-400d-8aed-75d764f843ba",
                  "parentUUID": "a81d597c-1dcc-49a9-b1bd-7a455f811a1c",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should be able to cumulate fees into deposits",
                  "fullTitle": "SCDP #Fee Distribution should be able to cumulate fees into deposits",
                  "timedOut": false,
                  "duration": 860,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await hre.Diamond.setFeeAssetSCDP(f.Collateral.address);\nconst feePerUser = depositAmount18Dec;\nconst feesToCumulate = feePerUser.mul(f.usersArr.length);\nconst feePerUserValue = (0, _values.toBig)(f.CollateralPrice.num(8) * depositAmount, 8);\nconst expectedDepositValue = (0, _values.toBig)(f.CollateralPrice.num(8) * depositAmount, 8);\n// deposit some\nawait Promise.all(f.usersArr.map((signer)=>hre.Diamond.connect(signer).depositSCDP(signer.address, f.Collateral.address, depositAmount18Dec)));\n// cumulate some income\nawait IncomeCumulator.cumulateIncomeSCDP(f.Collateral.address, feesToCumulate);\n// check that the fees are cumulated\nfor (const data of (await hre.Diamond.viewSCDPAccounts(hre.viewData(), f.usersArr.map((u)=>u.address), [\n    f.Collateral.address\n]))){\n    (0, _chai.expect)(data.deposits[0].val).to.equal(expectedDepositValue);\n    (0, _chai.expect)(data.deposits[0].valFees).to.equal(feePerUserValue);\n    (0, _chai.expect)(data.totals.valColl).to.equal(expectedDepositValue);\n    (0, _chai.expect)(data.totals.valFees).to.equal(feePerUserValue);\n}\n// withdraw principal\nawait Promise.all(f.usersArr.map(async (signer)=>hre.Diamond.connect(signer).withdrawSCDP({\n        account: signer.address,\n        asset: f.Collateral.address,\n        amount: depositAmount18Dec,\n        receiver: signer.address\n    }, await hre.updateData())));\nconst prices = hre.viewData();\nfor (const user of (await hre.Diamond.viewSCDPAccounts(prices, f.usersArr.map((u)=>u.address), [\n    f.Collateral.address\n]))){\n    const balance = await f.Collateral.balanceOf(user.addr);\n    (0, _chai.expect)(user.deposits[0].val).to.equal(0);\n    (0, _chai.expect)(user.deposits[0].valFees).to.equal(0);\n    (0, _chai.expect)(user.totals.valFees).to.equal(0);\n    (0, _chai.expect)(user.totals.valColl).to.equal(0);\n    (0, _chai.expect)(balance).to.equal(depositAmount18Dec.add(feePerUser));\n}\nconst [[assetInfo], { scdp }, balance] = await Promise.all([\n    hre.Diamond.viewSCDPAssets(prices, [\n        f.Collateral.address\n    ]),\n    hre.Diamond.viewProtocolData(prices),\n    f.Collateral.balanceOf(hre.Diamond.address)\n]);\n(0, _chai.expect)(balance).to.equal(0);\n(0, _chai.expect)(assetInfo.amountColl).to.equal(0);\n(0, _chai.expect)(assetInfo.valColl).to.equal(0);\n(0, _chai.expect)(assetInfo.valCollAdj).to.equal(0);\n(0, _chai.expect)(scdp.totals.valColl).to.equal(0);\n// nothing left in protocol.\nconst [colalteralBalanceKresko, [assetInfoFinal]] = await Promise.all([\n    f.Collateral.balanceOf(hre.Diamond.address),\n    hre.Diamond.viewSCDPAssets(prices, [\n        f.Collateral.address\n    ])\n]);\n(0, _chai.expect)(colalteralBalanceKresko).to.equal(0);\n(0, _chai.expect)(assetInfoFinal.amountColl).to.equal(0);\n(0, _chai.expect)(assetInfoFinal.valColl).to.equal(0);\n(0, _chai.expect)(assetInfoFinal.valCollAdj).to.equal(0);",
                  "err": {},
                  "uuid": "86ababd2-3362-47ab-acbc-692bd5ada521",
                  "parentUUID": "a81d597c-1dcc-49a9-b1bd-7a455f811a1c",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "86ababd2-3362-47ab-acbc-692bd5ada521"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 860,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            },
            {
              "uuid": "aa2c0906-79b2-4165-be96-23d57c15a4c2",
              "title": "#Swap",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/scdp/00-scdp.ts",
              "file": "/src/test/scdp/00-scdp.ts",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"#Swap\"",
                  "fullTitle": "SCDP #Swap \"before each\" hook in \"#Swap\"",
                  "timedOut": false,
                  "duration": 19,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await Promise.all(f.usersArr.map((signer)=>f.Collateral.setBalance(signer, (0, _values.toBig)(1_000_000))));\nawait f.KISS.setBalance(f.swapper, (0, _values.toBig)(10_000));\nawait f.KISS.setBalance(f.depositor, (0, _values.toBig)(10_000));\nawait f.KreskoDepositor.depositSCDP(f.depositor.address, f.KISS.address, depositAmount18Dec);",
                  "err": {},
                  "uuid": "8863c41e-24fc-4558-8bb9-b0b010f2cffb",
                  "parentUUID": "aa2c0906-79b2-4165-be96-23d57c15a4c2",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should have collateral in pool",
                  "fullTitle": "SCDP #Swap should have collateral in pool",
                  "timedOut": false,
                  "duration": 408,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const { scdp } = await hre.Diamond.viewProtocolData(hre.viewData());\n(0, _chai.expect)(scdp.totals.valColl).to.equal((0, _values.toBig)(depositAmount, 8));\n(0, _chai.expect)(scdp.totals.valDebt).to.equal(0);\n(0, _chai.expect)(scdp.totals.cr).to.equal(_viem.maxUint256);",
                  "err": {},
                  "uuid": "40836d4b-333e-407b-b56f-2f4cefb52432",
                  "parentUUID": "aa2c0906-79b2-4165-be96-23d57c15a4c2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should be able to preview a swap",
                  "fullTitle": "SCDP #Swap should be able to preview a swap",
                  "timedOut": false,
                  "duration": 20,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const swapAmount = (0, _values.toBig)(1);\n(0, _chai.expect)((await f.KrAsset2.getPrice()).pyth).to.equal(f.KrAsset2Price);\nconst feePercentageProtocol = Number(f.KISS.config.assetStruct.protocolFeeShareSCDP) + Number(f.KrAsset2.config.assetStruct.protocolFeeShareSCDP);\nconst expectedTotalFee = swapAmount.percentMul(f.KRASSET_KISS_ROUTE_FEE);\nconst expectedProtocolFee = expectedTotalFee.percentMul(feePercentageProtocol);\nconst expectedFee = expectedTotalFee.sub(expectedProtocolFee);\nconst amountInAfterFees = swapAmount.sub(expectedTotalFee);\nconst expectedAmountOut = amountInAfterFees.wadMul(f.KISSPrice).wadDiv(f.KrAsset2Price);\nconst [amountOut, feeAmount, feeAmountProtocol] = await hre.Diamond.previewSwapSCDP(f.KISS.address, f.KrAsset2.address, swapAmount);\n(0, _chai.expect)(amountOut).to.equal(expectedAmountOut);\n(0, _chai.expect)(feeAmount).to.equal(expectedFee);\n(0, _chai.expect)(feeAmountProtocol).to.equal(expectedProtocolFee);",
                  "err": {},
                  "uuid": "c577fefa-d387-4d0c-9ad1-fc0547a7619e",
                  "parentUUID": "aa2c0906-79b2-4165-be96-23d57c15a4c2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should be able to swap, shared debt == 0 | swap collateral == 0",
                  "fullTitle": "SCDP #Swap should be able to swap, shared debt == 0 | swap collateral == 0",
                  "timedOut": false,
                  "duration": 544,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const swapAmount = (0, _values.toBig)(1) // $1\n;\nconst kissInAfterFees = swapAmount.sub(swapAmount.percentMul(f.KRASSET_KISS_ROUTE_FEE));\nconst expectedAmountOut = kissInAfterFees.wadMul(f.KISSPrice).wadDiv(f.KrAsset2Price);\nconst tx = await f.KreskoSwapper.swapSCDP({\n    receiver: f.swapper.address,\n    assetIn: f.KISS.address,\n    assetOut: f.KrAsset2.address,\n    amountIn: swapAmount,\n    amountOutMin: 0,\n    prices: await hre.updateData()\n});\nconst event = await (0, _events.getNamedEvent)(tx, 'Swap');\n(0, _chai.expect)(event.args.who).to.equal(f.swapper.address);\n(0, _chai.expect)(event.args.assetIn).to.equal(f.KISS.address);\n(0, _chai.expect)(event.args.assetOut).to.equal(f.KrAsset2.address);\n(0, _chai.expect)(event.args.amountIn).to.equal(swapAmount);\n(0, _chai.expect)(event.args.amountOut).to.equal(expectedAmountOut);\nconst prices = hre.viewData();\nconst [KR2Balance, KISSBalance, swapperInfos, assetInfos, { scdp }] = await Promise.all([\n    f.KrAsset2.balanceOf(f.swapper.address),\n    f.KISS.balanceOf(f.swapper.address),\n    hre.Diamond.viewSCDPAccounts(prices, [\n        f.swapper.address\n    ], [\n        f.KrAsset2.address,\n        f.KISS.address\n    ]),\n    hre.Diamond.viewSCDPAssets(prices, [\n        f.KrAsset2.address,\n        f.KISS.address\n    ]),\n    hre.Diamond.viewProtocolData(prices)\n]);\nconst swapperInfo = swapperInfos[0];\n(0, _chai.expect)(KR2Balance).to.equal(expectedAmountOut);\n(0, _chai.expect)(KISSBalance).to.equal((0, _values.toBig)(10_000).sub(swapAmount));\n(0, _chai.expect)(swapperInfo.deposits[0].val).to.equal(0);\n(0, _chai.expect)(swapperInfo.deposits[1].val).to.equal(0);\n(0, _chai.expect)(assetInfos[0].amountDebt).to.equal(expectedAmountOut);\n(0, _chai.expect)(assetInfos[1].amountSwapDeposit).to.equal(kissInAfterFees);\nconst expectedDepositValue = (0, _values.toBig)(depositAmount, 8).add(kissInAfterFees.wadMul(f.KISSPrice));\n(0, _chai.expect)(assetInfos[1].valColl).to.equal(expectedDepositValue);\n(0, _chai.expect)(assetInfos[0].valDebt).to.equal(expectedAmountOut.wadMul(f.KrAsset2Price));\n(0, _chai.expect)(scdp.totals.valColl).to.equal(expectedDepositValue);\n(0, _chai.expect)(scdp.totals.valDebt).to.equal(expectedAmountOut.wadMul(f.KrAsset2Price));\n(0, _chai.expect)(scdp.totals.cr).to.equal(expectedDepositValue.percentDiv(expectedAmountOut.wadMul(f.KrAsset2Price)));",
                  "err": {},
                  "uuid": "32746eaa-c7df-4869-82bf-4ff96b319263",
                  "parentUUID": "aa2c0906-79b2-4165-be96-23d57c15a4c2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should be able to swap, shared debt == assetsIn | swap collateral == assetsOut",
                  "fullTitle": "SCDP #Swap should be able to swap, shared debt == assetsIn | swap collateral == assetsOut",
                  "timedOut": false,
                  "duration": 982,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const swapAmount = (0, _values.toBig)(100) // $100\n;\nconst swapAmountAsset = swapAmount.percentMul(1e4 - Number(f.KRASSET_KISS_ROUTE_FEE)).wadMul(f.KISSPrice.wadDiv(f.KrAsset2Price));\nconst expectedKissOut = swapAmountAsset.percentMul(1e4 - f.KRASSET_KISS_ROUTE_FEE).wadMul(f.KrAsset2Price).wadDiv(f.KISSPrice);\n// deposit some to kresko for minting first\nawait (0, _collaterals.depositCollateral)({\n    user: f.swapper,\n    asset: f.KISS,\n    amount: (0, _values.toBig)(100)\n});\nawait (0, _krassets.mintKrAsset)({\n    user: f.swapper,\n    asset: f.KrAsset2,\n    amount: (0, _values.toBig)(0.1)\n});\nconst { scdp } = await hre.Diamond.viewProtocolData(hre.viewData());\n(0, _chai.expect)(scdp.totals.valColl).to.equal(initialDepositValue);\nawait f.KreskoSwapper.swapSCDP({\n    receiver: f.swapper.address,\n    assetIn: f.KISS.address,\n    assetOut: f.KrAsset2.address,\n    amountIn: swapAmount,\n    amountOutMin: 0,\n    prices: await hre.updateData()\n});\n// the swap that clears debt\nconst tx = await f.KreskoSwapper.swapSCDP({\n    receiver: f.swapper.address,\n    assetIn: f.KrAsset2.address,\n    assetOut: f.KISS.address,\n    amountIn: swapAmountAsset,\n    amountOutMin: 0,\n    prices: await hre.updateData()\n});\nconst [event, assetInfos] = await Promise.all([\n    (0, _events.getNamedEvent)(tx, 'Swap'),\n    hre.Diamond.viewSCDPAssets(hre.viewData(), [\n        f.KISS.address,\n        f.KrAsset2.address\n    ])\n]);\n(0, _chai.expect)(event.args.who).to.equal(f.swapper.address);\n(0, _chai.expect)(event.args.assetIn).to.equal(f.KrAsset2.address);\n(0, _chai.expect)(event.args.assetOut).to.equal(f.KISS.address);\n(0, _chai.expect)(event.args.amountIn).to.equal(swapAmountAsset);\n(0, _chai.expect)(event.args.amountOut).to.equal(expectedKissOut);\n(0, _chai.expect)(assetInfos[0].amountSwapDeposit).to.equal(0);\n(0, _chai.expect)(assetInfos[0].valColl).to.equal(initialDepositValue);\n(0, _chai.expect)(assetInfos[1].valDebt).to.equal(0);\n(0, _chai.expect)(assetInfos[1].amountDebt).to.equal(0);\nconst { scdp: scdpAfter } = await hre.Diamond.viewProtocolData(hre.viewData());\n(0, _chai.expect)(scdpAfter.totals.valColl).to.equal((0, _values.toBig)(1000, 8));\n(0, _chai.expect)(scdpAfter.totals.valDebt).to.equal(0);\n(0, _chai.expect)(scdpAfter.totals.cr).to.equal(_viem.maxUint256);",
                  "err": {},
                  "uuid": "b3e23cbd-baf2-40c8-82b4-974f5743fbe8",
                  "parentUUID": "aa2c0906-79b2-4165-be96-23d57c15a4c2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should be able to swap, debt > assetsIn | swap deposits > assetsOut",
                  "fullTitle": "SCDP #Swap should be able to swap, debt > assetsIn | swap deposits > assetsOut",
                  "timedOut": false,
                  "duration": 652,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const swapAmount = (0, _values.toBig)(1) // $1\n;\nconst swapValue = (0, _values.toBig)(1, 8);\nawait f.KreskoSwapper.swapSCDP({\n    receiver: f.swapper.address,\n    assetIn: f.KISS.address,\n    assetOut: f.KrAsset2.address,\n    amountIn: swapAmount,\n    amountOutMin: 0,\n    prices: await hre.updateData()\n});\nconst [assetInfoKISS] = await hre.Diamond.viewSCDPAssets(hre.viewData(), [\n    f.KISS.address\n]);\nconst feeValueFirstSwap = swapValue.percentMul(f.KRASSET_KISS_ROUTE_FEE);\nconst valueInAfterFees = swapValue.sub(feeValueFirstSwap);\n(0, _chai.expect)(assetInfoKISS.valColl).to.equal(depositValue.add(valueInAfterFees));\nconst expectedSwapDeposits = valueInAfterFees.num(8).ebn(18);\n(0, _chai.expect)(assetInfoKISS.amountSwapDeposit).to.equal(expectedSwapDeposits);\nconst swapAmountSecond = (0, _values.toBig)(0.009) // this is $0.90, so less than $0.96 since we want to ensure debt > assetsIn | swap deposits > assetsOut\n;\nconst swapValueSecond = swapAmountSecond.wadMul(f.KrAsset2Price);\nconst feeValueSecondSwap = swapValueSecond.sub(swapValueSecond.percentMul(f.KRASSET_KISS_ROUTE_FEE));\nconst expectedKissOut = feeValueSecondSwap.wadDiv(f.KISSPrice) // 0.8685\n;\nconst tx = await f.KreskoSwapper.swapSCDP({\n    receiver: f.swapper.address,\n    assetIn: f.KrAsset2.address,\n    assetOut: f.KISS.address,\n    amountIn: swapAmountSecond,\n    amountOutMin: 0,\n    prices: await hre.updateData()\n});\nconst event = await (0, _events.getNamedEvent)(tx, 'Swap');\n(0, _chai.expect)(event.args.who).to.equal(f.swapper.address);\n(0, _chai.expect)(event.args.assetIn).to.equal(f.KrAsset2.address);\n(0, _chai.expect)(event.args.assetOut).to.equal(f.KISS.address);\n(0, _chai.expect)(event.args.amountIn).to.equal(swapAmountSecond);\n(0, _chai.expect)(event.args.amountOut).to.equal(expectedKissOut);\nconst [depositValueKR2, depositValueKISS, assetInfos, { scdp }] = await Promise.all([\n    f.KreskoSwapper.getAccountDepositValueSCDP(f.swapper.address, f.KrAsset2.address),\n    f.KreskoSwapper.getAccountDepositValueSCDP(f.swapper.address, f.KISS.address),\n    hre.Diamond.viewSCDPAssets(hre.viewData(), [\n        f.KISS.address,\n        f.KrAsset2.address\n    ]),\n    hre.Diamond.viewProtocolData(hre.viewData())\n]);\n(0, _chai.expect)(depositValueKR2).to.equal(0);\n(0, _chai.expect)(depositValueKISS).to.equal(0);\nconst expectedSwapDepositsAfter = expectedSwapDeposits.sub((0, _values.toBig)(0.9));\nconst expectedSwapDepositsValue = expectedSwapDepositsAfter.wadMul(assetInfoKISS.price);\n(0, _chai.expect)(assetInfos[0].amountSwapDeposit).to.equal(expectedSwapDepositsAfter);\n(0, _chai.expect)(assetInfos[0].valColl).to.equal((0, _values.toBig)(depositAmount, 8).add(expectedSwapDepositsValue));\n(0, _chai.expect)(assetInfos[1].valDebt).to.equal(expectedSwapDepositsValue);\nconst expectedDebtAfter = expectedSwapDepositsValue.wadDiv((await f.KrAsset2.getPrice()).pyth);\n(0, _chai.expect)(assetInfos[0].amountDebt).to.equal(0);\n(0, _chai.expect)(assetInfos[1].amountDebt).to.equal(expectedDebtAfter);\nconst expectedCollateralValue = expectedSwapDepositsValue.add(depositAmount.ebn(8));\n(0, _chai.expect)(scdp.totals.valColl).to.equal(expectedCollateralValue) // swap deposits + collateral deposited\n;\n(0, _chai.expect)(scdp.totals.valDebt).to.equal(expectedSwapDepositsValue) //\n;\n(0, _chai.expect)(scdp.totals.cr).to.equal(expectedCollateralValue.percentDiv(expectedSwapDepositsValue));",
                  "err": {},
                  "uuid": "bbb9095e-e44e-4ef7-8fc2-1cb7156fc960",
                  "parentUUID": "aa2c0906-79b2-4165-be96-23d57c15a4c2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should be able to swap, debt < assetsIn | swap deposits < assetsOut",
                  "fullTitle": "SCDP #Swap should be able to swap, debt < assetsIn | swap deposits < assetsOut",
                  "timedOut": false,
                  "duration": 1140,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const swapAmountKiss = (0, _values.toBig)(100) // $100\n;\nconst swapAmountKrAsset = (0, _values.toBig)(2) // $200\n;\nconst swapValue = 200;\nconst firstSwapFeeAmount = swapAmountKiss.percentMul(f.KRASSET_KISS_ROUTE_FEE);\nconst expectedKissOutSecondSwap = swapAmountKrAsset.sub(swapAmountKrAsset.percentMul(f.KRASSET_KISS_ROUTE_FEE)).wadMul(f.KrAsset2Price).wadDiv(f.KISSPrice);\nconst krAssetOutFirstSwap = swapAmountKiss.sub(firstSwapFeeAmount).wadMul(f.KISSPrice).wadDiv(f.KrAsset2Price);\nconst krAssetOutFirstSwapValue = krAssetOutFirstSwap.wadMul(f.KrAsset2Price);\n// deposit some to kresko for minting first\nawait (0, _collaterals.depositCollateral)({\n    user: f.swapper,\n    asset: f.KISS,\n    amount: (0, _values.toBig)(400)\n});\nconst ICDPMintAmount = (0, _values.toBig)(1.04);\nawait (0, _krassets.mintKrAsset)({\n    user: f.swapper,\n    asset: f.KrAsset2,\n    amount: ICDPMintAmount\n});\nawait f.KreskoSwapper.swapSCDP({\n    receiver: f.swapper.address,\n    assetIn: f.KISS.address,\n    assetOut: f.KrAsset2.address,\n    amountIn: swapAmountKiss,\n    amountOutMin: 0,\n    prices: await hre.updateData()\n});\nconst expectedSwapDeposits = swapAmountKiss.sub(firstSwapFeeAmount);\nconst { scdp } = await hre.Diamond.viewProtocolData(hre.viewData());\n(0, _chai.expect)(await f.KreskoSwapper.getSwapDepositsSCDP(f.KISS.address)).to.equal(expectedSwapDeposits);\n(0, _chai.expect)(scdp.totals.valColl).to.be.eq(depositAmount.ebn().add(expectedSwapDeposits).wadMul(f.KISSPrice));\n// the swap that matters, here user has 0.96 (previous swap) + 1.04 (mint). expecting 192 kiss from swap.\nconst [expectedAmountOut] = await f.KreskoSwapper.previewSwapSCDP(f.KrAsset2.address, f.KISS.address, swapAmountKrAsset);\n(0, _chai.expect)(expectedAmountOut).to.equal(expectedKissOutSecondSwap);\nconst tx = await f.KreskoSwapper.swapSCDP({\n    receiver: f.swapper.address,\n    assetIn: f.KrAsset2.address,\n    assetOut: f.KISS.address,\n    amountIn: swapAmountKrAsset,\n    amountOutMin: 0,\n    prices: await hre.updateData()\n});\nconst event = await (0, _events.getNamedEvent)(tx, 'Swap');\n(0, _chai.expect)(event.args.who).to.equal(f.swapper.address);\n(0, _chai.expect)(event.args.assetIn).to.equal(f.KrAsset2.address);\n(0, _chai.expect)(event.args.assetOut).to.equal(f.KISS.address);\n(0, _chai.expect)(event.args.amountIn).to.equal(swapAmountKrAsset);\n(0, _chai.expect)(event.args.amountOut).to.equal(expectedKissOutSecondSwap);\nconst assetInfos = await hre.Diamond.viewSCDPAssets(hre.viewData(), [\n    f.KISS.address,\n    f.KrAsset2.address\n]);\n// f.KISS deposits sent in swap\nconst acocuntPrincipalDepositsKISS = await f.KreskoSwapper.getAccountDepositSCDP(f.depositor.address, f.KISS.address);\n(0, _chai.expect)(assetInfos[0].amountSwapDeposit).to.equal(0) // half of 2 krAsset\n;\n(0, _chai.expect)(assetInfos[0].amountColl).to.equal(acocuntPrincipalDepositsKISS);\n// KrAsset debt is cleared\n(0, _chai.expect)(assetInfos[1].valDebt).to.equal(0);\n(0, _chai.expect)(assetInfos[1].amountDebt).to.equal(0);\n// KISS debt is issued\nconst expectedKissDebtValue = (0, _values.toBig)(swapValue, 8).sub(krAssetOutFirstSwapValue);\n(0, _chai.expect)(assetInfos[0].valDebt).to.equal(expectedKissDebtValue);\n(0, _chai.expect)(assetInfos[0].amountDebt).to.equal(expectedKissDebtValue.wadDiv(f.KISSPrice));\n// krAsset swap deposits\nconst expectedSwapDepositValue = (0, _values.toBig)(swapValue, 8).sub(krAssetOutFirstSwapValue);\n(0, _chai.expect)(assetInfos[1].amountSwapDeposit).to.equal((0, _values.toBig)(2).sub(krAssetOutFirstSwap));\n(0, _chai.expect)(assetInfos[1].valColl).to.equal(expectedSwapDepositValue) // asset price is $100\n;\nconst { scdp: scdpAfter } = await hre.Diamond.viewProtocolData(hre.viewData());\nconst expectedCollateralValue = (0, _values.toBig)(1000, 8).add(expectedSwapDepositValue);\n(0, _chai.expect)(scdpAfter.totals.valColl).to.equal(expectedCollateralValue);\n(0, _chai.expect)(scdpAfter.totals.valDebt).to.equal(expectedKissDebtValue);\n(0, _chai.expect)(scdpAfter.totals.cr).to.equal(expectedCollateralValue.percentDiv(expectedKissDebtValue));",
                  "err": {},
                  "uuid": "bc811ae6-e42c-49c7-be64-51f97bb1aebd",
                  "parentUUID": "aa2c0906-79b2-4165-be96-23d57c15a4c2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "cumulates fees on swap",
                  "fullTitle": "SCDP #Swap cumulates fees on swap",
                  "timedOut": false,
                  "duration": 345,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const depositAmountNew = (0, _values.toBig)(10000 - depositAmount);\nawait f.KISS.setBalance(f.depositor, depositAmountNew);\nawait f.KreskoDepositor.depositSCDP(f.depositor.address, f.KISS.address, depositAmountNew);\nconst swapAmount = (0, _values.toBig)(2600);\nconst feesBeforeSwap = await f.KreskoSwapper.getAccountFeesSCDP(f.depositor.address, f.KISS.address);\nawait f.KreskoSwapper.swapSCDP({\n    receiver: f.swapper.address,\n    assetIn: f.KISS.address,\n    assetOut: f.KrAsset2.address,\n    amountIn: swapAmount,\n    amountOutMin: 0,\n    prices: await hre.updateData()\n});\nconst feesAfterSwap = await f.KreskoSwapper.getAccountFeesSCDP(f.depositor.address, f.KISS.address);\n(0, _chai.expect)(feesAfterSwap).to.gt(feesBeforeSwap);\nawait f.KreskoSwapper.swapSCDP({\n    receiver: f.swapper.address,\n    assetIn: f.KrAsset2.address,\n    assetOut: f.KISS.address,\n    amountIn: f.KrAsset2.balanceOf(f.swapper.address),\n    amountOutMin: 0,\n    prices: await hre.updateData()\n});\nconst feesAfterSecondSwap = await f.KreskoSwapper.getAccountFeesSCDP(f.depositor.address, f.KISS.address);\n(0, _chai.expect)(feesAfterSecondSwap).to.gt(feesAfterSwap);\nawait f.KreskoDepositor.claimFeesSCDP(f.depositor.address, f.KISS.address, f.depositor.address);\nconst [depositsAfter, feesAfter] = await Promise.all([\n    f.KreskoSwapper.getAccountDepositSCDP(f.depositor.address, f.KISS.address),\n    f.KreskoSwapper.getAccountFeesSCDP(f.depositor.address, f.KISS.address)\n]);\n(0, _chai.expect)(feesAfter).to.eq(0);\n(0, _chai.expect)(depositsAfter).to.eq((0, _values.toBig)(10000));\nawait f.KreskoDepositor.withdrawSCDP({\n    account: f.depositor.address,\n    asset: f.KISS.address,\n    amount: (0, _values.toBig)(10000),\n    receiver: f.depositor.address\n}, await hre.updateData());\nconst [depositsAfterWithdraw, feesAfterWithdraw] = await Promise.all([\n    f.KreskoSwapper.getAccountDepositValueSCDP(f.depositor.address, f.KISS.address),\n    f.KreskoSwapper.getAccountFeesSCDP(f.depositor.address, f.KISS.address)\n]);\n(0, _chai.expect)(depositsAfterWithdraw).to.eq(0);\n(0, _chai.expect)(feesAfterWithdraw).to.eq(0);",
                  "err": {},
                  "uuid": "49f2b7a2-4c9b-484c-a370-75b10749cafd",
                  "parentUUID": "aa2c0906-79b2-4165-be96-23d57c15a4c2",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "40836d4b-333e-407b-b56f-2f4cefb52432",
                "c577fefa-d387-4d0c-9ad1-fc0547a7619e",
                "32746eaa-c7df-4869-82bf-4ff96b319263",
                "b3e23cbd-baf2-40c8-82b4-974f5743fbe8",
                "bbb9095e-e44e-4ef7-8fc2-1cb7156fc960",
                "bc811ae6-e42c-49c7-be64-51f97bb1aebd",
                "49f2b7a2-4c9b-484c-a370-75b10749cafd"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 4091,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            },
            {
              "uuid": "a0d9a7bb-62a2-4e06-a971-4e1e68a9f401",
              "title": "#Liquidations",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/scdp/00-scdp.ts",
              "file": "/src/test/scdp/00-scdp.ts",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"#Liquidations\"",
                  "fullTitle": "SCDP #Liquidations \"before each\" hook in \"#Liquidations\"",
                  "timedOut": false,
                  "duration": 43,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "for (const signer of f.usersArr){\n    await f.Collateral.setBalance(signer, (0, _values.toBig)(1_000_000));\n}\nawait f.KISS.setBalance(f.swapper, (0, _values.toBig)(10_000));\nawait f.KISS.setBalance(f.depositor2, (0, _values.toBig)(10_000));\nawait hre.Diamond.setFeeAssetSCDP(f.Collateral.address);\nawait f.KreskoDepositor.depositSCDP(f.depositor.address, f.Collateral.address, depositAmount18Dec);\nawait hre.Diamond.setFeeAssetSCDP(f.Collateral8Dec.address);\nawait f.KreskoDepositor.depositSCDP(f.depositor.address, f.Collateral8Dec.address, depositAmount8Dec);\nawait hre.Diamond.setFeeAssetSCDP(f.KISS.address);\nf.KreskoDepositor2.depositSCDP(f.depositor2.address, f.KISS.address, depositAmount18Dec);",
                  "err": {},
                  "uuid": "a5f8e95a-f2e6-4a9b-810b-abaa4804d8ec",
                  "parentUUID": "a0d9a7bb-62a2-4e06-a971-4e1e68a9f401",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should identify if the pool is not underwater",
                  "fullTitle": "SCDP #Liquidations should identify if the pool is not underwater",
                  "timedOut": false,
                  "duration": 176,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const swapAmount = (0, _values.toBig)(2600) // $1\n;\nawait f.KreskoSwapper.swapSCDP({\n    receiver: f.swapper.address,\n    assetIn: f.KISS.address,\n    assetOut: f.KrAsset2.address,\n    amountIn: swapAmount,\n    amountOutMin: 0,\n    prices: await hre.updateData()\n});\n(0, _chai.expect)(await hre.Diamond.getLiquidatableSCDP()).to.be.false;",
                  "err": {},
                  "uuid": "7ed111c4-9252-476b-be64-ccbceefb0cf1",
                  "parentUUID": "a0d9a7bb-62a2-4e06-a971-4e1e68a9f401",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should revert liquidations if the pool is not underwater",
                  "fullTitle": "SCDP #Liquidations should revert liquidations if the pool is not underwater",
                  "timedOut": false,
                  "duration": 265,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const swapAmount = (0, _values.toBig)(2600) // $1\n;\nawait f.KreskoSwapper.swapSCDP({\n    receiver: f.swapper.address,\n    assetIn: f.KISS.address,\n    assetOut: f.KrAsset2.address,\n    amountIn: swapAmount,\n    amountOutMin: 0,\n    prices: await hre.updateData()\n});\n(0, _chai.expect)(await hre.Diamond.getLiquidatableSCDP()).to.be.false;\nawait f.KrAsset2.setBalance(hre.users.liquidator, (0, _values.toBig)(1_000_000));\nawait (0, _chai.expect)(f.KreskoLiquidator.liquidateSCDP({\n    repayAsset: f.KrAsset2.address,\n    repayAmount: (0, _values.toBig)(7.7),\n    seizeAsset: f.Collateral8Dec.address\n}, await hre.updateData())).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'COLLATERAL_VALUE_GREATER_THAN_REQUIRED');",
                  "err": {},
                  "uuid": "828a6e77-98c7-40ef-975e-271436f165e1",
                  "parentUUID": "a0d9a7bb-62a2-4e06-a971-4e1e68a9f401",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should identify if the pool is underwater",
                  "fullTitle": "SCDP #Liquidations should identify if the pool is underwater",
                  "timedOut": false,
                  "duration": 623,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const swapAmount = (0, _values.toBig)(2600);\nawait f.KreskoSwapper.swapSCDP({\n    receiver: f.swapper.address,\n    assetIn: f.KISS.address,\n    assetOut: f.KrAsset2.address,\n    amountIn: swapAmount,\n    amountOutMin: 0,\n    prices: await hre.updateData()\n});\nawait f.Collateral.setPrice(f.CollateralPrice.num(8) / 1000);\nawait f.Collateral8Dec.setPrice(f.CollateralPrice.num(8) / 1000);\nconst [{ scdp }, liquidatable] = await Promise.all([\n    hre.Diamond.viewProtocolData(hre.viewData()),\n    hre.Diamond.getLiquidatableSCDP()\n]);\n(0, _chai.expect)(scdp.totals.cr).to.be.lt(scdp.LT);\n(0, _chai.expect)(liquidatable).to.be.true;",
                  "err": {},
                  "uuid": "f71df4d9-1391-4e2d-86e1-f4a964ad9aac",
                  "parentUUID": "a0d9a7bb-62a2-4e06-a971-4e1e68a9f401",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should allow liquidating the underwater pool",
                  "fullTitle": "SCDP #Liquidations should allow liquidating the underwater pool",
                  "timedOut": false,
                  "duration": 1779,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const swapAmount = (0, _values.toBig)(2600);\nawait f.KreskoSwapper.swapSCDP({\n    receiver: f.swapper.address,\n    assetIn: f.KISS.address,\n    assetOut: f.KrAsset2.address,\n    amountIn: swapAmount,\n    amountOutMin: 0,\n    prices: await hre.updateData()\n});\nconst newKreskoAssetPrice = 500;\nawait f.KrAsset2.setPrice(newKreskoAssetPrice);\nconst [scdpParams, maxLiquidatable, krAssetPrice, { scdp: scdpBefore }] = await Promise.all([\n    hre.Diamond.getParametersSCDP(),\n    hre.Diamond.getMaxLiqValueSCDP(f.KrAsset2.address, f.Collateral8Dec.address),\n    f.KrAsset2.getPrice(),\n    hre.Diamond.viewProtocolData(hre.viewData())\n]);\nconst repayAmount = maxLiquidatable.repayValue.wadDiv(krAssetPrice.pyth);\nawait f.KrAsset2.setBalance(hre.users.liquidator, repayAmount.add(1e18.toString()));\n(0, _chai.expect)(scdpBefore.totals.cr).to.lt(scdpParams.liquidationThreshold);\n(0, _chai.expect)(scdpBefore.totals.cr).to.gt(1e4);\n// Liquidate the shared CDP\nconst tx = await f.KreskoLiquidator.liquidateSCDP({\n    repayAsset: f.KrAsset2.address,\n    repayAmount,\n    seizeAsset: f.Collateral8Dec.address\n}, await hre.updateData());\n// Check the state after liquidation\nconst [{ scdp: scdpAfter }, liquidatableAfter] = await Promise.all([\n    hre.Diamond.viewProtocolData(hre.viewData()),\n    hre.Diamond.getLiquidatableSCDP()\n]);\n(0, _chai.expect)(scdpAfter.totals.cr).to.gt(scdpParams.liquidationThreshold);\n(0, _chai.expect)(scdpAfter.totals.crOgAdj).to.eq(2.01e4);\n(0, _chai.expect)(liquidatableAfter).to.eq(false);\n// Shared CDP should not be liquidatable since it is above the threshold\nawait (0, _chai.expect)(f.KreskoLiquidator.liquidateSCDP({\n    repayAsset: f.KrAsset2.address,\n    repayAmount,\n    seizeAsset: f.Collateral8Dec.address\n}, await hre.updateData())).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'COLLATERAL_VALUE_GREATER_THAN_REQUIRED');\n// Check what was emitted in the event\nconst event = await (0, _events.getNamedEvent)(tx, 'SCDPLiquidationOccured');\nconst expectedSeizeAmount = repayAmount.wadMul((0, _values.toBig)(newKreskoAssetPrice, 8)).percentMul(1.05e4).wadDiv(f.CollateralPrice).div(10 ** 10);\n(0, _chai.expect)(event.args.liquidator).to.eq(hre.users.liquidator.address);\n(0, _chai.expect)(event.args.seizeAmount).to.eq(expectedSeizeAmount);\n(0, _chai.expect)(event.args.repayAmount).to.eq(repayAmount);\n(0, _chai.expect)(event.args.seizeCollateral).to.eq(f.Collateral8Dec.address);\n(0, _chai.expect)(event.args.repayKreskoAsset).to.eq(f.KrAsset2.address);\n// Check account state changes\nconst expectedDepositsAfter = depositAmount8Dec.sub(event.args.seizeAmount);\n(0, _chai.expect)(expectedDepositsAfter).to.be.lt(depositAmount8Dec);\nconst [principalDeposits, fees, params] = await Promise.all([\n    hre.Diamond.getAccountDepositSCDP(f.depositor.address, f.Collateral8Dec.address),\n    hre.Diamond.getAccountFeesSCDP(f.depositor.address, f.Collateral8Dec.address),\n    hre.Diamond.getParametersSCDP()\n]);\n(0, _chai.expect)(principalDeposits).to.eq(expectedDepositsAfter);\n(0, _chai.expect)(fees).to.eq(0);\n// Sanity checking that users should be able to withdraw what is left\nawait hre.Diamond.setFeeAssetSCDP(f.Collateral.address);\nawait f.KreskoDepositor.depositSCDP(f.depositor.address, f.Collateral.address, depositAmount18Dec.mul(10));\nconst { scdp } = await hre.Diamond.viewProtocolData(hre.viewData());\n(0, _chai.expect)(scdp.totals.cr).to.gt(params.minCollateralRatio);\nawait (0, _chai.expect)(f.KreskoDepositor.withdrawSCDP({\n    account: f.depositor.address,\n    asset: f.Collateral8Dec.address,\n    amount: expectedDepositsAfter,\n    receiver: f.depositor.address\n}, await hre.updateData())).to.not.be.reverted;\nconst [principalEnd, feesAfter] = await Promise.all([\n    hre.Diamond.getAccountDepositSCDP(f.depositor.address, f.Collateral8Dec.address),\n    hre.Diamond.getAccountFeesSCDP(f.depositor.address, f.Collateral8Dec.address)\n]);\n(0, _chai.expect)(principalEnd).to.eq(0);\n(0, _chai.expect)(feesAfter).to.eq(0);",
                  "err": {},
                  "uuid": "e5d2fc8b-3adb-4ebe-90a0-2e9d6dc8d64d",
                  "parentUUID": "a0d9a7bb-62a2-4e06-a971-4e1e68a9f401",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "7ed111c4-9252-476b-be64-ccbceefb0cf1",
                "828a6e77-98c7-40ef-975e-271436f165e1",
                "f71df4d9-1391-4e2d-86e1-f4a964ad9aac",
                "e5d2fc8b-3adb-4ebe-90a0-2e9d6dc8d64d"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 2843,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            },
            {
              "uuid": "38dcc5a5-bd4f-4b49-a34b-fd772c5b7639",
              "title": "#Error",
              "fullFile": "/Users/panukettunen/projects/kresko-protocol/src/test/scdp/00-scdp.ts",
              "file": "/src/test/scdp/00-scdp.ts",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"#Error\"",
                  "fullTitle": "SCDP #Error \"before each\" hook in \"#Error\"",
                  "timedOut": false,
                  "duration": 43,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await Promise.all(f.usersArr.map((signer)=>f.Collateral.setBalance(signer, (0, _values.toBig)(1_000_000))));\nawait f.KISS.setBalance(f.swapper, (0, _values.toBig)(10_000));\nawait f.KISS.setBalance(f.depositor, hre.ethers.BigNumber.from(1));\nawait hre.Diamond.setFeeAssetSCDP(f.Collateral.address);\nawait f.KreskoDepositor.depositSCDP(f.depositor.address, f.Collateral.address, depositAmount18Dec);\nawait hre.Diamond.setFeeAssetSCDP(f.KISS.address);\nawait f.KreskoDepositor.depositSCDP(f.depositor.address, f.KISS.address, 1);",
                  "err": {},
                  "uuid": "c8f890de-95d4-4654-92e6-098f0b1d534a",
                  "parentUUID": "38dcc5a5-bd4f-4b49-a34b-fd772c5b7639",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should revert depositing unsupported tokens",
                  "fullTitle": "SCDP #Error should revert depositing unsupported tokens",
                  "timedOut": false,
                  "duration": 52,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const [UnsupportedToken] = await hre.deploy('MockERC20', {\n    args: [\n        'UnsupportedToken',\n        'UnsupportedToken',\n        18,\n        (0, _values.toBig)(1)\n    ]\n});\nawait UnsupportedToken.approve(hre.Diamond.address, hre.ethers.constants.MaxUint256);\nconst { deployer } = await hre.getNamedAccounts();\nawait (0, _chai.expect)(hre.Diamond.depositSCDP(deployer, UnsupportedToken.address, 1)).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'ASSET_NOT_FEE_ACCUMULATING_ASSET').withArgs([\n    'UnsupportedToken',\n    UnsupportedToken.address\n]);",
                  "err": {},
                  "uuid": "cb6701a9-a41c-4cea-baa7-c214a770df4a",
                  "parentUUID": "38dcc5a5-bd4f-4b49-a34b-fd772c5b7639",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should revert withdrawing without deposits",
                  "fullTitle": "SCDP #Error should revert withdrawing without deposits",
                  "timedOut": false,
                  "duration": 55,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const withdrawAmount = 1;\nawait (0, _chai.expect)(f.KreskoSwapper.withdrawSCDP({\n    account: f.swapper.address,\n    asset: f.Collateral.address,\n    amount: withdrawAmount,\n    receiver: f.swapper.address\n}, await hre.updateData())).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'ACCOUNT_HAS_NO_DEPOSITS').withArgs(f.swapper.address, f.Collateral.errorId);",
                  "err": {},
                  "uuid": "afa157af-3198-499e-917a-5a169d43bd5d",
                  "parentUUID": "38dcc5a5-bd4f-4b49-a34b-fd772c5b7639",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should revert withdrawals below MCR",
                  "fullTitle": "SCDP #Error should revert withdrawals below MCR",
                  "timedOut": false,
                  "duration": 208,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const swapAmount = (0, _values.toBig)(1000) // $1000\n;\nawait f.KreskoSwapper.swapSCDP({\n    receiver: f.swapper.address,\n    assetIn: f.KISS.address,\n    assetOut: f.KrAsset2.address,\n    amountIn: swapAmount,\n    amountOutMin: 0,\n    prices: await hre.updateData()\n}) // generates the debt\n;\nconst deposits = await f.KreskoSwapper.getAccountDepositSCDP(f.depositor.address, f.Collateral.address);\nawait (0, _chai.expect)(f.KreskoDepositor.withdrawSCDP({\n    account: f.depositor.address,\n    asset: f.Collateral.address,\n    amount: deposits,\n    receiver: f.depositor.address\n}, await hre.updateData())).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'COLLATERAL_VALUE_LESS_THAN_REQUIRED').withArgs(960e8, 4800e8, 5e4);",
                  "err": {},
                  "uuid": "c6d9d858-baf7-401c-9c0f-9e409f96272c",
                  "parentUUID": "38dcc5a5-bd4f-4b49-a34b-fd772c5b7639",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should revert withdrawals of swap owned collateral deposits",
                  "fullTitle": "SCDP #Error should revert withdrawals of swap owned collateral deposits",
                  "timedOut": false,
                  "duration": 178,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const swapAmount = (0, _values.toBig)(1);\nawait f.KrAsset2.setBalance(f.swapper, swapAmount);\nawait f.KreskoSwapper.swapSCDP({\n    receiver: f.swapper.address,\n    assetIn: f.KrAsset2.address,\n    assetOut: f.KISS.address,\n    amountIn: swapAmount,\n    amountOutMin: 0,\n    prices: await hre.updateData()\n});\nconst deposits = await f.KreskoSwapper.getSwapDepositsSCDP(f.KrAsset2.address);\n(0, _chai.expect)(deposits).to.be.gt(0);\nawait (0, _chai.expect)(f.KreskoSwapper.withdrawSCDP({\n    account: f.swapper.address,\n    asset: f.KrAsset2.address,\n    amount: deposits,\n    receiver: f.depositor.address\n}, await hre.updateData())).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'ASSET_DOES_NOT_HAVE_DEPOSITS').withArgs(f.KrAsset2.errorId);",
                  "err": {},
                  "uuid": "7bfed51b-62b3-4958-9a8d-d2615fbbb439",
                  "parentUUID": "38dcc5a5-bd4f-4b49-a34b-fd772c5b7639",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should revert swapping with price below minAmountOut",
                  "fullTitle": "SCDP #Error should revert swapping with price below minAmountOut",
                  "timedOut": false,
                  "duration": 111,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const swapAmount = (0, _values.toBig)(1);\nawait f.KrAsset2.setBalance(f.swapper, swapAmount);\nconst [amountOut] = await f.KreskoSwapper.previewSwapSCDP(f.KrAsset2.address, f.KISS.address, swapAmount);\nawait (0, _chai.expect)(f.KreskoSwapper.swapSCDP({\n    receiver: f.swapper.address,\n    assetIn: f.KrAsset2.address,\n    assetOut: f.KISS.address,\n    amountIn: swapAmount,\n    amountOutMin: amountOut.add(1),\n    prices: await hre.updateData()\n})).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'RECEIVED_LESS_THAN_DESIRED').withArgs(f.KISS.errorId, amountOut, amountOut.add(1));",
                  "err": {},
                  "uuid": "a807807a-2797-47aa-bb9a-3814e7849792",
                  "parentUUID": "38dcc5a5-bd4f-4b49-a34b-fd772c5b7639",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should revert swapping unsupported asset",
                  "fullTitle": "SCDP #Error should revert swapping unsupported asset",
                  "timedOut": false,
                  "duration": 62,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const swapAmount = (0, _values.toBig)(1);\nawait f.KrAsset2.setBalance(f.swapper, swapAmount);\nawait (0, _chai.expect)(f.KreskoSwapper.swapSCDP({\n    receiver: f.swapper.address,\n    assetIn: f.KrAsset2.address,\n    assetOut: f.Collateral.address,\n    amountIn: swapAmount,\n    amountOutMin: 0,\n    prices: await hre.updateData()\n})).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'SWAP_ROUTE_NOT_ENABLED').withArgs(f.KrAsset2.errorId, f.Collateral.errorId);",
                  "err": {},
                  "uuid": "d062fd46-0e16-425e-a367-448964524168",
                  "parentUUID": "38dcc5a5-bd4f-4b49-a34b-fd772c5b7639",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should revert swapping a disabled route",
                  "fullTitle": "SCDP #Error should revert swapping a disabled route",
                  "timedOut": false,
                  "duration": 63,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const swapAmount = (0, _values.toBig)(1);\nawait f.KrAsset2.setBalance(f.swapper, swapAmount);\nawait hre.Diamond.setSingleSwapRouteSCDP({\n    assetIn: f.KrAsset2.address,\n    assetOut: f.KISS.address,\n    enabled: false\n});\nawait (0, _chai.expect)(f.KreskoSwapper.swapSCDP({\n    receiver: f.swapper.address,\n    assetIn: f.KrAsset2.address,\n    assetOut: f.KISS.address,\n    amountIn: swapAmount,\n    amountOutMin: 0,\n    prices: await hre.updateData()\n})).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'SWAP_ROUTE_NOT_ENABLED').withArgs(f.KrAsset2.errorId, f.KISS.errorId);",
                  "err": {},
                  "uuid": "e9400d95-e325-4f14-8248-9bddb38c1d1f",
                  "parentUUID": "38dcc5a5-bd4f-4b49-a34b-fd772c5b7639",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should revert swapping causes CDP to go below MCR",
                  "fullTitle": "SCDP #Error should revert swapping causes CDP to go below MCR",
                  "timedOut": false,
                  "duration": 138,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const swapAmount = (0, _values.toBig)(1_500_000);\nawait f.KrAsset2.setBalance(f.swapper, swapAmount);\nconst tx = f.KreskoSwapper.swapSCDP({\n    receiver: f.swapper.address,\n    assetIn: f.KrAsset2.address,\n    assetOut: f.KISS.address,\n    amountIn: swapAmount,\n    amountOutMin: 0,\n    prices: await hre.updateData()\n});\nawait (0, _chai.expect)(tx).to.be.revertedWithCustomError((0, _errors.Errors)(hre), 'COLLATERAL_VALUE_LESS_THAN_REQUIRED').withArgs('15001000000000000', '75000000000000000', 5e4);",
                  "err": {},
                  "uuid": "f6a569b9-004d-43f4-b99d-636cfcf77558",
                  "parentUUID": "38dcc5a5-bd4f-4b49-a34b-fd772c5b7639",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "cb6701a9-a41c-4cea-baa7-c214a770df4a",
                "afa157af-3198-499e-917a-5a169d43bd5d",
                "c6d9d858-baf7-401c-9c0f-9e409f96272c",
                "7bfed51b-62b3-4958-9a8d-d2615fbbb439",
                "a807807a-2797-47aa-bb9a-3814e7849792",
                "d062fd46-0e16-425e-a367-448964524168",
                "e9400d95-e325-4f14-8248-9bddb38c1d1f",
                "f6a569b9-004d-43f4-b99d-636cfcf77558"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 867,
              "root": false,
              "rootEmpty": false,
              "_timeout": 30000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 30000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 30000
    }
  ],
  "meta": {
    "mocha": {
      "version": "10.2.0"
    },
    "mochawesome": {
      "options": {
        "quiet": false,
        "reportFilename": "mochawesome",
        "saveHtml": true,
        "saveJson": true,
        "consoleReporter": "spec",
        "useInlineDiffs": false,
        "code": true
      },
      "version": "7.1.3"
    },
    "marge": {
      "options": {
        "reportDir": "docs/test-report",
        "assetsDir": "docs/test-report/assets",
        "reportTitle": "Kresko Protocol Hardhat Test Report",
        "reportPageTitle": "Kresko Protocol Hardhat Test Report"
      },
      "version": "6.2.0"
    }
  }
}