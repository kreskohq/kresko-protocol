{
  "language": "Solidity",
  "sources": {
    "@kreskolabs/gnosis-safe-contracts/contracts/base/Executor.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/Enum.sol\";\n\n/// @title Executor - A contract that can execute transactions\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Executor {\n    function execute(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 txGas\n    ) internal returns (bool success) {\n        if (operation == Enum.Operation.DelegateCall) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n            }\n        } else {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n            }\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/base/FallbackManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../common/SelfAuthorized.sol\";\n\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract FallbackManager is SelfAuthorized {\n    event ChangedFallbackHandler(address handler);\n\n    // keccak256(\"fallback_manager.handler.address\")\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\n\n    function internalSetFallbackHandler(address handler) internal {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, handler)\n        }\n    }\n\n    /// @dev Allows to add a contract to handle fallback calls.\n    ///      Only fallback calls without value and with data will be forwarded.\n    ///      This can only be done via a Safe transaction.\n    /// @param handler contract to handle fallback calls.\n    function setFallbackHandler(address handler) public authorized {\n        internalSetFallbackHandler(handler);\n        emit ChangedFallbackHandler(handler);\n    }\n\n    // solhint-disable-next-line payable-fallback,no-complex-fallback\n    fallback() external {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let handler := sload(slot)\n            if iszero(handler) {\n                return(0, 0)\n            }\n            calldatacopy(0, 0, calldatasize())\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            mstore(calldatasize(), shl(96, caller()))\n            // Add 20 bytes for the address appended add the end\n            let success := call(gas(), handler, 0, 0, add(calldatasize(), 20), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if iszero(success) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/base/GuardManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\nimport \"../interfaces/IERC165.sol\";\n\ninterface Guard is IERC165 {\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address msgSender\n    ) external;\n\n    function checkAfterExecution(bytes32 txHash, bool success) external;\n}\n\nabstract contract BaseGuard is Guard {\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n        return\n            interfaceId == type(Guard).interfaceId || // 0xe6d7a83a\n            interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n}\n\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract GuardManager is SelfAuthorized {\n    event ChangedGuard(address guard);\n    // keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    /// @dev Set a guard that checks transactions before execution\n    /// @param guard The address of the guard to be used or the 0 address to disable the guard\n    function setGuard(address guard) external authorized {\n        if (guard != address(0)) {\n            require(Guard(guard).supportsInterface(type(Guard).interfaceId), \"GS300\");\n        }\n        bytes32 slot = GUARD_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, guard)\n        }\n        emit ChangedGuard(guard);\n    }\n\n    function getGuard() internal view returns (address guard) {\n        bytes32 slot = GUARD_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            guard := sload(slot)\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/base/ModuleManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\nimport \"./Executor.sol\";\n\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract ModuleManager is SelfAuthorized, Executor {\n    event EnabledModule(address module);\n    event DisabledModule(address module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    address internal constant SENTINEL_MODULES = address(0x1);\n\n    mapping(address => address) internal modules;\n\n    function setupModules(address to, bytes memory data) internal {\n        require(modules[SENTINEL_MODULES] == address(0), \"GS100\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0))\n            // Setup has to complete successfully or transaction fails.\n            require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), \"GS000\");\n    }\n\n    /// @dev Allows to add a module to the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Enables the module `module` for the Safe.\n    /// @param module Module to be whitelisted.\n    function enableModule(address module) public authorized {\n        // Module address cannot be null or sentinel.\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\n        // Module cannot be added twice.\n        require(modules[module] == address(0), \"GS102\");\n        modules[module] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = module;\n        emit EnabledModule(module);\n    }\n\n    /// @dev Allows to remove a module from the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Disables the module `module` for the Safe.\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\n    /// @param module Module to be removed.\n    function disableModule(address prevModule, address module) public authorized {\n        // Validate module address and check that it corresponds to module index.\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\n        require(modules[prevModule] == module, \"GS103\");\n        modules[prevModule] = modules[module];\n        modules[module] = address(0);\n        emit DisabledModule(module);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public virtual returns (bool success) {\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"GS104\");\n        // Execute transaction without further confirmations.\n        success = execute(to, value, data, operation, gasleft());\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public returns (bool success, bytes memory returnData) {\n        success = execTransactionFromModule(to, value, data, operation);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }\n\n    /// @dev Returns if an module is enabled\n    /// @return True if the module is enabled\n    function isModuleEnabled(address module) public view returns (bool) {\n        return SENTINEL_MODULES != module && modules[module] != address(0);\n    }\n\n    /// @dev Returns array of modules.\n    /// @param start Start of the page.\n    /// @param pageSize Maximum number of modules that should be returned.\n    /// @return array Array of modules.\n    /// @return next Start of the next page.\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next) {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        address currentModule = modules[start];\n        while (currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = currentModule;\n            currentModule = modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/base/OwnerManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/SelfAuthorized.sol\";\n\n/// @title OwnerManager - Manages a set of owners and a threshold to perform actions.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract OwnerManager is SelfAuthorized {\n    event AddedOwner(address owner);\n    event RemovedOwner(address owner);\n    event ChangedThreshold(uint256 threshold);\n\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    mapping(address => address) internal owners;\n    uint256 internal ownerCount;\n    uint256 internal threshold;\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    function setupOwners(address[] memory _owners, uint256 _threshold) internal {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"GS200\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"GS201\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"GS202\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this) && currentOwner != owner, \"GS203\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"GS204\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`.\n    /// @param owner New owner address.\n    /// @param _threshold New threshold.\n    function addOwnerWithThreshold(address owner, uint256 _threshold) public authorized {\n        // Owner address cannot be null, the sentinel or the Safe itself.\n        require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this), \"GS203\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"GS204\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.\n    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\n    /// @param owner Owner address to be removed.\n    /// @param _threshold New threshold.\n    function removeOwner(\n        address prevOwner,\n        address owner,\n        uint256 _threshold\n    ) public authorized {\n        // Only allow to remove an owner, if threshold can still be reached.\n        require(ownerCount - 1 >= _threshold, \"GS201\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"GS203\");\n        require(owners[prevOwner] == owner, \"GS205\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to swap/replace an owner from the Safe with another address.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\n    /// @param oldOwner Owner address to be replaced.\n    /// @param newOwner New owner address.\n    function swapOwner(\n        address prevOwner,\n        address oldOwner,\n        address newOwner\n    ) public authorized {\n        // Owner address cannot be null, the sentinel or the Safe itself.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS && newOwner != address(this), \"GS203\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"GS204\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"GS203\");\n        require(owners[prevOwner] == oldOwner, \"GS205\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }\n\n    /// @dev Allows to update the number of required confirmations by Safe owners.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Changes the threshold of the Safe to `_threshold`.\n    /// @param _threshold New threshold.\n    function changeThreshold(uint256 _threshold) public authorized {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"GS201\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"GS202\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }\n\n    function getThreshold() public view returns (uint256) {\n        return threshold;\n    }\n\n    function isOwner(address owner) public view returns (bool) {\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\n    }\n\n    /// @dev Returns array of owners.\n    /// @return Array of Safe owners.\n    function getOwners() public view returns (address[] memory) {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while (currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index++;\n        }\n        return array;\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/Enum.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {Call, DelegateCall}\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/EtherPaymentFallback.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract EtherPaymentFallback {\n    event SafeReceived(address indexed sender, uint256 value);\n\n    /// @dev Fallback function accepts Ether transactions.\n    receive() external payable {\n        emit SafeReceived(msg.sender, msg.value);\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/SecuredTokenTransfer.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SecuredTokenTransfer - Secure token transfer\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SecuredTokenTransfer {\n    /// @dev Transfers a token and returns if it was a success\n    /// @param token Token that should be transferred\n    /// @param receiver Receiver to whom the token should be transferred\n    /// @param amount The amount of tokens that should be transferred\n    function transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal returns (bool transferred) {\n        // 0xa9059cbb - keccack(\"transfer(address,uint256)\")\n        bytes memory data = abi.encodeWithSelector(0xa9059cbb, receiver, amount);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We write the return value to scratch space.\n            // See https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory\n            let success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            switch returndatasize()\n                case 0 {\n                    transferred := success\n                }\n                case 0x20 {\n                    transferred := iszero(or(iszero(success), iszero(mload(0))))\n                }\n                default {\n                    transferred := 0\n                }\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/SelfAuthorized.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SelfAuthorized - authorizes current contract to perform actions\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SelfAuthorized {\n    function requireSelfCall() private view {\n        require(msg.sender == address(this), \"GS031\");\n    }\n\n    modifier authorized() {\n        // This is a function call as it minimized the bytecode size\n        requireSelfCall();\n        _;\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/SignatureDecoder.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SignatureDecoder - Decodes signatures that a encoded as bytes\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SignatureDecoder {\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\n    /// @notice Make sure to perform a bounds check for @param pos, to avoid out of bounds access on @param signatures\n    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\n    /// @param signatures concatenated rsv signatures\n    function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/Singleton.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Singleton - Base for singleton contracts (should always be first super contract)\n///         This contract is tightly coupled to our proxy contract (see `proxies/GnosisSafeProxy.sol`)\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract Singleton {\n    // singleton always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\n    // It should also always be ensured that the address is stored alone (uses a full word)\n    address private singleton;\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/StorageAccessible.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title StorageAccessible - generic base contract that allows callers to access all internal storage.\n/// @notice See https://github.com/gnosis/util-contracts/blob/bb5fe5fb5df6d8400998094fb1b32a178a47c3a1/contracts/StorageAccessible.sol\ncontract StorageAccessible {\n    /**\n     * @dev Reads `length` bytes of storage in the currents contract\n     * @param offset - the offset in the current contract's storage in words to start reading from\n     * @param length - the number of words (32 bytes) of data to read\n     * @return the bytes that were read.\n     */\n    function getStorageAt(uint256 offset, uint256 length) public view returns (bytes memory) {\n        bytes memory result = new bytes(length * 32);\n        for (uint256 index = 0; index < length; index++) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let word := sload(add(offset, index))\n                mstore(add(add(result, 0x20), mul(index, 0x20)), word)\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Performs a delegatecall on a targetContract in the context of self.\n     * Internally reverts execution to avoid side effects (making it static).\n     *\n     * This method reverts with data equal to `abi.encode(bool(success), bytes(response))`.\n     * Specifically, the `returndata` after a call to this method will be:\n     * `success:bool || response.length:uint256 || response:bytes`.\n     *\n     * @param targetContract Address of the contract containing the code to execute.\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\n     */\n    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let success := delegatecall(gas(), targetContract, add(calldataPayload, 0x20), mload(calldataPayload), 0, 0)\n\n            mstore(0x00, success)\n            mstore(0x20, returndatasize())\n            returndatacopy(0x40, 0, returndatasize())\n            revert(0, add(returndatasize(), 0x40))\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/external/GnosisSafeMath.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title GnosisSafeMath\n * @dev Math operations with safety checks that revert on error\n * Renamed from SafeMath to GnosisSafeMath to avoid conflicts\n * TODO: remove once open zeppelin update to solc 0.5.0\n */\nlibrary GnosisSafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @notice More details at https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/IERC165.sol\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/interfaces/ISignatureValidator.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\ncontract ISignatureValidatorConstants {\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;\n}\n\nabstract contract ISignatureValidator is ISignatureValidatorConstants {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param _data Arbitrary length data signed on the behalf of address(this)\n     * @param _signature Signature byte array associated with _data\n     *\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(bytes memory _data, bytes memory _signature) public view virtual returns (bytes4);\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/proxies/GnosisSafeProxy.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\n/// @author Richard Meissner - <richard@gnosis.io>\ninterface IProxy {\n    function masterCopy() external view returns (address);\n}\n\n/// @title GnosisSafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract GnosisSafeProxy {\n    // singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\n    address internal singleton;\n\n    /// @dev Constructor function sets address of singleton contract.\n    /// @param _singleton Singleton address.\n    constructor(address _singleton) {\n        require(_singleton != address(0), \"Invalid singleton address provided\");\n        singleton = _singleton;\n    }\n\n    /// @dev Fallback function forwards all transactions and returns all received return data.\n    fallback() external payable {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\n                mstore(0, _singleton)\n                return(0, 0x20)\n            }\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/proxies/IProxyCreationCallback.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"./GnosisSafeProxy.sol\";\n\ninterface IProxyCreationCallback {\n    function proxyCreated(\n        GnosisSafeProxy proxy,\n        address _singleton,\n        bytes calldata initializer,\n        uint256 saltNonce\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SignedSafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMathUpgradeable {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/presets/ERC20PresetMinterPauser.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../extensions/ERC20Burnable.sol\";\nimport \"../extensions/ERC20Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC20PresetMinterPauser is Context, AccessControlEnumerable, ERC20Burnable, ERC20Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Pausable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "src/contracts/diamond/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable no-complex-fallback  */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable no-empty-blocks */\n\npragma solidity >=0.8.14;\n\nimport {IDiamondCutFacet} from \"./interfaces/IDiamondCutFacet.sol\";\nimport {Authorization, Role} from \"../libs/Authorization.sol\";\nimport {GeneralEvent} from \"../libs/Events.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\nimport {initializeDiamondCut} from \"./libs/LibDiamondCut.sol\";\nimport {ds} from \"./DiamondStorage.sol\";\n\ncontract Diamond {\n    struct Initialization {\n        address initContract;\n        bytes initData;\n    }\n\n    constructor(\n        address _owner,\n        IDiamondCutFacet.FacetCut[] memory _diamondCut,\n        Initialization[] memory _initializations\n    ) {\n        ds().initialize(_owner);\n        ds().diamondCut(_diamondCut, address(0), \"\");\n        Authorization._grantRole(Role.ADMIN, _owner);\n\n        for (uint256 i = 0; i < _initializations.length; i++) {\n            initializeDiamondCut(_initializations[i].initContract, _initializations[i].initData);\n        }\n\n        emit GeneralEvent.Initialized(_owner, ds().storageVersion);\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        // get facet from function selectors\n        address facet = ds().selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), Error.DIAMOND_INVALID_FUNCTION_SIGNATURE);\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "src/contracts/diamond/DiamondState.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {EnumerableSet} from \"../libs/EnumerableSet.sol\";\nimport {FacetAddressAndPosition, FacetFunctionSelectors, RoleData, ENTERED, NOT_ENTERED} from \"./DiamondTypes.sol\";\n\nimport {LibDiamondCut} from \"./libs/LibDiamondCut.sol\";\nimport {LibOwnership} from \"./libs/LibOwnership.sol\";\n\nusing LibDiamondCut for DiamondState global;\nusing LibOwnership for DiamondState global;\n\n/* -------------------------------------------------------------------------- */\n/*                                 Main Layout                                */\n/* -------------------------------------------------------------------------- */\n\nstruct DiamondState {\n    /* -------------------------------------------------------------------------- */\n    /*                                   Proxy                                    */\n    /* -------------------------------------------------------------------------- */\n    /// @notice Maps function selector to the facet address and\n    /// the position of the selector in the facetFunctionSelectors.selectors array\n    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n    /// @notice Maps facet addresses to function selectors\n    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n    /// @notice Facet addresses\n    address[] facetAddresses;\n    /// @notice ERC165 query implementation\n    mapping(bytes4 => bool) supportedInterfaces;\n    /* -------------------------------------------------------------------------- */\n    /*                               Initialization                               */\n    /* -------------------------------------------------------------------------- */\n    /// @notice Initialization status\n    bool initialized;\n    /// @notice Domain field separator\n    bytes32 domainSeparator;\n    /* -------------------------------------------------------------------------- */\n    /*                                  Ownership                                 */\n    /* -------------------------------------------------------------------------- */\n    /// @notice Current owner of the diamond\n    address contractOwner;\n    /// @notice Pending new diamond owner\n    address pendingOwner;\n    /// @notice Storage version\n    uint8 storageVersion;\n    /// @notice address(this) replacement for FF\n    address self;\n    /* -------------------------------------------------------------------------- */\n    /*                               Access Control                               */\n    /* -------------------------------------------------------------------------- */\n    mapping(bytes32 => RoleData) _roles;\n    mapping(bytes32 => EnumerableSet.AddressSet) _roleMembers;\n    /* -------------------------------------------------------------------------- */\n    /*                                 Reentrancy                                 */\n    /* -------------------------------------------------------------------------- */\n    uint256 entered;\n}\n"
    },
    "src/contracts/diamond/DiamondStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\npragma solidity >=0.8.14;\n\nimport \"./DiamondState.sol\";\n\n// Storage position\nbytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"kresko.diamond.storage\");\n\nfunction ds() pure returns (DiamondState storage state) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n        state.slot := position\n    }\n}\n"
    },
    "src/contracts/diamond/DiamondTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n/// @dev set the initial value to 1 as we do not\n/// wanna hinder possible gas refunds by setting it to 0 on exit.\n\n/* -------------------------------------------------------------------------- */\n/*                                 Reentrancy                                 */\n/* -------------------------------------------------------------------------- */\nuint256 constant NOT_ENTERED = 1;\nuint256 constant ENTERED = 2;\n\n/* ========================================================================== */\n/*                                   STRUCTS                                  */\n/* ========================================================================== */\n\nstruct FacetAddressAndPosition {\n    address facetAddress;\n    // position in facetFunctionSelectors.functionSelectors array\n    uint96 functionSelectorPosition;\n}\n\nstruct FacetFunctionSelectors {\n    bytes4[] functionSelectors;\n    // position of facetAddress in facetAddresses array\n    uint256 facetAddressPosition;\n}\n\nstruct RoleData {\n    mapping(address => bool) members;\n    bytes32 adminRole;\n}\n"
    },
    "src/contracts/diamond/facets/AuthorizationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IAuthorizationFacet} from \"../interfaces/IAuthorizationFacet.sol\";\n\nimport {Authorization, Role} from \"../../libs/Authorization.sol\";\n\n/**\n * @title Enumerable access control for the EIP2535-pattern following the OZ implementation.\n * @author Kresko\n * @notice The storage area is in the main proxy diamond storage.\n * @dev Difference here is the logic library that is shared and reused, there is no state here.\n */\n\ncontract AuthorizationFacet is IAuthorizationFacet {\n    /**\n     * @dev OpenZeppelin\n     * Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * @notice WARNING:\n     * When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block.\n     *\n     * See the following forum post for more information:\n     * - https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296\n     *\n     * @dev Kresko\n     *\n     * TL;DR above:\n     *\n     * - If you iterate the EnumSet outside a single block scope you might get different results.\n     * - Since when EnumSet member is deleted it is replaced with the highest index.\n     * @return address with the `role`\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address) {\n        return Authorization.getRoleMember(role, index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     * @notice See warning in {getRoleMember} if combining these two\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256) {\n        return Authorization.getRoleMemberCount(role);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external {\n        Authorization.grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * @notice Requirements\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external {\n        Authorization._revokeRole(role, account);\n    }\n\n    function hasRole(bytes32 role, address account) external view returns (bool) {\n        return Authorization.hasRole(role, account);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * @notice To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32) {\n        return Authorization.getRoleAdmin(role);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * @notice Requirements\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external {\n        Authorization._renounceRole(role, account);\n    }\n}\n"
    },
    "src/contracts/diamond/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IDiamondCutFacet} from \"../interfaces/IDiamondCutFacet.sol\";\nimport {DiamondModifiers} from \"../../shared/Modifiers.sol\";\nimport {initializeDiamondCut} from \"../libs/LibDiamondCut.sol\";\nimport {ds} from \"../DiamondStorage.sol\";\n\ncontract DiamondCutFacet is DiamondModifiers, IDiamondCutFacet {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///  a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override onlyOwner {\n        ds().diamondCut(_diamondCut, _init, _calldata);\n    }\n\n    /// @notice Use an initializer contract without doing modifications\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    /// - _calldata is executed with delegatecall on _init\n    function upgradeState(address _init, bytes calldata _calldata) external onlyOwner {\n        initializeDiamondCut(_init, _calldata);\n    }\n}\n"
    },
    "src/contracts/diamond/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IDiamondLoupeFacet} from \"../interfaces/IDiamondLoupeFacet.sol\";\nimport {ds, DiamondState} from \"../DiamondStorage.sol\";\n\ncontract DiamondLoupeFacet is IDiamondLoupeFacet {\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external view override returns (Facet[] memory facets_) {\n        DiamondState storage s = ds();\n        uint256 numFacets = s.facetAddresses.length;\n        facets_ = new Facet[](numFacets);\n        for (uint256 i; i < numFacets; i++) {\n            address facetAddress_ = s.facetAddresses[i];\n            facets_[i].facetAddress = facetAddress_;\n            facets_[i].functionSelectors = s.facetFunctionSelectors[facetAddress_].functionSelectors;\n        }\n    }\n\n    /// @notice Gets all the function selectors provided by a facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet)\n        external\n        view\n        override\n        returns (bytes4[] memory facetFunctionSelectors_)\n    {\n        facetFunctionSelectors_ = ds().facetFunctionSelectors[_facet].functionSelectors;\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view override returns (address[] memory facetAddresses_) {\n        facetAddresses_ = ds().facetAddresses;\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\n        facetAddress_ = ds().selectorToFacetAndPosition[_functionSelector].facetAddress;\n    }\n}\n"
    },
    "src/contracts/diamond/facets/DiamondOwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IDiamondOwnershipFacet} from \"../interfaces/IDiamondOwnershipFacet.sol\";\nimport {DiamondModifiers} from \"../../shared/Modifiers.sol\";\nimport {ds} from \"../DiamondStorage.sol\";\n\ncontract DiamondOwnershipFacet is DiamondModifiers, IDiamondOwnershipFacet {\n    /* -------------------------------------------------------------------------- */\n    /*                                    Write                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Initiate ownership transfer to a new address\n     * - caller must be the current contract owner\n     * - the new owner cannot be address(0)\n     * - emits a {AuthEvent.PendingOwnershipTransfer} event\n     * @param _newOwner address that is set as the pending new owner\n     */\n    function transferOwnership(address _newOwner) external override onlyOwner {\n        ds().initiateOwnershipTransfer(_newOwner);\n    }\n\n    /**\n     * @notice Transfer the ownership to the new pending owner\n     * - caller must be the pending owner\n     * - emits a {AccessEvent.OwnershipTransferred} event\n     */\n    function acceptOwnership() external override onlyPendingOwner {\n        ds().finalizeOwnershipTransfer();\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Read                                    */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Getter for the current owner\n    function owner() external view override returns (address) {\n        return ds().contractOwner;\n    }\n\n    /// @notice Getter for the pending owner\n    /// @return address\n    function pendingOwner() external view override returns (address) {\n        return ds().pendingOwner;\n    }\n\n    /// @notice Initialization status getter\n    /// @return initialized status\n    function initialized() external view returns (bool) {\n        return ds().initialized;\n    }\n}\n"
    },
    "src/contracts/diamond/facets/ERC165Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IERC165} from \"../../shared/IERC165.sol\";\n\nimport {Error} from \"../../libs/Errors.sol\";\nimport {DiamondModifiers} from \"../../shared/Modifiers.sol\";\n\nimport {ds, DiamondState} from \"../DiamondStorage.sol\";\n\ncontract ERC165Facet is DiamondModifiers, IERC165 {\n    /* -------------------------------------------------------------------------- */\n    /*                                    Read                                    */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Basic ERC165 support\n    /// @param _interfaceId interface id to support\n    function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\n        return ds().supportedInterfaces[_interfaceId];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Write                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice set or unset ERC165 using DiamondStorage.supportedInterfaces\n    /// @param interfaceIds list of interface id to set as supported\n    /// @param interfaceIdsToRemove list of interface id to unset as supported.\n    /// Technically, you can remove support of ERC165 by having the IERC165 id itself being part of that array.\n    function setERC165(bytes4[] calldata interfaceIds, bytes4[] calldata interfaceIdsToRemove) external onlyOwner {\n        DiamondState storage s = ds();\n\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            s.supportedInterfaces[interfaceIds[i]] = true;\n        }\n\n        for (uint256 i = 0; i < interfaceIdsToRemove.length; i++) {\n            s.supportedInterfaces[interfaceIdsToRemove[i]] = false;\n        }\n    }\n}\n"
    },
    "src/contracts/diamond/interfaces/IAuthorizationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface IAuthorizationFacet {\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    function grantRole(bytes32 role, address account) external;\n\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    function renounceRole(bytes32 role, address account) external;\n\n    function revokeRole(bytes32 role, address account) external;\n}\n"
    },
    "src/contracts/diamond/interfaces/IDiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface IDiamondCutFacet {\n    /// @dev  Add=0, Replace=1, Remove=2\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    /// a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "src/contracts/diamond/interfaces/IDiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupeFacet {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "src/contracts/diamond/interfaces/IDiamondOwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n/// @title Contract Ownership\ninterface IDiamondOwnershipFacet {\n    /// @dev Pending contract ownership transfer is initiated.\n    event PendingOwnershipTransfer(address indexed previousOwner, address indexed newOwner);\n    /// @dev Ownership of a contract is transferred\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Get the address of pending owner\n    /// @return pendingOwner_ The address of the pending owner.\n    function pendingOwner() external view returns (address pendingOwner_);\n\n    /// @notice Set the address of the new pending owner of the contract\n    /// @param _newOwner The address of the pending owner\n    function transferOwnership(address _newOwner) external;\n\n    /// @notice Change the ownership of the contract to the pending owner\n    function acceptOwnership() external;\n}\n"
    },
    "src/contracts/diamond/libs/LibDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {IDiamondCutFacet} from \"../interfaces/IDiamondCutFacet.sol\";\n\nimport {Meta} from \"../../libs/Meta.sol\";\nimport {DiamondEvent} from \"../../libs/Events.sol\";\nimport {DiamondState} from \"../DiamondState.sol\";\n\n// solhint-disable-next-line func-visibility\nfunction initializeDiamondCut(address _init, bytes memory _calldata) {\n    if (_init == address(0)) {\n        require(_calldata.length == 0, \"DiamondCut: _init is address(0) but_calldata is not empty\");\n    } else {\n        require(_calldata.length > 0, \"DiamondCut: _calldata is empty but _init is not address(0)\");\n        Meta.enforceHasContractCode(_init, \"DiamondCut: _init address has no code\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up the error\n                revert(string(error));\n            } else {\n                revert(\"DiamondCut: _init function reverted\");\n            }\n        }\n    }\n}\n\nlibrary LibDiamondCut {\n    /* -------------------------------------------------------------------------- */\n    /*                              Diamond Functions                             */\n    /* -------------------------------------------------------------------------- */\n\n    function diamondCut(\n        DiamondState storage self,\n        IDiamondCutFacet.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCutFacet.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCutFacet.FacetCutAction.Add) {\n                self.addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCutFacet.FacetCutAction.Replace) {\n                self.replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCutFacet.FacetCutAction.Remove) {\n                self.removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"DiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondEvent.DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(\n        DiamondState storage self,\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(_functionSelectors.length > 0, \"DiamondCut: No selectors in facet to cut\");\n        require(_facetAddress != address(0), \"DiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(self.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            self.addFacet(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = self.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"DiamondCut: Can't add function that already exists\");\n            self.addFunction(selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(\n        DiamondState storage self,\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(_functionSelectors.length > 0, \"DiamondCut: No selectors in facet to cut\");\n        require(_facetAddress != address(0), \"DiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(self.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            self.addFacet(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = self.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"DiamondCut: Can't replace function with same function\");\n            self.removeFunction(oldFacetAddress, selector);\n            self.addFunction(selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(\n        DiamondState storage self,\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(_functionSelectors.length > 0, \"DiamondCut: No selectors in facet to cut\");\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"DiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = self.selectorToFacetAndPosition[selector].facetAddress;\n            self.removeFunction(oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondState storage self, address _facetAddress) internal {\n        Meta.enforceHasContractCode(_facetAddress, \"DiamondCut: New facet has no code\");\n        self.facetFunctionSelectors[_facetAddress].facetAddressPosition = self.facetAddresses.length;\n        self.facetAddresses.push(_facetAddress);\n    }\n\n    function addFunction(\n        DiamondState storage self,\n        bytes4 _selector,\n        uint96 _selectorPosition,\n        address _facetAddress\n    ) internal {\n        self.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        self.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        self.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(\n        DiamondState storage self,\n        address _facetAddress,\n        bytes4 _selector\n    ) internal {\n        require(_facetAddress != address(0), \"DiamondCut: Can't remove function that doesn't exist\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = self.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = self.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = self.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            self.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            self.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        self.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete self.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = self.facetAddresses.length - 1;\n            uint256 facetAddressPosition = self.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = self.facetAddresses[lastFacetAddressPosition];\n                self.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                self.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            self.facetAddresses.pop();\n            delete self.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n}\n"
    },
    "src/contracts/diamond/libs/LibOwnership.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IERC165} from \"../../shared/IERC165.sol\";\nimport {IDiamondCutFacet} from \"../interfaces/IDiamondCutFacet.sol\";\nimport {IDiamondLoupeFacet} from \"../interfaces/IDiamondLoupeFacet.sol\";\nimport {IDiamondOwnershipFacet} from \"../interfaces/IDiamondOwnershipFacet.sol\";\nimport {IAuthorizationFacet} from \"../interfaces/IAuthorizationFacet.sol\";\n\nimport {GeneralEvent, AuthEvent} from \"../../libs/Events.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Meta} from \"../../libs/Meta.sol\";\n\nimport {NOT_ENTERED} from \"../DiamondTypes.sol\";\nimport {DiamondState} from \"../DiamondState.sol\";\n\nlibrary LibOwnership {\n    /* -------------------------------------------------------------------------- */\n    /*                         Initialization & Ownership                         */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Ownership initializer\n    /// @notice Only called on the first deployment\n    function initialize(DiamondState storage self, address _owner) internal {\n        require(!self.initialized, Error.ALREADY_INITIALIZED);\n        self.entered = NOT_ENTERED;\n        self.initialized = true;\n        self.storageVersion++;\n        self.contractOwner = _owner;\n\n        self.supportedInterfaces[type(IDiamondLoupeFacet).interfaceId] = true;\n        self.supportedInterfaces[type(IERC165).interfaceId] = true;\n        self.supportedInterfaces[type(IDiamondCutFacet).interfaceId] = true;\n        self.supportedInterfaces[type(IDiamondOwnershipFacet).interfaceId] = true;\n        self.supportedInterfaces[type(IAuthorizationFacet).interfaceId] = true;\n\n        emit GeneralEvent.Deployed(_owner, self.storageVersion);\n        emit AuthEvent.OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Initiate ownership transfer to a new address\n     * @param _newOwner address that is set as the pending new owner\n     * @notice caller must be the current contract owner\n     */\n    function initiateOwnershipTransfer(DiamondState storage self, address _newOwner) internal {\n        require(Meta.msgSender() == self.contractOwner, Error.DIAMOND_INVALID_OWNER);\n        require(_newOwner != address(0), \"DS: Owner cannot be 0-address\");\n\n        self.pendingOwner = _newOwner;\n\n        emit AuthEvent.PendingOwnershipTransfer(self.contractOwner, _newOwner);\n    }\n\n    /**\n     * @dev Transfer the ownership to the new pending owner\n     * @notice caller must be the pending owner\n     */\n    function finalizeOwnershipTransfer(DiamondState storage self) internal {\n        require(Meta.msgSender() == self.pendingOwner, Error.DIAMOND_INVALID_PENDING_OWNER);\n        self.contractOwner = self.pendingOwner;\n        self.pendingOwner = address(0);\n\n        emit AuthEvent.OwnershipTransferred(self.contractOwner, msg.sender);\n    }\n}\n"
    },
    "src/contracts/kiss/interfaces/IKISS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface IKISS {\n    function operatorRoleTimestamp() external returns (uint256);\n\n    function pendingOperator() external returns (address);\n\n    function kresko() external returns (address);\n}\n"
    },
    "src/contracts/kiss/KISS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol\";\n\nimport {IKreskoAssetIssuer} from \"../kreskoasset/IKreskoAssetIssuer.sol\";\nimport {IKISS} from \"./interfaces/IKISS.sol\";\nimport {Role} from \"../libs/Authorization.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @title Kresko Integrated Stable System\n * @author Kresko\n */\ncontract KISS is IKISS, IKreskoAssetIssuer, ERC20PresetMinterPauser {\n    bytes32 public constant OPERATOR_ROLE = 0x112e48a576fb3a75acc75d9fcf6e0bc670b27b1dbcd2463502e10e68cf57d6fd;\n    uint256 public constant OPERATOR_ROLE_PERIOD = 1 minutes; // testnet\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Layout                                   */\n    /* -------------------------------------------------------------------------- */\n\n    // AccessControl\n    uint256 public operatorRoleTimestamp;\n    address public pendingOperator;\n    address public kresko;\n\n    // ERC20\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Events                                   */\n    /* -------------------------------------------------------------------------- */\n    event NewMinterInitiated(address pendingNewMinter, uint256 unlockTimestamp);\n    event NewMinter(address newMinter);\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Writes                                   */\n    /* -------------------------------------------------------------------------- */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 dec_,\n        address kresko_\n    ) ERC20PresetMinterPauser(name_, symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = dec_;\n        kresko = kresko_;\n\n        // AccessControl\n        // 1. Setup admin\n        // 2. Kresko protocol can mint\n        // 3. Remove unnecessary MINTER_ROLE from multisig\n        _setupRole(Role.ADMIN, _msgSender());\n        _setupRole(Role.OPERATOR, kresko_);\n        _revokeRole(MINTER_ROLE, _msgSender());\n    }\n\n    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n        return\n            interfaceId != 0xffffffff &&\n            (interfaceId == type(IKISS).interfaceId ||\n                interfaceId == type(IKreskoAssetIssuer).interfaceId ||\n                interfaceId == 0x01ffc9a7 ||\n                interfaceId == 0x36372b07);\n    }\n\n    /**\n     * @notice Allows OPERATOR_ROLE to mint tokens\n     *\n     * @param _to address to mint tokens to\n     * @param _amount amount to mint\n     */\n    function issue(uint256 _amount, address _to) public override onlyRole(Role.OPERATOR) returns (uint256) {\n        require(msg.sender.code.length > 0, \"KISS: EOA\");\n        _mint(_to, _amount);\n        return _amount;\n    }\n\n    /**\n     * @notice Allows OPERATOR_ROLE to burn tokens\n     *\n     * @param _from address to burn tokens from\n     * @param _amount amount to burn\n     */\n    function destroy(uint256 _amount, address _from) external onlyRole(Role.OPERATOR) returns (uint256) {\n        require(msg.sender.code.length > 0, \"KISS: EOA\");\n        _burn(_from, _amount);\n        return _amount;\n    }\n\n    /**\n     * @notice Overrides `AccessControl.grantRole` for following:\n     * * Implement a cooldown period of `OPERATOR_ROLE_PERIOD` minutes for setting a new OPERATOR_ROLE\n     * * EOA cannot be granted the operator role\n     *\n     * @notice OPERATOR_ROLE can still be revoked without this cooldown period\n     * @notice PAUSER_ROLE can still be granted without this cooldown period\n     * @param _role role to grant\n     * @param _to address to grant role for\n     */\n    function grantRole(bytes32 _role, address _to)\n        public\n        override(AccessControl, IAccessControl)\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        // Default behavior\n        if (_role != Role.OPERATOR) {\n            _grantRole(_role, _to);\n            return;\n        }\n\n        // Handle operator role\n        require(_to.code.length > 0, \"KISS: EOA\");\n        if (pendingOperator != address(0)) {\n            // Ensure cooldown period\n            require(operatorRoleTimestamp < block.timestamp, \"KISS: !OPERATOR_ROLE_PERIOD\");\n            // Grant role\n            _grantRole(Role.OPERATOR, pendingOperator);\n            emit NewMinter(_msgSender());\n            // Reset pending owner\n            // No need to touch the timestamp (next call will just trigger the cooldown period)\n            pendingOperator = address(0);\n        } else if (operatorRoleTimestamp != 0) {\n            // Do not allow more than 2 minters\n            require(getRoleMemberCount(Role.OPERATOR) <= 1, \"KISS: !minterRevoked\");\n            // Set the timestamp for the cooldown period\n            operatorRoleTimestamp = block.timestamp + OPERATOR_ROLE_PERIOD;\n            // Set the pending minter, execution to upper clause next call\n            pendingOperator = _to;\n            emit NewMinterInitiated(_to, operatorRoleTimestamp);\n        } else {\n            // Initialize converter\n            _grantRole(Role.OPERATOR, _to);\n            emit NewMinter(_to);\n            // Set the timestamp, execution is not coming here again\n            operatorRoleTimestamp = block.timestamp;\n        }\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Views                                   */\n    /* -------------------------------------------------------------------------- */\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   TESTNET                                  */\n    /* -------------------------------------------------------------------------- */\n    function setMetadata(string memory _newName, string memory _newSymbol) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _name = _newSymbol;\n        _symbol = _newName;\n    }\n\n    function convertToShares(uint256 assets) external pure returns (uint256) {\n        return assets;\n    }\n\n    function convertToAssets(uint256 shares) external pure returns (uint256) {\n        return shares;\n    }\n}\n"
    },
    "src/contracts/kreskoasset/IKreskoAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport \"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"../shared/IERC20Upgradeable.sol\";\nimport {Rebase} from \"../shared/Rebase.sol\";\n\ninterface IKreskoAsset is IERC20Upgradeable, IAccessControlEnumerableUpgradeable {\n    function burn(address _from, uint256 _amount) external;\n\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _owner,\n        address _kresko\n    ) external;\n\n    function kresko() external view returns (address);\n\n    function mint(address _to, uint256 _amount) external;\n\n    function rebaseInfo() external view returns (Rebase memory);\n\n    function isRebased() external view returns (bool);\n\n    function rebase(uint256 _denominator, bool _positive) external;\n\n    function updateMetaData(\n        string memory _name,\n        string memory _symbol,\n        uint8 _version\n    ) external;\n}\n"
    },
    "src/contracts/kreskoasset/IKreskoAssetAnchor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport \"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\";\n\ninterface IKreskoAssetAnchor is IAccessControlEnumerableUpgradeable {\n    function asset() external view returns (address);\n\n    function convertToAssets(uint256 shares) external view returns (uint256);\n\n    function convertToShares(uint256 assets) external view returns (uint256);\n\n    function deposit(uint256, address) external returns (uint256);\n\n    function withdraw(\n        uint256,\n        address,\n        address\n    ) external returns (uint256);\n\n    function issue(uint256 _assets, address _to) external returns (uint256 shares);\n\n    function destroy(uint256 _assets, address _from) external returns (uint256 shares);\n\n    function initialize(\n        address _asset,\n        string memory _name,\n        string memory _symbol,\n        address _owner\n    ) external;\n\n    function maxDeposit(address) external view returns (uint256);\n\n    function maxMint(address) external view returns (uint256);\n\n    function maxRedeem(address owner) external view returns (uint256);\n\n    function maxWithdraw(address owner) external view returns (uint256);\n\n    function mint(uint256 _shares, address _receiver) external returns (uint256 assets);\n\n    function previewDeposit(uint256 assets) external view returns (uint256);\n\n    function previewMint(uint256 shares) external view returns (uint256);\n\n    function previewRedeem(uint256 shares) external view returns (uint256);\n\n    function previewWithdraw(uint256 assets) external view returns (uint256);\n\n    function renounceRole(bytes32 role, address account) external;\n\n    function revokeRole(bytes32 role, address account) external;\n\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    function symbol() external view returns (string memory);\n\n    function totalAssets() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function updateMetaData(\n        string memory _name,\n        string memory _symbol,\n        uint8 _version\n    ) external;\n}\n"
    },
    "src/contracts/kreskoasset/IKreskoAssetIssuer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n/// @title KreskoAsset issuer interface\n/// @author Kresko\n/// @notice Contract that can issue/destroy Kresko Assets through Kresko\n/// @dev This interface is used by KISS & KreskoAssetAnchor\ninterface IKreskoAssetIssuer {\n    function issue(uint256 _assets, address _to) external returns (uint256 shares);\n\n    function destroy(uint256 _assets, address _from) external returns (uint256 shares);\n\n    function convertToShares(uint256 assets) external view returns (uint256);\n\n    function convertToAssets(uint256 shares) external view returns (uint256);\n}\n"
    },
    "src/contracts/kreskoasset/KreskoAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n// solhint-disable-next-line\nimport {AccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\n\nimport {Role} from \"../libs/Authorization.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\nimport {RebaseMath, Rebase} from \"../shared/Rebase.sol\";\nimport {ERC20Upgradeable} from \"../shared/ERC20Upgradeable.sol\";\nimport {IERC165} from \"../shared/IERC165.sol\";\n\nimport {IKreskoAsset} from \"./IKreskoAsset.sol\";\n\n/**\n * @title Kresko Synthethic Asset - rebasing ERC20.\n * @author Kresko\n *\n * @notice Rebases to adjust for stock splits and reverse stock splits\n *\n * @notice Minting, burning and rebasing can only be performed by the `Role.OPERATOR`\n */\n\ncontract KreskoAsset is ERC20Upgradeable, AccessControlEnumerableUpgradeable, IERC165 {\n    using RebaseMath for uint256;\n\n    bool public isRebased;\n    address public kresko;\n    Rebase public rebaseInfo;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               Initialization                               */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Initializes a KreskoAsset ERC20 token.\n     * @dev Intended to be operated by the Kresko smart contract.\n     * @param _name The name of the KreskoAsset.\n     * @param _symbol The symbol of the KreskoAsset.\n     * @param _decimals Decimals for the asset.\n     * @param _owner The owner of this contract.\n     * @param _kresko The mint/burn operator.\n     */\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _owner,\n        address _kresko\n    ) external initializer {\n        __ERC20Upgradeable_init(_name, _symbol, _decimals);\n        __AccessControlEnumerable_init();\n        _setupRole(Role.ADMIN, _owner);\n        _setRoleAdmin(Role.OPERATOR, Role.ADMIN);\n        _setupRole(Role.OPERATOR, _kresko);\n        kresko = _kresko;\n    }\n\n    /**\n     * @notice ERC-165\n     * - IKreskoAsset, ERC20 and ERC-165 itself\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlEnumerableUpgradeable, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId != 0xffffffff &&\n            (interfaceId == type(IKreskoAsset).interfaceId || interfaceId == 0x01ffc9a7 || interfaceId == 0x36372b07);\n    }\n\n    /**\n     * @notice Updates metadata for the token in case eg. ticker change\n     * @param _name new name for the asset\n     * @param _symbol new symbol for the asset\n     * @param _version number that must be greater than latest emitted `Initialized` version\n     */\n    function updateMetaData(\n        string memory _name,\n        string memory _symbol,\n        uint8 _version\n    ) external onlyRole(Role.ADMIN) reinitializer(_version) {\n        __ERC20Upgradeable_init(_name, _symbol, decimals);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Read                                    */\n    /* -------------------------------------------------------------------------- */\n\n    function totalSupply() public view override returns (uint256) {\n        return isRebased ? _totalSupply.rebase(rebaseInfo) : _totalSupply;\n    }\n\n    function balanceOf(address _account) public view override returns (uint256) {\n        uint256 balance = _balances[_account];\n        return isRebased ? balance.rebase(rebaseInfo) : balance;\n    }\n\n    function allowance(address _owner, address _account) public view override returns (uint256) {\n        uint256 allowed = _allowances[_owner][_account];\n        return isRebased ? allowed.rebase(rebaseInfo) : allowed;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Overrides                                 */\n    /* -------------------------------------------------------------------------- */\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address _to, uint256 _amount) public override returns (bool) {\n        return _transfer(msg.sender, _to, _amount);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) public virtual override returns (bool) {\n        uint256 allowed = _allowances[_from][msg.sender]; // Saves gas for unlimited approvals.\n\n        if (allowed != type(uint256).max) {\n            require(_amount <= allowed, Error.NOT_ENOUGH_ALLOWANCE);\n            _allowances[_from][msg.sender] -= _amount;\n        }\n\n        return _transfer(_from, _to, _amount);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Restricted                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Perform a rebase, changing the denumerator and its operator\n     * @param _denominator the denumerator for the operator, 1 ether = 1\n     * @param _positive supply increasing/reducing rebase\n     * @dev denumerator values 0 and 1 ether will disable the rebase\n     */\n    function rebase(uint256 _denominator, bool _positive) external onlyRole(Role.OPERATOR) {\n        require(_denominator >= 1 ether, Error.REBASING_DENOMINATOR_LOW);\n        if (_denominator == 1 ether) {\n            isRebased = false;\n            rebaseInfo = Rebase(false, 0);\n        } else {\n            isRebased = true;\n            rebaseInfo = Rebase(_positive, _denominator);\n        }\n    }\n\n    /**\n     * @notice Mints tokens to an address.\n     * @dev Only callable by operator.\n     * @param _amount The amount of tokens to mint.\n     */\n    function mint(address _to, uint256 _amount) external onlyRole(Role.OPERATOR) {\n        _mint(_to, isRebased ? _amount.unrebase(rebaseInfo) : _amount);\n    }\n\n    /**\n     * @notice Burns tokens from an address.\n     * @dev Only callable by operator.\n     * @param _amount The amount of tokens to burn.\n     */\n    function burn(address _from, uint256 _amount) external onlyRole(Role.OPERATOR) {\n        _burn(_from, isRebased ? _amount.unrebase(rebaseInfo) : _amount);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Internal                                  */\n    /* -------------------------------------------------------------------------- */\n\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal returns (bool) {\n        if (!isRebased) {\n            _balances[_from] -= _amount;\n            unchecked {\n                _balances[_to] += _amount;\n            }\n        } else {\n            uint256 balance = balanceOf(_from);\n            require(_amount <= balance, Error.NOT_ENOUGH_BALANCE);\n\n            _amount = _amount.unrebase(rebaseInfo);\n\n            _balances[_from] -= _amount;\n            unchecked {\n                _balances[_to] += _amount;\n            }\n        }\n\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n}\n"
    },
    "src/contracts/kreskoasset/KreskoAssetAnchor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\n\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\nimport {Role} from \"../libs/Authorization.sol\";\n\nimport {IKreskoAssetIssuer} from \"./IKreskoAssetIssuer.sol\";\nimport {IKreskoAssetAnchor} from \"./IKreskoAssetAnchor.sol\";\nimport {ERC4626Upgradeable, KreskoAsset} from \"../shared/ERC4626Upgradeable.sol\";\n\n/* solhint-disable no-empty-blocks */\n\n/**\n * @title Kresko Asset Anchor - pro-rata representation of the underlying kresko asset.\n * Based on ERC-4626 by Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n * @author Kresko\n *\n * @notice Main purpose of this token is to provide a stable reference for the underlying rebasing KreskoAsset.\n * Enables easier normalized book-keeping and integration with external contracts.\n */\ncontract KreskoAssetAnchor is ERC4626Upgradeable, AccessControlEnumerableUpgradeable {\n    /* -------------------------------------------------------------------------- */\n    /*                                 Immutables                                 */\n    /* -------------------------------------------------------------------------- */\n    constructor(KreskoAsset _asset) payable ERC4626Upgradeable(_asset) {}\n\n    function initialize(\n        KreskoAsset _asset,\n        string memory _name,\n        string memory _symbol,\n        address _owner\n    ) external initializer {\n        __ERC4626Upgradeable_init(_asset, _name, _symbol);\n        __AccessControlEnumerable_init();\n        _setupRole(Role.ADMIN, _owner);\n        _setRoleAdmin(Role.OPERATOR, Role.ADMIN);\n        _setupRole(Role.OPERATOR, asset.kresko());\n    }\n\n    /**\n     * @notice ERC-165\n     * - KreskoAssetAnchor, ERC20 and ERC-165 itself\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId != 0xffffffff &&\n            (interfaceId == type(IKreskoAssetAnchor).interfaceId ||\n                interfaceId == type(IKreskoAssetIssuer).interfaceId ||\n                interfaceId == 0x01ffc9a7 ||\n                interfaceId == 0x36372b07);\n    }\n\n    /**\n     * @notice Updates metadata for the token in case eg. ticker change\n     * @param _name new name for the asset\n     * @param _symbol new symbol for the asset\n     * @param _version number that must be greater than latest emitted `Initialized` version\n     */\n    function updateMetaData(\n        string memory _name,\n        string memory _symbol,\n        uint8 _version\n    ) external onlyRole(Role.ADMIN) reinitializer(_version) {\n        __ERC20Upgradeable_init(_name, _symbol, decimals);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Overwrites                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Track the underlying amount\n     * @return Total supply for the underlying\n     */\n    function totalAssets() public view virtual override returns (uint256) {\n        return asset.totalSupply();\n    }\n\n    /**\n     * @notice Mints @param _assets of krAssets for @param _to,\n     * @notice Mints relative @return _shares of wkrAssets\n     */\n    function issue(uint256 _assets, address _to)\n        public\n        virtual\n        override\n        onlyRole(Role.OPERATOR)\n        returns (uint256 shares)\n    {\n        shares = super.issue(_assets, _to);\n    }\n\n    /**\n     * @notice Burns @param _assets of krAssets from @param _from,\n     * @notice Burns relative @return _shares of wkrAssets\n     */\n    function destroy(uint256 _assets, address _from)\n        public\n        virtual\n        override\n        onlyRole(Role.OPERATOR)\n        returns (uint256 shares)\n    {\n        shares = super.destroy(_assets, _from);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                            INTERNAL HOOKS LOGIC                            */\n    /* -------------------------------------------------------------------------- */\n\n    function _beforeWithdraw(uint256 assets, uint256 shares) internal virtual override {\n        super._beforeWithdraw(assets, shares);\n    }\n\n    function _afterDeposit(uint256 assets, uint256 shares) internal virtual override {\n        super._afterDeposit(assets, shares);\n    }\n}\n"
    },
    "src/contracts/libs/Arrays.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.14;\n\nimport {Error} from \"./Errors.sol\";\n\n/**\n * @title Library for operations on arrays\n */\nlibrary Arrays {\n    /**\n     * @dev Removes an element by copying the last element to the element to remove's place and removing\n     * the last element.\n     * @param _addresses The address array containing the item to be removed.\n     * @param _elementToRemove The element to be removed.\n     * @param _elementIndex The index of the element to be removed.\n     */\n    function removeAddress(\n        address[] storage _addresses,\n        address _elementToRemove,\n        uint256 _elementIndex\n    ) internal {\n        require(_addresses[_elementIndex] == _elementToRemove, Error.ARRAY_OUT_OF_BOUNDS);\n\n        uint256 lastIndex = _addresses.length - 1;\n        // If the index to remove is not the last one, overwrite the element at the index\n        // with the last element.\n        if (_elementIndex != lastIndex) {\n            _addresses[_elementIndex] = _addresses[lastIndex];\n        }\n        // Remove the last element.\n        _addresses.pop();\n    }\n}\n"
    },
    "src/contracts/libs/Authorization.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport \"../vendor/gnosis/IGnosisSafeL2.sol\";\nimport \"./Strings.sol\";\nimport {AuthEvent} from \"./Events.sol\";\nimport {EnumerableSet} from \"./EnumerableSet.sol\";\nimport {Error} from \"./Errors.sol\";\nimport {Meta} from \"./Meta.sol\";\nimport {ds} from \"../diamond/DiamondStorage.sol\";\n\n/* solhint-disable state-visibility */\n\n/**\n * @title Shared library for access control\n * @author Kresko\n */\n\n/* -------------------------------------------------------------------------- */\n/*                                    Roles                                   */\n/* -------------------------------------------------------------------------- */\n\nlibrary Role {\n    /// @dev role that grants other roles\n    bytes32 constant ADMIN = 0x00;\n    /// @dev keccak256(\"kresko.roles.minter.operator\")\n    bytes32 constant OPERATOR = 0x112e48a576fb3a75acc75d9fcf6e0bc670b27b1dbcd2463502e10e68cf57d6fd;\n    /// @dev keccak256(\"kresko.roles.minter.manager\")\n    bytes32 constant MANAGER = 0x46925e0f0cc76e485772167edccb8dc449d43b23b55fc4e756b063f49099e6a0;\n    /// @dev keccak256(\"kresko.roles.minter.safety.council\")\n    bytes32 constant SAFETY_COUNCIL = 0x9c387ecf1663f9144595993e2c602b45de94bf8ba3a110cb30e3652d79b581c0;\n}\n\nlibrary Authorization {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    function hasRole(bytes32 role, address account) internal view returns (bool) {\n        return ds()._roles[role].members[account];\n    }\n\n    function getRoleMemberCount(bytes32 role) internal view returns (uint256) {\n        return ds()._roleMembers[role].length();\n    }\n\n    /**\n     * @dev Revert with a standard message if `Meta.msgSender` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function checkRole(bytes32 role) internal view {\n        _checkRole(role, Meta.msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) internal view returns (bytes32) {\n        return ds()._roles[role].adminRole;\n    }\n\n    function getRoleMember(bytes32 role, uint256 index) internal view returns (address) {\n        return ds()._roleMembers[role].at(index);\n    }\n\n    /**\n     * @notice Checks if the target contract implements the ERC165 interfaceId for the multisig.\n     *\n     */\n    function setupSecurityCouncil(address _councilAddress) internal {\n        require(getRoleMemberCount(Role.SAFETY_COUNCIL) == 0, Error.SAFETY_COUNCIL_EXISTS);\n        require(IGnosisSafeL2(_councilAddress).isOwner(msg.sender), Error.ADDRESS_INVALID_SAFETY_COUNCIL);\n\n        ds()._roles[Role.SAFETY_COUNCIL].members[_councilAddress] = true;\n        ds()._roleMembers[Role.SAFETY_COUNCIL].add(_councilAddress);\n\n        emit AuthEvent.RoleGranted(Role.SAFETY_COUNCIL, _councilAddress, Meta.msgSender());\n    }\n\n    function transferSecurityCouncil(address _newCouncil) internal {\n        hasRole(Role.SAFETY_COUNCIL, msg.sender);\n        require(IGnosisSafeL2(_newCouncil).getOwners().length >= 5, Error.MULTISIG_NOT_ENOUGH_OWNERS);\n\n        // As this is called by the multisig - just check that it's not an EOA\n        ds()._roles[Role.SAFETY_COUNCIL].members[msg.sender] = false;\n        ds()._roleMembers[Role.SAFETY_COUNCIL].remove(msg.sender);\n\n        ds()._roles[Role.SAFETY_COUNCIL].members[_newCouncil] = true;\n        ds()._roleMembers[Role.SAFETY_COUNCIL].add(_newCouncil);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) internal {\n        checkRole(getRoleAdmin(role));\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) internal {\n        checkRole(getRoleAdmin(role));\n        _revokeRole(role, account);\n        ds()._roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function _renounceRole(bytes32 role, address account) internal {\n        require(account == Meta.msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        ds()._roles[role].adminRole = adminRole;\n        emit AuthEvent.RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * @notice Cannot grant the role `SAFETY_COUNCIL` - must be done via explicit function.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal ensureNotSafetyCouncil(role) {\n        if (!hasRole(role, account)) {\n            ds()._roles[role].members[account] = true;\n            ds()._roleMembers[role].add(account);\n            emit AuthEvent.RoleGranted(role, account, Meta.msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal {\n        if (hasRole(role, account)) {\n            ds()._roles[role].members[account] = false;\n            ds()._roleMembers[role].remove(account);\n            emit AuthEvent.RoleRevoked(role, account, Meta.msgSender());\n        }\n    }\n\n    /**\n     * @dev Ensure we use the explicit `grantSafetyCouncilRole` function.\n     */\n    modifier ensureNotSafetyCouncil(bytes32 role) {\n        require(role != Role.SAFETY_COUNCIL, Error.ADDRESS_INVALID_SAFETY_COUNCIL);\n        _;\n    }\n}\n"
    },
    "src/contracts/libs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity >=0.8.14;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "src/contracts/libs/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity <0.9.0;\n\n/* solhint-disable max-line-length */\n\n/**\n * @author Kresko\n * @title Error codes\n * @notice Kresko-specific revert return values and their explanation\n * @dev First number indicates the domain for the error\n */\nlibrary Error {\n    /* -------------------------------------------------------------------------- */\n    /*                                    Diamond                                 */\n    /* -------------------------------------------------------------------------- */\n\n    // Preserve readability for the diamond proxy\n    string public constant DIAMOND_INVALID_FUNCTION_SIGNATURE = \"krDiamond: function does not exist\";\n    string public constant DIAMOND_INVALID_PENDING_OWNER = \"krDiamond: Must be pending contract owner\";\n    string public constant DIAMOND_INVALID_OWNER = \"krDiamond: Must be diamond owner\";\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   1. General                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant NOT_OWNER = \"100\"; // The sender must be owner\n    string public constant NOT_OPERATOR = \"101\"; // The sender must be operator\n    string public constant ZERO_WITHDRAW = \"102\"; // Withdraw must be greater than 0\n    string public constant ZERO_DEPOSIT = \"103\"; // Deposit must be greater than 0\n    string public constant ZERO_ADDRESS = \"104\"; // Address provided cannot be address(0)\n    string public constant ALREADY_INITIALIZED = \"105\"; // Contract has already been initialized\n    string public constant RE_ENTRANCY = \"106\"; // Function does not allow re-entrant calls\n    string public constant NOT_ENOUGH_BALANCE = \"107\"; // Transfer of rebasing token exceeds value\n    string public constant NOT_ENOUGH_ALLOWANCE = \"108\"; // TransferFrom of rebasing token exceeds allowance\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   2. Minter                                 */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant NOT_LIQUIDATABLE = \"200\"; // Account has collateral deposits exceeding minCollateralValue\n    string public constant ZERO_MINT = \"201\"; // Mint amount must be greater than 0\n    string public constant ZERO_BURN = \"202\"; // Burn amount must be greater than 0\n    string public constant ADDRESS_INVALID_ORACLE = \"203\"; // Oracle address cant be set to address(0)\n    string public constant ADDRESS_INVALID_NRWT = \"204\"; // Underlying rebasing token address cant be set to address(0)\n    string public constant ADDRESS_INVALID_FEERECIPIENT = \"205\"; // Fee recipient address cant be set to address(0)\n    string public constant ADDRESS_INVALID_COLLATERAL = \"206\"; // Collateral address cant be set to address(0)\n    string public constant COLLATERAL_EXISTS = \"207\"; // Collateral has already been added into the protocol\n    string public constant COLLATERAL_INVALID_FACTOR = \"208\"; // cFactor must be greater than 1FP\n    string public constant COLLATERAL_WITHDRAW_OVERFLOW = \"209\"; // Withdraw amount cannot reduce accounts collateral value under minCollateralValue\n    string public constant KRASSET_INVALID_FACTOR = \"210\"; // kFactor must be greater than 1FP\n    string public constant KRASSET_BURN_AMOUNT_OVERFLOW = \"211\"; // Repaying more than account has debt\n    string public constant KRASSET_EXISTS = \"212\"; // KrAsset is already added\n    string public constant PARAM_CLOSE_FEE_TOO_HIGH = \"213\"; // \"Close fee exceeds MAX_CLOSE_FEE\"\n    string public constant PARAM_LIQUIDATION_INCENTIVE_LOW = \"214\"; // \"Liquidation incentive less than MIN_LIQUIDATION_INCENTIVE_MULTIPLIER\"\n    string public constant PARAM_LIQUIDATION_INCENTIVE_HIGH = \"215\"; // \"Liquidation incentive greater than MAX_LIQUIDATION_INCENTIVE_MULTIPLIER\"\n    string public constant PARAM_MIN_COLLATERAL_RATIO_LOW = \"216\"; // Minimum collateral ratio less than MIN_COLLATERALIZATION_RATIO\n    string public constant PARAM_MIN_DEBT_AMOUNT_HIGH = \"217\"; // Minimum debt param argument exceeds MAX_DEBT_VALUE\n    string public constant COLLATERAL_DOESNT_EXIST = \"218\"; // Collateral does not exist within the protocol\n    string public constant KRASSET_DOESNT_EXIST = \"219\"; // KrAsset does not exist within the protocol\n    string public constant KRASSET_NOT_MINTABLE = \"220\"; // KrAsset is not mintable\n    string public constant KRASSET_SYMBOL_EXISTS = \"221\"; // KrAsset with this symbol is already within the protocl\n    string public constant KRASSET_COLLATERAL_LOW = \"222\"; // Collateral deposits do not cover the amount being minted\n    string public constant KRASSET_MINT_AMOUNT_LOW = \"223\"; // Debt position must be greater than the minimum debt position value\n    string public constant KRASSET_MAX_SUPPLY_REACHED = \"224\"; // KrAsset being minted has reached its current supply limit\n    string public constant SELF_LIQUIDATION = \"225\"; // Account cannot liquidate itself\n    string public constant ZERO_REPAY = \"226\"; // Account cannot liquidate itself\n    string public constant STALE_PRICE = \"227\"; // Price for the asset is stale\n    string public constant LIQUIDATION_OVERFLOW = \"228\"; // Repaying more USD value than allowed\n    string public constant ADDRESS_INVALID_SAFETY_COUNCIL = \"229\"; // Account responsible for the safety council role must be a multisig\n    string public constant SAFETY_COUNCIL_EXISTS = \"230\"; // Only one council role can exist\n    string public constant NOT_SAFETY_COUNCIL = \"231\"; // Sender must have the role `Role.SAFETY_COUNCIL`\n    string public constant ACTION_PAUSED_FOR_ASSET = \"232\"; // This action is currently paused for this asset\n    string public constant INVALID_ASSET_SUPPLIED = \"233\"; // Asset supplied is not a collateral nor a krAsset\n    string public constant KRASSET_NOT_ANCHOR = \"234\"; // Address is not the anchor for the krAsset\n    string public constant INVALID_LT = \"235\"; // Liquidation threshold is greater than minimum collateralization ratio\n    string public constant COLLATERAL_INSUFFICIENT_AMOUNT = \"236\"; // Insufficient amount of collateral to complete the operation\n    string public constant MULTISIG_NOT_ENOUGH_OWNERS = \"237\"; // Multisig has invalid amount of owners\n    string public constant PARAM_OPEN_FEE_TOO_HIGH = \"238\"; // \"Close fee exceeds MAX_OPEN_FEE\"\n    string public constant INVALID_FEE_TYPE = \"239\"; // \"Invalid fee type\n    string public constant KRASSET_INVALID_ANCHOR = \"240\"; // krAsset anchor does not support the correct interfaceId\n    string public constant KRASSET_INVALID_CONTRACT = \"241\"; // krAsset does not support the correct interfaceId\n    string public constant KRASSET_MARKET_CLOSED = \"242\"; // KrAsset's market is currently closed\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   3. Staking                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant REWARD_PER_BLOCK_MISSING = \"300\"; // Each reward token must have a reward per block value\n    string public constant REWARD_TOKENS_MISSING = \"301\"; // Pool must include an array of reward token addresses\n    string public constant POOL_EXISTS = \"302\"; // Pool with this deposit token already exists\n    string public constant POOL_DOESNT_EXIST = \"303\"; // Pool with this deposit token does not exist\n    string public constant ADDRESS_INVALID_REWARD_RECIPIENT = \"304\"; // Reward recipient cant be address(0)\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   4. Libraries                             */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant ARRAY_OUT_OF_BOUNDS = \"400\"; // Array out of bounds error\n    string public constant PRICEFEEDS_MUST_MATCH_STATUS_FEEDS = \"401\"; // Supplied price feeds must match status feeds in length\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   5. KrAsset                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant REBASING_DENOMINATOR_LOW = \"500\"; // denominator of rebases must be >= 1\n    string public constant ISSUER_NOT_KRESKO = \"501\"; // issue must be done by kresko\n    string public constant REDEEMER_NOT_KRESKO = \"502\"; // redeem must be done by kresko\n    string public constant DESTROY_OVERFLOW = \"503\"; // trying to destroy more than allowed\n    string public constant ISSUE_OVERFLOW = \"504\"; // trying to destroy more than allowed\n    string public constant MINT_OVERFLOW = \"505\"; // trying to destroy more than allowed\n    string public constant DEPOSIT_OVERFLOW = \"506\"; // trying to destroy more than allowed\n    string public constant REDEEM_OVERFLOW = \"507\"; // trying to destroy more than allowed\n    string public constant WITHDRAW_OVERFLOW = \"508\"; // trying to destroy more than allowed\n    string public constant ZERO_SHARES = \"509\"; // amount of shares must be greater than 0\n    string public constant ZERO_ASSETS = \"510\"; // amount of assets must be greater than 0\n    string public constant INVALID_SCALED_AMOUNT = \"511\"; // amount of debt scaled must be greater than 0\n\n    /* -------------------------------------------------------------------------- */\n    /*                              6. STABILITY RATES                            */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant STABILITY_RATES_ALREADY_INITIALIZED = \"601\"; // stability rates for the asset are already initialized\n    string public constant INVALID_OPTIMAL_RATE = \"602\"; // the optimal price rate configured is less than 1e27 for the asset\n    string public constant INVALID_PRICE_RATE_DELTA = \"603\"; // the price rate delta configured is less than 1e27 for the asset\n    string public constant STABILITY_RATES_NOT_INITIALIZED = \"604\"; // the stability rates for the asset are not initialized\n    string public constant STABILITY_RATE_OVERFLOW = \"605\"; // the stability rates is > max uint128\n    string public constant DEBT_INDEX_OVERFLOW = \"606\"; // the debt index is > max uint128\n    string public constant KISS_NOT_SET = \"607\"; // the debt index is > max uint128\n    string public constant STABILITY_RATE_REPAYMENT_AMOUNT_ZERO = \"608\"; // interest being repaid cannot be 0\n    string public constant STABILITY_RATE_INTEREST_IS_ZERO = \"609\"; // account must have accrued interest to repay it\n    string public constant INTEREST_REPAY_NOT_PARTIAL = \"610\"; // account must have accrued interest to repay it\n\n    /* -------------------------------------------------------------------------- */\n    /*                              7. AMM ORACLE                                 */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant PAIR_ADDRESS_IS_ZERO = \"701\"; // Pair address to configure cannot be zero\n    string public constant INVALID_UPDATE_PERIOD = \"702\"; // Update period must be greater than the minimum\n    string public constant PAIR_ALREADY_EXISTS = \"703\"; // Pair with the address is already initialized\n    string public constant PAIR_DOES_NOT_EXIST = \"704\"; // Pair supplied does not exist\n    string public constant INVALID_LIQUIDITY = \"706\"; // Pair initializaition requires that the pair has liquidity\n    string public constant UPDATE_PERIOD_NOT_FINISHED = \"707\"; // Update can only be called once per update period\n    string public constant INVALID_PAIR = \"708\"; // Pair being consulted does not have the token that the price was requested for\n}\n"
    },
    "src/contracts/libs/Events.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {IDiamondCutFacet} from \"../diamond/interfaces/IDiamondCutFacet.sol\";\nimport {Action} from \"../minter/MinterTypes.sol\";\n\n/* solhint-disable var-name-mixedcase */\n\n/**\n * @author Kresko\n * @title Events\n * @notice Event definitions\n */\n\nlibrary GeneralEvent {\n    /**\n     * @dev Triggered when the contract has been deployed\n     */\n    event Deployed(address indexed owner, uint8 version);\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(address indexed operator, uint8 version);\n}\n\nlibrary DiamondEvent {\n    event DiamondCut(IDiamondCutFacet.FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n\nlibrary MinterEvent {\n    /* -------------------------------------------------------------------------- */\n    /*                                 Collateral                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Emitted when a collateral asset is added to the protocol.\n     * @dev Can only be emitted once for a given collateral asset.\n     * @param collateralAsset The address of the collateral asset.\n     * @param factor The collateral factor.\n     * @param oracle The address of the oracle.\n     * @param marketStatusOracle The address of the market status oracle.\n     */\n    event CollateralAssetAdded(\n        address indexed collateralAsset,\n        uint256 factor,\n        address indexed oracle,\n        address indexed marketStatusOracle,\n        address anchor\n    );\n\n    /**\n     * @notice Emitted when a collateral asset is updated.\n     * @param collateralAsset The address of the collateral asset.\n     * @param factor The collateral factor.\n     * @param oracle The oracle address.\n     * @param marketStatusOracle The address of the market status oracle.\n     */\n    event CollateralAssetUpdated(\n        address indexed collateralAsset,\n        uint256 factor,\n        address indexed oracle,\n        address indexed marketStatusOracle,\n        address anchor\n    );\n\n    /**\n     * @notice Emitted when an account deposits collateral.\n     * @param account The address of the account depositing collateral.\n     * @param collateralAsset The address of the collateral asset.\n     * @param amount The amount of the collateral asset that was deposited.\n     */\n    event CollateralDeposited(address indexed account, address indexed collateralAsset, uint256 indexed amount);\n\n    /**\n     * @notice Emitted when an account withdraws collateral.\n     * @param account The address of the account withdrawing collateral.\n     * @param collateralAsset The address of the collateral asset.\n     * @param amount The amount of the collateral asset that was withdrawn.\n     */\n    event CollateralWithdrawn(address indexed account, address indexed collateralAsset, uint256 indexed amount);\n\n    /**\n     * @notice Emitted when AMM oracle is set.\n     * @param ammOracle The address of the AMM oracle.\n     */\n    event AMMOracleUpdated(address indexed ammOracle);\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Kresko Assets                               */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Emitted when a Kresko asset is added to the protocol.\n     * @dev Can only be emitted once for a given Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param anchor anchor token\n     * @param kFactor The k-factor.\n     * @param oracle The address of the oracle.\n     * @param marketStatusOracle The address of the market status oracle.\n     * @param supplyLimit The total supply limit.\n     * @param closeFee The close fee percentage.\n     * @param openFee The open fee percentage.\n     */\n    event KreskoAssetAdded(\n        address indexed kreskoAsset,\n        address anchor,\n        address indexed oracle,\n        address indexed marketStatusOracle,\n        uint256 kFactor,\n        uint256 supplyLimit,\n        uint256 closeFee,\n        uint256 openFee\n    );\n\n    /**\n     * @notice Emitted when a Kresko asset's oracle is updated.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param kFactor The k-factor.\n     * @param oracle The address of the oracle.\n     * @param marketStatusOracle The address of the market status oracle.\n     * @param supplyLimit The total supply limit.\n     * @param closeFee The close fee percentage.\n     * @param openFee The open fee percentage.\n     */\n    event KreskoAssetUpdated(\n        address indexed kreskoAsset,\n        address anchor,\n        address indexed oracle,\n        address indexed marketStatusOracle,\n        uint256 kFactor,\n        uint256 supplyLimit,\n        uint256 closeFee,\n        uint256 openFee\n    );\n\n    /**\n     * @notice Emitted when an account mints a Kresko asset.\n     * @param account The address of the account minting the Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param amount The amount of the Kresko asset that was minted.\n     */\n    event KreskoAssetMinted(address indexed account, address indexed kreskoAsset, uint256 indexed amount);\n\n    /**\n     * @notice Emitted when an account burns a Kresko asset.\n     * @param account The address of the account burning the Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param amount The amount of the Kresko asset that was burned.\n     */\n    event KreskoAssetBurned(address indexed account, address indexed kreskoAsset, uint256 indexed amount);\n\n    /**\n     * @notice Emitted when an account burns a Kresko asset.\n     * @param account The address of the account burning the Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param amount The amount of the Kresko asset that was burned.\n     * @param interestRepaid The amount of the KISS repaid due to interest accrual\n     */\n    event DebtPositionClosed(\n        address indexed account,\n        address indexed kreskoAsset,\n        uint256 indexed amount,\n        uint256 interestRepaid\n    );\n\n    /**\n     * @notice Emitted when an account pays a close fee with a collateral asset upon burning a Kresko asset.\n     * @dev This can be emitted multiple times for a single Kresko asset burn.\n     * @param account The address of the account burning the Kresko asset.\n     * @param paymentCollateralAsset The address of the collateral asset used to pay the close fee.\n     * @param paymentAmount The amount of the payment collateral asset that was paid.\n     * @param paymentValue The USD value of the payment.\n     */\n    event CloseFeePaid(\n        address indexed account,\n        address indexed paymentCollateralAsset,\n        uint256 indexed paymentAmount,\n        uint256 paymentValue\n    );\n\n    /**\n     * @notice Emitted when an account pays an open fee with a collateral asset upon minting a Kresko asset.\n     * @dev This can be emitted multiple times for a single Kresko asset mint.\n     * @param account The address of the account minting the Kresko asset.\n     * @param paymentCollateralAsset The address of the collateral asset used to pay the open fee.\n     * @param paymentAmount The amount of the payment collateral asset that was paid.\n     * @param paymentValue The USD value of the payment.\n     */\n    event OpenFeePaid(\n        address indexed account,\n        address indexed paymentCollateralAsset,\n        uint256 indexed paymentAmount,\n        uint256 paymentValue\n    );\n\n    /**\n     * @notice Emitted when a liquidation occurs.\n     * @param account The address of the account being liquidated.\n     * @param liquidator The account performing the liquidation.\n     * @param repayKreskoAsset The address of the Kresko asset being paid back to the protocol by the liquidator.\n     * @param repayAmount The amount of the repay Kresko asset being paid back to the protocol by the liquidator.\n     * @param seizedCollateralAsset The address of the collateral asset being seized from the account by the liquidator.\n     * @param collateralSent The amount of the seized collateral asset being seized from the account by the liquidator.\n     */\n    event LiquidationOccurred(\n        address indexed account,\n        address indexed liquidator,\n        address indexed repayKreskoAsset,\n        uint256 repayAmount,\n        address seizedCollateralAsset,\n        uint256 collateralSent\n    );\n\n    /**\n     * @notice Emitted when a liquidation of interest occurs.\n     * @param account The address of the account being liquidated.\n     * @param liquidator The account performing the liquidation.\n     * @param repayKreskoAsset The address of the Kresko asset being paid back to the protocol by the liquidator.\n     * @param repayUSD The value of the repay Kresko asset being paid back to the protocol by the liquidator.\n     * @param seizedCollateralAsset The address of the collateral asset being seized from the account by the liquidator.\n     * @param collateralSent The amount of the seized collateral asset being seized from the account by the liquidator.\n     */\n    event InterestLiquidationOccurred(\n        address indexed account,\n        address indexed liquidator,\n        address indexed repayKreskoAsset,\n        uint256 repayUSD,\n        address seizedCollateralAsset,\n        uint256 collateralSent\n    );\n    /**\n     * @notice Emitted when a batch liquidation of interest occurs.\n     * @param account The address of the account being liquidated.\n     * @param liquidator The account performing the liquidation.\n     * @param seizedCollateralAsset The address of the collateral asset being seized from the account by the liquidator.\n     * @param repayUSD The value of the repay Kresko asset being paid back to the protocol by the liquidator.\n     * @param collateralSent The amount of the seized collateral asset being seized from the account by the liquidator.\n     */\n    event BatchInterestLiquidationOccurred(\n        address indexed account,\n        address indexed liquidator,\n        address indexed seizedCollateralAsset,\n        uint256 repayUSD,\n        uint256 collateralSent\n    );\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Parameters                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Emitted when a safety state is triggered for an asset\n     * @param action Target action\n     * @param asset Asset affected\n     * @param description change description\n     */\n    event SafetyStateChange(Action indexed action, address indexed asset, string indexed description);\n\n    /**\n     * @notice Emitted when the fee recipient is updated.\n     * @param feeRecipient The new fee recipient.\n     */\n    event FeeRecipientUpdated(address indexed feeRecipient);\n\n    /**\n     * @notice Emitted when the liquidation incentive multiplier is updated.\n     * @param liquidationIncentiveMultiplier The new liquidation incentive multiplier raw value.\n     */\n    event LiquidationIncentiveMultiplierUpdated(uint256 indexed liquidationIncentiveMultiplier);\n\n    /**\n     * @notice Emitted when the minimum collateralization ratio is updated.\n     * @param minimumCollateralizationRatio The new minimum collateralization ratio raw value.\n     */\n    event MinimumCollateralizationRatioUpdated(uint256 indexed minimumCollateralizationRatio);\n\n    /**\n     * @notice Emitted when the minimum debt value updated.\n     * @param minimumDebtValue The new minimum debt value.\n     */\n    event MinimumDebtValueUpdated(uint256 indexed minimumDebtValue);\n\n    /**\n     * @notice Emitted when the liquidation threshold value is updated\n     * @param liquidationThreshold The new liquidation threshold value.\n     */\n    event LiquidationThresholdUpdated(uint256 indexed liquidationThreshold);\n}\n\nlibrary StakingEvent {\n    event LiquidityAndStakeAdded(address indexed to, uint256 indexed amount, uint256 indexed pid);\n    event LiquidityAndStakeRemoved(address indexed to, uint256 indexed amount, uint256 indexed pid);\n    event Deposit(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event ClaimRewards(address indexed user, address indexed rewardToken, uint256 indexed amount);\n    event ClaimRewardsMulti(address indexed to);\n}\n\nlibrary AuthEvent {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event PendingOwnershipTransfer(address indexed previousOwner, address indexed newOwner);\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n}\n\nlibrary InterestRateEvent {\n    /**\n     * @dev Emitted when @param account repaid their @param asset interest @param value\n     */\n    event StabilityRateConfigured(\n        address indexed asset,\n        uint256 indexed stabilityRateBase,\n        uint256 indexed priceRateDelta,\n        uint256 rateSlope1,\n        uint256 rateSlope2\n    );\n    /**\n     * @dev Emitted when @param account repaid their @param asset interest @param value\n     */\n    event StabilityRateInterestRepaid(address indexed account, address indexed asset, uint256 value);\n    /**\n     * @dev Emitted when @param account repaid all interest @param value\n     */\n    event StabilityRateInterestBatchRepaid(address indexed account, uint256 value);\n\n    /**\n     * @notice Emitted when KISS address is set.\n     * @param KISS The address of KISS.\n     */\n    event KISSUpdated(address indexed KISS);\n}\n"
    },
    "src/contracts/libs/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.14;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SignedSafeMathUpgradeable.sol\";\n\n/* solhint-disable  func-name-mixedcase */\n\n/**\n * @title Library for fixed point arithmetic on uints\n */\n\nlibrary FixedPoint {\n    using SafeMathUpgradeable for uint256;\n    using SignedSafeMathUpgradeable for int256;\n\n    uint256 internal constant FP_DECIMALS = 18;\n    uint256 internal constant FP_SCALING_FACTOR = 10**FP_DECIMALS;\n    int256 internal constant SFP_SCALING_FACTOR = 10**18;\n\n    struct Unsigned {\n        uint256 rawValue;\n    }\n\n    struct Signed {\n        int256 rawValue;\n    }\n\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n    // For unsigned values:\n    //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\n\n    // --------------------------------------- UNSIGNED ---------------------------------------------------------------\n\n    /**\n     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5*(10**18)`.\n     * @param a uint to convert into a FixedPoint.\n     * @return the converted FixedPoint.\n     */\n    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if equal, or False.\n     */\n    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue == fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if equal, or False.\n     */\n    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue == b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue > fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue >= fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue < fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue <= fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice The minimum of `a` and `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the minimum of `a` and `b`.\n     */\n    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return a.rawValue < b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice The maximum of `a` and `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the maximum of `a` and `b`.\n     */\n    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return a.rawValue > b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice Adds two `Unsigned`s, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.add(b.rawValue));\n    }\n\n    /**\n     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return add(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Subtracts two `Unsigned`s, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.sub(b.rawValue));\n    }\n\n    /**\n     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return sub(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return sub(fromUnscaledUint(a), b);\n    }\n\n    /**\n     * @notice Multiplies two `Unsigned`s, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        // There are two caveats with this computation:\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n        // stored internally as a uint256 ~10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n        // would round to 3, but this computation produces the result 2.\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\n        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\n    }\n\n    /**\n     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Multiplies two `Unsigned`s and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        uint256 mulRaw = a.rawValue.mul(b.rawValue);\n        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\n        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\n        if (mod != 0) {\n            return Unsigned(mulFloor.add(1));\n        } else {\n            return Unsigned(mulFloor);\n        }\n    }\n\n    /**\n     * @notice Multiplies an `Unsigned` and an unscaled uint256 and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the product of `a` and `b`.\n     */\n    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\n        return Unsigned(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        // There are two caveats with this computation:\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n        // 10^41 is stored internally as a uint256 10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.div(b));\n    }\n\n    /**\n     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a uint256 numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return div(fromUnscaledUint(a), b);\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an `Unsigned` and \"ceil's\" the quotient, reverting on overflow or\n     * division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\n        uint256 divFloor = aScaled.div(b.rawValue);\n        uint256 mod = aScaled.mod(b.rawValue);\n        if (mod != 0) {\n            return Unsigned(divFloor.add(1));\n        } else {\n            return Unsigned(divFloor);\n        }\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an unscaled uint256 and \"ceil's\" the quotient, reverting on overflow or\n     * division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        // Because it is possible that a quotient gets truncated, we can't just call \"Unsigned(a.rawValue.div(b))\"\n        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\n        // This creates the possibility of overflow if b is very large.\n        return divCeil(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n     * @dev This will \"floor\" the result.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return output is `a` to the power of `b`.\n     */\n    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\n        output = fromUnscaledUint(1);\n        for (uint256 i = 0; i < b; i = i.add(1)) {\n            output = mul(output, a);\n        }\n    }\n\n    // ------------------------------------------------- SIGNED ------------------------------------------------------\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n    // For signed values:\n    //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored\n    //   internally as int256 10^76.\n\n    function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\n        require(a.rawValue >= 0, \"Negative value provided\");\n        return Unsigned(uint256(a.rawValue));\n    }\n\n    function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\n        require(a.rawValue <= uint256(type(int256).max), \"Unsigned too large\");\n        return Signed(int256(a.rawValue));\n    }\n\n    /**\n     * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5*(10**18)`.\n     * @param a int to convert into a FixedPoint.Signed.\n     * @return the converted FixedPoint.Signed.\n     */\n    function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\n        return Signed(a.mul(SFP_SCALING_FACTOR));\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a int256.\n     * @return True if equal, or False.\n     */\n    function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue == fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if equal, or False.\n     */\n    function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue == b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue > fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue >= fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue < fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue <= fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice The minimum of `a` and `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the minimum of `a` and `b`.\n     */\n    function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return a.rawValue < b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice The maximum of `a` and `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the maximum of `a` and `b`.\n     */\n    function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return a.rawValue > b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice Adds two `Signed`s, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.add(b.rawValue));\n    }\n\n    /**\n     * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return add(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Subtracts two `Signed`s, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.sub(b.rawValue));\n    }\n\n    /**\n     * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return sub(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\n        return sub(fromUnscaledInt(a), b);\n    }\n\n    /**\n     * @notice Multiplies two `Signed`s, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        // There are two caveats with this computation:\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n        // stored internally as an int256 ~10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n        // would round to 3, but this computation produces the result 2.\n        // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\n        return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\n    }\n\n    /**\n     * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Multiplies two `Signed`s and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        int256 mulRaw = a.rawValue.mul(b.rawValue);\n        int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\n        // Manual mod because SignedSafeMath doesn't support it.\n        int256 mod = mulRaw % SFP_SCALING_FACTOR;\n        if (mod != 0) {\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n            return Signed(mulTowardsZero.add(valueToAdd));\n        } else {\n            return Signed(mulTowardsZero);\n        }\n    }\n\n    /**\n     * @notice Multiplies an `Signed` and an unscaled int256 and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the product of `a` and `b`.\n     */\n    function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\n        return Signed(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        // There are two caveats with this computation:\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n        // 10^41 is stored internally as an int256 10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n        return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\n    }\n\n    /**\n     * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b an int256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.div(b));\n    }\n\n    /**\n     * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a an int256 numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\n        return div(fromUnscaledInt(a), b);\n    }\n\n    /**\n     * @notice Divides one `Signed` by an `Signed` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\n        int256 divTowardsZero = aScaled.div(b.rawValue);\n        // Manual mod because SignedSafeMath doesn't support it.\n        int256 mod = aScaled % b.rawValue;\n        if (mod != 0) {\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n            return Signed(divTowardsZero.add(valueToAdd));\n        } else {\n            return Signed(divTowardsZero);\n        }\n    }\n\n    /**\n     * @notice Divides one `Signed` by an unscaled int256 and \"ceil's\" the quotient, reverting on overflow or\n     * division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b an int256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        // Because it is possible that a quotient gets truncated, we can't just call \"Signed(a.rawValue.div(b))\"\n        // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\n        // This creates the possibility of overflow if b is very large.\n        return divAwayFromZero(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n     * @dev This will \"floor\" the result.\n     * @param a a FixedPoint.Signed.\n     * @param b a uint256 (negative exponents are not allowed).\n     * @return output is `a` to the power of `b`.\n     */\n    function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\n        output = fromUnscaledInt(1);\n        for (uint256 i = 0; i < b; i = i.add(1)) {\n            output = mul(output, a);\n        }\n    }\n\n    // ------------------- Additional Fixed Point math functions specific to Kresko protocol -------------------\n\n    function ONE_HUNDRED_PERCENT() internal pure returns (Unsigned memory) {\n        return FixedPoint.Unsigned(1e18);\n    }\n\n    function ONE_USD() internal pure returns (Unsigned memory) {\n        return FixedPoint.Unsigned(1e18);\n    }\n\n    function toFixedPoint(uint256 value) internal pure returns (Unsigned memory) {\n        return FixedPoint.Unsigned(value);\n    }\n\n    function toFixedPoint(uint128 value) internal pure returns (Unsigned memory) {\n        return FixedPoint.Unsigned(value);\n    }\n\n    function toFixedPoint(int256 value) internal pure returns (Unsigned memory) {\n        return FixedPoint.Unsigned(uint256(value));\n    }\n}\n"
    },
    "src/contracts/libs/Median.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.14;\n\n/**\n * @title Library for median calculation. Returns 0 if input array is empty.\n */\nlibrary Median {\n    function median(uint256[] memory array, uint256 length) internal pure returns (uint256) {\n        require(array.length == length, \"length != array.length\");\n        if (length == 0) {\n            return 0;\n        }\n        sort(array, 0, length);\n        return length % 2 == 0 ? (array[length / 2 - 1] + array[length / 2]) / 2 : array[length / 2];\n    }\n\n    function sort(\n        uint256[] memory array,\n        uint256 begin,\n        uint256 end\n    ) internal pure {\n        if (begin < end) {\n            uint256 j = begin;\n            uint256 pivot = array[j];\n            for (uint256 i = begin + 1; i < end; ++i) {\n                if (array[i] < pivot) {\n                    swap(array, i, ++j);\n                }\n            }\n            swap(array, begin, j);\n            sort(array, begin, j);\n            sort(array, j + 1, end);\n        }\n    }\n\n    function swap(\n        uint256[] memory array,\n        uint256 i,\n        uint256 j\n    ) internal pure {\n        (array[i], array[j]) = (array[j], array[i]);\n    }\n}\n"
    },
    "src/contracts/libs/Meta.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable no-inline-assembly */\n\npragma solidity >=0.8.14;\n\nlibrary Meta {\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(bytes(\"EIP712Domain(string name,string version,uint256 salt,address verifyingContract)\"));\n\n    function domainSeparator(string memory name, string memory version)\n        internal\n        view\n        returns (bytes32 domainSeparator_)\n    {\n        domainSeparator_ = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                getChainID(),\n                address(this)\n            )\n        );\n    }\n\n    function getChainID() internal view returns (uint256 id) {\n        assembly {\n            id := chainid()\n        }\n    }\n\n    function msgSender() internal view returns (address sender_) {\n        if (msg.sender == address(this)) {\n            bytes memory array = msg.data;\n            uint256 index = msg.data.length;\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n                sender_ := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n            }\n        } else {\n            sender_ = msg.sender;\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        /// @solidity memory-safe-assembly\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "src/contracts/libs/Percentages.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.10;\n\n/**\n * @title PercentageMath library\n * @author Aave\n * @notice Provides functions to perform percentage calculations\n * @dev Percentages are defined by default with 2 decimals of precision (100.00).\n * The precision is indicated by PERCENTAGE_FACTOR\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n **/\nlibrary Percentages {\n    // Maximum percentage factor (100.00%)\n    uint256 internal constant PERCENTAGE_FACTOR = 1e4;\n\n    // Half percentage factor (50.00%)\n    uint256 internal constant HALF_PERCENTAGE_FACTOR = 0.5e4;\n\n    /**\n     * @notice Executes a percentage multiplication\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param value The value of which the percentage needs to be calculated\n     * @param percentage The percentage of the value to be calculated\n     * @return result value percentmul percentage\n     **/\n    function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256 result) {\n        // to avoid overflow, value <= (type(uint256).max - HALF_PERCENTAGE_FACTOR) / percentage\n        assembly {\n            if iszero(or(iszero(percentage), iszero(gt(value, div(sub(not(0), HALF_PERCENTAGE_FACTOR), percentage))))) {\n                revert(0, 0)\n            }\n\n            result := div(add(mul(value, percentage), HALF_PERCENTAGE_FACTOR), PERCENTAGE_FACTOR)\n        }\n    }\n\n    /**\n     * @notice Executes a percentage division\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param value The value of which the percentage needs to be calculated\n     * @param percentage The percentage of the value to be calculated\n     * @return result value percentdiv percentage\n     **/\n    function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256 result) {\n        // to avoid overflow, value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR\n        assembly {\n            if or(\n                iszero(percentage),\n                iszero(iszero(gt(value, div(sub(not(0), div(percentage, 2)), PERCENTAGE_FACTOR))))\n            ) {\n                revert(0, 0)\n            }\n\n            result := div(add(mul(value, PERCENTAGE_FACTOR), div(percentage, 2)), percentage)\n        }\n    }\n}\n"
    },
    "src/contracts/libs/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity >=0.8.14;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "src/contracts/libs/WadRay.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.10;\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @notice Provides functions to perform calculations with Wad and Ray units\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\n * with 27 digits of precision)\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n **/\nlibrary WadRay {\n    // HALF_WAD and HALF_RAY expressed with extended notation\n    // as constant with operations are not supported in Yul assembly\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant HALF_WAD = 0.5e18;\n\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant HALF_RAY = 0.5e27;\n\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n    /**\n     * @dev Multiplies two wad, rounding half up to the nearest wad\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @param b Wad\n     * @return c = a*b, in wad\n     **/\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\n        assembly {\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, b), HALF_WAD), WAD)\n        }\n    }\n\n    /**\n     * @dev Divides two wad, rounding half up to the nearest wad\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @param b Wad\n     * @return c = a/b, in wad\n     **/\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\n        assembly {\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, WAD), div(b, 2)), b)\n        }\n    }\n\n    /**\n     * @notice Multiplies two ray, rounding half up to the nearest ray\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @param b Ray\n     * @return c = a raymul b\n     **/\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\n        assembly {\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, b), HALF_RAY), RAY)\n        }\n    }\n\n    /**\n     * @notice Divides two ray, rounding half up to the nearest ray\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @param b Ray\n     * @return c = a raydiv b\n     **/\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\n        assembly {\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, RAY), div(b, 2)), b)\n        }\n    }\n\n    /**\n     * @dev Casts ray down to wad\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @return b = a converted to wad, rounded half up to the nearest wad\n     **/\n    function rayToWad(uint256 a) internal pure returns (uint256 b) {\n        assembly {\n            b := div(a, WAD_RAY_RATIO)\n            let remainder := mod(a, WAD_RAY_RATIO)\n            if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\n                b := add(b, 1)\n            }\n        }\n    }\n\n    /**\n     * @dev Converts wad up to ray\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @return b = a converted in ray\n     **/\n    function wadToRay(uint256 a) internal pure returns (uint256 b) {\n        // to avoid overflow, b/WAD_RAY_RATIO == a\n        assembly {\n            b := mul(a, WAD_RAY_RATIO)\n\n            if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/minter/facets/AccountStateFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IAccountStateFacet} from \"../interfaces/IAccountStateFacet.sol\";\nimport {Action, Fee, KrAsset, CollateralAsset, FixedPoint} from \"../MinterTypes.sol\";\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/**\n * @author Kresko\n * @title AccountStateFacet\n * @notice Views concerning account state\n */\ncontract AccountStateFacet is IAccountStateFacet {\n    using LibDecimals for uint256;\n    using LibDecimals for uint8;\n    using LibDecimals for FixedPoint.Unsigned;\n    using FixedPoint for FixedPoint.Unsigned;\n    using FixedPoint for int256;\n    using FixedPoint for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  KrAssets                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Gets an index for the Kresko asset the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @param _kreskoAsset The asset lookup address.\n     * @return index of the minted Kresko asset.\n     */\n    function getMintedKreskoAssetsIndex(address _account, address _kreskoAsset) external view returns (uint256) {\n        return ms().getMintedKreskoAssetsIndex(_account, _kreskoAsset);\n    }\n\n    /**\n     * @notice Gets an array of Kresko assets the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @return An array of addresses of Kresko assets the account has minted.\n     */\n    function getMintedKreskoAssets(address _account) external view returns (address[] memory) {\n        return ms().mintedKreskoAssets[_account];\n    }\n\n    /**\n     * @notice Gets the Kresko asset value in USD of a particular account.\n     * @param _account The account to calculate the Kresko asset value for.\n     * @return The Kresko asset value of a particular account.\n     */\n    function getAccountKrAssetValue(address _account) external view returns (FixedPoint.Unsigned memory) {\n        return ms().getAccountKrAssetValue(_account);\n    }\n\n    /**\n     * @notice Get `_account` debt amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of debt for `_asset`\n     */\n    function kreskoAssetDebt(address _account, address _asset) external view returns (uint256) {\n        return ms().getKreskoAssetDebtScaled(_account, _asset);\n    }\n\n    /**\n     * @notice Get `_account` principal debt amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of principal debt for `_asset`\n     */\n    function kreskoAssetDebtPrincipal(address _account, address _asset) external view returns (uint256) {\n        return ms().getKreskoAssetDebtPrincipal(_account, _asset);\n    }\n\n    /**\n     * @notice Get `_account` interest amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return assetAmount the interest denominated in _asset\n     * @return kissAmount the interest denominated in KISS, ignores K-factor\n     */\n    function kreskoAssetDebtInterest(address _account, address _asset)\n        external\n        view\n        returns (uint256 assetAmount, uint256 kissAmount)\n    {\n        return ms().getKreskoAssetDebtInterest(_account, _asset);\n    }\n\n    /**\n     * @notice Get `_account` interest amount for `_asset`\n     * @param _account The account to query amount for\n     * @return kissAmount the interest denominated in KISS, ignores K-factor\n     */\n    function kreskoAssetDebtInterestTotal(address _account) external view returns (uint256 kissAmount) {\n        address[] memory mintedKreskoAssets = ms().mintedKreskoAssets[_account];\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            (, uint256 kissAmountForAsset) = ms().getKreskoAssetDebtInterest(_account, mintedKreskoAssets[i]);\n            kissAmount += kissAmountForAsset;\n        }\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Collateral                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Gets an array of collateral assets the account has deposited.\n     * @param _account The account to get the deposited collateral assets for.\n     * @return An array of addresses of collateral assets the account has deposited.\n     */\n    function getDepositedCollateralAssets(address _account) external view returns (address[] memory) {\n        return ms().depositedCollateralAssets[_account];\n    }\n\n    /**\n     * @notice Get `_account` collateral deposit amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of collateral deposited for `_asset`\n     */\n    function collateralDeposits(address _account, address _asset) external view returns (uint256) {\n        return ms().getCollateralDeposits(_account, _asset);\n    }\n\n    /**\n     * @notice Gets an index for the collateral asset the account has deposited.\n     * @param _account The account to get the index for.\n     * @param _collateralAsset The asset lookup address.\n     * @return i = index of the minted collateral asset.\n     */\n    function getDepositedCollateralAssetIndex(address _account, address _collateralAsset)\n        external\n        view\n        returns (uint256 i)\n    {\n        for (i; i < ms().depositedCollateralAssets[_account].length; i++) {\n            if (ms().depositedCollateralAssets[_account][i] == _collateralAsset) {\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Gets the collateral value of a particular account.\n     * @dev O(# of different deposited collateral assets by account) complexity.\n     * @param _account The account to calculate the collateral value for.\n     * @return The collateral value of a particular account.\n     */\n    function getAccountCollateralValue(address _account) public view returns (FixedPoint.Unsigned memory) {\n        return ms().getAccountCollateralValue(_account);\n    }\n\n    /**\n     * @notice Get an account's minimum collateral value required\n     * to back a Kresko asset amount at a given collateralization ratio.\n     * @dev Accounts that have their collateral value under the minimum collateral value are considered unhealthy,\n     *      accounts with their collateral value under the liquidation threshold are considered liquidatable.\n     * @param _account The account to calculate the minimum collateral value for.\n     * @param _ratio The collateralization ratio required: higher ratio = more collateral required\n     * @return The minimum collateral value of a particular account.\n     */\n    function getAccountMinimumCollateralValueAtRatio(address _account, FixedPoint.Unsigned memory _ratio)\n        public\n        view\n        returns (FixedPoint.Unsigned memory)\n    {\n        return ms().getAccountMinimumCollateralValueAtRatio(_account, _ratio);\n    }\n\n    /**\n     * @notice Get a list of accounts and their collateral ratios\n     * @return ratio for an `_account`\n     */\n    function getAccountCollateralRatio(address _account) public view returns (FixedPoint.Unsigned memory ratio) {\n        FixedPoint.Unsigned memory collateralValue = ms().getAccountCollateralValue(_account);\n        if (collateralValue.rawValue == 0) {\n            return FixedPoint.Unsigned(0);\n        }\n        FixedPoint.Unsigned memory krAssetValue = ms().getAccountKrAssetValue(_account);\n        if (krAssetValue.rawValue == 0) {\n            return FixedPoint.Unsigned(0);\n        }\n        ratio = collateralValue.div(krAssetValue);\n    }\n\n    function getAccountSingleCollateralValueAndRealValue(address _account, address _asset)\n        external\n        view\n        returns (FixedPoint.Unsigned memory value, FixedPoint.Unsigned memory realValue)\n    {\n        uint256 depositAmount = ms().getCollateralDeposits(_account, _asset);\n        return ms().getCollateralValueAndOraclePrice(_asset, depositAmount, false);\n    }\n\n    /**\n     * @notice Get a list of accounts and their collateral ratios\n     * @return ratios of the accounts\n     */\n    function getCollateralRatiosFor(address[] calldata _accounts) external view returns (FixedPoint.Unsigned[] memory) {\n        FixedPoint.Unsigned[] memory ratios = new FixedPoint.Unsigned[](_accounts.length);\n        for (uint256 i; i < _accounts.length; i++) {\n            ratios[i] = getAccountCollateralRatio(_accounts[i]);\n        }\n        return ratios;\n    }\n\n    /**\n     * @notice Calculates the expected fee to be taken from a user's deposited collateral assets,\n     *         by imitating calcFee without modifying state.\n     * @param _account The account to charge the open fee from.\n     * @param _kreskoAsset The address of the kresko asset being burned.\n     * @param _kreskoAssetAmount The amount of the kresko asset being minted.\n     * @param _feeType The fee type (open, close, etc).\n     * @return assets The collateral types as an array of addresses.\n     * @return amounts The collateral amounts as an array of uint256.\n     */\n    function calcExpectedFee(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kreskoAssetAmount,\n        uint256 _feeType\n    ) external view returns (address[] memory, uint256[] memory) {\n        require(_feeType <= 1, Error.INVALID_FEE_TYPE);\n\n        KrAsset memory krAsset = ms().kreskoAssets[_kreskoAsset];\n\n        // Calculate the value of the fee according to the value of the krAsset\n        FixedPoint.Unsigned memory feeValue = krAsset.fixedPointUSD(_kreskoAssetAmount).mul(\n            Fee(_feeType) == Fee.Open ? krAsset.openFee : krAsset.closeFee\n        );\n\n        address[] memory accountCollateralAssets = ms().depositedCollateralAssets[_account];\n\n        ExpectedFeeRuntimeInfo memory info; // Using ExpectedFeeRuntimeInfo struct to avoid StackTooDeep error\n        info.assets = new address[](accountCollateralAssets.length);\n        info.amounts = new uint256[](accountCollateralAssets.length);\n\n        // Return empty arrays if the fee value is 0.\n        if (feeValue.rawValue == 0) {\n            return (info.assets, info.amounts);\n        }\n\n        for (uint256 i = accountCollateralAssets.length - 1; i >= 0; i--) {\n            address collateralAssetAddress = accountCollateralAssets[i];\n\n            uint256 depositAmount = ms().collateralDeposits[_account][collateralAssetAddress];\n\n            // Don't take the collateral asset's collateral factor into consideration.\n            (FixedPoint.Unsigned memory depositValue, FixedPoint.Unsigned memory oraclePrice) = ms()\n                .getCollateralValueAndOraclePrice(collateralAssetAddress, depositAmount, true);\n\n            FixedPoint.Unsigned memory feeValuePaid;\n            uint256 transferAmount;\n            // If feeValue < depositValue, the entire fee can be charged for this collateral asset.\n            if (feeValue.isLessThan(depositValue)) {\n                transferAmount = ms().collateralAssets[collateralAssetAddress].decimals.fromCollateralFixedPointAmount(\n                    feeValue.div(oraclePrice)\n                );\n                feeValuePaid = feeValue;\n            } else {\n                transferAmount = depositAmount;\n                feeValuePaid = depositValue;\n            }\n\n            if (transferAmount > 0) {\n                info.assets[info.collateralTypeCount] = collateralAssetAddress;\n                info.amounts[info.collateralTypeCount] = transferAmount;\n                info.collateralTypeCount = info.collateralTypeCount++;\n            }\n\n            feeValue = feeValue.sub(feeValuePaid);\n            // If the entire fee has been paid, no more action needed.\n            if (feeValue.rawValue == 0) {\n                return (info.assets, info.amounts);\n            }\n        }\n        return (info.assets, info.amounts);\n    }\n\n    // ExpectedFeeRuntimeInfo is used to avoid StackTooDeep error\n    struct ExpectedFeeRuntimeInfo {\n        address[] assets;\n        uint256[] amounts;\n        uint256 collateralTypeCount;\n    }\n}\n"
    },
    "src/contracts/minter/facets/BurnFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IBurnFacet} from \"../interfaces/IBurnFacet.sol\";\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {DiamondModifiers, MinterModifiers} from \"../../shared/Modifiers.sol\";\nimport {Action, FixedPoint, KrAsset} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title BurnFacet\n * @notice Main end-user functionality concerning burning of kresko assets\n */\ncontract BurnFacet is DiamondModifiers, MinterModifiers, IBurnFacet {\n    using FixedPoint for FixedPoint.Unsigned;\n    using Arrays for address[];\n\n    /**\n     * @notice Burns existing Kresko assets.\n     * @param _account The address to burn kresko assets for\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _burnAmount The amount of the Kresko asset to be burned.\n     * @param _mintedKreskoAssetIndex The index of the collateral asset in the user's minted assets array.\n     * @notice Only needed if burning all principal debt of a particular collateral asset.\n     */\n    function burnKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _burnAmount,\n        uint256 _mintedKreskoAssetIndex\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        require(_burnAmount > 0, Error.ZERO_BURN);\n        MinterState storage s = ms();\n\n        if (s.safetyStateSet) {\n            ensureNotPaused(_kreskoAsset, Action.Repay);\n        }\n\n        // Get accounts principal debt\n        uint256 debtAmount = s.getKreskoAssetDebtPrincipal(_account, _kreskoAsset);\n\n        if (_burnAmount != type(uint256).max) {\n            require(_burnAmount <= debtAmount, Error.KRASSET_BURN_AMOUNT_OVERFLOW);\n            // Ensure principal left is either 0 or >= minDebtValue\n            _burnAmount = s.ensureNotDustPosition(_kreskoAsset, _burnAmount, debtAmount);\n        } else {\n            // _burnAmount of uint256 max, burn all principal debt\n            _burnAmount = debtAmount;\n        }\n\n        // If sender repays all principal debt of asset with no stability rate, remove it from minted assets array.\n        // For assets with stability rate the revomal is done when repaying interest\n        if (irs().srAssets[_kreskoAsset].asset == address(0) && _burnAmount == debtAmount) {\n            s.mintedKreskoAssets[_account].removeAddress(_kreskoAsset, _mintedKreskoAssetIndex);\n        }\n        // Charge the burn fee from collateral of _account\n        s.chargeCloseFee(_account, _kreskoAsset, _burnAmount);\n\n        // Record the burn\n        s.repay(_kreskoAsset, s.kreskoAssets[_kreskoAsset].anchor, _burnAmount, _account);\n\n        // Emit logs\n        emit MinterEvent.KreskoAssetBurned(_account, _kreskoAsset, _burnAmount);\n    }\n}\n"
    },
    "src/contracts/minter/facets/BurnHelperFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {IBurnHelperFacet} from \"../interfaces/IBurnHelperFacet.sol\";\nimport {DiamondModifiers, MinterModifiers} from \"../../shared/Modifiers.sol\";\nimport {Action, FixedPoint} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title BurnHelperFacet\n * @notice Helper functions for reducing positions\n */\ncontract BurnHelperFacet is DiamondModifiers, MinterModifiers, IBurnHelperFacet {\n    using FixedPoint for FixedPoint.Unsigned;\n    using Arrays for address[];\n\n    /**\n     * @notice Burns all Kresko asset debt and repays interest.\n     * @notice Account must have enough of krAsset balance to burn and ennough KISS to cover interest\n     * @param _account The address to close the position for\n     * @param _kreskoAsset The address of the Kresko asset.\n     */\n    function closeKrAssetDebtPosition(\n        address _account,\n        address _kreskoAsset\n    ) public nonReentrant kreskoAssetExists(_kreskoAsset) onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        MinterState storage s = ms();\n        if (s.safetyStateSet) {\n            super.ensureNotPaused(_kreskoAsset, Action.Repay);\n        }\n\n        // Get accounts principal debt\n        uint256 principalDebt = s.getKreskoAssetDebtPrincipal(_account, _kreskoAsset);\n        require(principalDebt != 0, Error.ZERO_BURN);\n\n        // Charge the burn fee from collateral of _account\n        s.chargeCloseFee(_account, _kreskoAsset, principalDebt);\n\n        // Record the burn\n        s.repay(_kreskoAsset, s.kreskoAssets[_kreskoAsset].anchor, principalDebt, _account);\n        uint256 kissRepayAmount = ms().repayFullStabilityRateInterest(_account, _kreskoAsset);\n\n        // If all all principal debt of asset with NO stability rate configured\n        // -> remove it from minted assets array.\n        // For assets with stability rate the revomal is done when repaying interest\n        if (irs().srAssets[_kreskoAsset].asset == address(0)) {\n            s.mintedKreskoAssets[_account].removeAddress(\n                _kreskoAsset,\n                ms().getMintedKreskoAssetsIndex(_account, _kreskoAsset)\n            );\n        }\n\n        emit MinterEvent.DebtPositionClosed(_account, _kreskoAsset, principalDebt, kissRepayAmount);\n    }\n\n    /**\n     * @notice Attempts to close all debt positions and interest\n     * @notice Account must have enough of krAsset balance to burn and ennough KISS to cover interest\n     * @param _account The address to close the positions for\n     */\n    function batchCloseKrAssetDebtPositions(\n        address _account\n    ) external onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        address[] memory mintedKreskoAssets = ms().getMintedKreskoAssets(_account);\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            closeKrAssetDebtPosition(_account, mintedKreskoAssets[i]);\n        }\n    }\n}\n"
    },
    "src/contracts/minter/facets/ConfigurationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IERC165} from \"../../shared/IERC165.sol\";\nimport {IERC20Upgradeable} from \"../../shared/IERC20Upgradeable.sol\";\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\nimport {IKISS} from \"../../kiss/interfaces/IKISS.sol\";\n\nimport {IConfigurationFacet} from \"../interfaces/IConfigurationFacet.sol\";\n\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent, GeneralEvent} from \"../../libs/Events.sol\";\nimport {Authorization, Role} from \"../../libs/Authorization.sol\";\nimport {Meta} from \"../../libs/Meta.sol\";\n\nimport {DiamondModifiers, MinterModifiers} from \"../../shared/Modifiers.sol\";\n\nimport {ds} from \"../../diamond/DiamondStorage.sol\";\n\n// solhint-disable-next-line\nimport {MinterInitArgs, CollateralAsset, KrAsset, AggregatorV2V3Interface, FixedPoint, Constants} from \"../MinterTypes.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/**\n * @author Kresko\n * @title ConfigurationFacet\n * @notice Functionality for `Role.OPERATOR` level actions.\n * @notice Can be only initialized by the `Role.ADMIN`\n */\ncontract ConfigurationFacet is DiamondModifiers, MinterModifiers, IConfigurationFacet {\n    using FixedPoint for FixedPoint.Unsigned;\n    using FixedPoint for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Initialize                                 */\n    /* -------------------------------------------------------------------------- */\n\n    function initialize(MinterInitArgs calldata args) external onlyOwner {\n        require(ms().initializations == 0, Error.ALREADY_INITIALIZED);\n        Authorization._grantRole(Role.OPERATOR, args.operator);\n        /**\n         * @notice Council can be set only by this specific function.\n         * Requirements:\n         *\n         * - address `_council` must implement ERC165 and a specific multisig interfaceId.\n         * - reverts if above is not true.\n         */\n        Authorization.setupSecurityCouncil(args.council);\n\n        /// @dev Temporarily set operator role for calling the update functions\n        Authorization._grantRole(Role.OPERATOR, msg.sender);\n\n        updateFeeRecipient(args.feeRecipient);\n        updateLiquidationIncentiveMultiplier(args.liquidationIncentiveMultiplier);\n        updateMinimumCollateralizationRatio(args.minimumCollateralizationRatio);\n        updateMinimumDebtValue(args.minimumDebtValue);\n        updateLiquidationThreshold(args.liquidationThreshold);\n        updateExtOracleDecimals(args.extOracleDecimals);\n\n        /// @dev Revoke the operator role\n        Authorization.revokeRole(Role.OPERATOR, msg.sender);\n\n        ms().initializations = 1;\n        ms().domainSeparator = Meta.domainSeparator(\"Kresko Minter\", \"V1\");\n        emit GeneralEvent.Initialized(args.operator, 1);\n    }\n\n    /**\n     * @notice Updates the fee recipient.\n     * @param _feeRecipient The new fee recipient.\n     */\n    function updateFeeRecipient(address _feeRecipient) public override onlyRole(Role.OPERATOR) {\n        require(_feeRecipient != address(0), Error.ADDRESS_INVALID_FEERECIPIENT);\n        ms().feeRecipient = _feeRecipient;\n        emit MinterEvent.FeeRecipientUpdated(_feeRecipient);\n    }\n\n    /**\n     * @notice Updates the liquidation incentive multiplier.\n     * @param _liquidationIncentiveMultiplier The new liquidation incentive multiplie.\n     */\n    function updateLiquidationIncentiveMultiplier(\n        uint256 _liquidationIncentiveMultiplier\n    ) public override onlyRole(Role.OPERATOR) {\n        require(\n            _liquidationIncentiveMultiplier >= Constants.MIN_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_LOW\n        );\n        require(\n            _liquidationIncentiveMultiplier <= Constants.MAX_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_HIGH\n        );\n        ms().liquidationIncentiveMultiplier = _liquidationIncentiveMultiplier.toFixedPoint();\n        emit MinterEvent.LiquidationIncentiveMultiplierUpdated(_liquidationIncentiveMultiplier);\n    }\n\n    /**\n     * @dev Updates the contract's collateralization ratio.\n     * @param _minimumCollateralizationRatio The new minimum collateralization ratio as a raw value\n     * for a FixedPoint.Unsigned.\n     */\n    function updateMinimumCollateralizationRatio(\n        uint256 _minimumCollateralizationRatio\n    ) public override onlyRole(Role.OPERATOR) {\n        require(\n            _minimumCollateralizationRatio >= Constants.MIN_COLLATERALIZATION_RATIO,\n            Error.PARAM_MIN_COLLATERAL_RATIO_LOW\n        );\n        ms().minimumCollateralizationRatio = _minimumCollateralizationRatio.toFixedPoint();\n        emit MinterEvent.MinimumCollateralizationRatioUpdated(_minimumCollateralizationRatio);\n    }\n\n    /**\n     * @dev Updates the contract's minimum debt value.\n     * @param _minimumDebtValue The new minimum debt value as a raw value for a FixedPoint.Unsigned.\n     */\n    function updateMinimumDebtValue(uint256 _minimumDebtValue) public override onlyRole(Role.OPERATOR) {\n        require(_minimumDebtValue <= Constants.MAX_DEBT_VALUE, Error.PARAM_MIN_DEBT_AMOUNT_HIGH);\n        ms().minimumDebtValue = _minimumDebtValue.toFixedPoint();\n        emit MinterEvent.MinimumDebtValueUpdated(_minimumDebtValue);\n    }\n\n    /**\n     * @dev Updates the contract's liquidation threshold value\n     * @param _liquidationThreshold The new liquidation threshold value\n     */\n    function updateLiquidationThreshold(uint256 _liquidationThreshold) public override onlyRole(Role.OPERATOR) {\n        // Liquidation threshold cannot be greater than minimum collateralization ratio\n        FixedPoint.Unsigned memory newThreshold = _liquidationThreshold.toFixedPoint();\n        require(newThreshold.isLessThanOrEqual(ms().minimumCollateralizationRatio), Error.INVALID_LT);\n\n        ms().liquidationThreshold = newThreshold;\n        emit MinterEvent.LiquidationThresholdUpdated(_liquidationThreshold);\n    }\n\n    /**\n     * @notice Sets the protocol AMM oracle address\n     * @param _ammOracle  The address of the oracle\n     */\n    function updateAMMOracle(address _ammOracle) external onlyOwner {\n        ms().ammOracle = _ammOracle;\n        emit MinterEvent.AMMOracleUpdated(_ammOracle);\n    }\n\n    /**\n     * @notice Sets the decimal precision of external oracle\n     * @param _decimals Amount of decimals\n     */\n    function updateExtOracleDecimals(uint8 _decimals) public onlyOwner {\n        ms().extOracleDecimals = _decimals;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 COLLATERAL                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Adds a collateral asset to the protocol.\n     * @dev Only callable by the owner and cannot be called more than once for an asset.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _anchor Underlying anchor for a krAsset collateral, needs to support IKreskoAssetAnchor.\n     * @param _factor The collateral factor of the collateral asset as a raw value for a FixedPoint.Unsigned.\n     * Must be <= 1e18.\n     * @param _priceFeedOracle The oracle address for the collateral asset's USD value.\n     * @param _marketStatusOracle The oracle address for the collateral asset's market open/closed status\n     */\n    function addCollateralAsset(\n        address _collateralAsset,\n        address _anchor,\n        uint256 _factor,\n        address _priceFeedOracle,\n        address _marketStatusOracle\n    ) external nonReentrant onlyRole(Role.OPERATOR) collateralAssetDoesNotExist(_collateralAsset) {\n        require(_collateralAsset != address(0), Error.ADDRESS_INVALID_COLLATERAL);\n        require(_priceFeedOracle != address(0), Error.ADDRESS_INVALID_ORACLE);\n        require(_factor <= FixedPoint.FP_SCALING_FACTOR, Error.COLLATERAL_INVALID_FACTOR);\n\n        bool krAsset = ms().kreskoAssets[_collateralAsset].exists;\n        require(\n            !krAsset ||\n                (IERC165(_collateralAsset).supportsInterface(type(IKISS).interfaceId)) ||\n                IERC165(_anchor).supportsInterface(type(IKreskoAssetIssuer).interfaceId),\n            Error.KRASSET_INVALID_ANCHOR\n        );\n\n        ms().collateralAssets[_collateralAsset] = CollateralAsset({\n            factor: FixedPoint.Unsigned(_factor),\n            oracle: AggregatorV2V3Interface(_priceFeedOracle),\n            marketStatusOracle: AggregatorV2V3Interface(_marketStatusOracle),\n            anchor: _anchor,\n            exists: true,\n            decimals: IERC20Upgradeable(_collateralAsset).decimals()\n        });\n        emit MinterEvent.CollateralAssetAdded(\n            _collateralAsset,\n            _factor,\n            _priceFeedOracle,\n            _marketStatusOracle,\n            _anchor\n        );\n    }\n\n    /**\n     * @notice Updates a previously added collateral asset.\n     * @dev Only callable by the owner.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _anchor Underlying anchor for a krAsset collateral, needs to support IKreskoAssetAnchor.\n     * @param _factor The new collateral factor as a raw value for a FixedPoint.Unsigned. Must be <= 1e18.\n     * @param _priceFeedOracle The new oracle address for the collateral asset.\n     * @param _marketStatusOracle The oracle address for the collateral asset's market open/closed status\n     */\n    function updateCollateralAsset(\n        address _collateralAsset,\n        address _anchor,\n        uint256 _factor,\n        address _priceFeedOracle,\n        address _marketStatusOracle\n    ) external onlyRole(Role.OPERATOR) collateralAssetExists(_collateralAsset) {\n        require(_priceFeedOracle != address(0), Error.ADDRESS_INVALID_ORACLE);\n        // Setting the factor to 0 effectively sunsets a collateral asset, which is intentionally allowed.\n        require(_factor <= FixedPoint.FP_SCALING_FACTOR, Error.COLLATERAL_INVALID_FACTOR);\n\n        if (_anchor != address(0)) {\n            ms().collateralAssets[_collateralAsset].anchor = _anchor;\n        }\n        if (_marketStatusOracle != address(0)) {\n            ms().collateralAssets[_collateralAsset].marketStatusOracle = AggregatorV2V3Interface(_marketStatusOracle);\n        }\n        if (_priceFeedOracle != address(0)) {\n            ms().collateralAssets[_collateralAsset].oracle = AggregatorV2V3Interface(_priceFeedOracle);\n        }\n\n        ms().collateralAssets[_collateralAsset].factor = _factor.toFixedPoint();\n\n        emit MinterEvent.CollateralAssetUpdated(\n            _collateralAsset,\n            _factor,\n            _priceFeedOracle,\n            _marketStatusOracle,\n            _anchor\n        );\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               Kresko Assets                                */\n    /* -------------------------------------------------------------------------- */\n    /**\n     * @notice Adds a Kresko asset to the protocol.\n     * @dev Only callable by the owner.\n     * @param _krAsset The address of the wrapped Kresko asset, needs to support IKreskoAsset.\n     * @param _anchor Underlying anchor for the krAsset, needs to support IKreskoAssetAnchor.\n     * @param _kFactor The k-factor of the Kresko asset as a raw value for a FixedPoint.Unsigned. Must be >= 1e18.\n     * @param _priceFeedOracle The oracle address for the Kresko asset.\n     * @param _marketStatusOracle The oracle address for the Kresko asset market status.\n     * @param _supplyLimit The initial total supply limit for the Kresko asset.\n     * @param _closeFee The initial close fee percentage for the Kresko asset.\n     * @param _openFee The initial open fee percentage for the Kresko asset.\n     */\n    function addKreskoAsset(\n        address _krAsset,\n        address _anchor,\n        uint256 _kFactor,\n        address _priceFeedOracle,\n        address _marketStatusOracle,\n        uint256 _supplyLimit,\n        uint256 _closeFee,\n        uint256 _openFee\n    ) external onlyRole(Role.OPERATOR) kreskoAssetDoesNotExist(_krAsset) {\n        require(_kFactor >= FixedPoint.FP_SCALING_FACTOR, Error.KRASSET_INVALID_FACTOR);\n        require(_priceFeedOracle != address(0), Error.ADDRESS_INVALID_ORACLE);\n\n        require(_closeFee <= Constants.MAX_CLOSE_FEE, Error.PARAM_CLOSE_FEE_TOO_HIGH);\n        require(_openFee <= Constants.MAX_OPEN_FEE, Error.PARAM_OPEN_FEE_TOO_HIGH);\n\n        require(\n            IERC165(_krAsset).supportsInterface(type(IKISS).interfaceId) ||\n                IERC165(_krAsset).supportsInterface(type(IKreskoAsset).interfaceId),\n            Error.KRASSET_INVALID_CONTRACT\n        );\n        require(IERC165(_anchor).supportsInterface(type(IKreskoAssetIssuer).interfaceId), Error.KRASSET_INVALID_ANCHOR);\n\n        // The diamond needs the operator role\n        require(IKreskoAsset(_krAsset).hasRole(Role.OPERATOR, address(this)), Error.NOT_OPERATOR);\n\n        // Store details.\n        ms().kreskoAssets[_krAsset] = KrAsset({\n            kFactor: _kFactor.toFixedPoint(),\n            oracle: AggregatorV2V3Interface(_priceFeedOracle),\n            marketStatusOracle: AggregatorV2V3Interface(_marketStatusOracle),\n            anchor: _anchor,\n            supplyLimit: _supplyLimit,\n            closeFee: _closeFee.toFixedPoint(),\n            openFee: _openFee.toFixedPoint(),\n            exists: true\n        });\n        emit MinterEvent.KreskoAssetAdded(\n            _krAsset,\n            _anchor,\n            _priceFeedOracle,\n            _marketStatusOracle,\n            _kFactor,\n            _supplyLimit,\n            _closeFee,\n            _openFee\n        );\n    }\n\n    /**\n     * @notice Updates the k-factor of a previously added Kresko asset.\n     * @dev Only callable by the owner.\n     * @param _krAsset The address of the Kresko asset.\n     * @param _anchor Underlying anchor for a krAsset.\n     * @param _kFactor The new k-factor as a raw value for a FixedPoint.Unsigned. Must be >= 1e18.\n     * @param _priceFeedOracle The new oracle address for the Kresko asset's USD value.\n     * @param _marketStatusOracle The oracle address for the Kresko asset market status.\n     * @param _supplyLimit The new total supply limit for the Kresko asset.\n     * @param _closeFee The new close fee percentage for the Kresko asset.\n     * @param _openFee The new open fee percentage for the Kresko asset.\n     */\n    function updateKreskoAsset(\n        address _krAsset,\n        address _anchor,\n        uint256 _kFactor,\n        address _priceFeedOracle,\n        address _marketStatusOracle,\n        uint256 _supplyLimit,\n        uint256 _closeFee,\n        uint256 _openFee\n    ) external onlyRole(Role.OPERATOR) kreskoAssetExists(_krAsset) {\n        require(_kFactor >= FixedPoint.FP_SCALING_FACTOR, Error.KRASSET_INVALID_FACTOR);\n        require(_priceFeedOracle != address(0), Error.ADDRESS_INVALID_ORACLE);\n        require(_closeFee <= Constants.MAX_CLOSE_FEE, Error.PARAM_CLOSE_FEE_TOO_HIGH);\n        require(_openFee <= Constants.MAX_OPEN_FEE, Error.PARAM_OPEN_FEE_TOO_HIGH);\n\n        KrAsset memory krAsset = ms().kreskoAssets[_krAsset];\n\n        if (address(_anchor) != address(0)) {\n            krAsset.anchor = _anchor;\n        }\n        if (address(_priceFeedOracle) != address(0)) {\n            krAsset.oracle = AggregatorV2V3Interface(_priceFeedOracle);\n        }\n        if (address(_marketStatusOracle) != address(0)) {\n            krAsset.marketStatusOracle = AggregatorV2V3Interface(_marketStatusOracle);\n        }\n\n        krAsset.kFactor = _kFactor.toFixedPoint();\n        krAsset.supplyLimit = _supplyLimit;\n        krAsset.closeFee = _closeFee.toFixedPoint();\n        krAsset.openFee = _openFee.toFixedPoint();\n        ms().kreskoAssets[_krAsset] = krAsset;\n\n        emit MinterEvent.KreskoAssetUpdated(\n            _krAsset,\n            _anchor,\n            _priceFeedOracle,\n            _marketStatusOracle,\n            _kFactor,\n            _supplyLimit,\n            _closeFee,\n            _openFee\n        );\n    }\n}\n"
    },
    "src/contracts/minter/facets/DepositWithdrawFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IDepositWithdrawFacet} from \"../interfaces/IDepositWithdrawFacet.sol\";\n\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\n\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"../../shared/SafeERC20Upgradeable.sol\";\nimport {DiamondModifiers, MinterModifiers} from \"../../shared/Modifiers.sol\";\nimport {Action, FixedPoint, KrAsset} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title DepositWithdrawFacet\n * @notice Main end-user functionality concerning collateral asset deposits and withdrawals within the Kresko protocol\n */\ncontract DepositWithdrawFacet is DiamondModifiers, MinterModifiers, IDepositWithdrawFacet {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using FixedPoint for FixedPoint.Unsigned;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Collateral                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Deposits collateral into the protocol.\n     * @param _account The user to deposit collateral for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _depositAmount The amount of the collateral asset to deposit.\n     */\n    function depositCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _depositAmount\n    ) external nonReentrant collateralAssetExists(_collateralAsset) {\n        if (ms().safetyStateSet) {\n            super.ensureNotPaused(_collateralAsset, Action.Deposit);\n        }\n\n        // Transfer tokens into this contract prior to any state changes as an extra measure against re-entrancy.\n        IERC20Upgradeable(_collateralAsset).safeTransferFrom(msg.sender, address(this), _depositAmount);\n\n        // Record the collateral deposit.\n        ms().recordCollateralDeposit(_account, _collateralAsset, _depositAmount);\n        emit MinterEvent.CollateralDeposited(_account, _collateralAsset, _depositAmount);\n    }\n\n    /**\n     * @notice Withdraws sender's collateral from the protocol.\n     * @dev Requires the post-withdrawal collateral value to violate minimum collateral requirement.\n     * @param _account The address to withdraw assets for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\n     * @param _depositedCollateralAssetIndex The index of the collateral asset in the sender's deposited collateral\n     * assets array. Only needed if withdrawing the entire deposit of a particular collateral asset.\n     */\n    function withdrawCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _depositedCollateralAssetIndex\n    ) external nonReentrant collateralAssetExists(_collateralAsset) onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        if (ms().safetyStateSet) {\n            ensureNotPaused(_collateralAsset, Action.Withdraw);\n        }\n\n        uint256 collateralDeposits = ms().getCollateralDeposits(_account, _collateralAsset);\n        _withdrawAmount = (_withdrawAmount > collateralDeposits ? collateralDeposits : _withdrawAmount);\n        ms().verifyAndRecordCollateralWithdrawal(\n            _account,\n            _collateralAsset,\n            _withdrawAmount,\n            collateralDeposits,\n            _depositedCollateralAssetIndex\n        );\n\n        IERC20Upgradeable(_collateralAsset).safeTransfer(_account, _withdrawAmount);\n        emit MinterEvent.CollateralWithdrawn(_account, _collateralAsset, _withdrawAmount);\n    }\n}\n"
    },
    "src/contracts/minter/facets/InterestLiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IInterestLiquidationFacet} from \"../interfaces/IInterestLiquidationFacet.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibDecimals, FixedPoint} from \"../libs/LibDecimals.sol\";\nimport {LibCalculation} from \"../libs/LibCalculation.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {MinterEvent, InterestRateEvent} from \"../../libs/Events.sol\";\n\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"../../shared/SafeERC20Upgradeable.sol\";\nimport {DiamondModifiers} from \"../../shared/Modifiers.sol\";\n\nimport {Constants, KrAsset} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title InterestLiquidationFacet\n * @notice Main end-user functionality concerning liquidations of accrued KISS interest within the Kresko protocol\n */\ncontract InterestLiquidationFacet is DiamondModifiers, IInterestLiquidationFacet {\n    using Arrays for address[];\n    using LibDecimals for uint8;\n    using LibDecimals for FixedPoint.Unsigned;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n    using FixedPoint for FixedPoint.Unsigned;\n    using FixedPoint for uint256;\n    using FixedPoint for int256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @notice Attempts to batch liquidate all KISS interest accrued for an account in a unhealthy position\n     * @notice Liquidator must have the KISS balance required with the Kresko contract approved\n     * @notice Checks liquidatable status on each iteration liquidating only what is necessary\n     * @param _account The account to attempt to liquidate.\n     * @param _collateralAssetToSeize The address of the collateral asset to be seized.\n     */\n    function batchLiquidateInterest(address _account, address _collateralAssetToSeize) external nonReentrant {\n        // Borrower cannot liquidate themselves\n        require(msg.sender != _account, Error.SELF_LIQUIDATION);\n        // Check that this account is below its minimum collateralization ratio and can be liquidated.\n        require(ms().isAccountLiquidatable(_account), Error.NOT_LIQUIDATABLE);\n        // Collateral exists\n        require(ms().collateralAssets[_collateralAssetToSeize].exists, Error.COLLATERAL_DOESNT_EXIST);\n\n        address[] memory mintedKreskoAssets = ms().getMintedKreskoAssets(_account);\n\n        // Loop all accounts minted assets and sum all accrued kiss interest\n        uint256 kissAmountToRepay;\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            address repayKreskoAsset = mintedKreskoAssets[i];\n            // Repays the full interest of this asset on behalf of the account being liquidated\n            kissAmountToRepay += ms().repayFullStabilityRateInterest(_account, repayKreskoAsset);\n            // If the liquidation repays the user's entire Kresko asset balance, remove it from minted assets array.\n            if (ms().kreskoAssetDebt[_account][repayKreskoAsset] == 0) {\n                ms().mintedKreskoAssets[_account].removeAddress(repayKreskoAsset, i);\n            }\n            // Check if the status with amount repaid is still underwater, if so no further liquidation is needed\n            if (\n                !ms().isAccountLiquidatable(\n                    _account,\n                    kissAmountToRepay.fromWadPriceToFixedPoint().mul(ms().liquidationIncentiveMultiplier)\n                )\n            ) break;\n        }\n\n        // Emit a separate event for batch repayment itself\n        emit InterestRateEvent.StabilityRateInterestBatchRepaid(_account, kissAmountToRepay);\n\n        // Seize collateral and send to liquidator according to the repayment made\n        uint256 collateralSeizeAmount = _seizeAndTransferCollateral(\n            _account,\n            _collateralAssetToSeize,\n            ms().getDepositedCollateralAssetIndex(_account, _collateralAssetToSeize),\n            kissAmountToRepay\n        );\n\n        emit MinterEvent.BatchInterestLiquidationOccurred(\n            _account,\n            msg.sender,\n            _collateralAssetToSeize,\n            kissAmountToRepay,\n            collateralSeizeAmount\n        );\n    }\n\n    /**\n     * @notice Attempts to liquidate all KISS interest accrued for an account in a unhealthy position\n     * @notice Liquidator must have the KISS balance required with the Kresko contract approved\n     * @param _account The account to attempt to liquidate.\n     * @param _repayKreskoAsset The address of the Kresko asset to be repaid.\n     * @param _collateralAssetToSeize The address of the collateral asset to be seized.\n     */\n    function liquidateInterest(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize\n    ) external nonReentrant {\n        // Borrower cannot liquidate themselves\n        require(msg.sender != _account, Error.SELF_LIQUIDATION);\n        // krAsset exists\n        require(ms().kreskoAssets[_repayKreskoAsset].exists, Error.KRASSET_DOESNT_EXIST);\n        // Check that this account is below its minimum collateralization ratio and can be liquidated.\n        require(ms().isAccountLiquidatable(_account), Error.NOT_LIQUIDATABLE);\n        // Collateral exists\n        require(ms().collateralAssets[_collateralAssetToSeize].exists, Error.COLLATERAL_DOESNT_EXIST);\n\n        // Repays the full interest of this asset on behalf of the account being liquidated\n        uint256 kissRepayAmount = ms().repayFullStabilityRateInterest(_account, _repayKreskoAsset);\n\n        uint256 mintedKreskoAssetIndex = ms().getMintedKreskoAssetsIndex(_account, _repayKreskoAsset);\n\n        // Seize collateral and send to liquidator according to the repayment made\n        uint256 collateralAmountSeized = _seizeAndTransferCollateral(\n            _account,\n            _collateralAssetToSeize,\n            ms().getDepositedCollateralAssetIndex(_account, _collateralAssetToSeize),\n            kissRepayAmount\n        );\n\n        // If the liquidation repays the user's entire Kresko asset balance, remove it from minted assets array.\n        if (ms().kreskoAssetDebt[_account][_repayKreskoAsset] == 0) {\n            ms().mintedKreskoAssets[_account].removeAddress(_repayKreskoAsset, mintedKreskoAssetIndex);\n        }\n\n        emit MinterEvent.InterestLiquidationOccurred(\n            _account,\n            msg.sender,\n            _repayKreskoAsset,\n            kissRepayAmount, // without the liquidation bonus\n            _collateralAssetToSeize,\n            collateralAmountSeized // with the liquidation bonus\n        );\n    }\n\n    /**\n     * @notice Internal function to perform collateral seizing when interest gets liquidated\n     * @dev\n     * @param _account Account being liquidated\n     * @param _collateralAssetToSeize Collateral asset used to liquidate the debt\n     * @param _depositedCollateralAssetIndex Deposit index for the liquidated accounts collateral\n     * @param _kissRepayAmount Accrued KISS interest value being liquidated\n     */\n    function _seizeAndTransferCollateral(\n        address _account,\n        address _collateralAssetToSeize,\n        uint256 _depositedCollateralAssetIndex,\n        uint256 _kissRepayAmount\n    ) internal returns (uint256 seizeAmount) {\n        MinterState storage s = ms();\n\n        seizeAmount = s.collateralAssets[_collateralAssetToSeize].decimals.fromCollateralFixedPointAmount(\n            LibCalculation.calculateAmountToSeize(\n                s.liquidationIncentiveMultiplier,\n                s.collateralAssets[_collateralAssetToSeize].fixedPointPrice(),\n                _kissRepayAmount.fromWadPriceToFixedPoint()\n            )\n        );\n\n        // Collateral deposits for the seized asset of the account being liquidated\n        uint256 collateralDeposit = s.getCollateralDeposits(_account, _collateralAssetToSeize);\n\n        // Default case where deposits are greater than the seized amount\n        if (collateralDeposit > seizeAmount) {\n            // Convert the value being seized into non-rebasing value\n            s.collateralDeposits[_account][_collateralAssetToSeize] -= ms()\n                .collateralAssets[_collateralAssetToSeize]\n                .toNonRebasingAmount(seizeAmount);\n        } else {\n            // This clause means user either has collateralDeposits equal or less than the _seizeAmount\n            seizeAmount = collateralDeposit;\n            // So we set the collateralDeposits to 0\n            s.collateralDeposits[_account][_collateralAssetToSeize] = 0;\n            // And remove the asset from the deposits array.\n            s.depositedCollateralAssets[_account].removeAddress(\n                _collateralAssetToSeize,\n                _depositedCollateralAssetIndex\n            );\n        }\n\n        // Send liquidator the seized collateral.\n        IERC20Upgradeable(_collateralAssetToSeize).safeTransfer(msg.sender, seizeAmount);\n    }\n}\n"
    },
    "src/contracts/minter/facets/LiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n// solhint-disable not-rely-on-time\n\nimport {ILiquidationFacet} from \"../interfaces/ILiquidationFacet.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibDecimals, FixedPoint} from \"../libs/LibDecimals.sol\";\nimport {LibCalculation} from \"../libs/LibCalculation.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"../../shared/SafeERC20Upgradeable.sol\";\nimport {DiamondModifiers} from \"../../shared/Modifiers.sol\";\n\nimport {Constants, KrAsset} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title LiquidationFacet\n * @notice Main end-user functionality concerning liquidations within the Kresko protocol\n */\ncontract LiquidationFacet is DiamondModifiers, ILiquidationFacet {\n    using Arrays for address[];\n    using LibDecimals for uint8;\n    using LibDecimals for FixedPoint.Unsigned;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n    using FixedPoint for FixedPoint.Unsigned;\n    using FixedPoint for uint256;\n    using FixedPoint for int256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @notice Attempts to liquidate an account by repaying the portion of the account's Kresko asset\n     *         princpal debt, receiving in return a portion of the account's collateral at a discounted rate.\n     * @param _account The account to attempt to liquidate.\n     * @param _repayKreskoAsset The address of the Kresko asset to be repaid.\n     * @param _repayAmount The amount of the Kresko asset to be repaid.\n     * @param _collateralAssetToSeize The address of the collateral asset to be seized.\n     * @param _mintedKreskoAssetIndex The index of the Kresko asset in the account's minted assets array.\n     * @param _depositedCollateralAssetIndex Index of the collateral asset in the account's collateral assets array.\n     */\n\n    function liquidate(\n        address _account,\n        address _repayKreskoAsset,\n        uint256 _repayAmount,\n        address _collateralAssetToSeize,\n        uint256 _mintedKreskoAssetIndex,\n        uint256 _depositedCollateralAssetIndex\n    ) external nonReentrant {\n        MinterState storage s = ms();\n        {\n            // No zero repays\n            require(_repayAmount > 0, Error.ZERO_REPAY);\n            // Borrower cannot liquidate themselves\n            require(msg.sender != _account, Error.SELF_LIQUIDATION);\n            // krAsset exists\n            require(s.kreskoAssets[_repayKreskoAsset].exists, Error.KRASSET_DOESNT_EXIST);\n            // Check that this account is below its minimum collateralization ratio and can be liquidated.\n            require(s.isAccountLiquidatable(_account), Error.NOT_LIQUIDATABLE);\n            // Collateral exists\n            require(s.collateralAssets[_collateralAssetToSeize].exists, Error.COLLATERAL_DOESNT_EXIST);\n        }\n\n        // Repay amount USD = repay amount * KR asset USD exchange rate.\n\n        FixedPoint.Unsigned memory repayAmountUSD = s.kreskoAssets[_repayKreskoAsset].fixedPointUSD(_repayAmount);\n        // Get the scaled debt amount\n        uint256 krAssetDebt = s.getKreskoAssetDebtPrincipal(_account, _repayKreskoAsset);\n        // Avoid stack too deep error\n        {\n            // Liquidator may not repay more value than what the liquidation pair allows\n            // Nor repay more tokens than the account holds debt for the asset\n            FixedPoint.Unsigned memory maxLiquidation = s.calculateMaxLiquidatableValueForAssets(\n                _account,\n                _repayKreskoAsset,\n                _collateralAssetToSeize\n            );\n            require(krAssetDebt >= _repayAmount, Error.KRASSET_BURN_AMOUNT_OVERFLOW);\n            require(repayAmountUSD.isLessThanOrEqual(maxLiquidation), Error.LIQUIDATION_OVERFLOW);\n        }\n\n        // Charge burn fee from the liquidated user\n        s.chargeCloseFee(_account, _repayKreskoAsset, _repayAmount);\n\n        // Perform the liquidation by burning KreskoAssets from msg.sender\n        // Get the amount of collateral to seize\n        uint256 seizedAmount = _liquidateAssets(\n            _account,\n            _repayAmount,\n            s.collateralAssets[_collateralAssetToSeize].decimals.fromCollateralFixedPointAmount(\n                LibCalculation.calculateAmountToSeize(\n                    s.liquidationIncentiveMultiplier,\n                    s.collateralAssets[_collateralAssetToSeize].fixedPointPrice(),\n                    repayAmountUSD\n                )\n            ),\n            _repayKreskoAsset,\n            _mintedKreskoAssetIndex,\n            _collateralAssetToSeize,\n            _depositedCollateralAssetIndex\n        );\n\n        // Send liquidator the seized collateral.\n        IERC20Upgradeable(_collateralAssetToSeize).safeTransfer(msg.sender, seizedAmount);\n\n        emit MinterEvent.LiquidationOccurred(\n            _account,\n            // solhint-disable-next-line avoid-tx-origin\n            tx.origin,\n            _repayKreskoAsset,\n            _repayAmount,\n            _collateralAssetToSeize,\n            seizedAmount\n        );\n    }\n\n    /**\n     * @notice Burns KreskoAssets from the liquidator, calculates collateral assets to send to liquidator.\n     * @param _account The account to attempt to liquidate.\n     * @param _repayAmount The amount of the Kresko asset to be repaid.\n     * @param _seizeAmount The calculated amount of collateral assets to be seized.\n     * @param _repayKreskoAsset The address of the Kresko asset to be repaid.\n     * @param _mintedKreskoAssetIndex The index of the Kresko asset in the user's minted assets array.\n     * @param _collateralAssetToSeize The address of the collateral asset to be seized.\n     * @param _depositedCollateralAssetIndex The index of the collateral asset in the account's collateral assets array.\n     */\n    function _liquidateAssets(\n        address _account,\n        uint256 _repayAmount,\n        uint256 _seizeAmount,\n        address _repayKreskoAsset,\n        uint256 _mintedKreskoAssetIndex,\n        address _collateralAssetToSeize,\n        uint256 _depositedCollateralAssetIndex\n    ) internal returns (uint256) {\n        MinterState storage s = ms();\n        KrAsset memory krAsset = s.kreskoAssets[_repayKreskoAsset];\n\n        {\n            // Subtract repaid Kresko assets from liquidated user's recorded debt.\n            uint256 destroyed = IKreskoAssetIssuer(krAsset.anchor).destroy(_repayAmount, msg.sender);\n            s.kreskoAssetDebt[_account][_repayKreskoAsset] -= destroyed;\n\n            // Update stability rate values\n            uint256 newDebtIndex = irs().srAssets[_repayKreskoAsset].updateDebtIndex();\n            uint256 amountScaled = destroyed.wadToRay().rayDiv(newDebtIndex);\n\n            // Update scaled values for the user\n            irs().srUserInfo[_account][_repayKreskoAsset].debtScaled -= uint128(amountScaled);\n            irs().srUserInfo[_account][_repayKreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n\n            // Update the global stability rate\n            irs().srAssets[_repayKreskoAsset].updateStabilityRate();\n        }\n\n        // If the liquidation repays the user's entire Kresko asset balance, remove it from minted assets array.\n        if (s.kreskoAssetDebt[_account][_repayKreskoAsset] == 0) {\n            s.mintedKreskoAssets[_account].removeAddress(_repayKreskoAsset, _mintedKreskoAssetIndex);\n        }\n\n        // Get users collateral deposit amount\n        uint256 collateralDeposit = s.getCollateralDeposits(_account, _collateralAssetToSeize);\n\n        if (collateralDeposit > _seizeAmount) {\n            s.collateralDeposits[_account][_collateralAssetToSeize] -= ms()\n                .collateralAssets[_collateralAssetToSeize]\n                .toNonRebasingAmount(_seizeAmount);\n        } else {\n            // This clause means user either has collateralDeposits equal or less than the _seizeAmount\n            _seizeAmount = collateralDeposit;\n            // So we set the collateralDeposits to 0\n            s.collateralDeposits[_account][_collateralAssetToSeize] = 0;\n            // And remove the asset from the deposits array.\n            s.depositedCollateralAssets[_account].removeAddress(\n                _collateralAssetToSeize,\n                _depositedCollateralAssetIndex\n            );\n        }\n\n        // Return the actual amount seized\n        return _seizeAmount;\n    }\n\n    /**\n     * @notice Calculates if an account's current collateral value is under its minimum collateral value\n     * @dev Returns true if the account's current collateral value is below the minimum collateral value\n     * required to consider the position healthy.\n     * @param _account The account to check.\n     * @return A boolean indicating if the account can be liquidated.\n     */\n    function isAccountLiquidatable(address _account) external view returns (bool) {\n        return ms().isAccountLiquidatable(_account);\n    }\n\n    /**\n     * @dev Calculates the total value that can be liquidated for a liquidation pair\n     * @param _account address to liquidate\n     * @param _repayKreskoAsset address of the kreskoAsset being repaid on behalf of the liquidatee\n     * @param _collateralAssetToSeize address of the collateral asset being seized from the liquidatee\n     * @return maxLiquidatableUSD USD value that can be liquidated, 0 if the pair has no liquidatable value\n     */\n    function calculateMaxLiquidatableValueForAssets(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize\n    ) public view returns (FixedPoint.Unsigned memory maxLiquidatableUSD) {\n        return ms().calculateMaxLiquidatableValueForAssets(_account, _repayKreskoAsset, _collateralAssetToSeize);\n    }\n}\n"
    },
    "src/contracts/minter/facets/MintFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IMintFacet} from \"../interfaces/IMintFacet.sol\";\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {DiamondModifiers, MinterModifiers} from \"../../shared/Modifiers.sol\";\nimport {Action, FixedPoint, KrAsset} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title MintFacet\n * @notice Main end-user functionality concerning minting kresko assets\n */\ncontract MintFacet is DiamondModifiers, MinterModifiers, IMintFacet {\n    using FixedPoint for FixedPoint.Unsigned;\n    using Arrays for address[];\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  KrAssets                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Mints new Kresko assets.\n     * @param _account The address to mint assets for.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _mintAmount The amount of the Kresko asset to be minted.\n     */\n    function mintKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _mintAmount\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        require(_mintAmount > 0, Error.ZERO_MINT);\n\n        MinterState storage s = ms();\n        if (s.safetyStateSet) {\n            super.ensureNotPaused(_kreskoAsset, Action.Borrow);\n        }\n\n        // Enforce krAsset's total supply limit\n        KrAsset memory krAsset = s.kreskoAssets[_kreskoAsset];\n        require(krAsset.marketStatusOracle.latestMarketOpen(), Error.KRASSET_MARKET_CLOSED);\n\n        require(\n            IKreskoAsset(_kreskoAsset).totalSupply() + _mintAmount <= krAsset.supplyLimit,\n            Error.KRASSET_MAX_SUPPLY_REACHED\n        );\n\n        if (krAsset.openFee.rawValue > 0) {\n            s.chargeOpenFee(_account, _kreskoAsset, _mintAmount);\n        }\n        {\n            // Get the account's current minimum collateral value required to maintain current debts.\n            // Calculate additional collateral amount required to back requested additional mint.\n            // Verify that minter has sufficient collateral to back current debt + new requested debt.\n            require(\n                s\n                    .getAccountMinimumCollateralValueAtRatio(_account, s.minimumCollateralizationRatio)\n                    .add(s.getMinimumCollateralValueAtRatio(_kreskoAsset, _mintAmount, s.minimumCollateralizationRatio))\n                    .isLessThanOrEqual(s.getAccountCollateralValue(_account)),\n                Error.KRASSET_COLLATERAL_LOW\n            );\n        }\n\n        // The synthetic asset debt position must be greater than the minimum debt position value\n        uint256 existingDebt = s.getKreskoAssetDebtScaled(_account, _kreskoAsset);\n        require(\n            krAsset.fixedPointUSD(existingDebt + _mintAmount).isGreaterThanOrEqual(s.minimumDebtValue),\n            Error.KRASSET_MINT_AMOUNT_LOW\n        );\n\n        // If the account does not have an existing debt for this Kresko Asset,\n        // push it to the list of the account's minted Kresko Assets.\n        if (existingDebt == 0) {\n            s.mintedKreskoAssets[_account].push(_kreskoAsset);\n        }\n\n        // Record the mint.\n        s.mint(_kreskoAsset, krAsset.anchor, _mintAmount, _account);\n\n        // Emit logs\n        emit MinterEvent.KreskoAssetMinted(_account, _kreskoAsset, _mintAmount);\n    }\n}\n"
    },
    "src/contracts/minter/facets/SafetyCouncilFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {ISafetyCouncilFacet} from \"../interfaces/ISafetyCouncilFacet.sol\";\n\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {Authorization, Role} from \"../../libs/Authorization.sol\";\nimport {DiamondModifiers, MinterModifiers} from \"../../shared/Modifiers.sol\";\n\nimport {Action, SafetyState, Pause} from \"../MinterTypes.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @author Kresko\n * @title SafetyCouncilFacet - protocol safety controls\n * @notice `Role.SAFETY_COUNCIL` must be a multisig.\n */\ncontract SafetyCouncilFacet is MinterModifiers, DiamondModifiers, ISafetyCouncilFacet {\n    /**\n     * @dev Toggle paused-state of assets in a per-action basis\n     *\n     * @notice These functions are only callable by a multisig quorum.\n     * @param _assets list of addresses of krAssets and/or collateral assets\n     * @param _action One of possible user actions:\n     *  Deposit = 0\n     *  Withdraw = 1,\n     *  Repay = 2,\n     *  Borrow = 3,\n     *  Liquidate = 4\n     * @param _withDuration Set a duration for this pause - @todo: implement it if required\n     * @param _duration Duration for the pause if `_withDuration` is true\n     */\n    function toggleAssetsPaused(\n        address[] calldata _assets,\n        Action _action,\n        bool _withDuration,\n        uint256 _duration\n    ) external override onlyRole(Role.SAFETY_COUNCIL) {\n        bool enabled;\n        /// @dev loop through `_assets` - be it krAsset or collateral\n        for (uint256 i; i < _assets.length; i++) {\n            address asset = _assets[i];\n            // Revert if invalid address is supplied\n            require(\n                ms().collateralAssets[asset].exists || ms().kreskoAssets[asset].exists,\n                Error.INVALID_ASSET_SUPPLIED\n            );\n            // Get the safety state\n            SafetyState memory safetyState = ms().safetyState[asset][_action];\n            // Flip the previous value\n            bool willPause = !safetyState.pause.enabled;\n            // Set a global flag in case any asset gets set to true\n            if (willPause) {\n                enabled = true;\n            }\n            // Update the state for this asset\n            ms().safetyState[asset][_action].pause = Pause(\n                willPause,\n                block.timestamp,\n                _withDuration ? block.timestamp + _duration : 0\n            );\n            // Emit the actions taken\n            emit MinterEvent.SafetyStateChange(_action, asset, enabled ? \"paused\" : \"unpaused\");\n        }\n    }\n\n    /**\n     * @notice For external checks if a safety state has been set for any asset\n     */\n    function safetyStateSet() external view override returns (bool) {\n        return ms().safetyStateSet;\n    }\n\n    /**\n     * @notice View the state of safety measures for an asset on a per-action basis\n     * @param _asset krAsset / collateral asset\n     * @param _action One of possible user actions:\n     *\n     *  Deposit = 0\n     *  Withdraw = 1,\n     *  Repay = 2,\n     *  Borrow = 3,\n     *  Liquidate = 4\n     */\n    function safetyStateFor(address _asset, Action _action) external view override returns (SafetyState memory) {\n        return ms().safetyState[_asset][_action];\n    }\n\n    /**\n     * @notice Check if `_asset` has a pause enabled for `_action`\n     * @param _action enum `Action`\n     *  Deposit = 0\n     *  Withdraw = 1,\n     *  Repay = 2,\n     *  Borrow = 3,\n     *  Liquidate = 4\n     * @return true if `_action` is paused\n     */\n    function assetActionPaused(Action _action, address _asset) external view returns (bool) {\n        return ms().safetyState[_asset][_action].pause.enabled;\n    }\n}\n"
    },
    "src/contracts/minter/facets/StabilityRateFacet.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.14;\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {InterestRateEvent} from \"../../libs/Events.sol\";\nimport {LibStabilityRate} from \"../libs/LibStabilityRate.sol\";\nimport {LibDecimals, FixedPoint} from \"../libs/LibDecimals.sol\";\nimport {StabilityRateConfig} from \"../InterestRateState.sol\";\nimport {ms} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {IERC20Upgradeable} from \"../../shared/IERC20Upgradeable.sol\";\nimport {IStabilityRateFacet} from \"../interfaces/IStabilityRateFacet.sol\";\nimport {MinterModifiers, DiamondModifiers, Error} from \"../../shared/Modifiers.sol\";\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"../../shared/SafeERC20Upgradeable.sol\";\n\n/* solhint-disable var-name-mixedcase */\n\n// Stability Rate setup params\nstruct StabilityRateParams {\n    uint128 stabilityRateBase;\n    uint128 rateSlope1;\n    uint128 rateSlope2;\n    uint128 optimalPriceRate;\n    uint128 priceRateDelta;\n}\n\n/**\n * @title Stability rate facet\n * @author Kresko\n * @notice Stability rate related views and state operations\n * @dev Uses both MinterState (ms) and InterestRateState (irs)\n */\ncontract StabilityRateFacet is MinterModifiers, DiamondModifiers {\n    using Arrays for address[];\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using WadRay for uint256;\n    using LibStabilityRate for StabilityRateConfig;\n    using LibDecimals for FixedPoint.Unsigned;\n    using LibDecimals for uint256;\n    using FixedPoint for uint256;\n    using FixedPoint for FixedPoint.Unsigned;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              ASSET STATE WRITES                            */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Initialize an asset with stability rate setup values\n     * @param _asset asset to setup\n     * @param _setup setup parameters\n     */\n    function setupStabilityRateParams(address _asset, StabilityRateParams memory _setup) external onlyOwner {\n        require(irs().kiss != address(0), Error.KISS_NOT_SET);\n        require(irs().srAssets[_asset].asset == address(0), Error.STABILITY_RATES_ALREADY_INITIALIZED);\n        require(WadRay.RAY >= _setup.optimalPriceRate, Error.INVALID_OPTIMAL_RATE);\n        require(WadRay.RAY >= _setup.priceRateDelta, Error.INVALID_PRICE_RATE_DELTA);\n\n        irs().srAssets[_asset] = StabilityRateConfig({\n            debtIndex: uint128(WadRay.RAY),\n            stabilityRateBase: _setup.stabilityRateBase,\n            // solhint-disable not-rely-on-time\n            lastUpdateTimestamp: uint40(block.timestamp),\n            asset: _asset,\n            rateSlope1: _setup.rateSlope1,\n            rateSlope2: _setup.rateSlope2,\n            optimalPriceRate: _setup.optimalPriceRate,\n            priceRateDelta: _setup.priceRateDelta,\n            stabilityRate: uint128(WadRay.RAY)\n        });\n\n        emit InterestRateEvent.StabilityRateConfigured(\n            _asset,\n            _setup.stabilityRateBase,\n            _setup.priceRateDelta,\n            _setup.rateSlope1,\n            _setup.rateSlope2\n        );\n    }\n\n    /**\n     * @notice Configure existing stability rate values\n     * @param _asset asset to configure\n     * @param _setup setup parameters\n     */\n    function updateStabilityRateParams(address _asset, StabilityRateParams memory _setup) external onlyOwner {\n        require(irs().srAssets[_asset].asset == _asset, Error.STABILITY_RATES_NOT_INITIALIZED);\n        require(WadRay.RAY >= _setup.optimalPriceRate, Error.INVALID_OPTIMAL_RATE);\n        require(WadRay.RAY >= _setup.priceRateDelta, Error.INVALID_PRICE_RATE_DELTA);\n\n        irs().srAssets[_asset].rateSlope1 = _setup.rateSlope1;\n        irs().srAssets[_asset].rateSlope2 = _setup.rateSlope2;\n        irs().srAssets[_asset].optimalPriceRate = _setup.optimalPriceRate;\n        irs().srAssets[_asset].priceRateDelta = _setup.priceRateDelta;\n        irs().srAssets[_asset].stabilityRateBase = _setup.stabilityRateBase;\n\n        emit InterestRateEvent.StabilityRateConfigured(\n            _asset,\n            _setup.stabilityRateBase,\n            _setup.priceRateDelta,\n            _setup.rateSlope1,\n            _setup.rateSlope2\n        );\n    }\n\n    /// @notice Updates the debt index and stability rates for an asset\n    /// @param _asset asset to update rate and index for\n    function updateStabilityRateAndIndexForAsset(address _asset) external {\n        irs().srAssets[_asset].updateDebtIndex();\n        irs().srAssets[_asset].updateStabilityRate();\n    }\n\n    /**\n     * @notice Sets the protocol AMM oracle address\n     * @param _kiss  The address of the oracle\n     */\n    function updateKiss(address _kiss) external onlyOwner {\n        irs().kiss = _kiss;\n        emit InterestRateEvent.KISSUpdated(_kiss);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                REPAYMENT                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Repays part of accrued stability rate interest for a single asset\n     * @param _account Account to repay interest for\n     * @param _kreskoAsset Kresko asset to repay interest for\n     * @param _kissRepayAmount USD value to repay (KISS)\n     */\n    function repayStabilityRateInterestPartial(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kissRepayAmount\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) {\n        // Update debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n\n        // Get the accrued interest in repayment token\n        (, uint256 maxKissRepayAmount) = ms().getKreskoAssetDebtInterest(_account, _kreskoAsset);\n        require(_kissRepayAmount < maxKissRepayAmount, Error.INTEREST_REPAY_NOT_PARTIAL);\n\n        // If no interest has accrued or 0 amount was supplied as parameter - no further operations needed\n        // Do not revert because we want the preserve new debt index and stability rate\n        // Also removes the need to check if the kresko asset exists as the maxKissAmount will return 0\n        if (_kissRepayAmount == 0 || maxKissRepayAmount == 0) {\n            // Update stability rate for asset\n            irs().srAssets[_kreskoAsset].updateStabilityRate();\n            return;\n        }\n\n        // Transfer the accrued interest\n        IERC20Upgradeable(irs().kiss).safeTransferFrom(msg.sender, ms().feeRecipient, _kissRepayAmount);\n        uint256 assetAmount = _kissRepayAmount.divByPrice(ms().kreskoAssets[_kreskoAsset].uintPrice());\n        uint256 amountScaled = assetAmount.wadToRay().rayDiv(newDebtIndex);\n        // Update scaled values for the user\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled -= uint128(amountScaled);\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n        // Update stability rate for asset\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n\n        // Emit event with the account, asset and amount repaid\n        emit InterestRateEvent.StabilityRateInterestRepaid(_account, _kreskoAsset, _kissRepayAmount);\n    }\n\n    /**\n     * @notice Repays accrued stability rate interest for a single asset\n     * @param _account Account to repay interest for\n     * @param _kreskoAsset Kresko asset to repay interest for\n     * @return kissRepayAmount KISS value repaid\n     */\n    function repayFullStabilityRateInterest(\n        address _account,\n        address _kreskoAsset\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) returns (uint256 kissRepayAmount) {\n        return ms().repayFullStabilityRateInterest(_account, _kreskoAsset);\n    }\n\n    /**\n     * @notice Repays all accrued stability rate interest for an account\n     * @param _account Account to repay all asset interests for\n     * @return kissRepayAmount KISS value repaid\n     */\n    function batchRepayFullStabilityRateInterest(\n        address _account\n    ) external nonReentrant returns (uint256 kissRepayAmount) {\n        address[] memory mintedKreskoAssets = ms().getMintedKreskoAssets(_account);\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            kissRepayAmount += ms().repayFullStabilityRateInterest(_account, mintedKreskoAssets[i]);\n        }\n        emit InterestRateEvent.StabilityRateInterestBatchRepaid(_account, kissRepayAmount);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   VIEWS                                    */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Gets the current stability rate for an asset\n     * @param _asset asset to get the stability rate for\n     * @return stabilityRate the return variables of a contracts function state variable\n     * @dev expressed in ray\n     */\n    function getStabilityRateForAsset(address _asset) external view returns (uint256 stabilityRate) {\n        return irs().srAssets[_asset].calculateStabilityRate();\n    }\n\n    /**\n     * @notice Gets the current price rate (difference between AMM <-> Oracle pricing)\n     * for an asset\n     * @param _asset asset to get the rate for\n     * @return priceRate the current\n     * @dev expressed in ray\n     */\n    function getPriceRateForAsset(address _asset) external view returns (uint256 priceRate) {\n        return irs().srAssets[_asset].getPriceRate();\n    }\n\n    /**\n     * @notice Gets the current running debt index\n     * @param _asset asset to get the index for\n     * @return debtIndex current running debt index\n     * @dev expressed in ray\n     */\n    function getDebtIndexForAsset(address _asset) external view returns (uint256 debtIndex) {\n        return irs().srAssets[_asset].getNormalizedDebtIndex();\n    }\n\n    /**\n     * @notice View stability rate configuration for an asset\n     * @param _asset asset to view configuration for\n     */\n    function getStabilityRateConfigurationForAsset(address _asset) external view returns (StabilityRateConfig memory) {\n        return irs().srAssets[_asset];\n    }\n\n    /**\n     * @notice The configured address of KISS\n     */\n    function kiss() external view returns (address) {\n        return irs().kiss;\n    }\n\n    /**\n     * @notice Get user stability rate data for an asset\n     * @param _account asset to view configuration for\n     * @param _asset asset to view configuration for\n     * @return lastDebtIndex the previous debt index for the user\n     */\n    function getLastDebtIndexForAccount(\n        address _account,\n        address _asset\n    ) external view returns (uint128 lastDebtIndex) {\n        return irs().srUserInfo[_account][_asset].lastDebtIndex;\n    }\n}\n"
    },
    "src/contracts/minter/facets/StateFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IStateFacet} from \"../interfaces/IStateFacet.sol\";\n\nimport {MinterParams, FixedPoint, KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {MinterState, ms} from \"../MinterStorage.sol\";\n\n/**\n * @author Kresko\n * @title View functions for protocol parameters and asset values\n * @dev As structs do not create views for members, we must expose most of the state values explicitly.\n */\ncontract StateFacet is IStateFacet {\n    function domainSeparator() external view returns (bytes32) {\n        return ms().domainSeparator;\n    }\n\n    function minterInitializations() external view returns (uint256) {\n        return ms().initializations;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Configurables                               */\n    /* -------------------------------------------------------------------------- */\n    function feeRecipient() external view returns (address) {\n        return ms().feeRecipient;\n    }\n\n    function ammOracle() external view returns (address) {\n        return ms().ammOracle;\n    }\n\n    function extOracleDecimals() external view returns (uint8) {\n        return ms().extOracleDecimals;\n    }\n\n    function minimumCollateralizationRatio() external view returns (FixedPoint.Unsigned memory) {\n        return ms().minimumCollateralizationRatio;\n    }\n\n    function liquidationIncentiveMultiplier() external view returns (FixedPoint.Unsigned memory) {\n        return ms().liquidationIncentiveMultiplier;\n    }\n\n    function minimumDebtValue() external view returns (FixedPoint.Unsigned memory) {\n        return ms().minimumDebtValue;\n    }\n\n    function liquidationThreshold() external view returns (FixedPoint.Unsigned memory) {\n        return ms().liquidationThreshold;\n    }\n\n    function getAllParams() external view returns (MinterParams memory) {\n        MinterState storage s = ms();\n        return\n            MinterParams(\n                s.minimumCollateralizationRatio,\n                s.liquidationIncentiveMultiplier,\n                s.minimumDebtValue,\n                s.liquidationThreshold,\n                s.feeRecipient,\n                s.extOracleDecimals\n            );\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Assets                                   */\n    /* -------------------------------------------------------------------------- */\n    /**\n     * @notice Returns true if the @param _kreskoAsset exists in the protocol\n     * @return exists boolean indicating if the asset exists\n     */\n    function krAssetExists(address _kreskoAsset) external view returns (bool exists) {\n        return ms().kreskoAssets[_kreskoAsset].exists;\n    }\n\n    /**\n     * @notice Get the state of a specific krAsset\n     * @param _kreskoAsset Address of the asset.\n     * @return asset State of assets `KrAsset` struct\n     */\n    function kreskoAsset(address _kreskoAsset) external view returns (KrAsset memory asset) {\n        return ms().kreskoAsset(_kreskoAsset);\n    }\n\n    /**\n     * @notice Returns true if the @param _collateralAsset exists in the protocol\n     * @return exists boolean indicating if the asset exists\n     */\n    function collateralExists(address _collateralAsset) external view returns (bool exists) {\n        return ms().collateralAssets[_collateralAsset].exists;\n    }\n\n    /**\n     * @notice Get the state of a specific collateral asset\n     * @param _collateralAsset Address of the asset.\n     * @return asset State of assets `CollateralAsset` struct\n     */\n    function collateralAsset(address _collateralAsset) external view returns (CollateralAsset memory asset) {\n        return ms().collateralAssets[_collateralAsset];\n    }\n\n    /**\n     * @notice Gets the collateral value for a single collateral asset and amount.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _amount The amount of the collateral asset to calculate the collateral value for.\n     * @param _ignoreCollateralFactor Boolean indicating if the asset's collateral factor should be ignored.\n     * @return value and oraclePrice The value and oracle price for the provided amount of the collateral asset.\n     */\n    function getCollateralValueAndOraclePrice(\n        address _collateralAsset,\n        uint256 _amount,\n        bool _ignoreCollateralFactor\n    ) external view returns (FixedPoint.Unsigned memory value, FixedPoint.Unsigned memory oraclePrice) {\n        return ms().getCollateralValueAndOraclePrice(_collateralAsset, _amount, _ignoreCollateralFactor);\n    }\n\n    /**\n     * @notice Gets the USD value for a single Kresko asset and amount.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _amount The amount of the Kresko asset to calculate the value for.\n     * @param _ignoreKFactor Boolean indicating if the asset's k-factor should be ignored.\n     * @return value The value for the provided amount of the Kresko asset.\n     */\n    function getKrAssetValue(\n        address _kreskoAsset,\n        uint256 _amount,\n        bool _ignoreKFactor\n    ) external view returns (FixedPoint.Unsigned memory value) {\n        return ms().getKrAssetValue(_kreskoAsset, _amount, _ignoreKFactor);\n    }\n}\n"
    },
    "src/contracts/minter/facets/UIDataProviderFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n/* solhint-disable max-line-length */\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable func-name-mixedcase */\n/* solhint-disable contract-name-camelcase */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\nimport {ds, Error, Meta} from \"../../shared/Modifiers.sol\";\nimport {InterestRateEvent} from \"../../libs/Events.sol\";\nimport {LibUI, IKrStaking, IUniswapV2Pair, IERC20Upgradeable, AggregatorV2V3Interface, ms} from \"../libs/LibUI.sol\";\n\n/**\n * @author Kresko\n * @title UIDataProviderFacet\n * @notice UI data aggregation views\n */\ncontract UIDataProviderFacet {\n    function getAccountData(\n        address _account,\n        address[] memory _tokens,\n        address _staking\n    )\n        external\n        view\n        returns (LibUI.KreskoUser memory user, LibUI.Balance[] memory balances, LibUI.StakingData[] memory stakingData)\n    {\n        user = LibUI.kreskoUser(_account);\n        balances = LibUI.getBalances(_tokens, _account);\n        stakingData = LibUI.getStakingData(_account, _staking);\n    }\n\n    function batchOracleValues(\n        address[] memory _assets,\n        address[] memory _oracles,\n        address[] memory _marketStatusOracles\n    ) public view returns (LibUI.Price[] memory result) {\n        return LibUI.batchOracleValues(_assets, _oracles, _marketStatusOracles);\n    }\n\n    function getTokenData(\n        address[] memory _allTokens,\n        address[] memory _assets,\n        address[] memory _priceFeeds,\n        address[] memory _marketStatusOracles\n    ) external view returns (LibUI.TokenMetadata[] memory metadatas, LibUI.Price[] memory prices) {\n        metadatas = new LibUI.TokenMetadata[](_allTokens.length);\n        for (uint256 i; i < _allTokens.length; i++) {\n            metadatas[i] = LibUI.TokenMetadata({\n                decimals: IERC20Upgradeable(_allTokens[i]).decimals(),\n                name: IERC20Upgradeable(_allTokens[i]).name(),\n                symbol: IERC20Upgradeable(_allTokens[i]).symbol(),\n                totalSupply: IERC20Upgradeable(_allTokens[i]).totalSupply()\n            });\n        }\n        prices = LibUI.batchOracleValues(_assets, _priceFeeds, _marketStatusOracles);\n    }\n}\n"
    },
    "src/contracts/minter/facets/UIDataProviderFacet2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n/* solhint-disable max-line-length */\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable func-name-mixedcase */\n/* solhint-disable contract-name-camelcase */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\nimport {ds, Error, Meta} from \"../../shared/Modifiers.sol\";\nimport {LibUI, IKrStaking, IUniswapV2Pair, IERC20Upgradeable, AggregatorV2V3Interface, ms} from \"../libs/LibUI.sol\";\n\n/**\n * @author Kresko\n * @title UIDataProviderFacet2\n * @notice UI data aggregation views\n */\ncontract UIDataProviderFacet2 {\n    function getGlobalData(\n        address[] memory _collateralAssets,\n        address[] memory _krAssets\n    )\n        external\n        view\n        returns (\n            LibUI.CollateralAssetInfo[] memory collateralAssets,\n            LibUI.krAssetInfo[] memory krAssets,\n            LibUI.ProtocolParams memory protocolParams\n        )\n    {\n        collateralAssets = LibUI.collateralAssetInfos(_collateralAssets);\n        krAssets = LibUI.krAssetInfos(_krAssets);\n        protocolParams = LibUI.ProtocolParams({\n            minCollateralRatio: ms().minimumCollateralizationRatio.rawValue,\n            liqMultiplier: ms().liquidationIncentiveMultiplier.rawValue,\n            minDebtValue: ms().minimumDebtValue.rawValue,\n            liquidationThreshold: ms().liquidationThreshold.rawValue\n        });\n    }\n\n    function getPairsData(address[] memory _pairAddresses) external view returns (LibUI.PairData[] memory result) {\n        result = new LibUI.PairData[](_pairAddresses.length);\n        for (uint256 i; i < _pairAddresses.length; i++) {\n            IUniswapV2Pair pair = IUniswapV2Pair(_pairAddresses[i]);\n            (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\n            result[i] = LibUI.PairData({\n                decimals0: IERC20Upgradeable(pair.token0()).decimals(),\n                decimals1: IERC20Upgradeable(pair.token1()).decimals(),\n                totalSupply: pair.totalSupply(),\n                reserve0: reserve0,\n                reserve1: reserve1\n            });\n        }\n    }\n}\n"
    },
    "src/contracts/minter/InterestRateState.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {LibStabilityRate} from \"./libs/LibStabilityRate.sol\";\n\nusing LibStabilityRate for StabilityRateConfig global;\n\n/* solhint-disable var-name-mixedcase */\n\n// Asset data\nstruct StabilityRateConfig {\n    // Interest index for debt\n    uint128 debtIndex;\n    // Represents the optimal price rate between an oracle report and an AMM twap\n    uint128 optimalPriceRate;\n    // Slope of the variable interest curve when rate > 0 and <= optimalPriceRate.\n    // Expressed in ray\n    uint128 rateSlope1;\n    // Slope of the variable interest curve when rate > optimalPriceRate.\n    // Expressed in ray\n    uint128 rateSlope2;\n    /**\n     * Represents the excess price premium in either direction.\n     * Expressed in ray\n     * Eg. 1/20 ray = 5% price premium in either direction is considered excess\n     */\n    uint128 priceRateDelta;\n    // Current accrual rate for debt\n    uint128 stabilityRate;\n    // Base accrual rate for debt\n    uint128 stabilityRateBase;\n    // Asset to configure\n    address asset;\n    // Last update for the asset\n    uint40 lastUpdateTimestamp;\n}\n\n// User data\nstruct StabilityRateUser {\n    uint128 debtScaled;\n    uint128 lastDebtIndex;\n}\n\n// Storage layout\nstruct InterestRateState {\n    // asset address -> asset data\n    mapping(address => StabilityRateConfig) srAssets;\n    // account address -> asset address -> user data\n    mapping(address => mapping(address => StabilityRateUser)) srUserInfo;\n    // interest repayment token is KISS\n    address kiss;\n}\n\n// Storage position\nbytes32 constant INTEREST_RATE_STORAGE_POSITION = keccak256(\"kresko.interest.rate.storage\");\n\n// solhint-disable func-visibility\nfunction irs() pure returns (InterestRateState storage state) {\n    bytes32 position = INTEREST_RATE_STORAGE_POSITION;\n    assembly {\n        state.slot := position\n    }\n}\n"
    },
    "src/contracts/minter/interfaces/IAccountStateFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\nimport {Action} from \"../MinterTypes.sol\";\n\ninterface IAccountStateFacet {\n    function getMintedKreskoAssets(address _account) external view returns (address[] memory);\n\n    function getMintedKreskoAssetsIndex(address _account, address _kreskoAsset) external view returns (uint256);\n\n    function getAccountKrAssetValue(address _account) external view returns (FixedPoint.Unsigned memory);\n\n    function kreskoAssetDebt(address _account, address _asset) external view returns (uint256);\n\n    function kreskoAssetDebtPrincipal(address _account, address _asset) external view returns (uint256);\n\n    function kreskoAssetDebtInterest(address _account, address _asset)\n        external\n        view\n        returns (uint256 assetAmount, uint256 kissAmount);\n\n    function getAccountCollateralValue(address _account) external view returns (FixedPoint.Unsigned memory);\n\n    function getAccountMinimumCollateralValueAtRatio(address _account, FixedPoint.Unsigned memory _ratio)\n        external\n        view\n        returns (FixedPoint.Unsigned memory);\n\n    function getAccountCollateralRatio(address _account) external view returns (FixedPoint.Unsigned memory ratio);\n\n    function getCollateralRatiosFor(address[] memory _accounts) external view returns (FixedPoint.Unsigned[] memory);\n\n    function getAccountSingleCollateralValueAndRealValue(address _account, address _asset)\n        external\n        view\n        returns (FixedPoint.Unsigned memory value, FixedPoint.Unsigned memory realValue);\n\n    function getDepositedCollateralAssetIndex(address _account, address _collateralAsset)\n        external\n        view\n        returns (uint256 i);\n\n    function getDepositedCollateralAssets(address _account) external view returns (address[] memory);\n\n    function collateralDeposits(address _account, address _asset) external view returns (uint256);\n\n    function calcExpectedFee(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kreskoAssetAmount,\n        uint256 _feeType\n    ) external view returns (address[] memory, uint256[] memory);\n}\n"
    },
    "src/contracts/minter/interfaces/IBurnFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface IBurnFacet {\n    function burnKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _amount,\n        uint256 _mintedKreskoAssetIndex\n    ) external;\n}\n"
    },
    "src/contracts/minter/interfaces/IBurnHelperFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\ninterface IBurnHelperFacet {\n    function batchCloseKrAssetDebtPositions(address _account) external;\n\n    function closeKrAssetDebtPosition(address _account, address _kreskoAsset) external;\n}\n"
    },
    "src/contracts/minter/interfaces/IConfigurationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {MinterInitArgs, KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\n\ninterface IConfigurationFacet {\n    function initialize(MinterInitArgs calldata args) external;\n\n    function addCollateralAsset(\n        address _collateralAsset,\n        address _anchor,\n        uint256 _factor,\n        address _oracle,\n        address _marketStatusOracle\n    ) external;\n\n    function addKreskoAsset(\n        address _krAsset,\n        address _anchor,\n        uint256 _kFactor,\n        address _oracle,\n        address _marketStatusOracle,\n        uint256 _supplyLimit,\n        uint256 _closeFee,\n        uint256 _openFee\n    ) external;\n\n    function updateCollateralAsset(\n        address _collateralAsset,\n        address _anchor,\n        uint256 _factor,\n        address _oracle,\n        address _marketStatusOracle\n    ) external;\n\n    function updateFeeRecipient(address _feeRecipient) external;\n\n    function updateKreskoAsset(\n        address _krAsset,\n        address _anchor,\n        uint256 _kFactor,\n        address _oracle,\n        address _marketStatusOracle,\n        uint256 _supplyLimit,\n        uint256 _closeFee,\n        uint256 _openFee\n    ) external;\n\n    function updateLiquidationIncentiveMultiplier(uint256 _liquidationIncentiveMultiplier) external;\n\n    function updateMinimumCollateralizationRatio(uint256 _minimumCollateralizationRatio) external;\n\n    function updateMinimumDebtValue(uint256 _minimumDebtValue) external;\n\n    function updateLiquidationThreshold(uint256 _minimumDebtValue) external;\n\n    function updateAMMOracle(address _ammOracle) external;\n\n    function updateExtOracleDecimals(uint8 _decimals) external;\n}\n"
    },
    "src/contracts/minter/interfaces/IDepositWithdrawFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface IDepositWithdrawFacet {\n    function depositCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _amount\n    ) external;\n\n    function withdrawCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _amount,\n        uint256 _depositedCollateralAssetIndex\n    ) external;\n}\n"
    },
    "src/contracts/minter/interfaces/IInterestLiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface IInterestLiquidationFacet {\n    function batchLiquidateInterest(address _account, address _collateralAssetToSeize) external;\n\n    function liquidateInterest(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize\n    ) external;\n}\n"
    },
    "src/contracts/minter/interfaces/ILiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport \"../../libs/FixedPoint.sol\";\n\ninterface ILiquidationFacet {\n    function calculateMaxLiquidatableValueForAssets(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize\n    ) external view returns (FixedPoint.Unsigned memory maxLiquidatableUSD);\n\n    function isAccountLiquidatable(address _account) external view returns (bool);\n\n    function liquidate(\n        address _account,\n        address _repayKreskoAsset,\n        uint256 _repayAmount,\n        address _collateralAssetToSeize,\n        uint256 _mintedKreskoAssetIndex,\n        uint256 _depositedCollateralAssetIndex\n    ) external;\n}\n"
    },
    "src/contracts/minter/interfaces/IMintFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface IMintFacet {\n    function mintKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _amount\n    ) external;\n}\n"
    },
    "src/contracts/minter/interfaces/ISafetyCouncilFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {Action, SafetyState, Pause} from \"../MinterTypes.sol\";\n\ninterface ISafetyCouncilFacet {\n    function toggleAssetsPaused(\n        address[] memory _assets,\n        Action _action,\n        bool _withDuration,\n        uint256 _duration\n    ) external;\n\n    function safetyStateSet() external view returns (bool);\n\n    function safetyStateFor(address _asset, Action _action) external view returns (SafetyState memory);\n}\n"
    },
    "src/contracts/minter/interfaces/IStabilityRateFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {StabilityRateParams} from \"../facets/StabilityRateFacet.sol\";\nimport {StabilityRateConfig} from \"../InterestRateState.sol\";\n\ninterface IStabilityRateFacet {\n    function setupStabilityRateParams(address _asset, StabilityRateParams memory _setup) external;\n\n    function updateStabilityRateParams(address _asset, StabilityRateParams memory _setup) external;\n\n    function updateStabilityRateAndIndexForAsset(address _asset) external;\n\n    function updateKiss(address _kiss) external;\n\n    function repayStabilityRateInterestPartial(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kissRepayAmount\n    ) external;\n\n    function repayFullStabilityRateInterest(address _account, address _kreskoAsset)\n        external\n        returns (uint256 kissRepayAmount);\n\n    function batchRepayFullStabilityRateInterest(address _account) external returns (uint256 kissRepayAmount);\n\n    function getStabilityRateForAsset(address _asset) external view returns (uint256 stabilityRate);\n\n    function getPriceRateForAsset(address _asset) external view returns (uint256 priceRate);\n\n    function getDebtIndexForAsset(address _asset) external view returns (uint256 debtIndex);\n\n    function getStabilityRateConfigurationForAsset(address _asset) external view returns (StabilityRateConfig memory);\n\n    function kiss() external view returns (address);\n\n    function getLastDebtIndexForAccount(address _account, address _asset) external view returns (uint128 lastDebtIndex);\n}\n"
    },
    "src/contracts/minter/interfaces/IStateFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\nimport {CollateralAsset, KrAsset, MinterParams} from \"../MinterTypes.sol\";\n\ninterface IStateFacet {\n    function domainSeparator() external view returns (bytes32);\n\n    function minterInitializations() external view returns (uint256);\n\n    function feeRecipient() external view returns (address);\n\n    function ammOracle() external view returns (address);\n\n    function extOracleDecimals() external view returns (uint8);\n\n    function liquidationThreshold() external view returns (FixedPoint.Unsigned memory);\n\n    function liquidationIncentiveMultiplier() external view returns (FixedPoint.Unsigned memory);\n\n    function minimumCollateralizationRatio() external view returns (FixedPoint.Unsigned memory);\n\n    function minimumDebtValue() external view returns (FixedPoint.Unsigned memory);\n\n    function krAssetExists(address _krAsset) external view returns (bool);\n\n    function kreskoAsset(address _asset) external view returns (KrAsset memory);\n\n    function collateralAsset(address _asset) external view returns (CollateralAsset memory);\n\n    function collateralExists(address _collateralAsset) external view returns (bool);\n\n    function getAllParams() external view returns (MinterParams memory);\n\n    function getCollateralValueAndOraclePrice(\n        address _collateralAsset,\n        uint256 _amount,\n        bool _ignoreCollateralFactor\n    ) external view returns (FixedPoint.Unsigned memory, FixedPoint.Unsigned memory);\n\n    function getKrAssetValue(\n        address _kreskoAsset,\n        uint256 _amount,\n        bool _ignoreKFactor\n    ) external view returns (FixedPoint.Unsigned memory);\n}\n"
    },
    "src/contracts/minter/interfaces/IUniswapV2Oracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface IUniswapV2Oracle {\n    function consultKrAsset(address _krAsset, uint256 _amount) external view returns (uint256 amountOut);\n\n    function consult(address _pair, address _token, uint256 _amountIn) external view returns (uint256 amountOut);\n\n    function initPair(address _pairAddress, address _krAsset, uint256 _updatePeriod) external;\n\n    function configurePair(address _pairAddress, uint256 _updatePeriod) external;\n\n    function update(address _pairAddress) external;\n\n    function krAssets(address) external returns (address);\n\n    function owner() external returns (address);\n\n    function factory() external returns (address);\n}\n"
    },
    "src/contracts/minter/libs/LibAccount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {MinterState} from \"../MinterState.sol\";\nimport {KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {RebaseMath, Rebase} from \"../../shared/Rebase.sol\";\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\n\nlibrary LibAccount {\n    using FixedPoint for FixedPoint.Unsigned;\n    using RebaseMath for uint256;\n    using WadRay for uint256;\n    using LibDecimals for FixedPoint.Unsigned;\n\n    /**\n     * @notice Gets an array of Kresko assets the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @return An array of addresses of Kresko assets the account has minted.\n     */\n    function getMintedKreskoAssets(MinterState storage self, address _account)\n        internal\n        view\n        returns (address[] memory)\n    {\n        return self.mintedKreskoAssets[_account];\n    }\n\n    /**\n     * @notice Gets an array of collateral assets the account has deposited.\n     * @param _account The account to get the deposited collateral assets for.\n     * @return An array of addresses of collateral assets the account has deposited.\n     */\n    function getDepositedCollateralAssets(MinterState storage self, address _account)\n        internal\n        view\n        returns (address[] memory)\n    {\n        return self.depositedCollateralAssets[_account];\n    }\n\n    /**\n     * @notice Get `_account` collateral amount for `_asset`\n     * @notice Performs rebasing conversion for KreskoAssets\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of collateral for `_asset`\n     */\n    function getCollateralDeposits(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256) {\n        return self.collateralAssets[_asset].toRebasingAmount(self.collateralDeposits[_account][_asset]);\n    }\n\n    /**\n     * @notice Calculates if an account's current collateral value is under its minimum collateral value.\n     * @dev Returns true if the account's current collateral value is below the minimum collateral value.\n     * required to consider the position healthy.\n     * @param _account The account to check.\n     * @return A boolean indicating if the account can be liquidated.\n     */\n    function isAccountLiquidatable(MinterState storage self, address _account) internal view returns (bool) {\n        return\n            self.getAccountCollateralValue(_account).isLessThan(\n                self.getAccountMinimumCollateralValueAtRatio(_account, self.liquidationThreshold)\n            );\n    }\n\n    /**\n     * @notice Overload function for calculating liquidatable status with a future liquidated collateral value\n     * @param _account The account to check.\n     * @param _valueLiquidated Value liquidated, eg. in a batch liquidation\n     * @return A boolean indicating if the account can be liquidated.\n     */\n    function isAccountLiquidatable(\n        MinterState storage self,\n        address _account,\n        FixedPoint.Unsigned memory _valueLiquidated\n    ) internal view returns (bool) {\n        return\n            self.getAccountCollateralValue(_account).sub(_valueLiquidated).isLessThan(\n                self.getAccountMinimumCollateralValueAtRatio(_account, self.liquidationThreshold)\n            );\n    }\n\n    /**\n     * @notice Gets the collateral value of a particular account.\n     * @dev O(# of different deposited collateral assets by account) complexity.\n     * @param _account The account to calculate the collateral value for.\n     * @return totalCollateralValue The collateral value of a particular account.\n     */\n    function getAccountCollateralValue(MinterState storage self, address _account)\n        internal\n        view\n        returns (FixedPoint.Unsigned memory totalCollateralValue)\n    {\n        address[] memory assets = self.depositedCollateralAssets[_account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            (FixedPoint.Unsigned memory collateralValue, ) = self.getCollateralValueAndOraclePrice(\n                asset,\n                self.getCollateralDeposits(_account, asset),\n                false // Take the collateral factor into consideration.\n            );\n            totalCollateralValue = totalCollateralValue.add(collateralValue);\n        }\n\n        return totalCollateralValue;\n    }\n\n    /**\n     * @notice Get an account's minimum collateral value required\n     *         to back a Kresko asset amount at a given collateralization ratio.\n     * @dev Accounts that have their collateral value under the minimum collateral value are considered unhealthy,\n     *      accounts with their collateral value under the liquidation threshold are considered liquidatable.\n     * @param _account The account to calculate the minimum collateral value for.\n     * @param _ratio The collateralization ratio required: higher ratio = more collateral required\n     * @return The minimum collateral value at a given collateralization ratio for a given account.\n     */\n    function getAccountMinimumCollateralValueAtRatio(\n        MinterState storage self,\n        address _account,\n        FixedPoint.Unsigned memory _ratio\n    ) internal view returns (FixedPoint.Unsigned memory) {\n        return self.getAccountKrAssetValue(_account).mul(_ratio);\n    }\n\n    /**\n     * @notice Gets the Kresko asset value in USD of a particular account.\n     * @param _account The account to calculate the Kresko asset value for.\n     * @return value The Kresko asset value of a particular account.\n     */\n    function getAccountKrAssetValue(MinterState storage self, address _account)\n        internal\n        view\n        returns (FixedPoint.Unsigned memory value)\n    {\n        address[] memory assets = self.mintedKreskoAssets[_account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            value = value.add(self.getKrAssetValue(asset, self.getKreskoAssetDebtScaled(_account, asset), false));\n        }\n        return value;\n    }\n\n    /**\n     * @notice Get `_account` scaled debt amount for `_asset`\n     * @notice debt amount of an account has one external effects\n     * * Effect #1: Stability rate accrual through debt index\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of scaled debt for `_asset`\n     */\n    function getKreskoAssetDebtScaled(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256) {\n        uint256 debt = self.kreskoAssets[_asset].toRebasingAmount(irs().srUserInfo[_account][_asset].debtScaled);\n        if (debt == 0) {\n            return 0;\n        }\n\n        return debt.rayMul(irs().srAssets[_asset].getNormalizedDebtIndex()).rayToWad();\n    }\n\n    /**\n     * @notice Get `_account` principal debt amount for `_asset`\n     * @notice Principal debt amount of an account has one external effects\n     * * Effect #1: Asset is rebased due to stock split/reverse split\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of principal debt for `_asset`\n     */\n    function getKreskoAssetDebtPrincipal(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256) {\n        return self.kreskoAssets[_asset].toRebasingAmount(self.kreskoAssetDebt[_account][_asset]);\n    }\n\n    /**\n     * @notice Get the total interest accrued on top of debt\n     * * eg: scaled debt - principal debt\n     * @return assetAmount the interest denominated in _asset\n     * @return kissAmount the interest denominated in KISS, ignores K-factor\n     **/\n    function getKreskoAssetDebtInterest(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256 assetAmount, uint256 kissAmount) {\n        assetAmount =\n            self.getKreskoAssetDebtScaled(_account, _asset) -\n            self.getKreskoAssetDebtPrincipal(_account, _asset);\n        kissAmount = self.getKrAssetValue(_asset, assetAmount, true).fromFixedPointPriceToWad();\n    }\n\n    /**\n     * @notice Gets an index for the Kresko asset the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @param _kreskoAsset The asset lookup address.\n     * @return i = index of the minted Kresko asset.\n     */\n    function getMintedKreskoAssetsIndex(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset\n    ) internal view returns (uint256 i) {\n        for (i; i < self.mintedKreskoAssets[_account].length; i++) {\n            if (self.mintedKreskoAssets[_account][i] == _kreskoAsset) {\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Gets an index for the collateral asset the account has deposited.\n     * @param _account The account to get the index for.\n     * @param _collateralAsset The asset lookup address.\n     * @return i = index of the minted collateral asset.\n     */\n    function getDepositedCollateralAssetIndex(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset\n    ) internal view returns (uint256 i) {\n        for (i; i < self.depositedCollateralAssets[_account].length; i++) {\n            if (self.depositedCollateralAssets[_account][i] == _collateralAsset) {\n                break;\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibAssetUtility.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {CollateralAsset, KrAsset} from \"../MinterTypes.sol\";\nimport {LibDecimals, FixedPoint} from \"../libs/LibDecimals.sol\";\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\n\n/**\n * @title LibAssetUtility\n * @author Kresko\n * @notice Utility functions for KrAsset and CollateralAsset structs\n */\nlibrary LibAssetUtility {\n    using FixedPoint for int256;\n    using FixedPoint for uint256;\n    using FixedPoint for FixedPoint.Unsigned;\n    using LibDecimals for int256;\n\n    /**\n     * @notice Amount of non rebasing tokens -> amount of rebasing tokens\n     * @param self the kresko asset struct\n     * @param _nonRebasedAmount the amount to convert\n     */\n    function toRebasingAmount(KrAsset memory self, uint256 _nonRebasedAmount) internal view returns (uint256) {\n        return IKreskoAssetAnchor(self.anchor).convertToAssets(_nonRebasedAmount);\n    }\n\n    /**\n     * @notice Amount of non rebasing tokens -> amount of rebasing tokens\n     * @dev if collateral is not a kresko asset, returns the input\n     * @param self the collateral asset struct\n     * @param _nonRebasedAmount the amount to convert\n     */\n    function toRebasingAmount(CollateralAsset memory self, uint256 _nonRebasedAmount) internal view returns (uint256) {\n        if (self.anchor == address(0)) return _nonRebasedAmount;\n        return IKreskoAssetAnchor(self.anchor).convertToAssets(_nonRebasedAmount);\n    }\n\n    /**\n     * @notice Amount of rebasing tokens -> amount of non rebasing tokens\n     * @param self the kresko asset struct\n     * @param _maybeRebasedAmount the amount to convert\n     */\n    function toNonRebasingAmount(KrAsset memory self, uint256 _maybeRebasedAmount) internal view returns (uint256) {\n        return IKreskoAssetAnchor(self.anchor).convertToShares(_maybeRebasedAmount);\n    }\n\n    /**\n     * @notice Amount of rebasing tokens -> amount of non rebasing tokens\n     * @dev if collateral is not a kresko asset, returns the input\n     * @param self the collateral asset struct\n     * @param _maybeRebasedAmount the amount to convert\n     */\n    function toNonRebasingAmount(CollateralAsset memory self, uint256 _maybeRebasedAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        if (self.anchor == address(0)) return _maybeRebasedAmount;\n        return IKreskoAssetAnchor(self.anchor).convertToShares(_maybeRebasedAmount);\n    }\n\n    /**\n     * @notice Get the oracle price of a collateral asset in uint256 with extOracleDecimals\n     */\n    function uintPrice(CollateralAsset memory self) internal view returns (uint256) {\n        return uint256(self.oracle.latestAnswer());\n    }\n\n    /**\n     * @notice Get the oracle price of a kresko asset in uint256 with extOracleDecimals\n     */\n    function uintPrice(KrAsset memory self) internal view returns (uint256) {\n        return uint256(self.oracle.latestAnswer());\n    }\n\n    /**\n     * @notice Get the oracle price of a collateral asset in uint256 with 18 decimals\n     */\n    function wadPrice(CollateralAsset memory self) internal view returns (uint256) {\n        return self.oracle.latestAnswer().oraclePriceToWad();\n    }\n\n    /**\n     * @notice Get the oracle price of a kresko asset in uint256 with 18 decimals\n     */\n    function wadPrice(KrAsset memory self) internal view returns (uint256) {\n        return self.oracle.latestAnswer().oraclePriceToWad();\n    }\n\n    /**\n     * @notice Get the oracle price of a collateral asset in FixedPoint.Unsigned\n     */\n    function fixedPointPrice(CollateralAsset memory self) internal view returns (FixedPoint.Unsigned memory) {\n        return self.oracle.latestAnswer().toFixedPoint();\n    }\n\n    /**\n     * @notice Get the oracle price of a kresko asset in FixedPoint.Unsigned\n     */\n    function fixedPointPrice(KrAsset memory self) internal view returns (FixedPoint.Unsigned memory) {\n        return self.oracle.latestAnswer().toFixedPoint();\n    }\n\n    /**\n     * @notice Get value for @param _assetAmount of @param self in uint256\n     */\n    function uintUSD(CollateralAsset memory self, uint256 _assetAmount) internal view returns (uint256) {\n        return self.uintPrice() * _assetAmount;\n    }\n\n    /**\n     * @notice Get value for @param _assetAmount of @param self in uint256\n     */\n    function uintUSD(KrAsset memory self, uint256 _assetAmount) internal view returns (uint256) {\n        return self.uintPrice() * _assetAmount;\n    }\n\n    /**\n     * @notice Get value for @param _assetAmount of @param self in FixedPoint.Unsigned\n     */\n    function fixedPointUSD(CollateralAsset memory self, uint256 _assetAmount)\n        internal\n        view\n        returns (FixedPoint.Unsigned memory)\n    {\n        return self.fixedPointPrice().mul(_assetAmount.toFixedPoint());\n    }\n\n    /**\n     * @notice Get value for @param _assetAmount of @param self in FixedPoint.Unsigned\n     */\n    function fixedPointUSD(KrAsset memory self, uint256 _assetAmount)\n        internal\n        view\n        returns (FixedPoint.Unsigned memory)\n    {\n        return self.fixedPointPrice().mul(_assetAmount.toFixedPoint());\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibCalculation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\nimport {MinterState} from \"../MinterState.sol\";\nimport {KrAsset} from \"../MinterTypes.sol\";\n\n/**\n * @title Calculation library for liquidation & fee values\n * @author Kresko\n */\nlibrary LibCalculation {\n    using Arrays for address[];\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n\n    using FixedPoint for FixedPoint.Unsigned;\n\n    /**\n     * @dev Calculates the total value that can be liquidated for a liquidation pair\n     * @param _account address to liquidate\n     * @param _repayKreskoAsset address of the kreskoAsset being repaid on behalf of the liquidatee\n     * @param _collateralAssetToSeize address of the collateral asset being seized from the liquidatee\n     * @return maxLiquidatableUSD USD value that can be liquidated, 0 if the pair has no liquidatable value\n     */\n    function calculateMaxLiquidatableValueForAssets(\n        MinterState storage self,\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize\n    ) internal view returns (FixedPoint.Unsigned memory maxLiquidatableUSD) {\n        FixedPoint.Unsigned memory minCollateralRequired = self.getAccountMinimumCollateralValueAtRatio(\n            _account,\n            self.liquidationThreshold\n        );\n        FixedPoint.Unsigned memory accountCollateralValue = self.getAccountCollateralValue(_account);\n\n        // Account is not liquidatable\n        if (accountCollateralValue.isGreaterThanOrEqual(minCollateralRequired)) {\n            return FixedPoint.Unsigned(0);\n        }\n\n        FixedPoint.Unsigned memory valueGainedPerUSDRepaid = self.calcValueGainedPerUSDRepaid(\n            _repayKreskoAsset,\n            _collateralAssetToSeize\n        );\n\n        // Max repayment value for this pair\n        maxLiquidatableUSD = minCollateralRequired.sub(accountCollateralValue).div(valueGainedPerUSDRepaid);\n\n        if (maxLiquidatableUSD.isLessThan(self.minimumDebtValue)) {\n            return self.minimumDebtValue;\n        }\n        // Diminish liquidatable value for assets with lower cFactor\n        // This is desired as they have more seizable value.\n        FixedPoint.Unsigned memory cFactor = self.collateralAssets[_collateralAssetToSeize].factor;\n\n        if (\n            self.depositedCollateralAssets[_account].length > 1 && cFactor.isLessThan(FixedPoint.ONE_HUNDRED_PERCENT())\n        ) {\n            // cFactor^4 is the diminishing factor (cFactor = 1 == nothing happens)\n            return maxLiquidatableUSD.mul(cFactor.pow(4));\n        }\n    }\n\n    function calcValueGainedPerUSDRepaid(\n        MinterState storage self,\n        address _repayKreskoAsset,\n        address _collateralToSeize\n    ) internal view returns (FixedPoint.Unsigned memory) {\n        KrAsset memory krAsset = self.kreskoAssets[_repayKreskoAsset];\n        FixedPoint.Unsigned memory cFactor = self.collateralAssets[_collateralToSeize].factor;\n        return\n            krAsset\n                .kFactor\n                .mul(self.liquidationThreshold)\n                .mul(FixedPoint.ONE_HUNDRED_PERCENT().sub(krAsset.closeFee))\n                .mul(cFactor)\n                .div(self.liquidationIncentiveMultiplier)\n                .sub(FixedPoint.ONE_USD());\n    }\n\n    /**\n     * @notice Calculate amount of collateral to seize during the liquidation process.\n     * @param _liquidationIncentiveMultiplier The liquidation incentive multiplier.\n     * @param _collateralOraclePriceUSD The address of the collateral asset to be seized.\n     * @param _kreskoAssetRepayAmountUSD Kresko asset amount being repaid in exchange for the seized collateral.\n     */\n    function calculateAmountToSeize(\n        FixedPoint.Unsigned memory _liquidationIncentiveMultiplier,\n        FixedPoint.Unsigned memory _collateralOraclePriceUSD,\n        FixedPoint.Unsigned memory _kreskoAssetRepayAmountUSD\n    ) internal pure returns (FixedPoint.Unsigned memory) {\n        // Seize amount = (repay amount USD * liquidation incentive / collateral price USD).\n        // Denominate seize amount in collateral type\n        // Apply liquidation incentive multiplier\n        return _kreskoAssetRepayAmountUSD.mul(_liquidationIncentiveMultiplier).div(_collateralOraclePriceUSD);\n    }\n\n    /**\n     * @notice Calculates the fee to be taken from a user's deposited collateral assets.\n     * @param _collateralAsset The collateral asset from which to take to the fee.\n     * @param _account The owner of the collateral.\n     * @param _feeValue The original value of the fee.\n     * @param _collateralAssetIndex The collateral asset's index in the user's depositedCollateralAssets array.\n     *\n     * @return transferAmount to be received as a uint256\n     * @return feeValuePaid FixedPoint.Unsigned representing the fee value paid.\n     */\n    function calcFee(\n        MinterState storage self,\n        address _collateralAsset,\n        address _account,\n        FixedPoint.Unsigned memory _feeValue,\n        uint256 _collateralAssetIndex\n    ) internal returns (uint256 transferAmount, FixedPoint.Unsigned memory feeValuePaid) {\n        uint256 depositAmount = self.getCollateralDeposits(_account, _collateralAsset);\n\n        // Don't take the collateral asset's collateral factor into consideration.\n        (FixedPoint.Unsigned memory depositValue, FixedPoint.Unsigned memory oraclePrice) = self\n            .getCollateralValueAndOraclePrice(_collateralAsset, depositAmount, true);\n\n        // If feeValue < depositValue, the entire fee can be charged for this collateral asset.\n        if (_feeValue.isLessThan(depositValue)) {\n            // We want to make sure that transferAmount is < depositAmount.\n            // Proof:\n            //   depositValue <= oraclePrice * depositAmount (<= due to a potential loss of precision)\n            //   feeValue < depositValue\n            // Meaning:\n            //   feeValue < oraclePrice * depositAmount\n            // Solving for depositAmount we get:\n            //   feeValue / oraclePrice < depositAmount\n            // Due to integer division:\n            //   transferAmount = floor(feeValue / oracleValue)\n            //   transferAmount <= feeValue / oraclePrice\n            // We see that:\n            //   transferAmount <= feeValue / oraclePrice < depositAmount\n            //   transferAmount < depositAmount\n            transferAmount = self.collateralAssets[_collateralAsset].decimals.fromCollateralFixedPointAmount(\n                _feeValue.div(oraclePrice)\n            );\n            feeValuePaid = _feeValue;\n        } else {\n            // If the feeValue >= depositValue, the entire deposit\n            // should be taken as the fee.\n            transferAmount = depositAmount;\n            feeValuePaid = depositValue;\n            // Because the entire deposit is taken, remove it from the depositCollateralAssets array.\n            self.depositedCollateralAssets[_account].removeAddress(_collateralAsset, _collateralAssetIndex);\n        }\n\n        return (transferAmount, feeValuePaid);\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibCollateral.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {AggregatorV2V3Interface} from \"../../vendor/flux/interfaces/AggregatorV2V3Interface.sol\";\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {CollateralAsset} from \"../MinterTypes.sol\";\nimport {MinterState} from \"../MinterState.sol\";\n\n/**\n * @title Library for collateral related operations\n * @author Kresko\n */\nlibrary LibCollateral {\n    using FixedPoint for FixedPoint.Unsigned;\n    using LibDecimals for uint8;\n    using Arrays for address[];\n\n    /**\n     * In case a collateral asset is also a kresko asset, convert an amount to anchor shares\n     * @param _amount amount to possibly convert\n     * @param _collateralAsset address of the collateral asset\n     */\n    function normalizeCollateralAmount(\n        MinterState storage self,\n        uint256 _amount,\n        address _collateralAsset\n    ) internal view returns (uint256 amount) {\n        CollateralAsset memory asset = self.collateralAssets[_collateralAsset];\n        if (asset.anchor != address(0)) {\n            return IKreskoAssetAnchor(asset.anchor).convertToShares(_amount);\n        }\n        return _amount;\n    }\n\n    /**\n     * @notice Get the state of a specific collateral asset\n     * @param _asset Address of the asset.\n     * @return State of assets `CollateralAsset` struct\n     */\n    function collateralAsset(MinterState storage self, address _asset) internal view returns (CollateralAsset memory) {\n        return self.collateralAssets[_asset];\n    }\n\n    /**\n     * @notice Gets the collateral value for a single collateral asset and amount.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _amount The amount of the collateral asset to calculate the collateral value for.\n     * @param _ignoreCollateralFactor Boolean indicating if the asset's collateral factor should be ignored.\n     * @return The collateral value for the provided amount of the collateral asset.\n     */\n    function getCollateralValueAndOraclePrice(\n        MinterState storage self,\n        address _collateralAsset,\n        uint256 _amount,\n        bool _ignoreCollateralFactor\n    ) internal view returns (FixedPoint.Unsigned memory, FixedPoint.Unsigned memory) {\n        CollateralAsset memory asset = self.collateralAssets[_collateralAsset];\n\n        FixedPoint.Unsigned memory fixedPointAmount = asset.decimals.toCollateralFixedPointAmount(_amount);\n        FixedPoint.Unsigned memory oraclePrice = asset.fixedPointPrice();\n        FixedPoint.Unsigned memory value = fixedPointAmount.mul(oraclePrice);\n\n        if (!_ignoreCollateralFactor) {\n            value = value.mul(asset.factor);\n        }\n        return (value, oraclePrice);\n    }\n\n    function verifyAndRecordCollateralWithdrawal(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _collateralDeposits,\n        uint256 _depositedCollateralAssetIndex\n    ) internal {\n        require(_withdrawAmount > 0, Error.ZERO_WITHDRAW);\n        require(\n            _depositedCollateralAssetIndex <= self.depositedCollateralAssets[_account].length - 1,\n            Error.ARRAY_OUT_OF_BOUNDS\n        );\n\n        // Ensure the withdrawal does not result in the account having a collateral value\n        // under the minimum collateral amount required to maintain a healthy position.\n        // I.e. the new account's collateral value must still exceed the account's minimum\n        // collateral value.\n        // Get the account's current collateral value.\n        FixedPoint.Unsigned memory accountCollateralValue = self.getAccountCollateralValue(_account);\n        // Get the collateral value that the account will lose as a result of this withdrawal.\n        (FixedPoint.Unsigned memory withdrawnCollateralValue, ) = self.getCollateralValueAndOraclePrice(\n            _collateralAsset,\n            _withdrawAmount,\n            false // Take the collateral factor into consideration.\n        );\n        // Get the account's minimum collateral value.\n        FixedPoint.Unsigned memory accountMinCollateralValue = self.getAccountMinimumCollateralValueAtRatio(\n            _account,\n            self.minimumCollateralizationRatio\n        );\n        // Require accountCollateralValue - withdrawnCollateralValue >= accountMinCollateralValue.\n        require(\n            accountCollateralValue.sub(withdrawnCollateralValue).isGreaterThanOrEqual(accountMinCollateralValue),\n            Error.COLLATERAL_INSUFFICIENT_AMOUNT\n        );\n\n        // Record the withdrawal.\n        self.collateralDeposits[_account][_collateralAsset] = self\n            .collateralAssets[_collateralAsset]\n            .toNonRebasingAmount(_collateralDeposits - _withdrawAmount);\n\n        // If the user is withdrawing all of the collateral asset, remove the collateral asset\n        // from the user's deposited collateral assets array.\n        if (_withdrawAmount == _collateralDeposits) {\n            self.depositedCollateralAssets[_account].removeAddress(_collateralAsset, _depositedCollateralAssetIndex);\n        }\n\n        emit MinterEvent.CollateralWithdrawn(_account, _collateralAsset, _withdrawAmount);\n    }\n\n    /**\n     * @notice Records account as having deposited an amount of a collateral asset.\n     * @dev Token transfers are expected to be done by the caller.\n     * @param _account The address of the collateral asset.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _depositAmount The amount of the collateral asset deposited.\n     */\n    function recordCollateralDeposit(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _depositAmount\n    ) internal {\n        // Because the depositedCollateralAssets[_account] is pushed to if the existing\n        // deposit amount is 0, require the amount to be > 0. Otherwise, the depositedCollateralAssets[_account]\n        // could be filled with duplicates, causing collateral to be double-counted in the collateral value.\n        require(_depositAmount > 0, Error.ZERO_DEPOSIT);\n\n        // If the account does not have an existing deposit for this collateral asset,\n        // push it to the list of the account's deposited collateral assets.\n        uint256 existingDepositAmount = self.getCollateralDeposits(_account, _collateralAsset);\n        if (existingDepositAmount == 0) {\n            self.depositedCollateralAssets[_account].push(_collateralAsset);\n        }\n        // Record the deposit.\n        unchecked {\n            self.collateralDeposits[_account][_collateralAsset] = self\n                .collateralAssets[_collateralAsset]\n                .toNonRebasingAmount(existingDepositAmount + _depositAmount);\n        }\n\n        emit MinterEvent.CollateralDeposited(_account, _collateralAsset, _depositAmount);\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibDecimals.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {ms} from \"../MinterStorage.sol\";\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\n\n/**\n * @title Library for Kresko specific decimals\n */\nlibrary LibDecimals {\n    using FixedPoint for FixedPoint.Unsigned;\n\n    /**\n     * @notice For a given collateral asset and amount, returns a FixedPoint.Unsigned representation.\n     * @dev If the collateral asset has decimals other than 18, the amount is scaled appropriately.\n     *   If decimals > 18, there may be a loss of precision.\n     * @param _collateralAssetDecimals The collateral asset's number of decimals\n     * @param _amount The amount of the collateral asset.\n     * @return A FixedPoint.Unsigned of amount scaled according to the collateral asset's decimals.\n     */\n    function toCollateralFixedPointAmount(uint256 _collateralAssetDecimals, uint256 _amount)\n        internal\n        pure\n        returns (FixedPoint.Unsigned memory)\n    {\n        // Initially, use the amount as the raw value for the FixedPoint.Unsigned,\n        // which internally uses FixedPoint.FP_DECIMALS (18) decimals. Most collateral\n        // assets will have 18 decimals.\n        FixedPoint.Unsigned memory fixedPointAmount = FixedPoint.Unsigned(_amount);\n        // Handle cases where the collateral asset's decimal amount is not 18.\n        if (_collateralAssetDecimals < FixedPoint.FP_DECIMALS) {\n            // If the decimals are less than 18, multiply the amount\n            // to get the correct fixed point value.\n            // E.g. 1 full token of a 17 decimal token will  cause the\n            // initial setting of amount to be 0.1, so we multiply\n            // by 10 ** (18 - 17) = 10 to get it to 0.1 * 10 = 1.\n            return fixedPointAmount.mul(10**(FixedPoint.FP_DECIMALS - _collateralAssetDecimals));\n        } else if (_collateralAssetDecimals > FixedPoint.FP_DECIMALS) {\n            // If the decimals are greater than 18, divide the amount\n            // to get the correct fixed point value.\n            // Note because FixedPoint numbers are 18 decimals, this results\n            // in loss of precision. E.g. if the collateral asset has 19\n            // decimals and the deposit amount is only 1 uint, this will divide\n            // 1 by 10 ** (19 - 18), resulting in 1 / 10 = 0\n            return fixedPointAmount.div(10**(_collateralAssetDecimals - FixedPoint.FP_DECIMALS));\n        }\n        return fixedPointAmount;\n    }\n\n    /**\n     * @notice For a given collateral asset and fixed point amount, i.e. where a rawValue of 1e18 is equal to 1\n     *   whole token, returns the amount according to the collateral asset's decimals.\n     * @dev If the collateral asset has decimals other than 18, the amount is scaled appropriately.\n     *   If decimals < 18, there may be a loss of precision.\n     * @param _collateralAssetDecimals The collateral asset's number of decimals\n     * @param _fixedPointAmount The fixed point amount of the collateral asset.\n     * @return An amount that is compatible with the collateral asset's decimals.\n     */\n    function fromCollateralFixedPointAmount(\n        uint256 _collateralAssetDecimals,\n        FixedPoint.Unsigned memory _fixedPointAmount\n    ) internal pure returns (uint256) {\n        // Initially, use the rawValue, which internally uses FixedPoint.FP_DECIMALS (18) decimals\n        // Most collateral assets will have 18 decimals.\n        uint256 amount = _fixedPointAmount.rawValue;\n        // Handle cases where the collateral asset's decimal amount is not 18.\n        if (_collateralAssetDecimals < FixedPoint.FP_DECIMALS) {\n            // If the decimals are less than 18, divide the depositAmount\n            // to get the correct fixed point value.\n            // E.g. 1 full token will result in amount being 1e18 at this point,\n            // so if the token has 17 decimals, divide by 10 ** (18 - 17) = 10\n            // to get a value of 1e17.\n            // This may result in a loss of precision.\n            return amount / (10**(FixedPoint.FP_DECIMALS - _collateralAssetDecimals));\n        } else if (_collateralAssetDecimals > FixedPoint.FP_DECIMALS) {\n            // If the decimals are greater than 18, multiply the depositAmount\n            // to get the correct fixed point value.\n            // E.g. 1 full token will result in amount being 1e18 at this point,\n            // so if the token has 19 decimals, multiply by 10 ** (19 - 18) = 10\n            // to get a value of 1e19.\n            return amount * (10**(_collateralAssetDecimals - FixedPoint.FP_DECIMALS));\n        }\n        return amount;\n    }\n\n    /**\n     * @notice Divides an uint256 @param _value with @param _priceWithOracleDecimals\n     * @param _value Left side value of the division\n     * @param wadValue result with 18 decimals\n     */\n    function divByPrice(uint256 _value, uint256 _priceWithOracleDecimals) internal view returns (uint256 wadValue) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals >= 18) return _priceWithOracleDecimals;\n        return (_value / _priceWithOracleDecimals) * 10**(oracleDecimals);\n    }\n\n    /**\n     * @notice Converts an uint256 with extOracleDecimals into a number with 18 decimals\n     * @param _wadPrice value with extOracleDecimals\n     */\n    function fromWadPriceToUint(uint256 _wadPrice) internal view returns (uint256 priceWithOracleDecimals) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals == 18) return _wadPrice;\n        return _wadPrice / 10**(18 - oracleDecimals);\n    }\n\n    /**\n     * @notice Converts an 18 decimal price to a FixedPoint with extOracleDecimals\n     * @param _wadPrice value with extOracleDecimals\n     * @return priceWithOracleDecimals FixedPoint value with extOracleDecimals\n     */\n    function fromWadPriceToFixedPoint(uint256 _wadPrice)\n        internal\n        view\n        returns (FixedPoint.Unsigned memory priceWithOracleDecimals)\n    {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals == 18) {\n            return FixedPoint.Unsigned(_wadPrice);\n        }\n        return FixedPoint.Unsigned(_wadPrice / 10**(18 - oracleDecimals));\n    }\n\n    /**\n     * @notice Converts an uint256 with extOracleDecimals into a number with 18 decimals\n     * @param _priceWithOracleDecimals value with extOracleDecimals\n     * @return wadPrice price with 18 decimals\n     */\n    function oraclePriceToWad(uint256 _priceWithOracleDecimals) internal view returns (uint256 wadPrice) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals == 18) {\n            return _priceWithOracleDecimals;\n        }\n        return _priceWithOracleDecimals * 10**(18 - oracleDecimals);\n    }\n\n    /**\n     * @notice Converts an int256 with extOracleDecimals into a number with 18 decimals\n     * @param _priceWithOracleDecimals value with extOracleDecimals\n     * @return wadPrice price with 18 decimals\n     */\n    function oraclePriceToWad(int256 _priceWithOracleDecimals) internal view returns (uint256 wadPrice) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals >= 18) return uint256(_priceWithOracleDecimals);\n        return uint256(_priceWithOracleDecimals) * 10**(18 - oracleDecimals);\n    }\n\n    /**\n     * @notice Converts an int256 with extOracleDecimals into a number with 18 decimals\n     * @param _priceWithOracleDecimals value with extOracleDecimals\n     * @return wadPrice price with 18 decimals\n     */\n    function fromFixedPointPriceToWad(FixedPoint.Unsigned memory _priceWithOracleDecimals)\n        internal\n        view\n        returns (uint256 wadPrice)\n    {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals == 18) return _priceWithOracleDecimals.rawValue;\n        return _priceWithOracleDecimals.rawValue * 10**(18 - oracleDecimals);\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibKrAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\nimport {IUniswapV2Oracle} from \"../interfaces/IUniswapV2Oracle.sol\";\nimport {KrAsset} from \"../MinterTypes.sol\";\nimport {MinterState} from \"../MinterState.sol\";\n\nlibrary LibKrAsset {\n    using FixedPoint for FixedPoint.Unsigned;\n    using FixedPoint for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Functions                                 */\n    /* -------------------------------------------------------------------------- */\n    /**\n     * @notice Get the state of a specific krAsset\n     * @param _asset Address of the asset.\n     * @return State of assets `KrAsset` struct\n     */\n    function kreskoAsset(MinterState storage self, address _asset) internal view returns (KrAsset memory) {\n        return self.kreskoAssets[_asset];\n    }\n\n    /**\n     * @notice Gets the USD value for a single Kresko asset and amount.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _amount The amount of the Kresko asset to calculate the value for.\n     * @param _ignoreKFactor Boolean indicating if the asset's k-factor should be ignored.\n     * @return The value for the provided amount of the Kresko asset.\n     */\n    function getKrAssetValue(\n        MinterState storage self,\n        address _kreskoAsset,\n        uint256 _amount,\n        bool _ignoreKFactor\n    ) internal view returns (FixedPoint.Unsigned memory) {\n        KrAsset memory krAsset = self.kreskoAssets[_kreskoAsset];\n        FixedPoint.Unsigned memory value = krAsset.fixedPointUSD(_amount);\n\n        if (!_ignoreKFactor) {\n            value = value.mul(krAsset.kFactor);\n        }\n\n        return value;\n    }\n\n    function getKrAssetAMMPrice(\n        MinterState storage self,\n        address _kreskoAsset,\n        uint256 _amount\n    ) internal view returns (FixedPoint.Unsigned memory) {\n        if (self.ammOracle == address(0)) {\n            return FixedPoint.Unsigned(0);\n        }\n        return IUniswapV2Oracle(self.ammOracle).consultKrAsset(_kreskoAsset, _amount).toFixedPoint();\n    }\n\n    /**\n     * @notice Get the minimum collateral value required to\n     * back a Kresko asset amount at a given collateralization ratio.\n     * @param _krAsset The address of the Kresko asset.\n     * @param _amount The Kresko Asset debt amount.\n     * @return minCollateralValue is the minimum collateral value required for this Kresko Asset amount.\n     * @param _ratio The collateralization ratio required: higher ratio = more collateral required.\n     */\n    function getMinimumCollateralValueAtRatio(\n        MinterState storage self,\n        address _krAsset,\n        uint256 _amount,\n        FixedPoint.Unsigned memory _ratio\n    ) internal view returns (FixedPoint.Unsigned memory minCollateralValue) {\n        // Calculate the collateral value required to back this Kresko asset amount at the given ratio\n        return self.getKrAssetValue(_krAsset, _amount, false).mul(_ratio);\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibMint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n// solhint-disable not-rely-on-time\n// solhint-disable-next-line\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\n\nimport {LibCalculation} from \"./LibCalculation.sol\";\nimport {KrAsset} from \"../MinterTypes.sol\";\nimport {MinterState} from \"../MinterState.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\nlibrary LibMint {\n    using Arrays for address[];\n\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n\n    using FixedPoint for FixedPoint.Unsigned;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using LibCalculation for MinterState;\n\n    /// @notice Mint kresko assets with stability rate updates.\n    /// @dev Updates the principal in MinterState and stability rate adjusted values in InterestRateState\n    /// @param _kreskoAsset the asset being repaid\n    /// @param _anchor the anchor token of the asset being repaid\n    /// @param _amount the asset amount being burned\n    /// @param _account the account the debt is subtracted from\n    function mint(\n        MinterState storage self,\n        address _kreskoAsset,\n        address _anchor,\n        uint256 _amount,\n        address _account\n    ) internal {\n        // Update global debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n        // Get possibly rebalanced amount of kresko asset\n        uint256 issued = IKreskoAssetIssuer(_anchor).issue(_amount, _account);\n        // Calculate debt index scaled value\n        uint256 amountScaled = issued.wadToRay().rayDiv(newDebtIndex);\n        require(amountScaled != 0, Error.INVALID_SCALED_AMOUNT);\n        // Increase principal debt\n        self.kreskoAssetDebt[_account][_kreskoAsset] += issued;\n        // Update scaled values for the user\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled += uint128(amountScaled);\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n        // Update the global rate for the asset\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n    }\n\n    /**\n     * @notice Charges the protocol open fee based off the value of the minted asset.\n     * @dev Takes the fee from the account's collateral assets. Attempts collateral assets\n     *   in reverse order of the account's deposited collateral assets array.\n     * @param _account The account to charge the open fee from.\n     * @param _kreskoAsset The address of the kresko asset being burned.\n     * @param _kreskoAssetAmountMinted The amount of the kresko asset being minted.\n     */\n    function chargeOpenFee(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset,\n        uint256 _kreskoAssetAmountMinted\n    ) internal {\n        KrAsset memory krAsset = self.kreskoAssets[_kreskoAsset];\n        // Calculate the value of the fee according to the value of the krAssets being minted.\n        FixedPoint.Unsigned memory feeValue = krAsset.fixedPointUSD(_kreskoAssetAmountMinted).mul(krAsset.openFee);\n\n        // Do nothing if the fee value is 0.\n        if (feeValue.rawValue == 0) {\n            return;\n        }\n\n        address[] memory accountCollateralAssets = self.depositedCollateralAssets[_account];\n        // Iterate backward through the account's deposited collateral assets to safely\n        // traverse the array while still being able to remove elements if necessary.\n        // This is because removing the last element of the array does not shift around\n        // other elements in the array.\n        for (uint256 i = accountCollateralAssets.length - 1; i >= 0; i--) {\n            address collateralAssetAddress = accountCollateralAssets[i];\n\n            (uint256 transferAmount, FixedPoint.Unsigned memory feeValuePaid) = self.calcFee(\n                collateralAssetAddress,\n                _account,\n                feeValue,\n                i\n            );\n\n            // Remove the transferAmount from the stored deposit for the account.\n            self.collateralDeposits[_account][collateralAssetAddress] -= self\n                .collateralAssets[collateralAssetAddress]\n                .toNonRebasingAmount(transferAmount);\n\n            // Transfer the fee to the feeRecipient.\n            IERC20Upgradeable(collateralAssetAddress).safeTransfer(self.feeRecipient, transferAmount);\n            emit MinterEvent.OpenFeePaid(_account, collateralAssetAddress, transferAmount, feeValuePaid.rawValue);\n\n            feeValue = feeValue.sub(feeValuePaid);\n            // If the entire fee has been paid, no more action needed.\n            if (feeValue.rawValue == 0) {\n                return;\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibRepay.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n// solhint-disable not-rely-on-time\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {MinterEvent, InterestRateEvent} from \"../../libs/Events.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\nimport {IERC20Upgradeable} from \"../../shared/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"../../shared/SafeERC20Upgradeable.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\n\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {LibCalculation} from \"./LibCalculation.sol\";\nimport {KrAsset} from \"../MinterTypes.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {MinterState} from \"../MinterState.sol\";\n\nlibrary LibRepay {\n    using Arrays for address[];\n\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n\n    using FixedPoint for FixedPoint.Unsigned;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using LibCalculation for MinterState;\n\n    /// @notice Repay user kresko asset debt with stability rate updates.\n    /// @dev Updates the principal in MinterState and stability rate adjusted values in InterestRateState\n    /// @param _kreskoAsset the asset being repaid\n    /// @param _anchor the anchor token of the asset being repaid\n    /// @param _burnAmount the asset amount being burned\n    /// @param _account the account the debt is subtracted from\n    function repay(\n        MinterState storage self,\n        address _kreskoAsset,\n        address _anchor,\n        uint256 _burnAmount,\n        address _account\n    ) internal {\n        // Update global debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n        // Get the possibly rebalanced amount of destroyed tokens\n        uint256 destroyed = IKreskoAssetIssuer(_anchor).destroy(_burnAmount, msg.sender);\n        // Calculate the debt index scaled amount\n        uint256 amountScaled = destroyed.wadToRay().rayDiv(newDebtIndex);\n        require(amountScaled != 0, Error.INVALID_SCALED_AMOUNT);\n\n        // Decrease the principal debt\n        self.kreskoAssetDebt[_account][_kreskoAsset] -= destroyed;\n        // Decrease the scaled debt and set user asset's last debt index\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled -= uint128(amountScaled);\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n        // Update the stability rate for the asset\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n    }\n\n    /**\n     * @notice Repays accrued stability rate interest for a single asset\n     * @param _account Account to repay interest for\n     * @param _kreskoAsset Kresko asset to repay interest for\n     * @return kissRepayAmount amount repaid\n     */\n    function repayFullStabilityRateInterest(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset\n    ) internal returns (uint256 kissRepayAmount) {\n        // Update debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n        // Get the accrued interest in repayment token\n        (, kissRepayAmount) = self.getKreskoAssetDebtInterest(_account, _kreskoAsset);\n\n        // If no interest has accrued no further operations needed\n        // Do not revert because we want the preserve new debt index and stability rate\n        if (kissRepayAmount == 0) {\n            // Update stability rate for asset\n            irs().srAssets[_kreskoAsset].updateStabilityRate();\n            return 0;\n        }\n\n        // Transfer the accrued interest\n        IERC20Upgradeable(irs().kiss).safeTransferFrom(msg.sender, self.feeRecipient, kissRepayAmount);\n\n        // Update scaled values for the user\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled = uint128(\n            self.getKreskoAssetDebtPrincipal(_account, _kreskoAsset).wadToRay().rayDiv(newDebtIndex)\n        );\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n\n        // Remove from minted kresko assets if debt is cleared\n        if (self.getKreskoAssetDebtPrincipal(_account, _kreskoAsset) == 0) {\n            self.mintedKreskoAssets[_account].removeAddress(\n                _kreskoAsset,\n                self.getMintedKreskoAssetsIndex(_account, _kreskoAsset)\n            );\n        }\n\n        // Update stability rates\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n        // Emit event with the account, asset and amount repaid\n        emit InterestRateEvent.StabilityRateInterestRepaid(_account, _kreskoAsset, kissRepayAmount);\n    }\n\n    /**\n     * @notice Charges the protocol close fee based off the value of the burned asset.\n     * @dev Takes the fee from the account's collateral assets. Attempts collateral assets\n     *   in reverse order of the account's deposited collateral assets array.\n     * @param _account The account to charge the close fee from.\n     * @param _kreskoAsset The address of the kresko asset being burned.\n     * @param _burnAmount The amount of the kresko asset being burned.\n     */\n    function chargeCloseFee(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset,\n        uint256 _burnAmount\n    ) internal {\n        KrAsset memory krAsset = self.kreskoAssets[_kreskoAsset];\n        // Calculate the value of the fee according to the value of the krAssets being burned.\n        FixedPoint.Unsigned memory feeValue = krAsset.fixedPointUSD(_burnAmount).mul(krAsset.closeFee);\n\n        // Do nothing if the fee value is 0.\n        if (feeValue.rawValue == 0) {\n            return;\n        }\n\n        address[] memory accountCollateralAssets = self.depositedCollateralAssets[_account];\n        // Iterate backward through the account's deposited collateral assets to safely\n        // traverse the array while still being able to remove elements if necessary.\n        // This is because removing the last element of the array does not shift around\n        // other elements in the array.\n\n        for (uint256 i = accountCollateralAssets.length - 1; i >= 0; i--) {\n            address collateralAssetAddress = accountCollateralAssets[i];\n\n            (uint256 transferAmount, FixedPoint.Unsigned memory feeValuePaid) = self.calcFee(\n                collateralAssetAddress,\n                _account,\n                feeValue,\n                i\n            );\n\n            // Remove the transferAmount from the stored deposit for the account.\n            self.collateralDeposits[_account][collateralAssetAddress] -= self\n                .collateralAssets[collateralAssetAddress]\n                .toNonRebasingAmount(transferAmount);\n\n            // Transfer the fee to the feeRecipient.\n            IERC20Upgradeable(collateralAssetAddress).safeTransfer(self.feeRecipient, transferAmount);\n            emit MinterEvent.CloseFeePaid(_account, collateralAssetAddress, transferAmount, feeValuePaid.rawValue);\n\n            feeValue = feeValue.sub(feeValuePaid);\n            // If the entire fee has been paid, no more action needed.\n            if (feeValue.rawValue == 0) {\n                return;\n            }\n        }\n    }\n\n    /**\n     * @notice Check that debt repaid does not leave a dust position, if it does:\n     * return an amount that pays up to minDebtValue\n     * @param _kreskoAsset The address of the kresko asset being burned.\n     * @param _burnAmount The amount being burned\n     * @param _debtAmount The debt amount of `_account`\n     * @return amount == 0 or >= minDebtAmount\n     */\n    function ensureNotDustPosition(\n        MinterState storage self,\n        address _kreskoAsset,\n        uint256 _burnAmount,\n        uint256 _debtAmount\n    ) internal view returns (uint256 amount) {\n        // If the requested burn would put the user's debt position below the minimum\n        // debt value, close up to the minimum debt value instead.\n        FixedPoint.Unsigned memory krAssetValue = self.getKrAssetValue(_kreskoAsset, _debtAmount - _burnAmount, true);\n        if (krAssetValue.isGreaterThan(0) && krAssetValue.isLessThan(self.minimumDebtValue)) {\n            FixedPoint.Unsigned memory minDebtValue = self.minimumDebtValue.div(\n                self.kreskoAssets[_kreskoAsset].fixedPointPrice()\n            );\n            amount = _debtAmount - minDebtValue.rawValue;\n        } else {\n            amount = _burnAmount;\n        }\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibStabilityRate.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.14;\n\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\nimport {IERC20Upgradeable} from \"../../shared/IERC20Upgradeable.sol\";\n\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Percentages} from \"../../libs/Percentages.sol\";\nimport {LibKrAsset} from \"../libs/LibKrAsset.sol\";\n\nimport {StabilityRateConfig} from \"../InterestRateState.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @author Kresko\n * @title AMM price stability rate library, derived from Aave Protocols VariableDebtToken calculations\n * @notice Library for performing stability rate related operations\n */\nlibrary LibStabilityRate {\n    using WadRay for uint256;\n    using WadRay for uint128;\n    using Percentages for uint256;\n    using FixedPoint for FixedPoint.Unsigned;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /**\n     * @notice Cumulates the stability rate from previous update and multiplies the debt index with it.\n     * @dev Updates the updated timestamp\n     * @dev New debt index cannot overflow uint128\n     * @param self configuration for the asset\n     * @return newDebtIndex the updated index\n     */\n    function updateDebtIndex(StabilityRateConfig storage self) internal returns (uint256 newDebtIndex) {\n        if (self.asset == address(0)) return WadRay.RAY;\n\n        newDebtIndex = self.debtIndex;\n        // only cumulating if there is any assets minted and rate is over 0\n        if (IERC20Upgradeable(self.asset).totalSupply() != 0) {\n            uint256 cumulatedStabilityRate = self.calculateCompoundedInterest(block.timestamp);\n            newDebtIndex = cumulatedStabilityRate.rayMul(self.debtIndex);\n            require(newDebtIndex <= type(uint128).max, Error.DEBT_INDEX_OVERFLOW);\n            self.debtIndex = uint128(newDebtIndex);\n        }\n\n        self.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /**\n     * @notice Updates the current stability rate for an asset\n     * @dev New stability rate cannot overflow uint128\n     * @param self rate configuration for the asset\n     */\n    function updateStabilityRate(StabilityRateConfig storage self) internal {\n        if (self.asset == address(0)) return;\n\n        uint256 stabilityRate = calculateStabilityRate(self);\n        require(stabilityRate <= type(uint128).max, Error.STABILITY_RATE_OVERFLOW);\n        self.stabilityRate = uint128(stabilityRate);\n    }\n\n    /**\n     * @notice Get the current price rate between AMM and oracle pricing\n     * @dev Raw return value of ammPrice == 0 when no AMM pair exists OR liquidity of the pair does not qualify\n     * @param self rate configuration for the asset\n     * @return priceRate the current price rate\n     */\n    function getPriceRate(StabilityRateConfig storage self) internal view returns (uint256 priceRate) {\n        FixedPoint.Unsigned memory oraclePrice = ms().getKrAssetValue(self.asset, 1 ether, true);\n        FixedPoint.Unsigned memory ammPrice = ms().getKrAssetAMMPrice(self.asset, 1 ether);\n        // no pair, no effect\n        if (ammPrice.rawValue == 0) {\n            return 0;\n        }\n        return ammPrice.div(oraclePrice).div(10).rawValue;\n    }\n\n    /**\n     * @notice Calculate new stability rate from the current price rate\n     * @dev Separate calculations exist for following cases:\n     * case 1: AMM premium > optimal + delta\n     * case 2: AMM premium < optimal - delta\n     * case 3: AMM premium <= optimal + delta && AMM premium >= optimal - delta\n     * @param self rate configuration for the asset\n     * @return stabilityRate the current stability rate\n     */\n    function calculateStabilityRate(StabilityRateConfig storage self) internal view returns (uint256 stabilityRate) {\n        uint256 priceRate = self.getPriceRate(); // 0.95 RAY = -5% PREMIUM, 1.05 RAY = +5% PREMIUM\n\n        // Return base rate if no AMM price exists\n        if (priceRate == 0) {\n            return self.stabilityRateBase;\n        }\n        // If AMM price > priceRate + delta, eg. AMM price is higher than oracle price\n        if (priceRate > self.optimalPriceRate + self.priceRateDelta) {\n            uint256 excessRate = priceRate - WadRay.RAY;\n            stabilityRate =\n                self.stabilityRateBase.rayDiv(priceRate.percentMul(125e2)) +\n                ((WadRay.RAY - excessRate).rayMul(self.rateSlope1));\n            // If AMM price < pricaRate + delta, AMM price is lower than oracle price\n        } else if (priceRate < self.optimalPriceRate - self.priceRateDelta) {\n            uint256 multiplier = (WadRay.RAY - priceRate).rayDiv(self.priceRateDelta);\n            stabilityRate =\n                (self.stabilityRateBase + self.rateSlope1) +\n                WadRay.RAY.rayMul(multiplier).rayMul(self.rateSlope2);\n            // Default case, AMM price is within optimal range of oracle price\n        } else {\n            stabilityRate = self.stabilityRateBase + (priceRate.rayMul(self.rateSlope1));\n        }\n    }\n\n    /**\n     * @dev Function to calculate the interest using a compounded interest rate formula\n     * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\n     *\n     *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n     *\n     * The approximation slightly underpays liquidity providers and undercharges borrowers\n     * with the advantage of great gas cost reductions\n     * The Aave whitepaper contains reference to the approximation\n     * with a table showing the margin of error per different time periods\n     *\n     * @param self rate configuration for the asset\n     * @param _currentTimestamp The timestamp of the last update of the interest\n     * @return The interest rate compounded during the timeDelta, in ray\n     **/\n    function calculateCompoundedInterest(StabilityRateConfig storage self, uint256 _currentTimestamp)\n        internal\n        view\n        returns (uint256)\n    {\n        //solium-disable-next-line\n        uint256 exp = _currentTimestamp - uint256(self.lastUpdateTimestamp);\n\n        if (exp == 0) {\n            return WadRay.RAY;\n        }\n\n        uint256 expMinusOne;\n        uint256 expMinusTwo;\n        uint256 basePowerTwo;\n        uint256 basePowerThree;\n        unchecked {\n            expMinusOne = exp - 1;\n\n            expMinusTwo = exp > 2 ? exp - 2 : 0;\n\n            basePowerTwo = self.stabilityRate.rayMul(self.stabilityRate) / (SECONDS_PER_YEAR * SECONDS_PER_YEAR);\n            basePowerThree = basePowerTwo.rayMul(self.stabilityRate) / SECONDS_PER_YEAR;\n        }\n\n        uint256 secondTerm = exp * expMinusOne * basePowerTwo;\n        unchecked {\n            secondTerm /= 2;\n        }\n        uint256 thirdTerm = exp * expMinusOne * expMinusTwo * basePowerThree;\n        unchecked {\n            thirdTerm /= 6;\n        }\n\n        return WadRay.RAY + (self.stabilityRate * exp) / SECONDS_PER_YEAR + secondTerm + thirdTerm;\n    }\n\n    /**\n     * @dev Returns the ongoing normalized debt index for the borrowers\n     * A value of 1e27 means there is no interest. As time passes, the interest is accrued\n     * A value of 2*1e27 means that for each unit of debt, one unit worth of interest has been accumulated\n     * @param self rate configuration for the asset\n     * @return The normalized debt index. expressed in ray\n     **/\n    function getNormalizedDebtIndex(StabilityRateConfig storage self) internal view returns (uint256) {\n        if (self.asset == address(0)) return WadRay.RAY;\n        //solium-disable-next-line\n        if (self.lastUpdateTimestamp == uint40(block.timestamp)) {\n            //if the index was updated in the same block, no need to perform any calculation\n            return self.debtIndex;\n        }\n\n        return self.calculateCompoundedInterest(block.timestamp).rayMul(self.debtIndex);\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibUI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n// solhint-disable-next-line\nimport {IERC20Upgradeable} from \"../../shared/IERC20Upgradeable.sol\";\nimport {AggregatorV2V3Interface} from \"../../vendor/flux/interfaces/AggregatorV2V3Interface.sol\";\nimport {IUniswapV2Pair} from \"../../vendor/uniswap/v2-core/interfaces/IUniswapV2Pair.sol\";\nimport {IKrStaking} from \"../../staking/interfaces/IKrStaking.sol\";\nimport {LibDecimals, FixedPoint} from \"../libs/LibDecimals.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\n\nimport {KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {MinterState, ms} from \"../MinterStorage.sol\";\n\n/* solhint-disable contract-name-camelcase */\n/* solhint-disable var-name-mixedcase */\n\n/**\n * @title Library for UI related views\n * @author Kresko\n */\nlibrary LibUI {\n    using LibDecimals for uint256;\n    using FixedPoint for FixedPoint.Unsigned;\n\n    struct CollateralAssetInfoUser {\n        address assetAddress;\n        address oracleAddress;\n        address anchorAddress;\n        uint256 amount;\n        FixedPoint.Unsigned amountUSD;\n        FixedPoint.Unsigned cFactor;\n        uint8 decimals;\n        uint256 index;\n        uint256 price;\n        string symbol;\n        string name;\n    }\n\n    struct CollateralAssetInfo {\n        address assetAddress;\n        address oracleAddress;\n        address anchorAddress;\n        uint256 price;\n        uint256 value;\n        FixedPoint.Unsigned cFactor;\n        uint8 decimals;\n        string symbol;\n        string name;\n        bool marketOpen;\n    }\n\n    struct ProtocolParams {\n        uint256 liqMultiplier;\n        uint256 minDebtValue;\n        uint256 minCollateralRatio;\n        uint256 liquidationThreshold;\n    }\n\n    struct krAssetInfo {\n        address oracleAddress;\n        address assetAddress;\n        address anchorAddress;\n        uint256 price;\n        uint256 value;\n        FixedPoint.Unsigned openFee;\n        FixedPoint.Unsigned closeFee;\n        FixedPoint.Unsigned kFactor;\n        string symbol;\n        string name;\n        bool marketOpen;\n    }\n\n    struct KreskoUser {\n        krAssetInfoUser[] krAssets;\n        CollateralAssetInfoUser[] collateralAssets;\n        FixedPoint.Unsigned healthFactor;\n        FixedPoint.Unsigned debtActualUSD;\n        FixedPoint.Unsigned debtUSD;\n        FixedPoint.Unsigned collateralActualUSD;\n        FixedPoint.Unsigned collateralUSD;\n        FixedPoint.Unsigned minCollateralUSD;\n        FixedPoint.Unsigned borrowingPowerUSD;\n    }\n\n    struct PairData {\n        uint8 decimals0;\n        uint8 decimals1;\n        uint256 reserve0;\n        uint256 reserve1;\n        uint256 totalSupply;\n    }\n\n    struct GenericInfo {\n        address assetAddress;\n        FixedPoint.Unsigned kFactor;\n        FixedPoint.Unsigned cFactor;\n        uint256 price;\n        bool isKrAsset;\n        bool isCollateral;\n        uint256 debtAmount;\n        uint256 depositAmount;\n        uint256 walletBalance;\n    }\n\n    struct Price {\n        uint256 price;\n        uint256 timestamp;\n        address assetAddress;\n        uint80 roundId;\n        bool marketOpen;\n    }\n\n    struct Allowance {\n        address owner;\n        address spender;\n        uint256 allowance;\n    }\n\n    struct Balance {\n        address token;\n        uint256 balance;\n    }\n\n    struct TokenMetadata {\n        uint8 decimals;\n        string symbol;\n        string name;\n        uint256 totalSupply;\n    }\n\n    struct StakingData {\n        uint256 pid;\n        address depositToken;\n        uint256 totalDeposits;\n        uint256 allocPoint;\n        uint256[] rewardPerBlocks;\n        uint256 lastRewardBlock;\n        uint256 depositAmount;\n        address[] rewardTokens;\n        uint256[] rewardAmounts;\n    }\n\n    struct krAssetInfoUser {\n        address assetAddress;\n        address oracleAddress;\n        address anchorAddress;\n        uint256 amount;\n        FixedPoint.Unsigned amountUSD;\n        uint256 index;\n        FixedPoint.Unsigned kFactor;\n        uint256 price;\n        string symbol;\n        string name;\n        FixedPoint.Unsigned openFee;\n        FixedPoint.Unsigned closeFee;\n    }\n\n    function getBalances(address[] memory _tokens, address account) internal view returns (Balance[] memory balances) {\n        balances = new Balance[](_tokens.length);\n        for (uint256 i; i < _tokens.length; i++) {\n            balances[i] = Balance({\n                token: address(_tokens[i]),\n                balance: IERC20Upgradeable(_tokens[i]).balanceOf(account)\n            });\n        }\n    }\n\n    function getAllowances(\n        address[] memory _tokens,\n        address owner,\n        address spender\n    ) internal view returns (Allowance[] memory allowances) {\n        allowances = new Allowance[](_tokens.length);\n        for (uint256 i; i < _tokens.length; i++) {\n            allowances[i] = Allowance({\n                allowance: IERC20Upgradeable(_tokens[i]).allowance(owner, spender),\n                spender: spender,\n                owner: owner\n            });\n        }\n    }\n\n    function getStakingData(address _account, address _staking) internal view returns (StakingData[] memory result) {\n        IKrStaking staking = IKrStaking(_staking);\n        IKrStaking.Reward[] memory rewards = staking.allPendingRewards(_account);\n        result = new StakingData[](rewards.length);\n\n        for (uint256 i; i < rewards.length; i++) {\n            IKrStaking.PoolInfo memory poolInfo = staking.poolInfo(rewards[i].pid);\n            address depositTokenAddress = address(poolInfo.depositToken);\n            result[i] = StakingData({\n                pid: rewards[i].pid,\n                totalDeposits: poolInfo.depositToken.balanceOf(_staking),\n                allocPoint: poolInfo.allocPoint,\n                depositToken: depositTokenAddress,\n                depositAmount: staking.userInfo(rewards[i].pid, _account).amount,\n                rewardTokens: rewards[i].tokens,\n                rewardAmounts: rewards[i].amounts,\n                rewardPerBlocks: staking.rewardPerBlockFor(depositTokenAddress),\n                lastRewardBlock: poolInfo.lastRewardBlock\n            });\n        }\n    }\n\n    function borrowingPowerUSD(address _account) internal view returns (FixedPoint.Unsigned memory) {\n        FixedPoint.Unsigned memory minCollateral = ms().getAccountMinimumCollateralValueAtRatio(\n            _account,\n            ms().minimumCollateralizationRatio\n        );\n        FixedPoint.Unsigned memory collateral = ms().getAccountCollateralValue(_account);\n\n        if (collateral.isLessThan(minCollateral)) {\n            return FixedPoint.Unsigned(0);\n        } else {\n            return collateral.sub(minCollateral);\n        }\n    }\n\n    function batchOracleValues(\n        address[] memory _assets,\n        address[] memory _priceFeeds,\n        address[] memory _marketStatusFeeds\n    ) internal view returns (Price[] memory result) {\n        require(_marketStatusFeeds.length == _priceFeeds.length, Error.PRICEFEEDS_MUST_MATCH_STATUS_FEEDS);\n        result = new Price[](_assets.length);\n        for (uint256 i; i < _assets.length; i++) {\n            result[i] = Price({\n                price: uint256(AggregatorV2V3Interface(_priceFeeds[i]).latestAnswer()),\n                timestamp: AggregatorV2V3Interface(_priceFeeds[i]).latestTimestamp(),\n                assetAddress: _assets[i],\n                roundId: uint80(AggregatorV2V3Interface(_priceFeeds[i]).latestRound()),\n                marketOpen: AggregatorV2V3Interface(_marketStatusFeeds[i]).latestMarketOpen()\n            });\n        }\n    }\n\n    function krAssetInfos(address[] memory assetAddresses) internal view returns (krAssetInfo[] memory result) {\n        result = new krAssetInfo[](assetAddresses.length);\n        for (uint256 i; i < assetAddresses.length; i++) {\n            address assetAddress = assetAddresses[i];\n            KrAsset memory krAsset = ms().kreskoAssets[assetAddress];\n\n            result[i] = krAssetInfo({\n                value: ms().getKrAssetValue(assetAddress, 1 ether, false).rawValue,\n                oracleAddress: address(krAsset.oracle),\n                anchorAddress: krAsset.anchor,\n                assetAddress: assetAddress,\n                closeFee: krAsset.closeFee,\n                openFee: krAsset.openFee,\n                kFactor: krAsset.kFactor,\n                price: uint256(krAsset.oracle.latestAnswer()),\n                marketOpen: krAsset.marketStatusOracle.latestMarketOpen(),\n                symbol: IERC20Upgradeable(assetAddress).symbol(),\n                name: IERC20Upgradeable(assetAddress).name()\n            });\n        }\n    }\n\n    function collateralAssetInfos(\n        address[] memory assetAddresses\n    ) internal view returns (CollateralAssetInfo[] memory result) {\n        result = new CollateralAssetInfo[](assetAddresses.length);\n        for (uint256 i; i < assetAddresses.length; i++) {\n            address assetAddress = assetAddresses[i];\n            CollateralAsset memory collateralAsset = ms().collateralAssets[assetAddress];\n            uint8 decimals = IERC20Upgradeable(assetAddress).decimals();\n\n            (FixedPoint.Unsigned memory value, FixedPoint.Unsigned memory price) = ms()\n                .getCollateralValueAndOraclePrice(assetAddress, 1 * 10 ** decimals, false);\n\n            result[i] = CollateralAssetInfo({\n                value: value.rawValue,\n                oracleAddress: address(collateralAsset.oracle),\n                anchorAddress: collateralAsset.anchor,\n                assetAddress: assetAddress,\n                cFactor: collateralAsset.factor,\n                decimals: decimals,\n                price: price.rawValue,\n                marketOpen: collateralAsset.marketStatusOracle.latestMarketOpen(),\n                symbol: IERC20Upgradeable(assetAddress).symbol(),\n                name: IERC20Upgradeable(assetAddress).name()\n            });\n        }\n    }\n\n    function collateralAssetInfoFor(\n        address _account\n    ) internal view returns (CollateralAssetInfoUser[] memory result, FixedPoint.Unsigned memory totalCollateralUSD) {\n        address[] memory collateralAssetAddresses = ms().getDepositedCollateralAssets(_account);\n        if (collateralAssetAddresses.length > 0) {\n            result = new CollateralAssetInfoUser[](collateralAssetAddresses.length);\n            for (uint256 i; i < collateralAssetAddresses.length; i++) {\n                address assetAddress = collateralAssetAddresses[i];\n                uint8 decimals = IERC20Upgradeable(assetAddress).decimals();\n\n                uint256 amount = ms().collateralDeposits[_account][assetAddress];\n\n                (FixedPoint.Unsigned memory amountUSD, FixedPoint.Unsigned memory price) = ms()\n                    .getCollateralValueAndOraclePrice(assetAddress, amount, true);\n\n                totalCollateralUSD.add(amountUSD);\n                result[i] = CollateralAssetInfoUser({\n                    amount: amount,\n                    amountUSD: amountUSD,\n                    anchorAddress: ms().collateralAssets[assetAddress].anchor,\n                    oracleAddress: address(ms().collateralAssets[assetAddress].oracle),\n                    assetAddress: assetAddress,\n                    cFactor: ms().collateralAssets[assetAddress].factor,\n                    decimals: decimals,\n                    index: i,\n                    price: price.rawValue,\n                    symbol: IERC20Upgradeable(assetAddress).symbol(),\n                    name: IERC20Upgradeable(assetAddress).name()\n                });\n            }\n        }\n    }\n\n    function krAssetInfoFor(\n        address _account\n    ) internal view returns (krAssetInfoUser[] memory result, FixedPoint.Unsigned memory totalDebtUSD) {\n        address[] memory krAssetAddresses = ms().mintedKreskoAssets[_account];\n        if (krAssetAddresses.length > 0) {\n            result = new krAssetInfoUser[](krAssetAddresses.length);\n            for (uint256 i; i < krAssetAddresses.length; i++) {\n                address assetAddress = krAssetAddresses[i];\n                KrAsset memory krAsset = ms().kreskoAssets[assetAddress];\n                uint256 amount = ms().getKreskoAssetDebtScaled(_account, assetAddress);\n\n                FixedPoint.Unsigned memory amountUSD = ms().getKrAssetValue(assetAddress, amount, true);\n\n                totalDebtUSD.add(amountUSD);\n                result[i] = krAssetInfoUser({\n                    assetAddress: assetAddress,\n                    oracleAddress: address(krAsset.oracle),\n                    anchorAddress: krAsset.anchor,\n                    openFee: krAsset.openFee,\n                    closeFee: krAsset.closeFee,\n                    amount: amount,\n                    amountUSD: amountUSD,\n                    index: i,\n                    kFactor: krAsset.kFactor,\n                    price: uint256(krAsset.oracle.latestAnswer()),\n                    symbol: IERC20Upgradeable(assetAddress).symbol(),\n                    name: IERC20Upgradeable(assetAddress).name()\n                });\n            }\n        }\n    }\n\n    function healthFactorFor(address _account) internal view returns (FixedPoint.Unsigned memory) {\n        FixedPoint.Unsigned memory userDebt = ms().getAccountKrAssetValue(_account);\n        FixedPoint.Unsigned memory userCollateral = ms().getAccountCollateralValue(_account);\n\n        if (userDebt.isGreaterThan(0)) {\n            return userCollateral.div(userDebt);\n        } else {\n            return FixedPoint.Unsigned(0);\n        }\n    }\n\n    function kreskoUser(address _account) internal view returns (KreskoUser memory user) {\n        (krAssetInfoUser[] memory krInfos, FixedPoint.Unsigned memory totalDebtUSD) = krAssetInfoFor(_account);\n        (\n            CollateralAssetInfoUser[] memory collateralInfos,\n            FixedPoint.Unsigned memory totalCollateralUSD\n        ) = collateralAssetInfoFor(_account);\n\n        if (krInfos.length > 0 || collateralInfos.length > 0) {\n            user = KreskoUser({\n                collateralAssets: collateralInfos,\n                krAssets: krInfos,\n                borrowingPowerUSD: borrowingPowerUSD(_account),\n                healthFactor: healthFactorFor(_account),\n                debtActualUSD: totalDebtUSD,\n                debtUSD: ms().getAccountKrAssetValue(_account),\n                collateralActualUSD: totalCollateralUSD,\n                collateralUSD: ms().getAccountCollateralValue(_account),\n                minCollateralUSD: ms().getAccountMinimumCollateralValueAtRatio(\n                    _account,\n                    ms().minimumCollateralizationRatio\n                )\n            });\n        }\n    }\n}\n"
    },
    "src/contracts/minter/MinterState.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {LibKrAsset} from \"./libs/LibKrAsset.sol\";\nimport {LibAccount} from \"./libs/LibAccount.sol\";\nimport {LibCollateral} from \"./libs/LibCollateral.sol\";\nimport {LibCalculation} from \"./libs/LibCalculation.sol\";\nimport {LibRepay} from \"./libs/LibRepay.sol\";\nimport {LibMint} from \"./libs/LibMint.sol\";\nimport {FixedPoint} from \"../libs/FixedPoint.sol\";\nimport {Action, SafetyState, CollateralAsset, KrAsset} from \"./MinterTypes.sol\";\n\n/* solhint-disable state-visibility */\nusing LibCalculation for MinterState global;\nusing LibKrAsset for MinterState global;\nusing LibCollateral for MinterState global;\nusing LibAccount for MinterState global;\nusing LibRepay for MinterState global;\nusing LibMint for MinterState global;\n\n/**\n * @title Storage layout for the minter state\n * @author Kresko\n */\nstruct MinterState {\n    /* -------------------------------------------------------------------------- */\n    /*                               Initialization                               */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Initialization version\n    uint256 initializations;\n    bytes32 domainSeparator;\n    /* -------------------------------------------------------------------------- */\n    /*                           Configurable Parameters                          */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice The recipient of protocol fees.\n    address feeRecipient;\n    /// @notice The factor used to calculate the incentive a liquidator receives in the form of seized collateral.\n    FixedPoint.Unsigned liquidationIncentiveMultiplier;\n    /// @notice The absolute minimum ratio of collateral value to debt value used to calculate collateral requirements.\n    FixedPoint.Unsigned minimumCollateralizationRatio;\n    /// @notice The minimum USD value of an individual synthetic asset debt position.\n    FixedPoint.Unsigned minimumDebtValue;\n    /// @notice The collateralization ratio at which positions may be liquidated.\n    FixedPoint.Unsigned liquidationThreshold;\n    /// @notice Flag tells if there is a need to perform safety checks on user actions\n    bool safetyStateSet;\n    /// @notice asset -> action -> state\n    mapping(address => mapping(Action => SafetyState)) safetyState;\n    /* -------------------------------------------------------------------------- */\n    /*                              Collateral Assets                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Mapping of collateral asset token address to information on the collateral asset.\n    mapping(address => CollateralAsset) collateralAssets;\n    /**\n     * @notice Mapping of account -> asset -> deposit amount\n     */\n    mapping(address => mapping(address => uint256)) collateralDeposits;\n    /// @notice Mapping of account -> collateral asset addresses deposited\n    mapping(address => address[]) depositedCollateralAssets;\n    /* -------------------------------------------------------------------------- */\n    /*                                Kresko Assets                               */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Mapping of kresko asset token address to information on the Kresko asset.\n    mapping(address => KrAsset) kreskoAssets;\n    /// @notice Mapping of account -> krAsset -> debt amount owed to the protocol\n    mapping(address => mapping(address => uint256)) kreskoAssetDebt;\n    /// @notice Mapping of account -> addresses of borrowed krAssets\n    mapping(address => address[]) mintedKreskoAssets;\n    /// @notice The AMM oracle address.\n    address ammOracle;\n    /// @notice Offchain oracle decimals\n    uint8 extOracleDecimals;\n}\n"
    },
    "src/contracts/minter/MinterStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\npragma solidity >=0.8.14;\n\nimport {MinterState} from \"./MinterState.sol\";\n\n// Storage position\nbytes32 constant MINTER_STORAGE_POSITION = keccak256(\"kresko.minter.storage\");\n\nfunction ms() pure returns (MinterState storage state) {\n    bytes32 position = MINTER_STORAGE_POSITION;\n    assembly {\n        state.slot := position\n    }\n}\n"
    },
    "src/contracts/minter/MinterTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {AggregatorV2V3Interface} from \"../vendor/flux/interfaces/AggregatorV2V3Interface.sol\";\nimport {FixedPoint} from \"../libs/FixedPoint.sol\";\nimport {IKreskoAssetAnchor} from \"../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {LibAssetUtility} from \"./libs/LibAssetUtility.sol\";\n\n/* solhint-disable state-visibility */\n\n/* -------------------------------------------------------------------------- */\n/*                                  CONSTANTS                                 */\n/* -------------------------------------------------------------------------- */\n\nlibrary Constants {\n    uint256 constant ONE_HUNDRED_PERCENT = 1e18;\n\n    /// @dev The maximum configurable close fee.\n    uint256 constant MAX_CLOSE_FEE = 10e16; // 10%\n\n    /// @dev The maximum configurable open fee.\n    uint256 constant MAX_OPEN_FEE = 10e16; // 10%\n\n    /// @dev The minimum configurable minimum collateralization ratio.\n    uint256 constant MIN_COLLATERALIZATION_RATIO = ONE_HUNDRED_PERCENT;\n\n    /// @dev The minimum configurable liquidation incentive multiplier.\n    /// This means liquidator only receives equal amount of collateral to debt repaid.\n    uint256 constant MIN_LIQUIDATION_INCENTIVE_MULTIPLIER = ONE_HUNDRED_PERCENT;\n\n    /// @dev The maximum configurable liquidation incentive multiplier.\n    /// This means liquidator receives 25% bonus collateral compared to the debt repaid.\n    uint256 constant MAX_LIQUIDATION_INCENTIVE_MULTIPLIER = 1.25e18; // 125%\n\n    /// @dev The maximum configurable minimum debt USD value.\n    uint256 constant MAX_DEBT_VALUE = 1000e18; // $1,000\n}\n\n/* -------------------------------------------------------------------------- */\n/*                                    ENUM                                    */\n/* -------------------------------------------------------------------------- */\n\n/**\n * @dev Protocol user facing actions\n *\n * Deposit = 0\n * Withdraw = 1,\n * Repay = 2,\n * Borrow = 3,\n * Liquidate = 4\n */\nenum Action {\n    Deposit,\n    Withdraw,\n    Repay,\n    Borrow,\n    Liquidation\n}\n\n/**\n * @dev Fee types\n *\n * Open = 0\n * Close = 1\n */\nenum Fee {\n    Open,\n    Close\n}\n\n/* ========================================================================== */\n/*                                   STRUCTS                                  */\n/* ========================================================================== */\n\n/**\n * @notice Initialization arguments for the protocol\n */\nstruct MinterInitArgs {\n    address operator;\n    address council;\n    address feeRecipient;\n    uint8 extOracleDecimals;\n    uint256 liquidationIncentiveMultiplier;\n    uint256 minimumCollateralizationRatio;\n    uint256 minimumDebtValue;\n    uint256 liquidationThreshold;\n}\n\n/**\n * @notice Configurable parameters within the protocol\n */\n\nstruct MinterParams {\n    FixedPoint.Unsigned minimumCollateralizationRatio;\n    FixedPoint.Unsigned liquidationIncentiveMultiplier;\n    FixedPoint.Unsigned minimumDebtValue;\n    FixedPoint.Unsigned liquidationThreshold;\n    address feeRecipient;\n    uint8 extOracleDecimals;\n}\n\n/**\n * @notice Information on a token that is a KreskoAsset.\n * @dev Each KreskoAsset has 18 decimals.\n * @param kFactor The k-factor used for calculating the required collateral value for KreskoAsset debt.\n * @param oracle The oracle that provides the USD price of one KreskoAsset.\n * @param supplyLimit The total supply limit of the KreskoAsset.\n * @param anchor The anchor address\n * @param closeFee The percentage paid in fees when closing a debt position of this type.\n * @param openFee The percentage paid in fees when opening a debt position of this type.\n * @param exists Whether the KreskoAsset exists within the protocol.\n */\nstruct KrAsset {\n    FixedPoint.Unsigned kFactor;\n    AggregatorV2V3Interface oracle;\n    AggregatorV2V3Interface marketStatusOracle;\n    uint256 supplyLimit;\n    address anchor;\n    FixedPoint.Unsigned closeFee;\n    FixedPoint.Unsigned openFee;\n    bool exists;\n}\nusing LibAssetUtility for KrAsset global;\n/**\n * @notice Information on a token that can be used as collateral.\n * @dev Setting the factor to zero effectively makes the asset useless as collateral while still allowing\n * it to be deposited and withdrawn.\n * @param factor The collateral factor used for calculating the value of the collateral.\n * @param oracle The oracle that provides the USD price of one collateral asset.\n * @param anchor If the collateral is a KreskoAsset, the anchor address\n * @param decimals The decimals for the token, stored here to avoid repetitive external calls.\n * @param exists Whether the collateral asset exists within the protocol.\n */\nstruct CollateralAsset {\n    FixedPoint.Unsigned factor;\n    AggregatorV2V3Interface oracle;\n    AggregatorV2V3Interface marketStatusOracle;\n    address anchor;\n    uint8 decimals;\n    bool exists;\n}\nusing LibAssetUtility for CollateralAsset global;\n\n/// @notice Configuration for pausing `Action`\nstruct Pause {\n    bool enabled;\n    uint256 timestamp0;\n    uint256 timestamp1;\n}\n\n/// @notice Safety configuration for assets\nstruct SafetyState {\n    Pause pause;\n}\n"
    },
    "src/contracts/shared/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.14;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./IERC20Upgradeable.sol\";\n\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable not-rely-on-time */\n/* solhint-disable func-name-mixedcase */\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @author Kresko: modified to an upgradeable\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\n\ncontract ERC20Upgradeable is Initializable, IERC20Upgradeable {\n    /* -------------------------------------------------------------------------- */\n    /*                                   Events                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /* -------------------------------------------------------------------------- */\n    /*                                ERC20 Storage                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  EIP-2612                                  */\n    /* -------------------------------------------------------------------------- */\n\n    mapping(address => uint256) public nonces;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Immutables                                 */\n    /* -------------------------------------------------------------------------- */\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    constructor() payable initializer {\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20Upgradeable_init(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) internal onlyInitializing {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    READ                                    */\n    /* -------------------------------------------------------------------------- */\n\n    function balanceOf(address _account) public view virtual returns (uint256) {\n        return _balances[_account];\n    }\n\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    function allowance(address _owner, address _spender) public view virtual returns (uint256) {\n        return _allowances[_owner][_spender];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 ERC20 Logic                                */\n    /* -------------------------------------------------------------------------- */\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _balances[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balances[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = _allowances[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) _allowances[from][msg.sender] = allowed - amount;\n\n        _balances[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               EIP-2612 Logic                               */\n    /* -------------------------------------------------------------------------- */\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            _allowances[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Internals                                 */\n    /* -------------------------------------------------------------------------- */\n\n    function _mint(address to, uint256 amount) internal virtual {\n        _totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balances[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        _balances[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "src/contracts/shared/ERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\n\nimport {SafeERC20Upgradeable} from \"./SafeERC20Upgradeable.sol\";\nimport {KreskoAsset, ERC20Upgradeable} from \"../kreskoasset/KreskoAsset.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\n/* solhint-disable func-name-mixedcase */\n/* solhint-disable no-empty-blocks */\n/* solhint-disable func-visibility */\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @notice Kresko:\n/// Adds issue/destroy functions that are called when KreskoAssets are minted/burned through the protocol.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @author Kresko (https://www.kresko.fi)\nabstract contract ERC4626Upgradeable is ERC20Upgradeable {\n    using SafeERC20Upgradeable for KreskoAsset;\n    using FixedPointMathLib for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Events                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event Issue(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Destroy(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Immutables                                 */\n    /* -------------------------------------------------------------------------- */\n\n    KreskoAsset public immutable asset;\n\n    constructor(KreskoAsset _asset) payable {\n        asset = _asset;\n    }\n\n    function __ERC4626Upgradeable_init(\n        ERC20Upgradeable _asset,\n        string memory _name,\n        string memory _symbol\n    ) internal onlyInitializing {\n        __ERC20Upgradeable_init(_name, _symbol, _asset.decimals());\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Issue & Destroy                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice When new KreskoAssets are burned:\n     * Issues the equivalent amount of anchor tokens to Kresko\n     * Issues the equivalent amount of assets to user\n     */\n    function issue(uint256 assets, address to) public virtual returns (uint256 shares) {\n        require(msg.sender == asset.kresko(), Error.ISSUER_NOT_KRESKO);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewIssue(assets)) != 0, Error.ZERO_SHARES);\n\n        // Mint shares to kresko\n        _mint(asset.kresko(), shares);\n        // Mint assets to receiver\n        asset.mint(to, assets);\n\n        emit Issue(msg.sender, to, assets, shares);\n\n        _afterDeposit(assets, shares);\n    }\n\n    /**\n     * @notice When new KreskoAssets are burned:\n     * Destroys the equivalent amount of anchor tokens from Kresko\n     * Destorys the equivalent amount of assets from user\n     */\n    function destroy(uint256 assets, address from) public virtual returns (uint256 shares) {\n        require(msg.sender == asset.kresko(), Error.REDEEMER_NOT_KRESKO);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewIssue(assets)) != 0, Error.ZERO_SHARES);\n\n        _beforeWithdraw(assets, shares);\n\n        // Burn shares from kresko\n        _burn(asset.kresko(), shares);\n        // Burn assets from user\n        asset.burn(from, assets);\n\n        emit Destroy(msg.sender, from, from, assets, shares);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              Accounting Logic                              */\n    /* -------------------------------------------------------------------------- */\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if _totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    /// @notice amount of shares for amount of @param assets\n    function previewIssue(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @notice amount of assets for amount of @param shares\n    function previewDestroy(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /// @notice amount of shares for amount of @param assets\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @notice amount of assets for amount of @param shares\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if _totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    /// @notice amount of shares for amount of @param assets\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if _totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    /// @notice amount of assets for amount of @param shares\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                       DEPOSIT/WITHDRAWAL LIMIT VIEWS                       */\n    /* -------------------------------------------------------------------------- */\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxIssue(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxDestroy(address owner) public view virtual returns (uint256) {\n        return convertToAssets(_balances[owner]);\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(_balances[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return _balances[owner];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                            INTERNAL HOOKS LOGIC                            */\n    /* -------------------------------------------------------------------------- */\n\n    function _beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function _afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n\n    /* -------------------------------------------------------------------------- */\n    /*                               EXTERNAL USE                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Deposit KreskoAssets for equivalent amount of anchor tokens\n     */\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, Error.ZERO_SHARES);\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        _afterDeposit(assets, shares);\n    }\n\n    /**\n     * @notice Withdraw KreskoAssets for equivalent amount of anchor tokens\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = _allowances[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) {\n                _allowances[owner][msg.sender] = allowed - shares;\n            }\n        }\n\n        _beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /**\n     * @notice Mint shares of anchor tokens for equivalent amount of KreskoAssets\n     */\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        _afterDeposit(assets, shares);\n    }\n\n    /**\n     * @notice Redeem shares of anchor for KreskoAssets\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = _allowances[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) {\n                _allowances[owner][msg.sender] = allowed - shares;\n            }\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, Error.ZERO_ASSETS);\n\n        _beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n}\n"
    },
    "src/contracts/shared/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/contracts/shared/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n/* solhint-disable func-name-mixedcase */\n\ninterface IERC20Upgradeable {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function allowance(address, address) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function name() external view returns (string memory);\n\n    function nonces(address) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "src/contracts/shared/Modifiers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {Authorization, Role} from \"../libs/Authorization.sol\";\nimport {Meta} from \"../libs/Meta.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\nimport {Action} from \"../minter/MinterTypes.sol\";\nimport {ms} from \"../minter/MinterStorage.sol\";\n\nimport {ENTERED, NOT_ENTERED} from \"../diamond/DiamondTypes.sol\";\nimport {ds} from \"../diamond/DiamondStorage.sol\";\n\nabstract contract DiamondModifiers {\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^Authorization: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        Authorization.checkRole(role);\n        _;\n    }\n\n    /**\n     * @notice Ensure only trusted contracts can act on behalf of `_account`\n     * @param _accountIsNotMsgSender The address of the collateral asset.\n     */\n    modifier onlyRoleIf(bool _accountIsNotMsgSender, bytes32 role) {\n        if (_accountIsNotMsgSender) {\n            Authorization.checkRole(role);\n        }\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(Meta.msgSender() == ds().contractOwner, Error.DIAMOND_INVALID_OWNER);\n        _;\n    }\n\n    modifier onlyPendingOwner() {\n        require(Meta.msgSender() == ds().pendingOwner, Error.DIAMOND_INVALID_PENDING_OWNER);\n        _;\n    }\n\n    modifier nonReentrant() {\n        require(ds().entered == NOT_ENTERED, Error.RE_ENTRANCY);\n        ds().entered = ENTERED;\n        _;\n        ds().entered = NOT_ENTERED;\n    }\n}\n\nabstract contract MinterModifiers {\n    /**\n     * @notice Reverts if a collateral asset does not exist within the protocol.\n     * @param _collateralAsset The address of the collateral asset.\n     */\n    modifier collateralAssetExists(address _collateralAsset) {\n        require(ms().collateralAssets[_collateralAsset].exists, Error.COLLATERAL_DOESNT_EXIST);\n        _;\n    }\n\n    /**\n     * @notice Reverts if a collateral asset already exists within the protocol.\n     * @param _collateralAsset The address of the collateral asset.\n     */\n    modifier collateralAssetDoesNotExist(address _collateralAsset) {\n        require(!ms().collateralAssets[_collateralAsset].exists, Error.COLLATERAL_EXISTS);\n        _;\n    }\n\n    /**\n     * @notice Reverts if a Kresko asset does not exist within the protocol. Does not revert if\n     * the Kresko asset is not mintable.\n     * @param _kreskoAsset The address of the Kresko asset.\n     */\n    modifier kreskoAssetExists(address _kreskoAsset) {\n        require(ms().kreskoAssets[_kreskoAsset].exists, Error.KRASSET_DOESNT_EXIST);\n        _;\n    }\n\n    /**\n     * @notice Reverts if the symbol of a Kresko asset already exists within the protocol.\n     * @param _kreskoAsset The address of the Kresko asset.\n     */\n    modifier kreskoAssetDoesNotExist(address _kreskoAsset) {\n        require(!ms().kreskoAssets[_kreskoAsset].exists, Error.KRASSET_EXISTS);\n        _;\n    }\n\n    /// @dev Simple check for the enabled flag\n    function ensureNotPaused(address _asset, Action _action) internal view virtual {\n        require(!ms().safetyState[_asset][_action].pause.enabled, Error.ACTION_PAUSED_FOR_ASSET);\n    }\n}\n"
    },
    "src/contracts/shared/Rebase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\n\nstruct Rebase {\n    bool positive;\n    uint256 denominator;\n}\n\nlibrary RebaseMath {\n    using FixedPointMathLib for uint256;\n\n    function unrebase(uint256 self, Rebase memory _rebase) internal pure returns (uint256) {\n        if (_rebase.denominator == 0) return self;\n        return _rebase.positive ? self.divWadDown(_rebase.denominator) : self.mulWadDown(_rebase.denominator);\n    }\n\n    function rebase(uint256 self, Rebase memory _rebase) internal pure returns (uint256) {\n        if (_rebase.denominator == 0) return self;\n        return _rebase.positive ? self.mulWadDown(_rebase.denominator) : self.divWadDown(_rebase.denominator);\n    }\n}\n"
    },
    "src/contracts/shared/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "src/contracts/staking/interfaces/IKrStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IKrStaking {\n    struct UserInfo {\n        uint256 amount;\n        uint256[] rewardDebts;\n    }\n\n    struct PoolInfo {\n        IERC20 depositToken; // Address of LP token contract.\n        uint128 allocPoint; // How many allocation points assigned to this pool.\n        uint128 lastRewardBlock; // Last block number that rewards distribution occurs.\n        uint256[] accRewardPerShares; // Accumulated rewards per share, times 1e12.\n        address[] rewardTokens; // Reward tokens for this pool.\n    }\n\n    struct Reward {\n        uint256 pid;\n        address[] tokens;\n        uint256[] amounts;\n    }\n\n    function getPidFor(address _token) external view returns (uint256 pid, bool found);\n\n    function poolLength() external view returns (uint256);\n\n    function deposit(\n        address _to,\n        uint256 _pid,\n        uint256 _amount\n    ) external;\n\n    function withdrawFor(\n        address _for,\n        uint256 _pid,\n        uint256 _amount,\n        address _claimRewardsTo\n    ) external;\n\n    function claimFor(\n        address _for,\n        uint256 _pid,\n        address _rewardRecipient\n    ) external;\n\n    function allPendingRewards(address) external view returns (Reward[] memory);\n\n    function userInfo(uint256 _pid, address _account) external view returns (UserInfo memory);\n\n    function poolInfo(uint256 _pid) external view returns (PoolInfo memory);\n\n    function rewardPerBlockFor(address depositTokenAddress) external view returns (uint256[] memory rewardPerBlocks);\n}\n"
    },
    "src/contracts/staking/KrStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract KrStaking is AccessControlUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n\n    // keccak256(\"kresko.operator.role\")\n    bytes32 public constant OPERATOR_ROLE = 0x8952ae23cc3fea91b9dba0cefa16d18a26ca2bf124b54f42b5d04bce3aacecd2;\n\n    /**\n     * ==================================================\n     * =============== Structs ==========================\n     * ==================================================\n     */\n\n    struct UserInfo {\n        uint256 amount;\n        uint256[] rewardDebts;\n    }\n\n    struct PoolInfo {\n        IERC20 depositToken; // Address of LP token contract.\n        uint128 allocPoint; // How many allocation points assigned to this pool.\n        uint128 lastRewardBlock; // Last block number that rewards distribution occurs.\n        uint256[] accRewardPerShares; // Accumulated rewards per share, times 1e12.\n        address[] rewardTokens; // Reward tokens for this pool.\n    }\n\n    struct Reward {\n        uint256 pid;\n        address[] tokens;\n        uint256[] amounts;\n    }\n\n    /**\n     * ==================================================\n     * =============== Storage ==========================\n     * ==================================================\n     */\n\n    // Info of each staked user.\n    mapping(uint256 => mapping(address => UserInfo)) private _userInfo;\n\n    // Reward token drip per block\n    mapping(address => uint256) public rewardPerBlockFor;\n\n    // Info of each pool.\n    PoolInfo[] private _poolInfo;\n\n    // Total allocation points.\n    uint128 public totalAllocPoint;\n\n    /**\n     * ==================================================\n     * ============== Events ============================\n     * ==================================================\n     */\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event ClaimRewards(address indexed user, address indexed rewardToken, uint256 indexed amount);\n\n    /**\n     * ==================================================\n     * ============== Initializer =======================\n     * ==================================================\n     */\n\n    /**\n     * @notice Initialize the contract with a single pool\n     * @notice Sets initial reward token and rates\n     * @notice Sets the caller as DEFAULT_ADMIN\n     */\n    function initialize(\n        address[] calldata _rewardTokens,\n        uint256[] calldata _rewardPerBlocks,\n        IERC20 _depositToken,\n        uint128 _allocPoint,\n        uint128 _startBlock\n    ) external initializer {\n        require(_rewardPerBlocks.length == _rewardTokens.length, \"Reward tokens must have a rewardPerBlock value\");\n\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n        // Set initial reward tokens and allocations\n        for (uint256 i; i < _rewardTokens.length; i++) {\n            rewardPerBlockFor[_rewardTokens[i]] = _rewardPerBlocks[i];\n        }\n\n        // Push the initial pool in.\n        _poolInfo.push(\n            PoolInfo({\n                depositToken: _depositToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: _startBlock,\n                accRewardPerShares: new uint256[](_rewardTokens.length),\n                rewardTokens: _rewardTokens\n            })\n        );\n\n        totalAllocPoint += _allocPoint;\n    }\n\n    /**\n     * ==================================================\n     * =============== Modifiers ========================\n     * ==================================================\n     */\n\n    /**\n     * @notice Ensures no pool exists with this depositToken\n     * @param _depositToken to check\n     */\n    modifier ensurePoolDoesNotExist(IERC20 _depositToken) {\n        for (uint256 i; i < _poolInfo.length; i++) {\n            require(address(_poolInfo[i].depositToken) != address(_depositToken), \"KR: poolExists\");\n        }\n        _;\n    }\n\n    /**\n     * @notice Ensures this pool exists\n     * @param _pid to check\n     */\n    modifier ensurePoolExists(uint256 _pid) {\n        require(address(_poolInfo[_pid].depositToken) != address(0), \"KR: !poolExists\");\n        _;\n    }\n\n    /**\n     * ==================================================\n     * ================== Views =========================\n     * ==================================================\n     */\n\n    /**\n     * @notice Get pending rewards from a certain pool\n     * @param _pid id in `_poolInfo`\n     * @param _user id in `_userInfo[_pid]`\n     */\n    function pendingRewards(uint256 _pid, address _user) public view returns (Reward memory rewards) {\n        PoolInfo memory pool = _poolInfo[_pid];\n        UserInfo memory user = _userInfo[_pid][_user];\n        uint256 depositTokenSupply = pool.depositToken.balanceOf(address(this));\n        uint256 rewardTokensLength = pool.rewardTokens.length;\n\n        rewards = Reward({pid: _pid, tokens: pool.rewardTokens, amounts: new uint256[](rewardTokensLength)});\n\n        if (depositTokenSupply != 0 && user.amount > 0) {\n            for (uint256 rewardIndex; rewardIndex < rewardTokensLength; rewardIndex++) {\n                uint256 accRewardPerShare = pool.accRewardPerShares[rewardIndex];\n\n                uint256 rewardPerBlock = rewardPerBlockFor[pool.rewardTokens[rewardIndex]];\n                uint256 blocks = block.number - pool.lastRewardBlock;\n                uint256 reward = (rewardPerBlock * blocks * pool.allocPoint) / totalAllocPoint;\n\n                accRewardPerShare += (reward * 1e12) / depositTokenSupply;\n\n                rewards.amounts[rewardIndex] = (user.amount * accRewardPerShare) / 1e12 - user.rewardDebts[rewardIndex];\n                rewards.tokens[rewardIndex] = pool.rewardTokens[rewardIndex];\n            }\n        }\n    }\n\n    /**\n     * @notice Get all pending rewards for an account\n     * @param _account to get rewards for\n     */\n    function allPendingRewards(address _account) external view returns (Reward[] memory allRewards) {\n        allRewards = new Reward[](_poolInfo.length);\n        for (uint256 pid; pid < _poolInfo.length; pid++) {\n            Reward memory poolReward = pendingRewards(pid, _account);\n            allRewards[pid] = poolReward;\n        }\n    }\n\n    /**\n     * @notice Amount of pools\n     */\n    function poolLength() external view returns (uint256) {\n        return _poolInfo.length;\n    }\n\n    /**\n     * @notice Get pool information\n     * @param _pid in `_poolInfo`\n     */\n    function poolInfo(uint256 _pid) external view returns (PoolInfo memory) {\n        return _poolInfo[_pid];\n    }\n\n    /**\n     * @notice Get id for a token\n     * @notice Useful for external contracts\n     * @param _depositToken depositToken in `_poolInfo`\n     * @return pid of pool with `_depositToken`\n     * @return found ensure 0 index\n     */\n    function getPidFor(address _depositToken) external view returns (uint256 pid, bool found) {\n        for (pid; pid < _poolInfo.length; pid++) {\n            if (address(_poolInfo[pid].depositToken) == _depositToken) {\n                found = true;\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Get account information on a pool\n     * @param _pid in `_poolInfo`\n     * @param _account to get information for\n     */\n    function userInfo(uint256 _pid, address _account) external view returns (UserInfo memory) {\n        return _userInfo[_pid][_account];\n    }\n\n    /**\n     * ==================================================\n     * =========== Core public functions ================\n     * ==================================================\n     */\n\n    /**\n     * @notice Updates all pools to be up-to date\n     */\n    function massUpdatePools() public payable {\n        for (uint256 pid; pid < _poolInfo.length; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n    /**\n     * @notice Updates a pools reward variables to be up-to date\n     * @param _pid pool to update\n     */\n    function updatePool(uint256 _pid) public payable returns (PoolInfo memory pool) {\n        pool = _poolInfo[_pid];\n        // Updates once per block\n        if (block.number > pool.lastRewardBlock) {\n            uint256 deposits = pool.depositToken.balanceOf(address(this));\n            // No rewards for 0 deposits\n            if (deposits > 0) {\n                for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n                    // Reward per block for a particular reward token\n                    uint256 rewardPerBlock = rewardPerBlockFor[pool.rewardTokens[rewardIndex]];\n                    // Blocks advanced since last update\n                    uint256 blocks = block.number - pool.lastRewardBlock;\n                    // Allocation for this particular pool\n                    uint256 reward = (rewardPerBlock * blocks * pool.allocPoint) / totalAllocPoint;\n                    // Increment accumulated rewards for new block height\n                    pool.accRewardPerShares[rewardIndex] += (reward * 1e12) / deposits;\n                }\n            }\n            // No further updates within same block height\n            pool.lastRewardBlock = uint128(block.number);\n            // storage\n            _poolInfo[_pid] = pool;\n        }\n    }\n\n    /**\n     * @notice Deposits tokens for @param _to\n     * @param _to address that msg.sender deposits tokens for\n     * @param _pid in `_poolInfo`\n     * @param _amount amount of tokens to deposit\n     */\n    function deposit(\n        address _to,\n        uint256 _pid,\n        uint256 _amount\n    ) external payable nonReentrant ensurePoolExists(_pid) {\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][_to];\n\n        // Initialize rewardDebts\n        if (user.rewardDebts.length == 0) {\n            user.rewardDebts = new uint256[](pool.rewardTokens.length);\n        }\n\n        pool.depositToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n        user.amount += _amount;\n\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] += (_amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n        }\n\n        emit Deposit(_to, _pid, _amount);\n    }\n\n    /**\n     * @notice Withdraw deposited tokens and rewards.\n     * @param _pid id in `_poolInfo`\n     * @param _amount amount to withdraw\n     * @param _rewardRecipient address to send rewards to\n     */\n    function withdraw(\n        uint256 _pid,\n        uint256 _amount,\n        address _rewardRecipient\n    ) external payable nonReentrant {\n        require(_amount > 0, \"KR: 0-withdraw\");\n        require(_rewardRecipient != address(0), \"KR: !rewardRecipient\");\n\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][msg.sender];\n\n        sendRewards(pool, user, _rewardRecipient);\n\n        // Send whole balance in case of amount exceeds deposits\n        if (_amount > user.amount) {\n            _amount = user.amount;\n            user.amount = 0;\n        } else {\n            user.amount -= _amount;\n        }\n\n        pool.depositToken.safeTransfer(address(msg.sender), _amount);\n\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n        }\n\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n\n    /**\n     * @notice Claim rewards only\n     * @param _pid id in `_poolInfo`\n     * @param _rewardRecipient address to send rewards to\n     */\n    function claim(uint256 _pid, address _rewardRecipient) external payable nonReentrant {\n        require(_rewardRecipient != address(0), \"KR: !rewardRecipient\");\n\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][msg.sender];\n\n        if (user.amount > 0) {\n            sendRewards(pool, user, _rewardRecipient);\n\n            for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n                user.rewardDebts[rewardIndex] = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n            }\n        }\n    }\n\n    /**\n     * @notice Emergency function, withdraws deposits from a pool\n     * @notice This will forfeit your rewards.\n     * @param _pid pool id to withdraw tokens from\n     */\n    function emergencyWithdraw(uint256 _pid) external payable nonReentrant {\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][msg.sender];\n        pool.depositToken.safeTransfer(address(msg.sender), user.amount);\n        user.amount = 0;\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] = 0;\n        }\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n    }\n\n    /**\n     * ==================================================\n     * ============= Admin functions ====================\n     * ==================================================\n     */\n\n    /**\n     * @notice Adjust/Set reward per block for a particular reward token\n     * @param _rewardToken token to adjust the drip for\n     * @param _rewardPerBlock tokens to drip per block\n     */\n    function setRewardPerBlockFor(address _rewardToken, uint256 _rewardPerBlock)\n        external\n        payable\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        rewardPerBlockFor[_rewardToken] = _rewardPerBlock;\n    }\n\n    /**\n     * @notice Adds a new reward pool\n     * @notice Updates reward token count in case of adding extra tokens\n     * @param _rewardTokens tokens to reward from this pool\n     * @param _depositToken token to deposit for rewards\n     * @param _allocPoint weight of rewards this pool receives\n     */\n    function addPool(\n        address[] calldata _rewardTokens,\n        IERC20 _depositToken,\n        uint128 _allocPoint,\n        uint128 _startBlock\n    ) external payable onlyRole(DEFAULT_ADMIN_ROLE) ensurePoolDoesNotExist(_depositToken) {\n        require(_rewardTokens.length > 0, \"KR: !rewardTokens\");\n\n        totalAllocPoint += _allocPoint;\n\n        _poolInfo.push(\n            PoolInfo({\n                depositToken: _depositToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: _startBlock != 0 ? _startBlock : uint128(block.number),\n                accRewardPerShares: new uint256[](_rewardTokens.length),\n                rewardTokens: _rewardTokens\n            })\n        );\n    }\n\n    /**\n     * @notice Set new allocations for a pool\n     * @notice Set `_newAllocPoint` to 0 to retire a pool\n     * @param _pid pool to modify\n     * @param _newAllocPoint new allocation (weight) for rewards\n     */\n    function setPool(uint256 _pid, uint128 _newAllocPoint)\n        external\n        payable\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        ensurePoolExists(_pid)\n    {\n        totalAllocPoint -= _poolInfo[_pid].allocPoint + _newAllocPoint;\n        _poolInfo[_pid].allocPoint = _newAllocPoint;\n    }\n\n    /**\n     * ==================================================\n     * ============ Protected functions =================\n     * ==================================================\n     */\n\n    /**\n     * @notice Trusted helper contract can withdraw rewards and deposits on behalf of an account\n     * @notice For eg. withdraw + remove liquidity\n     * @param _for account to withdraw from\n     * @param _pid id in `_poolInfo`\n     * @param _amount amount to withdraw\n     * @param _rewardRecipient reward recipient\n     */\n    function withdrawFor(\n        address _for,\n        uint256 _pid,\n        uint256 _amount,\n        address _rewardRecipient\n    ) external payable nonReentrant onlyRole(OPERATOR_ROLE) {\n        require(_amount > 0, \"KR: 0-withdraw\");\n        require(_rewardRecipient != address(0), \"KR: !rewardRecipient\");\n\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][_for];\n\n        sendRewards(pool, user, _rewardRecipient);\n\n        // Send whole balance in case of amount exceeds deposits\n        if (_amount > user.amount) {\n            _amount = user.amount;\n            user.amount = 0;\n        } else {\n            user.amount -= _amount;\n        }\n\n        pool.depositToken.safeTransfer(address(msg.sender), _amount);\n\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n        }\n\n        emit Withdraw(_for, _pid, _amount);\n    }\n\n    /**\n     * @notice Trusted helper contract can claim rewards on behalf of an account\n     * @param _for account to claim for\n     * @param _pid id in `_poolInfo`\n     * @param _rewardRecipient address that receives rewards\n     */\n    function claimFor(\n        address _for,\n        uint256 _pid,\n        address _rewardRecipient\n    ) external payable nonReentrant onlyRole(OPERATOR_ROLE) {\n        require(_rewardRecipient != address(0), \"KR: !rewardRecipient\");\n\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][_for];\n\n        if (user.amount > 0) {\n            sendRewards(pool, user, _rewardRecipient);\n\n            for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n                user.rewardDebts[rewardIndex] = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n            }\n        }\n    }\n\n    /**\n     * @notice A rescue function for missent msg.value\n     * @notice Since we are using payable functions to save gas on calls\n     */\n    function rescueNative() external payable onlyRole(DEFAULT_ADMIN_ROLE) {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    /**\n     * @notice A rescue function for missent tokens / airdrops\n     * @notice This cannot withdraw any deposits due `ensurePoolDoesNotExist` modifier.\n     */\n    function rescueNonPoolToken(IERC20 _tokenToRescue, uint256 _amount)\n        external\n        payable\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        ensurePoolDoesNotExist(_tokenToRescue)\n    {\n        _tokenToRescue.safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * ==================================================\n     * ============= Internal functions =================\n     * ==================================================\n     */\n\n    /**\n     * @notice Loops over pools reward tokens and sends them to the user\n     * @param pool pool to send rewards from in `_poolInfo`\n     * @param user users info in the @param pool\n     * @param recipient user to send rewards to\n     */\n    function sendRewards(\n        PoolInfo memory pool,\n        UserInfo memory user,\n        address recipient\n    ) internal {\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            uint256 rewardDebt = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n            uint256 pending = rewardDebt - user.rewardDebts[rewardIndex];\n\n            if (pending > 0) {\n                IERC20(pool.rewardTokens[rewardIndex]).safeTransfer(recipient, pending);\n                emit ClaimRewards(recipient, pool.rewardTokens[rewardIndex], pending);\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/staking/KrStakingHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IUniswapV2Factory} from \"../vendor/uniswap/v2-core/interfaces/IUniswapV2Factory.sol\";\nimport {IUniswapV2Router02} from \"../vendor/uniswap/v2-periphery/interfaces/IUniswapV2Router02.sol\";\nimport \"./interfaces/IKrStaking.sol\";\n\ncontract KrStakingHelper {\n    using SafeERC20 for IERC20;\n\n    IUniswapV2Router02 public router;\n    IUniswapV2Factory public factory;\n    IKrStaking public staking;\n\n    constructor(\n        IUniswapV2Router02 _router,\n        IUniswapV2Factory _factory,\n        IKrStaking _staking\n    ) {\n        router = _router;\n        factory = _factory;\n        staking = _staking;\n    }\n\n    /**\n     * ==================================================\n     * ============ Events ==============================\n     * ==================================================\n     */\n\n    event LiquidityAndStakeAdded(address indexed to, uint256 indexed amount, uint256 indexed pid);\n    event LiquidityAndStakeRemoved(address indexed to, uint256 indexed amount, uint256 indexed pid);\n    event ClaimRewardsMulti(address indexed to);\n\n    /**\n     * ==================================================\n     * ============ Public functions ====================\n     * ==================================================\n     */\n\n    /**\n     * @notice Add liquidity to a pair, deposit liquidity tokens to staking\n     * @param tokenA address of tokenA\n     * @param tokenB address of tokenB\n     * @param amountADesired optimal amount of token A\n     * @param amountBDesired optimal amount of token B\n     * @param amountAMin min amountA (slippage)\n     * @param amountBMin min amountB (slippage)\n     * @param to address to deposit for\n     * @param deadline transaction deadline (used by router)\n     */\n    function addLiquidityAndStake(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256) {\n        require(to != address(0), \"KR: !address\");\n        address pair = factory.getPair(tokenA, tokenB);\n        (uint256 pid, bool found) = staking.getPidFor(pair);\n\n        require(found, \"KR: !poolExists\");\n\n        IERC20(tokenA).safeTransferFrom(msg.sender, address(this), amountADesired);\n        IERC20(tokenB).safeTransferFrom(msg.sender, address(this), amountBDesired);\n\n        IERC20(tokenA).approve(address(router), amountADesired);\n        IERC20(tokenB).approve(address(router), amountBDesired);\n\n        (, , uint256 liquidity) = router.addLiquidity(\n            tokenA,\n            tokenB,\n            amountADesired,\n            amountBDesired,\n            amountAMin,\n            amountBMin,\n            address(this),\n            deadline\n        );\n\n        IERC20(pair).approve(address(staking), liquidity);\n        staking.deposit(to, pid, liquidity);\n\n        emit LiquidityAndStakeAdded(to, liquidity, pid);\n        return liquidity;\n    }\n\n    /**\n     * @notice Withdraw liquidity tokens from staking, remove the underlying\n     * @param tokenA address of tokenA\n     * @param tokenB address of tokenB\n     * @param liquidity liquidity token amount to remove\n     * @param amountAMin min amountA to receive (slippage)\n     * @param amountBMin min amountB to receive (slippage)\n     * @param to address that receives the underlying\n     * @param deadline transaction deadline (used by router)\n     */\n    function withdrawAndRemoveLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external {\n        require(to != address(0), \"KR: !address\");\n        address pair = factory.getPair(tokenA, tokenB);\n        (uint256 pid, bool found) = staking.getPidFor(pair);\n\n        require(found, \"KR: !poolExists\");\n\n        staking.withdrawFor(msg.sender, pid, liquidity, to);\n\n        IERC20(pair).approve(address(router), liquidity);\n        router.removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n\n        emit LiquidityAndStakeRemoved(to, liquidity, pid);\n    }\n\n    /**\n     * @notice Claim rewards from each pool\n     * @param to address that receives the rewards\n     */\n    function claimRewardsMulti(address to) external {\n        require(to != address(0), \"KR: !address\");\n\n        uint256 length = staking.poolLength();\n\n        for (uint256 i; i < length; i++) {\n            staking.claimFor(msg.sender, i, to);\n        }\n\n        emit ClaimRewardsMulti(to);\n    }\n}\n"
    },
    "src/contracts/test/interfaces/ISmockFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface ISmockFacet {\n    event NewMessage(address indexed caller, string message);\n\n    function activate() external;\n\n    function disable() external;\n\n    function setMessage(string memory message) external;\n}\n"
    },
    "src/contracts/test/markets/UniswapMath.sol": {
      "content": "pragma solidity >=0.6.6;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"./UniswapV2LiquidityMathLibrary.sol\";\n\ncontract UniswapMath {\n    using SafeMath for uint256;\n    IUniswapV2Router02 public immutable router;\n    address public immutable factory;\n\n    constructor(address factory_, IUniswapV2Router02 router_) {\n        factory = factory_;\n        router = router_;\n    }\n\n    // computes the direction and magnitude of the profit-maximizing trade\n    function computeProfitMaximizingTrade(\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 reserveA,\n        uint256 reserveB\n    ) public pure returns (bool aToB, uint256 amountIn) {\n        aToB = reserveA.mul(truePriceTokenB) / reserveB < truePriceTokenA;\n\n        uint256 invariant = reserveA.mul(reserveB);\n\n        uint256 leftSide = Babylonian.sqrt(\n            invariant.mul(aToB ? truePriceTokenA : truePriceTokenB).mul(1000) /\n                uint256(aToB ? truePriceTokenB : truePriceTokenA).mul(997)\n        );\n        uint256 rightSide = (aToB ? reserveA.mul(1000) : reserveB.mul(1000)) / 997;\n\n        // compute the amount that must be sent to move the price to the profit-maximizing price\n        amountIn = leftSide.sub(rightSide);\n    }\n\n    // swaps an amount of either token such that the trade is profit-maximizing, given an external true price\n    // true price is expressed in the ratio of token A to token B\n    // caller must approve this contract to spend whichever token is intended to be swapped\n    function swapToPrice(\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 maxSpendTokenA,\n        uint256 maxSpendTokenB,\n        address to,\n        uint256 deadline\n    ) public {\n        // true price is expressed as a ratio, so both values must be non-zero\n        require(truePriceTokenA != 0 && truePriceTokenB != 0, \"ExampleSwapToPrice: ZERO_PRICE\");\n        // caller can specify 0 for either if they wish to swap in only one direction, but not both\n        require(maxSpendTokenA != 0 || maxSpendTokenB != 0, \"ExampleSwapToPrice: ZERO_SPEND\");\n\n        bool aToB;\n        uint256 amountIn;\n        {\n            (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n            (aToB, amountIn) = computeProfitMaximizingTrade(truePriceTokenA, truePriceTokenB, reserveA, reserveB);\n        }\n\n        // spend up to the allowance of the token in\n        uint256 maxSpend = aToB ? maxSpendTokenA : maxSpendTokenB;\n        if (amountIn > maxSpend) {\n            amountIn = maxSpend;\n        }\n\n        address tokenIn = aToB ? tokenA : tokenB;\n        address tokenOut = aToB ? tokenB : tokenA;\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, address(this), amountIn);\n        TransferHelper.safeApprove(tokenIn, address(router), amountIn);\n\n        address[] memory path = new address[](2);\n        path[0] = tokenIn;\n        path[1] = tokenOut;\n\n        router.swapExactTokensForTokens(\n            amountIn,\n            0, // amountOutMin: we can skip computing this number because the math is tested\n            path,\n            to,\n            deadline\n        );\n    }\n\n    function profitMaximizingTrade(\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB\n    ) external view returns (uint256 amountIn, bool aToB) {\n        (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n        (aToB, amountIn) = computeProfitMaximizingTrade(truePriceTokenA, truePriceTokenB, reserveA, reserveB);\n    }\n\n    function getReservesAfterArbitrage(\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB\n    ) external view returns (uint256 reserveA, uint256 reserveB) {\n        return\n            UniswapV2LiquidityMathLibrary.getReservesAfterArbitrage(\n                factory,\n                tokenA,\n                tokenB,\n                truePriceTokenA,\n                truePriceTokenB\n            );\n    }\n\n    function getLiquidityValue(\n        address tokenA,\n        address tokenB,\n        uint256 liquidityAmount\n    ) external view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n        return UniswapV2LiquidityMathLibrary.getLiquidityValue(factory, tokenA, tokenB, liquidityAmount);\n    }\n\n    function getLiquidityValueAfterArbitrageToPrice(\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 liquidityAmount\n    ) external view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n        return\n            UniswapV2LiquidityMathLibrary.getLiquidityValueAfterArbitrageToPrice(\n                factory,\n                tokenA,\n                tokenB,\n                truePriceTokenA,\n                truePriceTokenB,\n                liquidityAmount\n            );\n    }\n\n    function getGasCostOfGetLiquidityValueAfterArbitrageToPrice(\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 liquidityAmount\n    ) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        UniswapV2LiquidityMathLibrary.getLiquidityValueAfterArbitrageToPrice(\n            factory,\n            tokenA,\n            tokenB,\n            truePriceTokenA,\n            truePriceTokenB,\n            liquidityAmount\n        );\n        uint256 gasAfter = gasleft();\n        return gasBefore - gasAfter;\n    }\n}\n"
    },
    "src/contracts/test/markets/UniswapV2LiquidityMathLibrary.sol": {
      "content": "pragma solidity >=0.5.0;\n\nimport \"@uniswap/lib/contracts/libraries/Babylonian.sol\";\nimport \"../../vendor/uniswap/v2-periphery/libraries/UniswapV2Library.sol\";\n\n// library containing some math for dealing with the liquidity shares of a pair, e.g. computing their exact value\n// in terms of the underlying tokens\nlibrary UniswapV2LiquidityMathLibrary {\n    using SafeMath for uint256;\n\n    // computes the direction and magnitude of the profit-maximizing trade\n    function computeProfitMaximizingTrade(\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 reserveA,\n        uint256 reserveB\n    ) public pure returns (bool aToB, uint256 amountIn) {\n        aToB = reserveA.mul(truePriceTokenB) / reserveB < truePriceTokenA;\n\n        uint256 invariant = reserveA.mul(reserveB);\n\n        uint256 leftSide = Babylonian.sqrt(\n            invariant.mul(aToB ? truePriceTokenA : truePriceTokenB).mul(1000) /\n                uint256(aToB ? truePriceTokenB : truePriceTokenA).mul(997)\n        );\n        uint256 rightSide = (aToB ? reserveA.mul(1000) : reserveB.mul(1000)) / 997;\n\n        // compute the amount that must be sent to move the price to the profit-maximizing price\n        amountIn = leftSide.sub(rightSide);\n    }\n\n    // gets the reserves after an arbitrage moves the price to\n    // the profit-maximizing ratio given an externally observed true price\n    function getReservesAfterArbitrage(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        // first get reserves before the swap\n        (reserveA, reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n\n        require(reserveA > 0 && reserveB > 0, \"UniswapV2ArbitrageLibrary: ZERO_PAIR_RESERVES\");\n\n        // then compute how much to swap to arb to the true price\n        (bool aToB, uint256 amountIn) = computeProfitMaximizingTrade(\n            truePriceTokenA,\n            truePriceTokenB,\n            reserveA,\n            reserveB\n        );\n\n        if (amountIn == 0) {\n            return (reserveA, reserveB);\n        }\n\n        // now affect the trade to the reserves\n        if (aToB) {\n            uint256 amountOut = UniswapV2Library.getAmountOut(amountIn, reserveA, reserveB);\n            reserveA += amountIn;\n            reserveB -= amountOut;\n        } else {\n            uint256 amountOut = UniswapV2Library.getAmountOut(amountIn, reserveB, reserveA);\n            reserveB += amountIn;\n            reserveA -= amountOut;\n        }\n    }\n\n    // computes liquidity value given all the parameters of the pair\n    function computeLiquidityValue(\n        uint256 reservesA,\n        uint256 reservesB,\n        uint256 totalSupply,\n        uint256 liquidityAmount,\n        bool feeOn,\n        uint256 kLast\n    ) internal pure returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n        if (feeOn && kLast > 0) {\n            uint256 rootK = Babylonian.sqrt(reservesA.mul(reservesB));\n            uint256 rootKLast = Babylonian.sqrt(kLast);\n            if (rootK > rootKLast) {\n                uint256 numerator1 = totalSupply;\n                uint256 numerator2 = rootK.sub(rootKLast);\n                uint256 denominator = rootK.mul(5).add(rootKLast);\n                uint256 feeLiquidity = numerator1.mul(numerator2) / denominator;\n                totalSupply = totalSupply.add(feeLiquidity);\n            }\n        }\n        return (reservesA.mul(liquidityAmount) / totalSupply, reservesB.mul(liquidityAmount) / totalSupply);\n    }\n\n    // get all current parameters from the pair and compute value of a liquidity amount\n    // **note this is subject to manipulation, e.g. sandwich attacks**. prefer passing a manipulation resistant price to\n    // #getLiquidityValueAfterArbitrageToPrice\n    function getLiquidityValue(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint256 liquidityAmount\n    ) internal view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n        (uint256 reservesA, uint256 reservesB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n        IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, tokenA, tokenB));\n        bool feeOn = IUniswapV2Factory(factory).feeTo() != address(0);\n        uint256 kLast = feeOn ? pair.kLast() : 0;\n        uint256 totalSupply = pair.totalSupply();\n        return computeLiquidityValue(reservesA, reservesB, totalSupply, liquidityAmount, feeOn, kLast);\n    }\n\n    // Given two tokens, tokenA and tokenB, and their \"true price\",\n    // i.e. the observed ratio of value of token A to token B,\n    // and a liquidity amount, returns the value of the liquidity in terms of tokenA and tokenB\n    function getLiquidityValueAfterArbitrageToPrice(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 liquidityAmount\n    ) internal view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n        bool feeOn = IUniswapV2Factory(factory).feeTo() != address(0);\n        IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, tokenA, tokenB));\n        uint256 kLast = feeOn ? pair.kLast() : 0;\n        uint256 totalSupply = pair.totalSupply();\n\n        // this also checks that totalSupply > 0\n        require(totalSupply >= liquidityAmount && liquidityAmount > 0, \"ComputeLiquidityValue: LIQUIDITY_AMOUNT\");\n\n        (uint256 reservesA, uint256 reservesB) = getReservesAfterArbitrage(\n            factory,\n            tokenA,\n            tokenB,\n            truePriceTokenA,\n            truePriceTokenB\n        );\n\n        return computeLiquidityValue(reservesA, reservesB, totalSupply, liquidityAmount, feeOn, kLast);\n    }\n}\n"
    },
    "src/contracts/test/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    mapping(address => bool) public minters;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _initialSupply\n    ) ERC20(_name, _symbol, _decimals) {\n        _mint(msg.sender, _initialSupply);\n        minters[msg.sender] = true;\n    }\n\n    function toggleMinters(address[] calldata _minters) external {\n        require(minters[msg.sender], \"!minter\");\n        for (uint256 i; i < _minters.length; i++) {\n            minters[_minters[i]] = !minters[_minters[i]];\n        }\n    }\n\n    function mint(address to, uint256 value) public virtual {\n        require(minters[msg.sender], \"!minter\");\n        _mint(to, value);\n    }\n\n    function burn(address from, uint256 value) public virtual {\n        require(minters[msg.sender], \"!minter\");\n        _burn(from, value);\n    }\n}\n"
    },
    "src/contracts/test/Multisender.sol": {
      "content": "pragma solidity >=0.8.14;\n\nimport \"./MockERC20.sol\";\nimport \"./WETH.sol\";\n\n/* solhint-disable no-empty-blocks */\n\nstruct Token {\n    uint256 amount;\n    address token;\n}\n\ncontract Multisender {\n    mapping(address => bool) public owners;\n    mapping(address => bool) public funded;\n\n    Token[] internal tokens;\n    WETH internal weth;\n    address internal kiss;\n\n    event Funded(address indexed account);\n\n    constructor(\n        Token[] memory _tokens,\n        address _weth,\n        address _kiss\n    ) {\n        owners[msg.sender] = true;\n\n        for (uint256 i; i < _tokens.length; i++) {\n            tokens.push(_tokens[i]);\n        }\n        weth = WETH(_weth);\n        kiss = _kiss;\n    }\n\n    function addToken(Token memory _token) external {\n        require(owners[msg.sender], \"!o\");\n        tokens.push(_token);\n    }\n\n    function setTokens(Token[] memory _tokens) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < _tokens.length; i++) {\n            tokens[i].amount = _tokens[i].amount;\n            tokens[i].token = _tokens[i].token;\n        }\n    }\n\n    function toggleOwners(address[] calldata accounts) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < accounts.length; i++) {\n            owners[accounts[i]] = !owners[accounts[i]];\n        }\n    }\n\n    function distribute(\n        address[] calldata accounts,\n        uint256 wethAmount,\n        uint256 ethAmount,\n        uint256 kissAmount\n    ) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < accounts.length; i++) {\n            if (funded[accounts[i]]) continue;\n\n            funded[accounts[i]] = true;\n            for (uint256 j; j < tokens.length; j++) {\n                MockERC20(tokens[j].token).mint(accounts[i], tokens[j].amount);\n            }\n\n            weth.deposit(wethAmount);\n            weth.transfer(accounts[i], wethAmount);\n            MockERC20(kiss).transfer(accounts[i], kissAmount);\n\n            payable(accounts[i]).transfer(ethAmount);\n\n            emit Funded(accounts[i]);\n        }\n    }\n\n    function drain() external {\n        require(owners[msg.sender], \"!o\");\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function drainERC20() external {\n        require(owners[msg.sender], \"!o\");\n        MockERC20(kiss).transfer(msg.sender, MockERC20(kiss).balanceOf(address(this)));\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}\n"
    },
    "src/contracts/test/SmockFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {ISmockFacet} from \"./interfaces/ISmockFacet.sol\";\nimport {DiamondModifiers} from \"../shared/Modifiers.sol\";\nimport {SmockStorage, Errors} from \"./SmockStorage.sol\";\n\nbytes32 constant TEST_OPERATOR_ROLE = keccak256(\"kresko.test.operator\");\n\n/**\n * @dev Use for Smock fakes / mocks.\n */\ncontract SmockFacet is DiamondModifiers, ISmockFacet {\n    uint256 public constant MESSAGE_THROTTLE = 2;\n\n    function operator() external view returns (address) {\n        return SmockStorage.state().operator;\n    }\n\n    function activate() external override onlyRole(TEST_OPERATOR_ROLE) onlyDisabled {\n        SmockStorage.activate();\n    }\n\n    function disable() external override onlyRole(TEST_OPERATOR_ROLE) onlyActive {\n        SmockStorage.disable();\n    }\n\n    function smockInitialized() external view returns (bool) {\n        return SmockStorage.state().initialized;\n    }\n\n    function setMessage(string memory message) external override onlyActive {\n        require(block.number >= SmockStorage.state().lastMessageBlock + MESSAGE_THROTTLE, \"Cant set message yet\");\n\n        SmockStorage.state().message = message;\n        SmockStorage.state().callers[msg.sender] = true;\n\n        emit SmockStorage.Call(msg.sender);\n        emit NewMessage(msg.sender, message);\n    }\n\n    modifier onlyActive() {\n        require(SmockStorage.state().isActive, Errors.ACTIVE);\n        _;\n    }\n    modifier onlyDisabled() {\n        require(!SmockStorage.state().isActive, Errors.NOT_ACTIVE);\n        _;\n    }\n}\n"
    },
    "src/contracts/test/SmockFacet2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {GeneralEvent} from \"../libs/Events.sol\";\nimport \"../shared/Modifiers.sol\";\n\nimport {ISmockFacet} from \"./interfaces/ISmockFacet.sol\";\nimport {TEST_OPERATOR_ROLE} from \"./SmockFacet.sol\";\nimport {SmockStorage} from \"./SmockStorage.sol\";\n\ncontract SmockFacet2 {\n    function initialize() external {\n        SmockStorage.stateExtended().extended = true;\n    }\n\n    function getOldStructValueFromExtended() external view returns (bool) {\n        return SmockStorage.stateExtended().initialized;\n    }\n\n    function getNewStructValueFromExtended() external view returns (bool) {\n        return SmockStorage.stateExtended().extended;\n    }\n}\n"
    },
    "src/contracts/test/SmockInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {GeneralEvent} from \"../libs/Events.sol\";\nimport {Authorization, ds, Role, DiamondModifiers} from \"../shared/Modifiers.sol\";\n\nimport {ISmockFacet} from \"./interfaces/ISmockFacet.sol\";\nimport {TEST_OPERATOR_ROLE} from \"./SmockFacet.sol\";\nimport {SmockStorage} from \"./SmockStorage.sol\";\n\ncontract SmockInit is DiamondModifiers {\n    function initialize(address _operator) external onlyOwner onlyRole(Role.ADMIN) {\n        require(msg.sender == ds().contractOwner, \"WithStorage: Not owner\");\n        SmockStorage.initialize(_operator);\n\n        Authorization.grantRole(TEST_OPERATOR_ROLE, _operator);\n\n        ds().supportedInterfaces[type(ISmockFacet).interfaceId] = true;\n        emit GeneralEvent.Initialized(msg.sender, 1);\n    }\n\n    function getNumber() public pure returns (uint8) {\n        return 1;\n    }\n\n    function getBool() public pure returns (bool) {\n        return false;\n    }\n\n    function upgradeState() external {\n        ds().initialized = getBool();\n    }\n}\n"
    },
    "src/contracts/test/SmockStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nlibrary Errors {\n    string public constant INITIALIZED = \"Already initialized\";\n    string public constant NOT_ACTIVE = \"SmockFacet: Not active\";\n    string public constant ACTIVE = \"SmockFacet: Active\";\n}\n\nstruct SmockState {\n    bool initialized;\n    bool isActive;\n    address operator;\n    mapping(address => bool) callers;\n    string message;\n    uint256 lastMessageBlock;\n}\n// This is not how it has to be done in reality\n// We can just extend the original\nstruct SmockState2 {\n    bool initialized;\n    bool isActive;\n    address operator;\n    mapping(address => bool) callers;\n    string message;\n    uint256 lastMessageBlock;\n    bool extended;\n}\n\nlibrary SmockStorage {\n    event Call(address indexed caller);\n\n    bytes32 public constant SMOCK_STORAGE_POSITION = keccak256(\"kresko.smock.storage\");\n\n    function initialize(address _operator) internal {\n        SmockState storage ss = state();\n        require(!ss.initialized, Errors.INITIALIZED);\n        ss.initialized = true;\n        ss.operator = _operator;\n        emit Call(msg.sender);\n    }\n\n    function state() internal pure returns (SmockState storage ss) {\n        bytes32 position = SMOCK_STORAGE_POSITION;\n        assembly {\n            ss.slot := position\n        }\n    }\n\n    // This is not how it has to be done in reality\n    function stateExtended() internal pure returns (SmockState2 storage ss) {\n        bytes32 position = SMOCK_STORAGE_POSITION;\n        assembly {\n            ss.slot := position\n        }\n    }\n\n    function activate() internal {\n        state().isActive = true;\n        state().callers[msg.sender] = true;\n        emit Call(msg.sender);\n    }\n\n    function disable() internal {\n        state().isActive = false;\n        state().callers[msg.sender] = true;\n        emit Call(msg.sender);\n    }\n}\n"
    },
    "src/contracts/test/WETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport \"../vendor/WETH9.sol\";\n\ncontract WETH is WETH9 {\n    function deposit(uint256 amount) public {\n        balanceOf[msg.sender] += amount;\n        emit Deposit(msg.sender, amount);\n    }\n}\n"
    },
    "src/contracts/vendor/flux/FeedsRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./interfaces/AggregatorV3Interface.sol\";\n\n/**\n * @title   Flux Feeds Registry\n * @notice  Get price in usd from an ERC20 token address\n * @dev     Contains a registry of price feeds. If a TOKEN/USD feed exists,\n *          just use that. Otherwise multiply prices from TOKEN/ETH and ETH/USD\n *          feeds. For USD, just return 1.\n */\ncontract FeedsRegistry is AccessControl {\n    using Address for address;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    event AddFeed(bytes32 indexed currencyKey, bool isEth, address feed);\n\n    // stringToBytes32(\"ETH\")\n    bytes32 public constant ETH = 0x4554480000000000000000000000000000000000000000000000000000000000;\n\n    // stringToBytes32(\"USD\")\n    bytes32 public constant USD = 0x5553440000000000000000000000000000000000000000000000000000000000;\n\n    mapping(bytes32 => address) public usdFeeds;\n    mapping(bytes32 => address) public ethFeeds;\n\n    constructor(address admin) {\n        _setupRole(ADMIN_ROLE, admin);\n    }\n\n    /**\n     * @notice Get price in usd multiplied by 1e8\n     * @param currencyKey ERC20 token whose price we want\n     */\n    function getPrice(bytes32 currencyKey) public view returns (uint256 price) {\n        address tokenUsd = usdFeeds[currencyKey];\n        if (tokenUsd != address(0)) {\n            // USD feeds are already scaled by 1e8 so can just return price\n            return _latestPrice(usdFeeds[currencyKey]);\n        }\n\n        address tokenEth = ethFeeds[currencyKey];\n        address ethUsd = usdFeeds[ETH];\n        if (tokenEth != address(0) && ethUsd != address(0)) {\n            uint256 price1 = _latestPrice(tokenEth);\n            uint256 price2 = _latestPrice(ethUsd);\n\n            // USD feeds are scale by 1e8 and ETH feeds by 1e18 so need to\n            // divide by 1e18\n            return price1.mul(price2).div(1e18);\n        } else if (currencyKey == USD) {\n            return 1e8;\n        }\n    }\n\n    function _latestPrice(address feed) internal view returns (uint256) {\n        if (feed == address(0)) {\n            return 0;\n        }\n        (, int256 price, , , , ) = AggregatorV3Interface(feed).latestRoundData();\n        return uint256(price);\n    }\n\n    /**\n     * @notice Add TOKEN/USD feed to registry\n     * @param currencyKey ERC20 token symbol for which feed is being added\n     */\n    function addUsdFeed(bytes32 currencyKey, address feed) external {\n        require(hasRole(ADMIN_ROLE, msg.sender), \"Caller is not a admin\");\n        require(_latestPrice(feed) > 0, \"Price should be > 0\");\n        usdFeeds[currencyKey] = feed;\n        emit AddFeed(currencyKey, false, feed);\n    }\n\n    /**\n     * @notice Add TOKEN/ETH feed to registry\n     * @param currencyKey ERC20 token symbol for which feed is being added\n     */\n    function addEthFeed(bytes32 currencyKey, address feed) external {\n        require(hasRole(ADMIN_ROLE, msg.sender), \"Caller is not a admin\");\n        require(_latestPrice(feed) > 0, \"Price should be > 0\");\n        ethFeeds[currencyKey] = feed;\n        emit AddFeed(currencyKey, true, feed);\n    }\n\n    function getPriceFromSymbol(string memory symbol) external view returns (uint256) {\n        return getPrice(stringToBytes32(symbol));\n    }\n\n    function stringToBytes32(string memory source) public pure returns (bytes32 result) {\n        bytes memory b = bytes(source);\n        if (b.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n}\n"
    },
    "src/contracts/vendor/flux/FluxPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./interfaces/AggregatorV2V3Interface.sol\";\n\n/**\n * @notice Simple data posting on chain of a scalar value, compatible with Chainlink V2 and V3 aggregator interface\n */\ncontract FluxPriceFeed is AccessControl, AggregatorV2V3Interface {\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant VALIDATOR_ROLE = keccak256(\"VALIDATOR_ROLE\");\n    uint32 public latestAggregatorRoundId;\n\n    // Transmission records the answer from the transmit transaction at\n    // time timestamp\n    struct Transmission {\n        int192 answer; // 192 bits ought to be enough for anyone\n        uint64 timestamp;\n        bool marketOpen;\n    }\n    mapping(uint32 => Transmission) s_transmissions; /* aggregator round ID */\n       \n\n    /**\n     * @param _validator the initial validator that can post data to this contract\n     * @param _decimals answers are stored in fixed-point format, with this many digits of precision\n     * @param _description short human-readable description of observable this contract's answers pertain to\n     */\n    constructor(\n        address _validator,\n        uint8 _decimals,\n        string memory _description\n    ) {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setupRole(VALIDATOR_ROLE, _validator);\n        decimals = _decimals;\n        s_description = _description;\n    }\n\n    /*\n     * Versioning\n     */\n    function typeAndVersion() external pure virtual returns (string memory) {\n        return \"FluxPriceFeed 1.0.0\";\n    }\n\n    /*\n     * Transmission logic\n     */\n\n    /**\n     * @notice indicates that a new report was transmitted\n     * @param aggregatorRoundId the round to which this report was assigned\n     * @param answer value posted by validator\n     * @param marketOpen bool indicating if the market is open\n     * @param transmitter address from which the report was transmitted\n     */\n    event NewTransmission(uint32 indexed aggregatorRoundId, int192 answer, bool marketOpen, address transmitter);\n        \n    /**\n     * @notice details about the most recent report\n     * @return _latestAnswer value from latest report\n     * @return _latestTimestamp when the latest report was transmitted\n     * @return _marketOpen value from latest report\n     */\n    function latestTransmissionDetails() external view returns (int192 _latestAnswer, uint64 _latestTimestamp, bool _marketOpen) {\n        require(msg.sender == tx.origin, \"Only callable by EOA\");\n        return (\n            s_transmissions[latestAggregatorRoundId].answer,\n            s_transmissions[latestAggregatorRoundId].timestamp,\n            s_transmissions[latestAggregatorRoundId].marketOpen\n        );\n    }\n\n    /**\n     * @notice transmit is called to post a new report to the contract\n     * @param _answer latest answer\n     */\n    function transmit(int192 _answer, bool _marketOpen) external {\n        require(hasRole(VALIDATOR_ROLE, msg.sender), \"Caller is not a validator\");\n\n        // Check the report contents, and record the result\n        latestAggregatorRoundId++;\n        s_transmissions[latestAggregatorRoundId] = Transmission(_answer, uint64(block.timestamp), _marketOpen);\n\n        emit NewTransmission(latestAggregatorRoundId, _answer, _marketOpen, msg.sender);\n    }\n\n    /*\n     * v2 Aggregator interface\n     */\n\n    /**\n     * @notice answer from the most recent report\n     */\n    function latestAnswer() public view virtual override returns (int256) {\n        return s_transmissions[latestAggregatorRoundId].answer;\n    }\n\n    /**\n     * @notice timestamp of block in which last report was transmitted\n     */\n    function latestTimestamp() public view virtual override returns (uint256) {\n        return s_transmissions[latestAggregatorRoundId].timestamp;\n    }\n\n     /**\n     * @notice market open indicator from the most recent report\n     */\n    function latestMarketOpen() public view virtual override returns (bool) {\n        return s_transmissions[latestAggregatorRoundId].marketOpen;\n    }\n\n    /**\n     * @notice Aggregator round in which last report was transmitted\n     */\n    function latestRound() public view virtual override returns (uint256) {\n        return latestAggregatorRoundId;\n    }\n\n    /**\n     * @notice answer of report from given aggregator round\n     * @param _roundId the aggregator round of the target report\n     */\n    function getAnswer(uint256 _roundId) public view virtual override returns (int256) {\n        if (_roundId > 0xFFFFFFFF) {\n            return 0;\n        }\n        return s_transmissions[uint32(_roundId)].answer;\n    }\n\n    /**\n     * @notice timestamp of block in which report from given aggregator round was transmitted\n     * @param _roundId aggregator round of target report\n     */\n    function getTimestamp(uint256 _roundId) public view virtual override returns (uint256) {\n        if (_roundId > 0xFFFFFFFF) {\n            return 0;\n        }\n        return s_transmissions[uint32(_roundId)].timestamp;\n    }\n\n    /**\n     * @notice market open of report from given aggregator round\n     * @param _roundId the aggregator round of the target report\n     */\n    function getMarketOpen(uint256 _roundId) public view virtual override returns (bool) {\n        require(_roundId <= 0xFFFFFFFF, \"FluxPriceFeed: round ID\");\n        return s_transmissions[uint32(_roundId)].marketOpen;\n    }\n\n    /*\n     * v3 Aggregator interface\n     */\n\n    string private constant V3_NO_DATA_ERROR = \"No data present\";\n\n    /**\n     * @return answers are stored in fixed-point format, with this many digits of precision\n     */\n    uint8 public immutable override decimals;\n\n    /**\n     * @notice aggregator contract version\n     */\n    uint256 public constant override version = 1;\n\n    string internal s_description;\n\n    /**\n     * @notice human-readable description of observable this contract is reporting on\n     */\n    function description() public view virtual override returns (string memory) {\n        return s_description;\n    }\n\n    /**\n     * @notice details for the given aggregator round\n     * @param _roundId target aggregator round. Must fit in uint32\n     * @return roundId _roundId\n     * @return answer answer of report from given _roundId\n     * @return marketOpen of report from given _roundId\n     * @return startedAt timestamp of block in which report from given _roundId was transmitted\n     * @return updatedAt timestamp of block in which report from given _roundId was transmitted\n     * @return answeredInRound _roundId\n     */\n    function getRoundData(uint80 _roundId)\n        public\n        view\n        virtual\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            bool marketOpen,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        require(_roundId <= 0xFFFFFFFF, V3_NO_DATA_ERROR);\n        Transmission memory transmission = s_transmissions[uint32(_roundId)];\n        return (_roundId, transmission.answer, transmission.marketOpen, transmission.timestamp, transmission.timestamp, _roundId);\n    }\n\n    /**\n     * @notice aggregator details for the most recently transmitted report\n     * @return roundId aggregator round of latest report\n     * @return answer answer of latest report\n     * @return marketOpen of latest report\n     * @return startedAt timestamp of block containing latest report\n     * @return updatedAt timestamp of block containing latest report\n     * @return answeredInRound aggregator round of latest report\n     */\n    function latestRoundData()\n        public\n        view\n        virtual\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            bool marketOpen,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        roundId = latestAggregatorRoundId;\n\n        // Skipped for compatability with existing FluxAggregator in which latestRoundData never reverts.\n        // require(roundId != 0, V3_NO_DATA_ERROR);\n\n        Transmission memory transmission = s_transmissions[uint32(roundId)];\n        return (roundId, transmission.answer, transmission.marketOpen, transmission.timestamp, transmission.timestamp, roundId);\n    }\n}\n"
    },
    "src/contracts/vendor/flux/FluxPriceFeedFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"./FluxPriceFeed.sol\";\n\n/**\n * @title Flux first-party price feed factory\n * @author fluxprotocol.org\n */\ncontract FluxPriceFeedFactory {\n    address public owner;\n    // roles\n    bytes32 public constant VALIDATOR_ROLE = keccak256(\"VALIDATOR_ROLE\");\n\n    // mapping of id to FluxPriceFeed\n    mapping(bytes32 => FluxPriceFeed) public fluxPriceFeeds;\n\n    /**\n     * @notice indicates that a new oracle was created\n     * @param id hash of the price pair of the deployed oracle\n     * @param oracle address of the deployed oracle\n     */\n    event FluxPriceFeedCreated(bytes32 indexed id, address indexed oracle);\n\n    /**\n     * @notice to log error messages\n     * @param message the logged message\n     */\n    event Log(string message);\n\n    constructor () {\n        owner = msg.sender;\n    }\n\n    function transferOwnership(address newOwner) external {\n        require(msg.sender == owner, \"!owner\");\n        owner = newOwner;\n    }\n\n    /**\n     * @notice transmit submits an answer to a price feed or creates a new one if it does not exist\n     * @param _pricePairs array of price pairs strings (e.g. ETH/USD)\n     * @param _decimals array of decimals for associated price pairs (e.g. 3)\n     * @param _answers array of prices for associated price pairs\n     * @param _marketStatusAnswers array of market open/closed statuses\n     * @param _provider optional address of the provider, if different from msg.sender\n     */\n    function transmit(\n        string[] calldata _pricePairs,\n        uint8[] calldata _decimals,\n        int192[] calldata _answers,\n        bool[] calldata _marketStatusAnswers,\n        address _provider\n    ) external {\n        require(\n            (_pricePairs.length == _decimals.length) && (_pricePairs.length == _answers.length) && (_pricePairs.length == _marketStatusAnswers.length),\n            \"Transmitted arrays must be equal\"\n        );\n        // if no provider is provided, use the msg.sender\n        address provider = (_provider == address(0)) ? msg.sender : _provider;\n\n        // Iterate through each transmitted price pair\n        for (uint256 i = 0; i < _pricePairs.length; i++) {\n            string memory str = string(\n                abi.encodePacked(\"Price-\", _pricePairs[i], \"-\", Strings.toString(_decimals[i]), \"-\", provider)\n            );\n            bytes32 id = keccak256(bytes(str));\n\n            // deploy a new oracle if there's none previously deployed and this is the original provider\n            if (address(fluxPriceFeeds[id]) == address(0x0)) { \n                _deployOracle(id, _pricePairs[i], _decimals[i], _provider);\n            }\n\n            require(address(fluxPriceFeeds[id]) != address(0x0), \"Provider doesn't exist\");\n\n            require(fluxPriceFeeds[id].hasRole(VALIDATOR_ROLE, msg.sender), \"Only validators can transmit\");\n\n            // try transmitting values to the oracle\n            /* solhint-disable-next-line no-empty-blocks */\n            try fluxPriceFeeds[id].transmit(_answers[i], _marketStatusAnswers[i]) {\n                // transmission is successful, nothing to do\n            } catch Error(string memory reason) {\n                // catch failing revert() and require()\n                emit Log(reason);\n            }\n        }\n    }\n\n    /**\n     * @notice internal function to create a new FluxPriceFeed\n     * @dev only a validator should be able to call this function\n     */\n    function _deployOracle(\n        bytes32 _id,\n        string calldata _pricePair,\n        uint8 _decimals,\n        address _provider\n    ) internal {\n        require(msg.sender == owner, \"!owner\");\n        // deploy the new contract and store it in the mapping\n        FluxPriceFeed newPriceFeed = new FluxPriceFeed(address(this), _decimals, _pricePair);\n\n        fluxPriceFeeds[_id] = newPriceFeed;\n\n        // grant the provider DEFAULT_ADMIN_ROLE and VALIDATOR_ROLE on the new FluxPriceFeed\n        newPriceFeed.grantRole(0x00, msg.sender);\n        newPriceFeed.grantRole(VALIDATOR_ROLE, msg.sender);\n        newPriceFeed.grantRole(VALIDATOR_ROLE, _provider);\n\n        emit FluxPriceFeedCreated(_id, address(newPriceFeed));\n    }\n\n    /**\n     * @notice answer from the most recent report of a certain price pair from factory\n     * @param _id hash of the price pair string to query\n     */\n    function valueFor(bytes32 _id)\n        external\n        view\n        returns (\n            int256,\n            bool,\n            uint256,\n            uint256\n        )\n    {\n        // if oracle exists then fetch values\n        if (address(fluxPriceFeeds[_id]) != address(0x0)) {\n            // fetch the price feed contract and read its latest answer and timestamp\n            try fluxPriceFeeds[_id].latestRoundData() returns (\n                uint80,\n                int256 answer,\n                bool marketOpen,\n                uint256,\n                uint256 updatedAt,\n                uint80\n            ) {\n                return (answer,marketOpen, updatedAt, 200);\n            } catch {\n                // catch failing revert() and require()\n                return (0, false, 0, 404);\n            }\n\n            // else return not found\n        } else {\n            return (0, false, 0, 404);\n        }\n    }\n\n    /**\n     * @notice returns address of a price feed id\n     * @param _id hash of the price pair string to query\n     */\n    function addressOfPricePairId(bytes32 _id) external view returns (address) {\n        return address(fluxPriceFeeds[_id]);\n    }\n\n    /**\n     * @notice returns the hash of a price pair\n     * @param _pricePair ETH/USD\n     * @param _decimals decimal of the price pair\n     * @param _provider original provider of the price pair\n     */\n    function getId(\n        string calldata _pricePair,\n        uint8 _decimals,\n        address _provider\n    ) external pure returns (bytes32) {\n        string memory str = string(\n            abi.encodePacked(\"Price-\", _pricePair, \"-\", Strings.toString(_decimals), \"-\", _provider)\n        );\n        bytes32 id = keccak256(bytes(str));\n        return id;\n    }\n\n    /**\n     * @notice returns address of a price feed id\n     * @param _pricePair ETH/USD\n     * @param _decimals decimal of the price pair\n     * @param _provider original provider of the price pair\n     */\n    function addressOfPricePair(\n        string calldata _pricePair,\n        uint8 _decimals,\n        address _provider\n    ) external view returns (address) {\n        bytes32 id = this.getId(_pricePair, _decimals, _provider);\n        return address(fluxPriceFeeds[id]);\n    }\n\n    /**\n     * @notice returns factory's type and version\n     */\n    function typeAndVersion() external pure virtual returns (string memory) {\n        return \"FluxPriceFeedFactory 2.0.0\";\n    }\n}"
    },
    "src/contracts/vendor/flux/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface AggregatorInterface {\n    function latestAnswer() external view returns (int256);\n\n    function latestTimestamp() external view returns (uint256);\n\n    function latestMarketOpen() external view returns (bool);\n\n    function latestRound() external view returns (uint256);\n\n    function getAnswer(uint256 roundId) external view returns (int256);\n\n    function getTimestamp(uint256 roundId) external view returns (uint256);\n\n    function getMarketOpen(uint256 roundId) external view returns (bool);\n\n    event AnswerUpdated(int256 indexed current, bool marketOpen, uint256 indexed roundId, uint256 updatedAt);\n    event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "src/contracts/vendor/flux/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "src/contracts/vendor/flux/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n    \n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            bool marketOpen,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            bool marketOpen,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "src/contracts/vendor/flux/interfaces/IERC2362.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n/**\n * @dev EIP2362 Interface for pull oracles\n * https://github.com/tellor-io/EIP-2362\n */\ninterface IERC2362 {\n    /**\n     * @dev Exposed function pertaining to EIP standards\n     * @param _id bytes32 ID of the query\n     * @return int,uint,uint returns the value, timestamp, and status code of query\n     */\n    function valueFor(bytes32 _id)\n        external\n        view\n        returns (\n            int256,\n            uint256,\n            uint256\n        );\n}"
    },
    "src/contracts/vendor/gnosis/GnosisSafe.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.14;\n\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/base/ModuleManager.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/base/OwnerManager.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/base/FallbackManager.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/base/GuardManager.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/common/EtherPaymentFallback.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/common/Singleton.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/common/SignatureDecoder.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/common/SecuredTokenTransfer.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/common/StorageAccessible.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/interfaces/ISignatureValidator.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/external/GnosisSafeMath.sol\";\n\n/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract GnosisSafe is\n    EtherPaymentFallback,\n    Singleton,\n    ModuleManager,\n    OwnerManager,\n    SignatureDecoder,\n    SecuredTokenTransfer,\n    ISignatureValidatorConstants,\n    FallbackManager,\n    StorageAccessible,\n    GuardManager\n{\n    using GnosisSafeMath for uint256;\n\n    string public constant VERSION = \"1.3.0\";\n\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n        0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // keccak256(\n    //     \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    event SafeSetup(\n        address indexed initiator,\n        address[] owners,\n        uint256 threshold,\n        address initializer,\n        address fallbackHandler\n    );\n    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);\n    event SignMsg(bytes32 indexed msgHash);\n    event ExecutionFailure(bytes32 txHash, uint256 payment);\n    event ExecutionSuccess(bytes32 txHash, uint256 payment);\n\n    uint256 public nonce;\n    bytes32 private _deprecatedDomainSeparator;\n    // Mapping to keep track of all message hashes that have been approved by ALL REQUIRED owners\n    mapping(bytes32 => uint256) public signedMessages;\n    // Mapping to keep track of all hashes (message or transaction) that have been approved by ANY owners\n    mapping(address => mapping(bytes32 => uint256)) public approvedHashes;\n\n    // This constructor ensures that this contract can only be used as a master copy for Proxy contracts\n    constructor() {\n        // By setting the threshold it is not possible to call setup anymore,\n        // so we create a Safe with 0 owners and threshold 1.\n        // This is an unusable Safe, perfect for the singleton\n        threshold = 1;\n    }\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    /// @param to Contract address for optional delegate call.\n    /// @param data Data payload for optional delegate call.\n    /// @param fallbackHandler Handler for fallback calls to this contract\n    /// @param paymentToken Token that should be used for the payment (0 is ETH)\n    /// @param payment Value that should be paid\n    /// @param paymentReceiver Address that should receive the payment (or 0 if tx.origin)\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external {\n        // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n        emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);\n    }\n\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    ///      Note: The fees are always transferred, even if the user transaction fails.\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\n    /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Gas price that should be used for the payment calculation.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable virtual returns (bool success) {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData = encodeTransactionData(\n                // Transaction info\n                to,\n                value,\n                data,\n                operation,\n                safeTxGas,\n                // Payment info\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                // Signature info\n                nonce\n            );\n            // Increase nonce and execute transaction.\n            nonce++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n        address guard = getGuard();\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkTransaction(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    signatures,\n                    msg.sender\n                );\n            }\n        }\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500, \"GS010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas\n            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || safeTxGas != 0 || gasPrice != 0, \"GS013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkAfterExecution(txHash, success);\n            }\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    ) private returns (uint256 payment) {\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            require(receiver.send(payment), \"GS011\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            require(transferToken(gasToken, receiver, payment), \"GS012\");\n        }\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) public view {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        require(_threshold > 0, \"GS001\");\n        checkNSignatures(dataHash, data, signatures, _threshold);\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     * @param requiredSignatures Amount of required valid signatures.\n     */\n    function checkNSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures,\n        uint256 requiredSignatures\n    ) public view {\n        // Check that the provided signature data is not too short\n        require(signatures.length >= requiredSignatures.mul(65), \"GS020\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < requiredSignatures; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= requiredSignatures.mul(65), \"GS021\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s).add(32) <= signatures.length, \"GS022\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"GS023\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(\n                    ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE,\n                    \"GS024\"\n                );\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"GS025\");\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(\n                    keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)),\n                    v - 4,\n                    r,\n                    s\n                );\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n            require(\n                currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS,\n                \"GS026\"\n            );\n            lastOwner = currentOwner;\n        }\n    }\n\n    /// @dev Allows to estimate a Safe transaction.\n    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    /// @notice Deprecated in favor of common/StorageAccessible.sol and will be removed in next version.\n    function requiredTxGas(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (uint256) {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n     * @dev Marks a hash as approved. This can be used to validate a hash that is used by a signature.\n     * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.\n     */\n    function approveHash(bytes32 hashToApprove) external {\n        require(owners[msg.sender] != address(0), \"GS030\");\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(hashToApprove, msg.sender);\n    }\n\n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Gas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash = keccak256(\n            abi.encode(\n                SAFE_TX_TYPEHASH,\n                to,\n                value,\n                keccak256(data),\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                _nonce\n            )\n        );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    /// @dev Returns hash to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        return\n            keccak256(\n                encodeTransactionData(\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    _nonce\n                )\n            );\n    }\n}\n"
    },
    "src/contracts/vendor/gnosis/GnosisSafeL2.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./GnosisSafe.sol\";\n\n/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract GnosisSafeL2 is GnosisSafe {\n    event SafeMultiSigTransaction(\n        address to,\n        uint256 value,\n        bytes data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes signatures,\n        // We combine nonce, sender and threshold into one to avoid stack too deep\n        // Dev note: additionalInfo should not contain `bytes`, as this complicates decoding\n        bytes additionalInfo\n    );\n\n    event SafeModuleTransaction(address module, address to, uint256 value, bytes data, Enum.Operation operation);\n\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    ///      Note: The fees are always transferred, even if the user transaction fails.\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\n    /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Gas price that should be used for the payment calculation.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable override returns (bool) {\n        bytes memory additionalInfo;\n        {\n            additionalInfo = abi.encode(nonce, msg.sender, threshold);\n        }\n        emit SafeMultiSigTransaction(\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver,\n            signatures,\n            additionalInfo\n        );\n        return\n            super.execTransaction(\n                to,\n                value,\n                data,\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                signatures\n            );\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public override returns (bool success) {\n        emit SafeModuleTransaction(msg.sender, to, value, data, operation);\n        success = super.execTransactionFromModule(to, value, data, operation);\n    }\n}\n"
    },
    "src/contracts/vendor/gnosis/GnosisSafeProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/proxies/IProxyCreationCallback.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/proxies/GnosisSafeProxy.sol\";\n\n/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n/// @author Stefan George - <stefan@gnosis.pm>\ncontract GnosisSafeProxyFactory {\n    event ProxyCreation(GnosisSafeProxy proxy, address singleton);\n\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n    /// @param singleton Address of singleton contract.\n    /// @param data Payload for message call sent to new proxy contract.\n    function createProxy(address singleton, bytes memory data) public returns (GnosisSafeProxy proxy) {\n        proxy = new GnosisSafeProxy(singleton);\n        if (data.length > 0)\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                if eq(call(gas(), proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) {\n                    revert(0, 0)\n                }\n            }\n        emit ProxyCreation(proxy, singleton);\n    }\n\n    /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\n    function proxyRuntimeCode() public pure returns (bytes memory) {\n        return type(GnosisSafeProxy).runtimeCode;\n    }\n\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\n    function proxyCreationCode() public pure returns (bytes memory) {\n        return type(GnosisSafeProxy).creationCode;\n    }\n\n    /// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\n    ///      This method is only meant as an utility to be called from other methods\n    /// @param _singleton Address of singleton contract.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function deployProxyWithNonce(\n        address _singleton,\n        bytes memory initializer,\n        uint256 saltNonce\n    ) internal returns (GnosisSafeProxy proxy) {\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\n        bytes memory deploymentData = abi.encodePacked(\n            type(GnosisSafeProxy).creationCode,\n            uint256(uint160(_singleton))\n        );\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        require(address(proxy) != address(0), \"Create2 call failed\");\n    }\n\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n    /// @param _singleton Address of singleton contract.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function createProxyWithNonce(\n        address _singleton,\n        bytes memory initializer,\n        uint256 saltNonce\n    ) public returns (GnosisSafeProxy proxy) {\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\n        if (initializer.length > 0)\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) {\n                    revert(0, 0)\n                }\n            }\n        emit ProxyCreation(proxy, _singleton);\n    }\n\n    /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction\n    /// @param _singleton Address of singleton contract.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    /// @param callback Callback that will be invoked after the new proxy contract has been successfully deployed and initialized.\n    function createProxyWithCallback(\n        address _singleton,\n        bytes memory initializer,\n        uint256 saltNonce,\n        IProxyCreationCallback callback\n    ) public returns (GnosisSafeProxy proxy) {\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\n        proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback);\n        if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce);\n    }\n\n    /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce`\n    ///      This method is only meant for address calculation purpose when you use an initializer that would revert,\n    ///      therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory.\n    /// @param _singleton Address of singleton contract.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function calculateCreateProxyWithNonceAddress(\n        address _singleton,\n        bytes calldata initializer,\n        uint256 saltNonce\n    ) external returns (GnosisSafeProxy proxy) {\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\n        revert(string(abi.encodePacked(proxy)));\n    }\n}\n"
    },
    "src/contracts/vendor/gnosis/IGnosisSafeL2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface IGnosisSafeL2 {\n    function isOwner(address owner) external view returns (bool);\n\n    function getOwners() external view returns (address[] memory);\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-core/interfaces/IERC20.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-core/interfaces/IUniswapV2Callee.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-core/interfaces/IUniswapV2ERC20.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2ERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-core/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-core/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.16;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/interfaces/IERC20.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/interfaces/IUniswapV2Migrator.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Migrator {\n    function migrate(\n        address token,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport \"./IUniswapV2Router01.sol\";\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/interfaces/IWETH.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}"
    },
    "src/contracts/vendor/uniswap/v2-periphery/libraries/SafeMath.sol": {
      "content": "pragma solidity >=0.6.6;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/libraries/UniswapV2Library.sol": {
      "content": "pragma solidity >=0.5.0;\n\nimport \"../../v2-core/interfaces/IUniswapV2Pair.sol\";\nimport \"../../v2-core/interfaces/IUniswapV2Factory.sol\";\n\nimport \"./SafeMath.sol\";\n\nlibrary UniswapV2Library {\n    using SafeMath for uint256;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (address pair) {\n        pair = IUniswapV2Factory(factory).getPair(tokenA, tokenB);\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n        require(reserveA > 0 && reserveB > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        uint256 amountOut,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "src/contracts/vendor/WETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.14;\n\ncontract WETH9 {\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    function deposit() public payable virtual {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public virtual {\n        require(balanceOf[msg.sender] >= wad, \"WETH9: Error\");\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public virtual returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public virtual returns (bool) {\n        require(balanceOf[src] >= wad, \"WETH9: Error\");\n\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\n            require(allowance[src][msg.sender] >= wad, \"WETH9: Error\");\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "constantOptimizer": false,
        "deduplicate": true,
        "yul": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "metadata",
          "abi",
          "storageLayout",
          "evm.methodIdentifiers",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "evm.byteCode",
          "evm.bytecode",
          "evm.deployedBytecode"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}