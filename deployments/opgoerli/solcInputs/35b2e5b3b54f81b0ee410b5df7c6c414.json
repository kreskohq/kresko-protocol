{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SignedSafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMathUpgradeable {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/presets/ERC20PresetMinterPauser.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../extensions/ERC20Burnable.sol\";\nimport \"../extensions/ERC20Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC20PresetMinterPauser is Context, AccessControlEnumerable, ERC20Burnable, ERC20Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Pausable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "src/contracts/diamond/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable no-complex-fallback  */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable no-empty-blocks */\n\npragma solidity >=0.8.14;\n\nimport {IDiamondCutFacet} from \"./interfaces/IDiamondCutFacet.sol\";\nimport {Authorization, Role} from \"../libs/Authorization.sol\";\nimport {GeneralEvent} from \"../libs/Events.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\nimport {initializeDiamondCut} from \"./libs/LibDiamondCut.sol\";\nimport {ds} from \"./DiamondStorage.sol\";\n\ncontract Diamond {\n    struct Initialization {\n        address initContract;\n        bytes initData;\n    }\n\n    constructor(\n        address _owner,\n        IDiamondCutFacet.FacetCut[] memory _diamondCut,\n        Initialization[] memory _initializations\n    ) {\n        ds().initialize(_owner);\n        ds().diamondCut(_diamondCut, address(0), \"\");\n        Authorization._grantRole(Role.ADMIN, _owner);\n\n        for (uint256 i = 0; i < _initializations.length; i++) {\n            initializeDiamondCut(_initializations[i].initContract, _initializations[i].initData);\n        }\n\n        emit GeneralEvent.Initialized(_owner, ds().storageVersion);\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        // get facet from function selectors\n        address facet = ds().selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), Error.DIAMOND_INVALID_FUNCTION_SIGNATURE);\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "src/contracts/diamond/DiamondState.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {EnumerableSet} from \"../libs/EnumerableSet.sol\";\nimport {FacetAddressAndPosition, FacetFunctionSelectors, RoleData, ENTERED, NOT_ENTERED} from \"./DiamondTypes.sol\";\n\nimport {LibDiamondCut} from \"./libs/LibDiamondCut.sol\";\nimport {LibOwnership} from \"./libs/LibOwnership.sol\";\n\nusing LibDiamondCut for DiamondState global;\nusing LibOwnership for DiamondState global;\n\n/* -------------------------------------------------------------------------- */\n/*                                 Main Layout                                */\n/* -------------------------------------------------------------------------- */\n\nstruct DiamondState {\n    /* -------------------------------------------------------------------------- */\n    /*                                   Proxy                                    */\n    /* -------------------------------------------------------------------------- */\n    /// @notice Maps function selector to the facet address and\n    /// the position of the selector in the facetFunctionSelectors.selectors array\n    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n    /// @notice Maps facet addresses to function selectors\n    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n    /// @notice Facet addresses\n    address[] facetAddresses;\n    /// @notice ERC165 query implementation\n    mapping(bytes4 => bool) supportedInterfaces;\n    /* -------------------------------------------------------------------------- */\n    /*                               Initialization                               */\n    /* -------------------------------------------------------------------------- */\n    /// @notice Initialization status\n    bool initialized;\n    /// @notice Domain field separator\n    bytes32 domainSeparator;\n    /* -------------------------------------------------------------------------- */\n    /*                                  Ownership                                 */\n    /* -------------------------------------------------------------------------- */\n    /// @notice Current owner of the diamond\n    address contractOwner;\n    /// @notice Pending new diamond owner\n    address pendingOwner;\n    /// @notice Storage version\n    uint8 storageVersion;\n    /// @notice address(this) replacement for FF\n    address self;\n    /* -------------------------------------------------------------------------- */\n    /*                               Access Control                               */\n    /* -------------------------------------------------------------------------- */\n    mapping(bytes32 => RoleData) _roles;\n    mapping(bytes32 => EnumerableSet.AddressSet) _roleMembers;\n    /* -------------------------------------------------------------------------- */\n    /*                                 Reentrancy                                 */\n    /* -------------------------------------------------------------------------- */\n    uint256 entered;\n}\n"
    },
    "src/contracts/diamond/DiamondStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\npragma solidity >=0.8.14;\n\nimport {DiamondState} from \"./DiamondState.sol\";\n\n// Storage position\nbytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"kresko.diamond.storage\");\n\nfunction ds() pure returns (DiamondState storage state) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n        state.slot := position\n    }\n}\n"
    },
    "src/contracts/diamond/DiamondTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n/// @dev set the initial value to 1 as we do not\n/// wanna hinder possible gas refunds by setting it to 0 on exit.\n\n/* -------------------------------------------------------------------------- */\n/*                                 Reentrancy                                 */\n/* -------------------------------------------------------------------------- */\nuint256 constant NOT_ENTERED = 1;\nuint256 constant ENTERED = 2;\n\n/* ========================================================================== */\n/*                                   STRUCTS                                  */\n/* ========================================================================== */\n\nstruct FacetAddressAndPosition {\n    address facetAddress;\n    // position in facetFunctionSelectors.functionSelectors array\n    uint96 functionSelectorPosition;\n}\n\nstruct FacetFunctionSelectors {\n    bytes4[] functionSelectors;\n    // position of facetAddress in facetAddresses array\n    uint256 facetAddressPosition;\n}\n\nstruct RoleData {\n    mapping(address => bool) members;\n    bytes32 adminRole;\n}\n"
    },
    "src/contracts/diamond/facets/AuthorizationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IAuthorizationFacet} from \"../interfaces/IAuthorizationFacet.sol\";\n\nimport {Authorization, Role} from \"../../libs/Authorization.sol\";\n\n/**\n * @title Enumerable access control for the EIP2535-pattern following the OZ implementation.\n * @author Kresko\n * @notice The storage area is in the main proxy diamond storage.\n * @dev Difference here is the logic library that is shared and reused, there is no state here.\n */\n\ncontract AuthorizationFacet is IAuthorizationFacet {\n    /**\n     * @dev OpenZeppelin\n     * Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * @notice WARNING:\n     * When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block.\n     *\n     * See the following forum post for more information:\n     * - https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296\n     *\n     * @dev Kresko\n     *\n     * TL;DR above:\n     *\n     * - If you iterate the EnumSet outside a single block scope you might get different results.\n     * - Since when EnumSet member is deleted it is replaced with the highest index.\n     * @return address with the `role`\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address) {\n        return Authorization.getRoleMember(role, index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     * @notice See warning in {getRoleMember} if combining these two\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256) {\n        return Authorization.getRoleMemberCount(role);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external {\n        Authorization.grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * @notice Requirements\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external {\n        Authorization._revokeRole(role, account);\n    }\n\n    function hasRole(bytes32 role, address account) external view returns (bool) {\n        return Authorization.hasRole(role, account);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * @notice To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32) {\n        return Authorization.getRoleAdmin(role);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * @notice Requirements\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external {\n        Authorization._renounceRole(role, account);\n    }\n}\n"
    },
    "src/contracts/diamond/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IDiamondCutFacet} from \"../interfaces/IDiamondCutFacet.sol\";\nimport {DiamondModifiers, Role} from \"../../shared/Modifiers.sol\";\nimport {initializeDiamondCut} from \"../libs/LibDiamondCut.sol\";\nimport {ds} from \"../DiamondStorage.sol\";\n\ncontract DiamondCutFacet is DiamondModifiers, IDiamondCutFacet {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///  a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override onlyRole(Role.ADMIN) {\n        ds().diamondCut(_diamondCut, _init, _calldata);\n    }\n\n    /// @notice Use an initializer contract without doing modifications\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    /// - _calldata is executed with delegatecall on _init\n    function upgradeState(address _init, bytes calldata _calldata) external onlyRole(Role.ADMIN) {\n        initializeDiamondCut(_init, _calldata);\n    }\n}\n"
    },
    "src/contracts/diamond/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IDiamondLoupeFacet} from \"../interfaces/IDiamondLoupeFacet.sol\";\nimport {ds, DiamondState} from \"../DiamondStorage.sol\";\n\ncontract DiamondLoupeFacet is IDiamondLoupeFacet {\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external view override returns (Facet[] memory facets_) {\n        DiamondState storage s = ds();\n        uint256 numFacets = s.facetAddresses.length;\n        facets_ = new Facet[](numFacets);\n        for (uint256 i; i < numFacets; i++) {\n            address facetAddress_ = s.facetAddresses[i];\n            facets_[i].facetAddress = facetAddress_;\n            facets_[i].functionSelectors = s.facetFunctionSelectors[facetAddress_].functionSelectors;\n        }\n    }\n\n    /// @notice Gets all the function selectors provided by a facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(\n        address _facet\n    ) external view override returns (bytes4[] memory facetFunctionSelectors_) {\n        facetFunctionSelectors_ = ds().facetFunctionSelectors[_facet].functionSelectors;\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view override returns (address[] memory facetAddresses_) {\n        facetAddresses_ = ds().facetAddresses;\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\n        facetAddress_ = ds().selectorToFacetAndPosition[_functionSelector].facetAddress;\n    }\n}\n"
    },
    "src/contracts/diamond/facets/DiamondOwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IDiamondOwnershipFacet} from \"../interfaces/IDiamondOwnershipFacet.sol\";\nimport {DiamondModifiers} from \"../../shared/Modifiers.sol\";\nimport {ds} from \"../DiamondStorage.sol\";\n\ncontract DiamondOwnershipFacet is DiamondModifiers, IDiamondOwnershipFacet {\n    /* -------------------------------------------------------------------------- */\n    /*                                    Write                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Initiate ownership transfer to a new address\n     * - caller must be the current contract owner\n     * - the new owner cannot be address(0)\n     * - emits a {AuthEvent.PendingOwnershipTransfer} event\n     * @param _newOwner address that is set as the pending new owner\n     */\n    function transferOwnership(address _newOwner) external override onlyOwner {\n        ds().initiateOwnershipTransfer(_newOwner);\n    }\n\n    /**\n     * @notice Transfer the ownership to the new pending owner\n     * - caller must be the pending owner\n     * - emits a {AccessEvent.OwnershipTransferred} event\n     */\n    function acceptOwnership() external override onlyPendingOwner {\n        ds().finalizeOwnershipTransfer();\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Read                                    */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Getter for the current owner\n    function owner() external view override returns (address) {\n        return ds().contractOwner;\n    }\n\n    /// @notice Getter for the pending owner\n    /// @return address\n    function pendingOwner() external view override returns (address) {\n        return ds().pendingOwner;\n    }\n\n    /// @notice Initialization status getter\n    /// @return initialized status\n    function initialized() external view returns (bool) {\n        return ds().initialized;\n    }\n}\n"
    },
    "src/contracts/diamond/facets/ERC165Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IERC165} from \"../../shared/IERC165.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {DiamondModifiers, Role} from \"../../shared/Modifiers.sol\";\n\nimport {ds, DiamondState} from \"../DiamondStorage.sol\";\n\ncontract ERC165Facet is DiamondModifiers, IERC165 {\n    /* -------------------------------------------------------------------------- */\n    /*                                    Read                                    */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Basic ERC165 support\n    /// @param _interfaceId interface id to support\n    function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\n        return ds().supportedInterfaces[_interfaceId];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Write                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice set or unset ERC165 using DiamondStorage.supportedInterfaces\n    /// @param interfaceIds list of interface id to set as supported\n    /// @param interfaceIdsToRemove list of interface id to unset as supported.\n    /// Technically, you can remove support of ERC165 by having the IERC165 id itself being part of that array.\n    function setERC165(\n        bytes4[] calldata interfaceIds,\n        bytes4[] calldata interfaceIdsToRemove\n    ) external onlyRole(Role.ADMIN) {\n        DiamondState storage s = ds();\n\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            s.supportedInterfaces[interfaceIds[i]] = true;\n        }\n\n        for (uint256 i = 0; i < interfaceIdsToRemove.length; i++) {\n            s.supportedInterfaces[interfaceIdsToRemove[i]] = false;\n        }\n    }\n}\n"
    },
    "src/contracts/diamond/interfaces/IAuthorizationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface IAuthorizationFacet {\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    function grantRole(bytes32 role, address account) external;\n\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    function renounceRole(bytes32 role, address account) external;\n\n    function revokeRole(bytes32 role, address account) external;\n}\n"
    },
    "src/contracts/diamond/interfaces/IDiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface IDiamondCutFacet {\n    /// @dev  Add=0, Replace=1, Remove=2\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    /// a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "src/contracts/diamond/interfaces/IDiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupeFacet {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "src/contracts/diamond/interfaces/IDiamondOwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n/// @title Contract Ownership\ninterface IDiamondOwnershipFacet {\n    /// @dev Pending contract ownership transfer is initiated.\n    event PendingOwnershipTransfer(address indexed previousOwner, address indexed newOwner);\n    /// @dev Ownership of a contract is transferred\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Get the address of pending owner\n    /// @return pendingOwner_ The address of the pending owner.\n    function pendingOwner() external view returns (address pendingOwner_);\n\n    /// @notice Set the address of the new pending owner of the contract\n    /// @param _newOwner The address of the pending owner\n    function transferOwnership(address _newOwner) external;\n\n    /// @notice Change the ownership of the contract to the pending owner\n    function acceptOwnership() external;\n}\n"
    },
    "src/contracts/diamond/libs/LibDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {IDiamondCutFacet} from \"../interfaces/IDiamondCutFacet.sol\";\n\nimport {Meta} from \"../../libs/Meta.sol\";\nimport {DiamondEvent} from \"../../libs/Events.sol\";\nimport {DiamondState} from \"../DiamondState.sol\";\n\n// solhint-disable-next-line func-visibility\nfunction initializeDiamondCut(address _init, bytes memory _calldata) {\n    if (_init == address(0)) {\n        require(_calldata.length == 0, \"DiamondCut: _init is address(0) but_calldata is not empty\");\n    } else {\n        require(_calldata.length > 0, \"DiamondCut: _calldata is empty but _init is not address(0)\");\n        Meta.enforceHasContractCode(_init, \"DiamondCut: _init address has no code\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up the error\n                revert(string(error));\n            } else {\n                revert(\"DiamondCut: _init function reverted\");\n            }\n        }\n    }\n}\n\nlibrary LibDiamondCut {\n    /* -------------------------------------------------------------------------- */\n    /*                              Diamond Functions                             */\n    /* -------------------------------------------------------------------------- */\n\n    function diamondCut(\n        DiamondState storage self,\n        IDiamondCutFacet.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCutFacet.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCutFacet.FacetCutAction.Add) {\n                self.addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCutFacet.FacetCutAction.Replace) {\n                self.replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCutFacet.FacetCutAction.Remove) {\n                self.removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"DiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondEvent.DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(\n        DiamondState storage self,\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(_functionSelectors.length > 0, \"DiamondCut: No selectors in facet to cut\");\n        require(_facetAddress != address(0), \"DiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(self.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            self.addFacet(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = self.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"DiamondCut: Can't add function that already exists\");\n            self.addFunction(selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(\n        DiamondState storage self,\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(_functionSelectors.length > 0, \"DiamondCut: No selectors in facet to cut\");\n        require(_facetAddress != address(0), \"DiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(self.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            self.addFacet(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = self.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"DiamondCut: Can't replace function with same function\");\n            self.removeFunction(oldFacetAddress, selector);\n            self.addFunction(selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(\n        DiamondState storage self,\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(_functionSelectors.length > 0, \"DiamondCut: No selectors in facet to cut\");\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"DiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = self.selectorToFacetAndPosition[selector].facetAddress;\n            self.removeFunction(oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondState storage self, address _facetAddress) internal {\n        Meta.enforceHasContractCode(_facetAddress, \"DiamondCut: New facet has no code\");\n        self.facetFunctionSelectors[_facetAddress].facetAddressPosition = self.facetAddresses.length;\n        self.facetAddresses.push(_facetAddress);\n    }\n\n    function addFunction(\n        DiamondState storage self,\n        bytes4 _selector,\n        uint96 _selectorPosition,\n        address _facetAddress\n    ) internal {\n        self.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        self.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        self.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondState storage self, address _facetAddress, bytes4 _selector) internal {\n        require(_facetAddress != address(0), \"DiamondCut: Can't remove function that doesn't exist\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = self.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = self.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = self.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            self.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            self.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        self.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete self.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = self.facetAddresses.length - 1;\n            uint256 facetAddressPosition = self.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = self.facetAddresses[lastFacetAddressPosition];\n                self.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                self.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            self.facetAddresses.pop();\n            delete self.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n}\n"
    },
    "src/contracts/diamond/libs/LibOwnership.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IERC165} from \"../../shared/IERC165.sol\";\nimport {IDiamondCutFacet} from \"../interfaces/IDiamondCutFacet.sol\";\nimport {IDiamondLoupeFacet} from \"../interfaces/IDiamondLoupeFacet.sol\";\nimport {IDiamondOwnershipFacet} from \"../interfaces/IDiamondOwnershipFacet.sol\";\nimport {IAuthorizationFacet} from \"../interfaces/IAuthorizationFacet.sol\";\n\nimport {GeneralEvent, AuthEvent} from \"../../libs/Events.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Meta} from \"../../libs/Meta.sol\";\n\nimport {NOT_ENTERED} from \"../DiamondTypes.sol\";\nimport {DiamondState} from \"../DiamondState.sol\";\n\nlibrary LibOwnership {\n    /* -------------------------------------------------------------------------- */\n    /*                         Initialization & Ownership                         */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Ownership initializer\n    /// @notice Only called on the first deployment\n    function initialize(DiamondState storage self, address _owner) internal {\n        require(!self.initialized, Error.ALREADY_INITIALIZED);\n        self.entered = NOT_ENTERED;\n        self.initialized = true;\n        self.storageVersion++;\n        self.contractOwner = _owner;\n\n        self.supportedInterfaces[type(IDiamondLoupeFacet).interfaceId] = true;\n        self.supportedInterfaces[type(IERC165).interfaceId] = true;\n        self.supportedInterfaces[type(IDiamondCutFacet).interfaceId] = true;\n        self.supportedInterfaces[type(IDiamondOwnershipFacet).interfaceId] = true;\n        self.supportedInterfaces[type(IAuthorizationFacet).interfaceId] = true;\n\n        emit GeneralEvent.Deployed(_owner, self.storageVersion);\n        emit AuthEvent.OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Initiate ownership transfer to a new address\n     * @param _newOwner address that is set as the pending new owner\n     * @notice caller must be the current contract owner\n     */\n    function initiateOwnershipTransfer(DiamondState storage self, address _newOwner) internal {\n        require(Meta.msgSender() == self.contractOwner, Error.DIAMOND_INVALID_OWNER);\n        require(_newOwner != address(0), \"DS: Owner cannot be 0-address\");\n\n        self.pendingOwner = _newOwner;\n\n        emit AuthEvent.PendingOwnershipTransfer(self.contractOwner, _newOwner);\n    }\n\n    /**\n     * @dev Transfer the ownership to the new pending owner\n     * @notice caller must be the pending owner\n     */\n    function finalizeOwnershipTransfer(DiamondState storage self) internal {\n        address sender = Meta.msgSender();\n        require(sender == self.pendingOwner, Error.DIAMOND_INVALID_PENDING_OWNER);\n        self.contractOwner = self.pendingOwner;\n        self.pendingOwner = address(0);\n\n        emit AuthEvent.OwnershipTransferred(self.contractOwner, sender);\n    }\n}\n"
    },
    "src/contracts/kiss/interfaces/IKISS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {IERC20Upgradeable} from \"../../shared/IERC20Upgradeable.sol\";\n\ninterface IKISS {\n    function pendingOperatorUnlockTime() external returns (uint256);\n\n    function pendingOperator() external returns (address);\n\n    function maxOperators() external returns (uint256);\n\n    function setMaxOperators(uint256 _maxMinters) external;\n\n    function kresko() external returns (address);\n}\n"
    },
    "src/contracts/kiss/KISS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {ERC20PresetMinterPauser, AccessControl, IAccessControl} from \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol\";\n\nimport {IKreskoAssetIssuer} from \"../kreskoasset/IKreskoAssetIssuer.sol\";\nimport {IKISS} from \"./interfaces/IKISS.sol\";\nimport {Role} from \"../libs/Authorization.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @title Kresko Integrated Stable System\n * This is a non-rebasing Kresko Asset, intended to be paired to a stable-value underlying.\n * @author Kresko\n */\ncontract KISS is IKISS, IKreskoAssetIssuer, ERC20PresetMinterPauser {\n    bytes32 public constant OPERATOR_ROLE = 0x112e48a576fb3a75acc75d9fcf6e0bc670b27b1dbcd2463502e10e68cf57d6fd;\n\n    modifier onlyContract() {\n        require(msg.sender.code.length > 0, Error.CALLER_NOT_CONTRACT);\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Layout                                   */\n    /* -------------------------------------------------------------------------- */\n\n    uint256 public pendingOperatorWaitPeriod;\n    uint256 public pendingOperatorUnlockTime;\n    uint256 public maxOperators;\n    address public pendingOperator;\n    address public kresko;\n\n    // ERC20\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Events                                   */\n    /* -------------------------------------------------------------------------- */\n    event NewOperatorInitialized(address indexed pendingNewOperator, uint256 unlockTimestamp);\n    event NewOperator(address indexed newOperator);\n    event NewMaxOperators(uint256 newMaxOperators);\n    event NewPendingOperatorWaitPeriod(uint256 newPeriod);\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Writes                                   */\n    /* -------------------------------------------------------------------------- */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 dec_,\n        address admin_,\n        address kresko_\n    ) ERC20PresetMinterPauser(name_, symbol_) {\n        // Few sanity checks, we do not want EOA's here\n        require(kresko_.code.length > 0, Error.KRESKO_NOT_CONTRACT);\n        // require(admin_.code.length > 0, Error.ADMIN_NOT_A_CONTRACT);\n\n        // ERC20\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = dec_;\n        kresko = kresko_;\n\n        // 2 operators needed at the time of writing, the volative market and the stable market.\n        maxOperators = 2;\n\n        // 15 minutes to wait before the operator can accept the role, this is the minimum value that can be set.\n        pendingOperatorWaitPeriod = 15 minutes;\n\n        // Setup the admin\n        _setupRole(Role.DEFAULT_ADMIN, admin_);\n        _setupRole(Role.ADMIN, admin_);\n\n        // Setup the protocol\n        kresko = kresko_;\n        _setupRole(Role.OPERATOR, kresko_);\n        _setupRole(MINTER_ROLE, kresko_);\n        _setupRole(PAUSER_ROLE, kresko_);\n\n        // Deployer does not need roles, uncomment for mainnet\n        renounceRole(MINTER_ROLE, msg.sender);\n        renounceRole(PAUSER_ROLE, msg.sender);\n        // renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n        return\n            interfaceId != 0xffffffff &&\n            (interfaceId == type(IKISS).interfaceId ||\n                interfaceId == type(IKreskoAssetIssuer).interfaceId ||\n                interfaceId == 0x01ffc9a7 ||\n                interfaceId == 0x36372b07);\n    }\n\n    /**\n     * @notice This function adds KISS to circulation\n     * Caller must be a contract and have the OPERATOR_ROLE\n     * @param _to address to mint tokens to\n     * @param _amount amount to mint\n     */\n    function issue(\n        uint256 _amount,\n        address _to\n    ) public override onlyContract onlyRole(Role.OPERATOR) returns (uint256) {\n        _mint(_to, _amount);\n        return _amount;\n    }\n\n    /**\n     * @notice Use operator role for minting, so override the parent\n     * Caller must be a contract and have the OPERATOR_ROLE\n     * @param _to address to mint tokens to\n     * @param _amount amount to mint\n     * @dev Does not return a value\n     */\n    function mint(address _to, uint256 _amount) public override onlyContract onlyRole(Role.OPERATOR) {\n        _mint(_to, _amount);\n    }\n\n    /**\n     * @notice This function removes KISS from circulation\n     * Caller must be a contract and have the OPERATOR_ROLE\n     * @param _from address to burn tokens from\n     * @param _amount amount to burn\n     */\n    function destroy(uint256 _amount, address _from) external onlyContract onlyRole(Role.OPERATOR) returns (uint256) {\n        _burn(_from, _amount);\n        return _amount;\n    }\n\n    /**\n     * @notice Allows ADMIN_ROLE to perform a pause\n     */\n    function pause() public override onlyContract onlyRole(Role.ADMIN) {\n        _pause();\n    }\n\n    /**\n     * @notice Allows ADMIN_ROLE to unpause\n     */\n    function unpause() public override onlyContract onlyRole(Role.ADMIN) {\n        _unpause();\n    }\n\n    /**\n     * @notice Set a new waiting period for a new operator\n     *\n     * Must be at least 15 minutes\n     *\n     * @param _newPeriod the period, in seconds\n     */\n    function setPendingOperatorWaitPeriod(uint256 _newPeriod) external onlyRole(Role.ADMIN) {\n        require(_newPeriod >= 15 minutes, Error.OPERATOR_WAIT_PERIOD_TOO_SHORT);\n        pendingOperatorWaitPeriod = _newPeriod;\n        emit NewPendingOperatorWaitPeriod(_newPeriod);\n    }\n\n    /**\n     * @notice Allows ADMIN_ROLE to change the maximum operators\n     * @param _maxOperators new maximum amount of operators\n     */\n    function setMaxOperators(uint256 _maxOperators) external onlyRole(Role.ADMIN) {\n        maxOperators = _maxOperators;\n        emit NewMaxOperators(_maxOperators);\n    }\n\n    /**\n     * @notice Overrides `AccessControl.grantRole` for following:\n     * * Implement a cooldown period of `pendingOperatorWaitPeriod` minutes for setting a new OPERATOR_ROLE\n     * * EOA cannot be granted the operator role\n     *\n     * @notice OPERATOR_ROLE can still be revoked without this cooldown period\n     * @notice PAUSER_ROLE can still be granted without this cooldown period\n     * @param _role role to grant\n     * @param _to address to grant role for\n     */\n    function grantRole(bytes32 _role, address _to) public override(AccessControl, IAccessControl) onlyRole(Role.ADMIN) {\n        // Default behavior\n        if (_role != Role.OPERATOR) {\n            _grantRole(_role, _to);\n            return;\n        }\n\n        // Handle the operator role\n        require(_to.code.length > 0, Error.OPERATOR_NOT_CONTRACT);\n        if (pendingOperator != address(0)) {\n            // Ensure cooldown period\n            require(pendingOperatorUnlockTime < block.timestamp, Error.OPERATOR_WAIT_PERIOD_NOT_OVER);\n            // Grant role\n            _grantRole(Role.OPERATOR, pendingOperator);\n            emit NewOperator(_msgSender());\n            // Reset pending owner\n            // No need to touch the timestamp (next call will just trigger the cooldown period)\n            pendingOperator = address(0);\n        } else if (pendingOperatorUnlockTime != 0) {\n            // Do not allow more than `maxOperators` of operators\n            require(getRoleMemberCount(Role.OPERATOR) < maxOperators, Error.OPERATOR_LIMIT_REACHED);\n            // Set the timestamp for the cooldown period\n            pendingOperatorUnlockTime = block.timestamp + pendingOperatorWaitPeriod;\n            // Set the pending oeprator, execution to upper if clause next call as this pending operator is set\n            pendingOperator = _to;\n            emit NewOperatorInitialized(_to, pendingOperatorUnlockTime);\n        } else {\n            // Initialize operator for the first time\n            _grantRole(Role.OPERATOR, _to);\n            emit NewOperator(_to);\n            // Set the timestamp, execution will not come here again\n            pendingOperatorUnlockTime = block.timestamp;\n        }\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Views                                   */\n    /* -------------------------------------------------------------------------- */\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * KreskoAssetIssuer compability\n     * @param assets amount of assets\n     * @return shares with kiss, this is equal to assets as there is no rebasing\n     */\n    function convertToShares(uint256 assets) external pure returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * KreskoAssetIssuer compability\n     * @param shares amount of shares\n     * @return assets with kiss, this is equal to shares as there is no rebasing\n     */\n    function convertToAssets(uint256 shares) external pure returns (uint256) {\n        return shares;\n    }\n}\n"
    },
    "src/contracts/kreskoasset/IKreskoAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {IAccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"../shared/IERC20Upgradeable.sol\";\nimport {Rebase} from \"../shared/Rebase.sol\";\nimport {IERC165} from \"../shared/IERC165.sol\";\n\ninterface IKreskoAsset is IERC20Upgradeable, IAccessControlEnumerableUpgradeable, IERC165 {\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _owner,\n        address _kresko\n    ) external;\n\n    function kresko() external view returns (address);\n\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n\n    function rebaseInfo() external view returns (Rebase memory);\n\n    function isRebased() external view returns (bool);\n\n    function rebase(uint256 _denominator, bool _positive, address[] calldata pools) external;\n\n    function reinitializeERC20(string memory _name, string memory _symbol, uint8 _version) external;\n}\n"
    },
    "src/contracts/kreskoasset/IKreskoAssetAnchor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {IAccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\";\nimport {IERC165} from \"../shared/IERC165.sol\";\nimport {IERC20Upgradeable} from \"../shared/IERC20Upgradeable.sol\";\nimport {IKreskoAssetIssuer} from \"./IKreskoAssetIssuer.sol\";\n\ninterface IKreskoAssetAnchor is IKreskoAssetIssuer, IERC20Upgradeable, IAccessControlEnumerableUpgradeable, IERC165 {\n    function asset() external view returns (address);\n\n    function deposit(uint256, address) external returns (uint256);\n\n    function withdraw(uint256, address, address) external returns (uint256);\n\n    function initialize(address _asset, string memory _name, string memory _symbol, address _admin) external;\n\n    function maxDeposit(address) external view returns (uint256);\n\n    function maxMint(address) external view returns (uint256);\n\n    function maxRedeem(address owner) external view returns (uint256);\n\n    function maxWithdraw(address owner) external view returns (uint256);\n\n    function mint(uint256 _shares, address _receiver) external returns (uint256 assets);\n\n    function previewDeposit(uint256 assets) external view returns (uint256);\n\n    function previewMint(uint256 shares) external view returns (uint256);\n\n    function previewRedeem(uint256 shares) external view returns (uint256);\n\n    function previewWithdraw(uint256 assets) external view returns (uint256);\n\n    function totalAssets() external view returns (uint256);\n\n    function reinitializeERC20(string memory _name, string memory _symbol, uint8 _version) external;\n}\n"
    },
    "src/contracts/kreskoasset/IKreskoAssetIssuer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n/// @title KreskoAsset issuer interface\n/// @author Kresko\n/// @notice Contract that can issue/destroy Kresko Assets through Kresko\n/// @dev This interface is used by KISS & KreskoAssetAnchor\ninterface IKreskoAssetIssuer {\n    function issue(uint256 _assets, address _to) external returns (uint256 shares);\n\n    function destroy(uint256 _assets, address _from) external returns (uint256 shares);\n\n    function convertToShares(uint256 assets) external view returns (uint256);\n\n    function convertToAssets(uint256 shares) external view returns (uint256);\n}\n"
    },
    "src/contracts/kreskoasset/KreskoAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n// solhint-disable-next-line\nimport {AccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\n\nimport {Role} from \"../libs/Authorization.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\nimport {RebaseMath, Rebase} from \"../shared/Rebase.sol\";\nimport {ERC20Upgradeable} from \"../shared/ERC20Upgradeable.sol\";\nimport {IERC165} from \"../shared/IERC165.sol\";\n\nimport {IKreskoAsset} from \"./IKreskoAsset.sol\";\nimport {IUniswapV2Pair} from \"../vendor/uniswap/v2-core/interfaces/IUniswapV2Pair.sol\";\n\n/**\n * @title Kresko Synthethic Asset - rebasing ERC20.\n * @author Kresko\n *\n * @notice Rebases to adjust for stock splits and reverse stock splits\n *\n * @notice Minting, burning and rebasing can only be performed by the `Role.OPERATOR`\n */\n\ncontract KreskoAsset is ERC20Upgradeable, AccessControlEnumerableUpgradeable, IERC165 {\n    using RebaseMath for uint256;\n\n    bool public isRebased;\n    address public kresko;\n    Rebase public rebaseInfo;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               Initialization                               */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Initializes a KreskoAsset ERC20 token.\n     * @dev Intended to be operated by the Kresko smart contract.\n     * @param _name The name of the KreskoAsset.\n     * @param _symbol The symbol of the KreskoAsset.\n     * @param _decimals Decimals for the asset.\n     * @param _admin The adminstrator of this contract.\n     * @param _kresko The protocol, can perform mint and burn.\n     */\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _admin,\n        address _kresko\n    ) external initializer {\n        // ERC20\n        __ERC20Upgradeable_init(_name, _symbol, _decimals);\n\n        // This does nothing but doesn't hurt to make sure it's called\n        __AccessControlEnumerable_init();\n\n        // Setup the admin\n        _setupRole(Role.DEFAULT_ADMIN, msg.sender);\n        _setupRole(Role.ADMIN, msg.sender);\n\n        _setupRole(Role.DEFAULT_ADMIN, _admin);\n        _setupRole(Role.ADMIN, _admin);\n\n        // Setup the protocol\n        _setupRole(Role.OPERATOR, _kresko);\n        kresko = _kresko;\n    }\n\n    /**\n     * @notice ERC-165\n     * IKreskoAsset, ERC20 and ERC-165\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControlEnumerableUpgradeable, IERC165) returns (bool) {\n        return (interfaceId != 0xffffffff &&\n            (interfaceId == type(IKreskoAsset).interfaceId ||\n                interfaceId == 0x01ffc9a7 ||\n                interfaceId == 0x36372b07 ||\n                super.supportsInterface(interfaceId)));\n    }\n\n    /**\n     * @notice Updates ERC20 metadata for the token in case eg. a ticker change\n     * @param _name new name for the asset\n     * @param _symbol new symbol for the asset\n     * @param _version number that must be greater than latest emitted `Initialized` version\n     */\n    function reinitializeERC20(\n        string memory _name,\n        string memory _symbol,\n        uint8 _version\n    ) external onlyRole(Role.ADMIN) reinitializer(_version) {\n        __ERC20Upgradeable_init(_name, _symbol, decimals);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Read                                    */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Returns the total supply of the token.\n    /// @notice This amount is adjusted by rebases.\n    function totalSupply() public view override returns (uint256) {\n        return !isRebased ? _totalSupply : _totalSupply.rebase(rebaseInfo);\n    }\n\n    /// @notice Returns the balance of @param _account\n    /// @notice This amount is adjusted by rebases.\n    function balanceOf(address _account) public view override returns (uint256) {\n        uint256 balance = _balances[_account];\n        return !isRebased ? balance : balance.rebase(rebaseInfo);\n    }\n\n    /// @notice Returns the allowance from @param _owner to @param _account\n    /// @notice This amount is adjusted by rebases.\n    function allowance(address _owner, address _account) public view override returns (uint256) {\n        return _allowances[_owner][_account];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Overrides                                 */\n    /* -------------------------------------------------------------------------- */\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address _to, uint256 _amount) public override returns (bool) {\n        return _transfer(msg.sender, _to, _amount);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _amount) public virtual override returns (bool) {\n        uint256 allowed = allowance(_from, msg.sender); // Saves gas for unlimited approvals.\n\n        if (allowed != type(uint256).max) {\n            require(_amount <= allowed, Error.NOT_ENOUGH_ALLOWANCE);\n            _allowances[_from][msg.sender] -= _amount;\n        }\n\n        return _transfer(_from, _to, _amount);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Restricted                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Perform a rebase, changing the denumerator and its operator\n     * @param _denominator the denumerator for the operator, 1 ether = 1\n     * @param _positive supply increasing/reducing rebase\n     * @param _pools UniswapV2Pair address to sync so we wont get rekt by skim() calls.\n     * @dev denumerator values 0 and 1 ether will disable the rebase\n     */\n    function rebase(uint256 _denominator, bool _positive, address[] calldata _pools) external onlyRole(Role.ADMIN) {\n        require(_denominator >= 1 ether, Error.REBASING_DENOMINATOR_LOW);\n        if (_denominator == 1 ether) {\n            isRebased = false;\n            rebaseInfo = Rebase(false, 0);\n        } else {\n            isRebased = true;\n            rebaseInfo = Rebase(_positive, _denominator);\n        }\n        uint256 length = _pools.length;\n        for (uint256 i; i < length; ) {\n            IUniswapV2Pair(_pools[i]).sync();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Mints tokens to an address.\n     * @dev Only callable by operator.\n     * @dev Internal balances are always unrebased, events emitted are not.\n     * @param _to The address to mint tokens to.\n     * @param _amount The amount of tokens to mint.\n     */\n    function mint(address _to, uint256 _amount) external onlyRole(Role.OPERATOR) {\n        uint256 normalizedAmount = !isRebased ? _amount : _amount.unrebase(rebaseInfo);\n        _totalSupply += normalizedAmount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balances[_to] += normalizedAmount;\n        }\n        // Emit user input amount, not the maybe unrebased amount.\n        emit Transfer(address(0), _to, _amount);\n    }\n\n    /**\n     * @notice Burns tokens from an address.\n     * @dev Only callable by operator.\n     * @dev Internal balances are always unrebased, events emitted are not.\n     * @param _from The address to burn tokens from.\n     * @param _amount The amount of tokens to burn.\n     */\n    function burn(address _from, uint256 _amount) external onlyRole(Role.OPERATOR) {\n        uint256 normalizedAmount = !isRebased ? _amount : _amount.unrebase(rebaseInfo);\n\n        _balances[_from] -= normalizedAmount;\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            _totalSupply -= normalizedAmount;\n        }\n\n        emit Transfer(_from, address(0), _amount);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Internal                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /// @dev Internal balances are always unrebased, events emitted are not.\n    function _transfer(address _from, address _to, uint256 _amount) internal returns (bool) {\n        require(_amount <= balanceOf(_from), Error.NOT_ENOUGH_BALANCE);\n        uint256 normalizedAmount = !isRebased ? _amount : _amount.unrebase(rebaseInfo);\n\n        _balances[_from] -= normalizedAmount;\n        unchecked {\n            _balances[_to] += normalizedAmount;\n        }\n\n        // Emit user input amount, not the maybe unrebased amount.\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n}\n"
    },
    "src/contracts/kreskoasset/KreskoAssetAnchor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {AccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\n\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\nimport {Role} from \"../libs/Authorization.sol\";\n\nimport {IKreskoAssetIssuer} from \"./IKreskoAssetIssuer.sol\";\nimport {IKreskoAssetAnchor} from \"./IKreskoAssetAnchor.sol\";\nimport {ERC4626Upgradeable, IKreskoAsset} from \"../shared/ERC4626Upgradeable.sol\";\n\n/* solhint-disable no-empty-blocks */\n\n/**\n * @title Kresko Asset Anchor\n * Pro-rata representation of the underlying kresko asset.\n * Based on ERC-4626 by Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n *\n * @notice Main purpose of this token is to represent a static amount of the possibly rebased underlying KreskoAsset.\n * Main use-cases are normalized book-keeping, bridging and integration with external contracts.\n *\n * @author Kresko\n */\ncontract KreskoAssetAnchor is ERC4626Upgradeable, AccessControlEnumerableUpgradeable {\n    /* -------------------------------------------------------------------------- */\n    /*                                 Immutables                                 */\n    /* -------------------------------------------------------------------------- */\n    constructor(IKreskoAsset _asset) payable ERC4626Upgradeable(_asset) {}\n\n    /**\n     * @notice Initializes the Kresko Asset Anchor.\n     *\n     * @param _asset The underlying (Kresko) Asset\n     * @param _name Name of the anchor token\n     * @param _symbol Symbol of the anchor token\n     * @param _admin The adminstrator of this contract.\n     * @dev Decimals are not supplied as they are read from the underlying Kresko Asset\n     */\n    function initialize(\n        IKreskoAsset _asset,\n        string memory _name,\n        string memory _symbol,\n        address _admin\n    ) external initializer {\n        // ERC4626\n        __ERC4626Upgradeable_init(_asset, _name, _symbol);\n\n        // This does nothing but doesn't hurt to make sure it's called\n        __AccessControlEnumerable_init();\n\n        // Default admin setup\n        _setupRole(Role.DEFAULT_ADMIN, _admin);\n        _setupRole(Role.ADMIN, _admin);\n\n        _setupRole(Role.DEFAULT_ADMIN, msg.sender);\n        _setupRole(Role.ADMIN, msg.sender);\n\n        // Setup the operator, which is the protocol linked to the main asset\n        _setupRole(Role.OPERATOR, asset.kresko());\n    }\n\n    /**\n     * @notice ERC-165\n     * - KreskoAssetAnchor, ERC20 and ERC-165 itself\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId != 0xffffffff &&\n            (interfaceId == type(IKreskoAssetAnchor).interfaceId ||\n                interfaceId == type(IKreskoAssetIssuer).interfaceId ||\n                interfaceId == 0x01ffc9a7 ||\n                interfaceId == 0x36372b07 ||\n                super.supportsInterface(interfaceId));\n    }\n\n    /**\n     * @notice Updates ERC20 metadata for the token in case eg. a ticker change\n     * @param _name new name for the asset\n     * @param _symbol new symbol for the asset\n     * @param _version number that must be greater than latest emitted `Initialized` version\n     */\n    function reinitializeERC20(\n        string memory _name,\n        string memory _symbol,\n        uint8 _version\n    ) external onlyRole(Role.ADMIN) reinitializer(_version) {\n        __ERC20Upgradeable_init(_name, _symbol, decimals);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Overwrites                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Track the underlying amount\n     * @return Total supply for the underlying\n     */\n    function totalAssets() public view virtual override returns (uint256) {\n        return asset.totalSupply();\n    }\n\n    /**\n     * @notice Mints @param _assets of krAssets for @param _to,\n     * @notice Mints relative @return _shares of wkrAssets\n     */\n    function issue(\n        uint256 _assets,\n        address _to\n    ) public virtual override onlyRole(Role.OPERATOR) returns (uint256 shares) {\n        shares = super.issue(_assets, _to);\n    }\n\n    /**\n     * @notice Burns @param _assets of krAssets from @param _from,\n     * @notice Burns relative @return _shares of wkrAssets\n     */\n    function destroy(\n        uint256 _assets,\n        address _from\n    ) public virtual override onlyRole(Role.OPERATOR) returns (uint256 shares) {\n        shares = super.destroy(_assets, _from);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                            INTERNAL HOOKS LOGIC                            */\n    /* -------------------------------------------------------------------------- */\n\n    function _beforeWithdraw(uint256 assets, uint256 shares) internal virtual override {\n        super._beforeWithdraw(assets, shares);\n    }\n\n    function _afterDeposit(uint256 assets, uint256 shares) internal virtual override {\n        super._afterDeposit(assets, shares);\n    }\n}\n"
    },
    "src/contracts/libs/Arrays.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.14;\n\nimport {Error} from \"./Errors.sol\";\n\n/**\n * @title Library for operations on arrays\n */\nlibrary Arrays {\n    /**\n     * @dev Removes an element by copying the last element to the element to remove's place and removing\n     * the last element.\n     * @param _addresses The address array containing the item to be removed.\n     * @param _elementToRemove The element to be removed.\n     * @param _elementIndex The index of the element to be removed.\n     */\n    function removeAddress(address[] storage _addresses, address _elementToRemove, uint256 _elementIndex) internal {\n        require(_addresses[_elementIndex] == _elementToRemove, Error.ARRAY_OUT_OF_BOUNDS);\n\n        uint256 lastIndex = _addresses.length - 1;\n        // If the index to remove is not the last one, overwrite the element at the index\n        // with the last element.\n        if (_elementIndex != lastIndex) {\n            _addresses[_elementIndex] = _addresses[lastIndex];\n        }\n        // Remove the last element.\n        _addresses.pop();\n    }\n}\n"
    },
    "src/contracts/libs/Authorization.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IGnosisSafeL2} from \"../vendor/gnosis/IGnosisSafeL2.sol\";\nimport {Strings} from \"./Strings.sol\";\nimport {AuthEvent} from \"./Events.sol\";\nimport {EnumerableSet} from \"./EnumerableSet.sol\";\nimport {Error} from \"./Errors.sol\";\nimport {Meta} from \"./Meta.sol\";\nimport {ds} from \"../diamond/DiamondStorage.sol\";\n\n/* solhint-disable state-visibility */\n\n/**\n * @title Shared library for access control\n * @author Kresko\n */\n\n/* -------------------------------------------------------------------------- */\n/*                                    Roles                                   */\n/* -------------------------------------------------------------------------- */\n\nlibrary Role {\n    /// @dev role that grants other roles\n    bytes32 constant DEFAULT_ADMIN = 0x00;\n    /// @dev  keccak256(\"kresko.roles.minter.admin\")\n    bytes32 constant ADMIN = 0xb9dacdf02281f2e98ddbadaaf44db270b3d5a916342df47c59f77937a6bcd5d8;\n    /// @dev keccak256(\"kresko.roles.minter.operator\")\n    bytes32 constant OPERATOR = 0x112e48a576fb3a75acc75d9fcf6e0bc670b27b1dbcd2463502e10e68cf57d6fd;\n    /// @dev keccak256(\"kresko.roles.minter.manager\")\n    bytes32 constant MANAGER = 0x46925e0f0cc76e485772167edccb8dc449d43b23b55fc4e756b063f49099e6a0;\n    /// @dev keccak256(\"kresko.roles.minter.safety.council\")\n    bytes32 constant SAFETY_COUNCIL = 0x9c387ecf1663f9144595993e2c602b45de94bf8ba3a110cb30e3652d79b581c0;\n}\n\nlibrary Authorization {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    function hasRole(bytes32 role, address account) internal view returns (bool) {\n        return ds()._roles[role].members[account];\n    }\n\n    function getRoleMemberCount(bytes32 role) internal view returns (uint256) {\n        return ds()._roleMembers[role].length();\n    }\n\n    /**\n     * @dev Revert with a standard message if `Meta.msgSender` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function checkRole(bytes32 role) internal view {\n        _checkRole(role, Meta.msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) internal view returns (bytes32) {\n        return ds()._roles[role].adminRole;\n    }\n\n    function getRoleMember(bytes32 role, uint256 index) internal view returns (address) {\n        return ds()._roleMembers[role].at(index);\n    }\n\n    /**\n     * @notice Checks if the target contract implements the ERC165 interfaceId for the multisig.\n     *\n     */\n    function setupSecurityCouncil(address _councilAddress) internal {\n        require(getRoleMemberCount(Role.SAFETY_COUNCIL) == 0, Error.SAFETY_COUNCIL_EXISTS);\n        require(IGnosisSafeL2(_councilAddress).isOwner(msg.sender), Error.ADDRESS_INVALID_SAFETY_COUNCIL);\n\n        ds()._roles[Role.SAFETY_COUNCIL].members[_councilAddress] = true;\n        ds()._roleMembers[Role.SAFETY_COUNCIL].add(_councilAddress);\n\n        emit AuthEvent.RoleGranted(Role.SAFETY_COUNCIL, _councilAddress, Meta.msgSender());\n    }\n\n    function transferSecurityCouncil(address _newCouncil) internal {\n        hasRole(Role.SAFETY_COUNCIL, msg.sender);\n        require(IGnosisSafeL2(_newCouncil).getOwners().length >= 5, Error.MULTISIG_NOT_ENOUGH_OWNERS);\n\n        // As this is called by the multisig - just check that it's not an EOA\n        ds()._roles[Role.SAFETY_COUNCIL].members[msg.sender] = false;\n        ds()._roleMembers[Role.SAFETY_COUNCIL].remove(msg.sender);\n\n        ds()._roles[Role.SAFETY_COUNCIL].members[_newCouncil] = true;\n        ds()._roleMembers[Role.SAFETY_COUNCIL].add(_newCouncil);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) internal {\n        checkRole(getRoleAdmin(role));\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) internal {\n        checkRole(getRoleAdmin(role));\n        _revokeRole(role, account);\n        ds()._roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function _renounceRole(bytes32 role, address account) internal {\n        require(account == Meta.msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        ds()._roles[role].adminRole = adminRole;\n        emit AuthEvent.RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * @notice Cannot grant the role `SAFETY_COUNCIL` - must be done via explicit function.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal ensureNotSafetyCouncil(role) {\n        if (!hasRole(role, account)) {\n            ds()._roles[role].members[account] = true;\n            ds()._roleMembers[role].add(account);\n            emit AuthEvent.RoleGranted(role, account, Meta.msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal {\n        if (hasRole(role, account)) {\n            ds()._roles[role].members[account] = false;\n            ds()._roleMembers[role].remove(account);\n            emit AuthEvent.RoleRevoked(role, account, Meta.msgSender());\n        }\n    }\n\n    /**\n     * @dev Ensure we use the explicit `grantSafetyCouncilRole` function.\n     */\n    modifier ensureNotSafetyCouncil(bytes32 role) {\n        require(role != Role.SAFETY_COUNCIL, Error.ADDRESS_INVALID_SAFETY_COUNCIL);\n        _;\n    }\n}\n"
    },
    "src/contracts/libs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity >=0.8.14;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "src/contracts/libs/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity <0.9.0;\n\n/* solhint-disable max-line-length */\n\n/**\n * @author Kresko\n * @title Error codes\n * @notice Kresko-specific revert return values and their explanation\n * @dev First number indicates the domain for the error\n */\nlibrary Error {\n    /* -------------------------------------------------------------------------- */\n    /*                                    Diamond                                 */\n    /* -------------------------------------------------------------------------- */\n\n    // Preserve readability for the diamond proxy\n    string public constant DIAMOND_INVALID_FUNCTION_SIGNATURE = \"krDiamond: function does not exist\";\n    string public constant DIAMOND_INVALID_PENDING_OWNER = \"krDiamond: Must be pending contract owner\";\n    string public constant DIAMOND_INVALID_OWNER = \"krDiamond: Must be diamond owner\";\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   1. General                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant NOT_OWNER = \"100\"; // The sender must be owner\n    string public constant NOT_OPERATOR = \"101\"; // The sender must be operator\n    string public constant ZERO_WITHDRAW = \"102\"; // Withdraw must be greater than 0\n    string public constant ZERO_DEPOSIT = \"103\"; // Deposit must be greater than 0\n    string public constant ZERO_ADDRESS = \"104\"; // Address provided cannot be address(0)\n    string public constant ALREADY_INITIALIZED = \"105\"; // Contract has already been initialized\n    string public constant RE_ENTRANCY = \"106\"; // Function does not allow re-entrant calls\n    string public constant NOT_ENOUGH_BALANCE = \"107\"; // Transfer of rebasing token exceeds value\n    string public constant NOT_ENOUGH_ALLOWANCE = \"108\"; // TransferFrom of rebasing token exceeds allowance\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   2. Minter                                 */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant NOT_LIQUIDATABLE = \"200\"; // Account has collateral deposits exceeding minCollateralValue\n    string public constant ZERO_MINT = \"201\"; // Mint amount must be greater than 0\n    string public constant ZERO_BURN = \"202\"; // Burn amount must be greater than 0\n    string public constant ADDRESS_INVALID_ORACLE = \"203\"; // Oracle address cant be set to address(0)\n    string public constant ADDRESS_INVALID_NRWT = \"204\"; // Underlying rebasing token address cant be set to address(0)\n    string public constant ADDRESS_INVALID_FEERECIPIENT = \"205\"; // Fee recipient address cant be set to address(0)\n    string public constant ADDRESS_INVALID_COLLATERAL = \"206\"; // Collateral address cant be set to address(0)\n    string public constant COLLATERAL_EXISTS = \"207\"; // Collateral has already been added into the protocol\n    string public constant COLLATERAL_INVALID_FACTOR = \"208\"; // cFactor must be greater than 1FP\n    string public constant COLLATERAL_WITHDRAW_OVERFLOW = \"209\"; // Withdraw amount cannot reduce accounts collateral value under minCollateralValue\n    string public constant KRASSET_INVALID_FACTOR = \"210\"; // kFactor must be greater than 1FP\n    string public constant KRASSET_BURN_AMOUNT_OVERFLOW = \"211\"; // Repaying more than account has debt\n    string public constant KRASSET_EXISTS = \"212\"; // KrAsset is already added\n    string public constant PARAM_CLOSE_FEE_TOO_HIGH = \"213\"; // \"Close fee exceeds MAX_CLOSE_FEE\"\n    string public constant PARAM_LIQUIDATION_INCENTIVE_LOW = \"214\"; // \"Liquidation incentive less than MIN_LIQUIDATION_INCENTIVE_MULTIPLIER\"\n    string public constant PARAM_LIQUIDATION_INCENTIVE_HIGH = \"215\"; // \"Liquidation incentive greater than MAX_LIQUIDATION_INCENTIVE_MULTIPLIER\"\n    string public constant PARAM_MIN_COLLATERAL_RATIO_LOW = \"216\"; // Minimum collateral ratio less than MIN_COLLATERALIZATION_RATIO\n    string public constant PARAM_MIN_DEBT_AMOUNT_HIGH = \"217\"; // Minimum debt param argument exceeds MAX_MIN_DEBT_VALUE\n    string public constant COLLATERAL_DOESNT_EXIST = \"218\"; // Collateral does not exist within the protocol\n    string public constant KRASSET_DOESNT_EXIST = \"219\"; // KrAsset does not exist within the protocol\n    string public constant KRASSET_NOT_MINTABLE = \"220\"; // KrAsset is not mintable\n    string public constant KRASSET_SYMBOL_EXISTS = \"221\"; // KrAsset with this symbol is already within the protocl\n    string public constant KRASSET_COLLATERAL_LOW = \"222\"; // Collateral deposits do not cover the amount being minted\n    string public constant KRASSET_MINT_AMOUNT_LOW = \"223\"; // Debt position must be greater than the minimum debt position value\n    string public constant KRASSET_MAX_SUPPLY_REACHED = \"224\"; // KrAsset being minted has reached its current supply limit\n    string public constant SELF_LIQUIDATION = \"225\"; // Account cannot liquidate itself\n    string public constant ZERO_REPAY = \"226\"; // Cannot liquidate zero value\n    string public constant STALE_PRICE = \"227\"; // Price for the asset is stale\n    string public constant LIQUIDATION_OVERFLOW = \"228\"; // Repaying more USD value than allowed\n    string public constant ADDRESS_INVALID_SAFETY_COUNCIL = \"229\"; // Account responsible for the safety council role must be a multisig\n    string public constant SAFETY_COUNCIL_EXISTS = \"230\"; // Only one council role can exist\n    string public constant NOT_SAFETY_COUNCIL = \"231\"; // Sender must have the role `Role.SAFETY_COUNCIL`\n    string public constant ACTION_PAUSED_FOR_ASSET = \"232\"; // This action is currently paused for this asset\n    string public constant INVALID_ASSET_SUPPLIED = \"233\"; // Asset supplied is not a collateral nor a krAsset\n    string public constant KRASSET_NOT_ANCHOR = \"234\"; // Address is not the anchor for the krAsset\n    string public constant INVALID_LT = \"235\"; // Liquidation threshold is greater than minimum collateralization ratio\n    string public constant COLLATERAL_INSUFFICIENT_AMOUNT = \"236\"; // Insufficient amount of collateral to complete the operation\n    string public constant MULTISIG_NOT_ENOUGH_OWNERS = \"237\"; // Multisig has invalid amount of owners\n    string public constant PARAM_OPEN_FEE_TOO_HIGH = \"238\"; // \"Close fee exceeds MAX_OPEN_FEE\"\n    string public constant INVALID_FEE_TYPE = \"239\"; // \"Invalid fee type\n    string public constant KRASSET_INVALID_ANCHOR = \"240\"; // krAsset anchor does not support the correct interfaceId\n    string public constant KRASSET_INVALID_CONTRACT = \"241\"; // krAsset does not support the correct interfaceId\n    string public constant KRASSET_MARKET_CLOSED = \"242\"; // KrAsset's market is currently closed\n    string public constant NO_KRASSETS_MINTED = \"243\"; // Account has no active KreskoAsset positions\n    string public constant NO_COLLATERAL_DEPOSITS = \"244\"; // Account has no active Collateral deposits\n    string public constant INVALID_ORACLE_DECIMALS = \"245\"; // Oracle decimals do not match extOracleDecimals\n    string public constant PARAM_LIQUIDATION_OVERFLOW_LOW = \"246\"; // Liquidation overflow is less than MIN_LIQUIDATION_OVERFLOW\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   3. Staking                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant REWARD_PER_BLOCK_MISSING = \"300\"; // Each reward token must have a reward per block value\n    string public constant REWARD_TOKENS_MISSING = \"301\"; // Pool must include an array of reward token addresses\n    string public constant POOL_EXISTS = \"302\"; // Pool with this deposit token already exists\n    string public constant POOL_DOESNT_EXIST = \"303\"; // Pool with this deposit token does not exist\n    string public constant ADDRESS_INVALID_REWARD_RECIPIENT = \"304\"; // Reward recipient cant be address(0)\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   4. Libraries                             */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant ARRAY_OUT_OF_BOUNDS = \"400\"; // Array out of bounds error\n    string public constant PRICEFEEDS_MUST_MATCH_STATUS_FEEDS = \"401\"; // Supplied price feeds must match status feeds in length\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   5. KrAsset                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant REBASING_DENOMINATOR_LOW = \"500\"; // denominator of rebases must be >= 1\n    string public constant ISSUER_NOT_KRESKO = \"501\"; // issue must be done by kresko\n    string public constant REDEEMER_NOT_KRESKO = \"502\"; // redeem must be done by kresko\n    string public constant DESTROY_OVERFLOW = \"503\"; // trying to destroy more than allowed\n    string public constant ISSUE_OVERFLOW = \"504\"; // trying to destroy more than allowed\n    string public constant MINT_OVERFLOW = \"505\"; // trying to destroy more than allowed\n    string public constant DEPOSIT_OVERFLOW = \"506\"; // trying to destroy more than allowed\n    string public constant REDEEM_OVERFLOW = \"507\"; // trying to destroy more than allowed\n    string public constant WITHDRAW_OVERFLOW = \"508\"; // trying to destroy more than allowed\n    string public constant ZERO_SHARES = \"509\"; // amount of shares must be greater than 0\n    string public constant ZERO_ASSETS = \"510\"; // amount of assets must be greater than 0\n    string public constant INVALID_SCALED_AMOUNT = \"511\"; // amount of debt scaled must be greater than 0\n\n    /* -------------------------------------------------------------------------- */\n    /*                              6. STABILITY RATES                            */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant STABILITY_RATES_ALREADY_INITIALIZED = \"601\"; // stability rates for the asset are already initialized\n    string public constant INVALID_OPTIMAL_RATE = \"602\"; // the optimal price rate configured is less than 1e27 for the asset\n    string public constant INVALID_PRICE_RATE_DELTA = \"603\"; // the price rate delta configured is less than 1e27 for the asset\n    string public constant STABILITY_RATES_NOT_INITIALIZED = \"604\"; // the stability rates for the asset are not initialized\n    string public constant STABILITY_RATE_OVERFLOW = \"605\"; // the stability rates is > max uint128\n    string public constant DEBT_INDEX_OVERFLOW = \"606\"; // the debt index is > max uint128\n    string public constant KISS_NOT_SET = \"607\"; // the debt index is > max uint128\n    string public constant STABILITY_RATE_REPAYMENT_AMOUNT_ZERO = \"608\"; // interest being repaid cannot be 0\n    string public constant STABILITY_RATE_INTEREST_IS_ZERO = \"609\"; // account must have accrued interest to repay it\n    string public constant INTEREST_REPAY_NOT_PARTIAL = \"610\"; // account must have accrued interest to repay it\n\n    /* -------------------------------------------------------------------------- */\n    /*                              7. AMM ORACLE                                 */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant PAIR_ADDRESS_IS_ZERO = \"701\"; // Pair address to configure cannot be zero\n    string public constant INVALID_UPDATE_PERIOD = \"702\"; // Update period must be greater than the minimum\n    string public constant PAIR_ALREADY_EXISTS = \"703\"; // Pair with the address is already initialized\n    string public constant PAIR_DOES_NOT_EXIST = \"704\"; // Pair supplied does not exist\n    string public constant INVALID_LIQUIDITY = \"706\"; // Pair initializaition requires that the pair has liquidity\n    string public constant UPDATE_PERIOD_NOT_FINISHED = \"707\"; // Update can only be called once per update period\n    string public constant INVALID_PAIR = \"708\"; // Pair being consulted does not have the token that the price was requested for\n    string public constant CALLER_NOT_ADMIN = \"709\"; // Caller must be the admin\n    string public constant CONSTRUCTOR_INVALID_ADMIN = \"710\"; // Admin cannot be zero address in the constructor\n    string public constant CONSTRUCTOR_INVALID_FACTORY = \"711\"; // Factory cannot be the zero address\n    string public constant NO_INCENTIVES_LEFT = \"712\"; // No incentives left for updating the price\n\n    /* -------------------------------------------------------------------------- */\n    /*                              8. KISS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant OPERATOR_WAIT_PERIOD_NOT_OVER = \"800\"; // Operator role has a cooldown period which has not passed\n    string public constant OPERATOR_LIMIT_REACHED = \"801\"; // More minters cannot be assigned before existing one is removed\n    string public constant CALLER_NOT_CONTRACT = \"802\"; // Caller of the function must be a contract\n    string public constant OPERATOR_NOT_CONTRACT = \"803\"; // Operator role can only be granted to a contract\n    string public constant KRESKO_NOT_CONTRACT = \"804\"; // Operator role can only be granted to a contract\n    string public constant ADMIN_NOT_A_CONTRACT = \"805\"; // Operator role can only be granted to a contract\n    string public constant OPERATOR_WAIT_PERIOD_TOO_SHORT = \"806\"; // Operator assignment cooldown period must be greater than 15 minutes\n}\n"
    },
    "src/contracts/libs/Events.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {IDiamondCutFacet} from \"../diamond/interfaces/IDiamondCutFacet.sol\";\nimport {Action} from \"../minter/MinterTypes.sol\";\n\n/* solhint-disable var-name-mixedcase */\n\n/**\n * @author Kresko\n * @title Events\n * @notice Event definitions\n */\n\nlibrary GeneralEvent {\n    /**\n     * @dev Triggered when the contract has been deployed\n     */\n    event Deployed(address indexed owner, uint8 version);\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(address indexed operator, uint8 version);\n}\n\nlibrary DiamondEvent {\n    event DiamondCut(IDiamondCutFacet.FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n\nlibrary MinterEvent {\n    /* -------------------------------------------------------------------------- */\n    /*                                 Collateral                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Emitted when a collateral asset is added to the protocol.\n     * @dev Can only be emitted once for a given collateral asset.\n     * @param collateralAsset The address of the collateral asset.\n     * @param factor The collateral factor.\n     * @param oracle The address of the oracle.\n     * @param marketStatusOracle The address of the market status oracle.\n     */\n    event CollateralAssetAdded(\n        address indexed collateralAsset,\n        uint256 factor,\n        address indexed oracle,\n        address indexed marketStatusOracle,\n        address anchor\n    );\n\n    /**\n     * @notice Emitted when a collateral asset is updated.\n     * @param collateralAsset The address of the collateral asset.\n     * @param factor The collateral factor.\n     * @param oracle The oracle address.\n     * @param marketStatusOracle The address of the market status oracle.\n     */\n    event CollateralAssetUpdated(\n        address indexed collateralAsset,\n        uint256 factor,\n        address indexed oracle,\n        address indexed marketStatusOracle,\n        address anchor\n    );\n\n    /**\n     * @notice Emitted when an account deposits collateral.\n     * @param account The address of the account depositing collateral.\n     * @param collateralAsset The address of the collateral asset.\n     * @param amount The amount of the collateral asset that was deposited.\n     */\n    event CollateralDeposited(address indexed account, address indexed collateralAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when an account withdraws collateral.\n     * @param account The address of the account withdrawing collateral.\n     * @param collateralAsset The address of the collateral asset.\n     * @param amount The amount of the collateral asset that was withdrawn.\n     */\n    event CollateralWithdrawn(address indexed account, address indexed collateralAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when AMM helper withdraws account collateral without MCR checks.\n     * @param account The address of the account withdrawing collateral.\n     * @param collateralAsset The address of the collateral asset.\n     * @param amount The amount of the collateral asset that was withdrawn.\n     */\n    event UncheckedCollateralWithdrawn(address indexed account, address indexed collateralAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when AMM oracle is set.\n     * @param ammOracle The address of the AMM oracle.\n     */\n    event AMMOracleUpdated(address indexed ammOracle);\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Kresko Assets                               */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Emitted when a KreskoAsset is added to the protocol.\n     * @dev Can only be emitted once for a given Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param anchor anchor token\n     * @param kFactor The k-factor.\n     * @param oracle The address of the oracle.\n     * @param marketStatusOracle The address of the market status oracle.\n     * @param supplyLimit The total supply limit.\n     * @param closeFee The close fee percentage.\n     * @param openFee The open fee percentage.\n     */\n    event KreskoAssetAdded(\n        address indexed kreskoAsset,\n        address anchor,\n        address indexed oracle,\n        address indexed marketStatusOracle,\n        uint256 kFactor,\n        uint256 supplyLimit,\n        uint256 closeFee,\n        uint256 openFee\n    );\n\n    /**\n     * @notice Emitted when a Kresko asset's oracle is updated.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param kFactor The k-factor.\n     * @param oracle The address of the oracle.\n     * @param marketStatusOracle The address of the market status oracle.\n     * @param supplyLimit The total supply limit.\n     * @param closeFee The close fee percentage.\n     * @param openFee The open fee percentage.\n     */\n    event KreskoAssetUpdated(\n        address indexed kreskoAsset,\n        address anchor,\n        address indexed oracle,\n        address indexed marketStatusOracle,\n        uint256 kFactor,\n        uint256 supplyLimit,\n        uint256 closeFee,\n        uint256 openFee\n    );\n\n    /**\n     * @notice Emitted when an account mints a Kresko asset.\n     * @param account The address of the account minting the Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param amount The amount of the KreskoAsset that was minted.\n     */\n    event KreskoAssetMinted(address indexed account, address indexed kreskoAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when an account burns a Kresko asset.\n     * @param account The address of the account burning the Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param amount The amount of the KreskoAsset that was burned.\n     */\n    event KreskoAssetBurned(address indexed account, address indexed kreskoAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when an account burns a Kresko asset.\n     * @param account The address of the account burning the Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param amount The amount of the KreskoAsset that was burned.\n     * @param interestRepaid The amount of the KISS repaid due to interest accrual\n     */\n    event DebtPositionClosed(\n        address indexed account,\n        address indexed kreskoAsset,\n        uint256 amount,\n        uint256 interestRepaid\n    );\n\n    /**\n     * @notice Emitted when cFactor is updated for a collateral asset.\n     * @param collateralAsset The address of the collateral asset.\n     * @param cFactor The new cFactor\n     */\n    event CFactorUpdated(address indexed collateralAsset, uint256 cFactor);\n    /**\n     * @notice Emitted when kFactor is updated for a KreskoAsset.\n     * @param kreskoAsset The address of the KreskoAsset.\n     * @param kFactor The new kFactor\n     */\n    event KFactorUpdated(address indexed kreskoAsset, uint256 kFactor);\n\n    /**\n     * @notice Emitted when an account pays a close fee with a collateral asset upon burning a KreskoAsset.\n     * @dev This can be emitted multiple times for a single KreskoAsset burn.\n     * @param account The address of the account burning the KreskoAsset.\n     * @param paymentCollateralAsset The address of the collateral asset used to pay the close fee.\n     * @param paymentAmount The amount of the payment collateral asset that was paid.\n     * @param paymentValue The USD value of the payment.\n     */\n    event CloseFeePaid(\n        address indexed account,\n        address indexed paymentCollateralAsset,\n        uint256 paymentAmount,\n        uint256 paymentValue\n    );\n\n    /**\n     * @notice Emitted when an account pays an open fee with a collateral asset upon minting a KreskoAsset.\n     * @dev This can be emitted multiple times for a single KreskoAsset mint.\n     * @param account The address of the account minting the KreskoAsset.\n     * @param paymentCollateralAsset The address of the collateral asset used to pay the open fee.\n     * @param paymentAmount The amount of the payment collateral asset that was paid.\n     * @param paymentValue The USD value of the payment.\n     */\n    event OpenFeePaid(\n        address indexed account,\n        address indexed paymentCollateralAsset,\n        uint256 paymentAmount,\n        uint256 paymentValue\n    );\n\n    /**\n     * @notice Emitted when a liquidation occurs.\n     * @param account The address of the account being liquidated.\n     * @param liquidator The account performing the liquidation.\n     * @param repayKreskoAsset The address of the KreskoAsset being paid back to the protocol by the liquidator.\n     * @param repayAmount The amount of the repay KreskoAsset being paid back to the protocol by the liquidator.\n     * @param seizedCollateralAsset The address of the collateral asset being seized from the account by the liquidator.\n     * @param collateralSent The amount of the seized collateral asset being seized from the account by the liquidator.\n     */\n    event LiquidationOccurred(\n        address indexed account,\n        address indexed liquidator,\n        address indexed repayKreskoAsset,\n        uint256 repayAmount,\n        address seizedCollateralAsset,\n        uint256 collateralSent\n    );\n\n    /**\n     * @notice Emitted when a liquidation of interest occurs.\n     * @param account The address of the account being liquidated.\n     * @param liquidator The account performing the liquidation.\n     * @param repayKreskoAsset The address of the KreskoAsset being paid back to the protocol by the liquidator.\n     * @param repayUSD The value of the repay KreskoAsset being paid back to the protocol by the liquidator.\n     * @param seizedCollateralAsset The address of the collateral asset being seized from the account by the liquidator.\n     * @param collateralSent The amount of the seized collateral asset being seized from the account by the liquidator.\n     */\n    event InterestLiquidationOccurred(\n        address indexed account,\n        address indexed liquidator,\n        address indexed repayKreskoAsset,\n        uint256 repayUSD,\n        address seizedCollateralAsset,\n        uint256 collateralSent\n    );\n    /**\n     * @notice Emitted when a batch liquidation of interest occurs.\n     * @param account The address of the account being liquidated.\n     * @param liquidator The account performing the liquidation.\n     * @param seizedCollateralAsset The address of the collateral asset being seized from the account by the liquidator.\n     * @param repayUSD The value of the repay KreskoAsset being paid back to the protocol by the liquidator.\n     * @param collateralSent The amount of the seized collateral asset being seized from the account by the liquidator.\n     */\n    event BatchInterestLiquidationOccurred(\n        address indexed account,\n        address indexed liquidator,\n        address indexed seizedCollateralAsset,\n        uint256 repayUSD,\n        uint256 collateralSent\n    );\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Parameters                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Emitted when a safety state is triggered for an asset\n     * @param action Target action\n     * @param asset Asset affected\n     * @param description change description\n     */\n    event SafetyStateChange(Action indexed action, address indexed asset, string indexed description);\n\n    /**\n     * @notice Emitted when the fee recipient is updated.\n     * @param feeRecipient The new fee recipient.\n     */\n    event FeeRecipientUpdated(address indexed feeRecipient);\n\n    /**\n     * @notice Emitted when the liquidation incentive multiplier is updated.\n     * @param asset The collateral asset being updated.\n     * @param liquidationIncentiveMultiplier The new liquidation incentive multiplier raw value.\n     */\n    event LiquidationIncentiveMultiplierUpdated(address indexed asset, uint256 liquidationIncentiveMultiplier);\n\n    /**\n     * @notice Emitted when the liquidation overflow multiplier is updated.\n     * @param maxLiquidationMultiplier The new liquidation overflow multiplier value.\n     */\n    event maxLiquidationMultiplierUpdated(uint256 maxLiquidationMultiplier);\n\n    /**\n     * @notice Emitted when the minimum collateralization ratio is updated.\n     * @param minimumCollateralizationRatio The new minimum collateralization ratio raw value.\n     */\n    event MinimumCollateralizationRatioUpdated(uint256 minimumCollateralizationRatio);\n\n    /**\n     * @notice Emitted when the minimum debt value updated.\n     * @param minimumDebtValue The new minimum debt value.\n     */\n    event MinimumDebtValueUpdated(uint256 minimumDebtValue);\n\n    /**\n     * @notice Emitted when the liquidation threshold value is updated\n     * @param liquidationThreshold The new liquidation threshold value.\n     */\n    event LiquidationThresholdUpdated(uint256 liquidationThreshold);\n}\n\nlibrary StakingEvent {\n    event LiquidityAndStakeAdded(address indexed to, uint256 indexed amount, uint256 indexed pid);\n    event LiquidityAndStakeRemoved(address indexed to, uint256 indexed amount, uint256 indexed pid);\n    event Deposit(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event ClaimRewards(address indexed user, address indexed rewardToken, uint256 indexed amount);\n    event ClaimRewardsMulti(address indexed to);\n}\n\nlibrary AuthEvent {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event PendingOwnershipTransfer(address indexed previousOwner, address indexed newOwner);\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n}\n\nlibrary InterestRateEvent {\n    /**\n     * @dev Emitted when @param account repaid their @param asset interest @param value\n     */\n    event StabilityRateConfigured(\n        address indexed asset,\n        uint256 stabilityRateBase,\n        uint256 priceRateDelta,\n        uint256 rateSlope1,\n        uint256 rateSlope2\n    );\n    /**\n     * @dev Emitted when @param account repaid their @param asset interest @param value\n     */\n    event StabilityRateInterestRepaid(address indexed account, address indexed asset, uint256 value);\n    /**\n     * @dev Emitted when @param account repaid all interest @param value\n     */\n    event StabilityRateInterestBatchRepaid(address indexed account, uint256 value);\n\n    /**\n     * @notice Emitted when KISS address is set.\n     * @param KISS The address of KISS.\n     */\n    event KISSUpdated(address indexed KISS);\n}\n"
    },
    "src/contracts/libs/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.14;\n\nimport {SafeMathUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport {SignedSafeMathUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SignedSafeMathUpgradeable.sol\";\n\n/* solhint-disable  func-name-mixedcase */\n\n/**\n * @title Library for fixed point arithmetic on uints\n */\n\nlibrary FixedPoint {\n    using SafeMathUpgradeable for uint256;\n    using SignedSafeMathUpgradeable for int256;\n\n    uint256 internal constant FP_DECIMALS = 18;\n    uint256 internal constant FP_SCALING_FACTOR = 10 ** FP_DECIMALS;\n    int256 internal constant SFP_SCALING_FACTOR = 10 ** 18;\n\n    struct Unsigned {\n        uint256 rawValue;\n    }\n\n    struct Signed {\n        int256 rawValue;\n    }\n\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n    // For unsigned values:\n    //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\n\n    // --------------------------------------- UNSIGNED ---------------------------------------------------------------\n\n    /**\n     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5*(10**18)`.\n     * @param a uint to convert into a FixedPoint.\n     * @return the converted FixedPoint.\n     */\n    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if equal, or False.\n     */\n    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue == fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if equal, or False.\n     */\n    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue == b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue > fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue >= fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue < fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue <= fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice The minimum of `a` and `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the minimum of `a` and `b`.\n     */\n    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return a.rawValue < b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice The maximum of `a` and `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the maximum of `a` and `b`.\n     */\n    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return a.rawValue > b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice Adds two `Unsigned`s, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.add(b.rawValue));\n    }\n\n    /**\n     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return add(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Subtracts two `Unsigned`s, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.sub(b.rawValue));\n    }\n\n    /**\n     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return sub(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return sub(fromUnscaledUint(a), b);\n    }\n\n    /**\n     * @notice Multiplies two `Unsigned`s, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        // There are two caveats with this computation:\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n        // stored internally as a uint256 ~10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n        // would round to 3, but this computation produces the result 2.\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\n        return Unsigned((a.rawValue * b.rawValue) / FP_SCALING_FACTOR);\n    }\n\n    /**\n     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue * b);\n    }\n\n    /**\n     * @notice Multiplies two `Unsigned`s and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        uint256 mulRaw = a.rawValue.mul(b.rawValue);\n        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\n        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\n        if (mod != 0) {\n            return Unsigned(mulFloor.add(1));\n        } else {\n            return Unsigned(mulFloor);\n        }\n    }\n\n    /**\n     * @notice Multiplies an `Unsigned` and an unscaled uint256 and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the product of `a` and `b`.\n     */\n    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\n        return Unsigned(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        // There are two caveats with this computation:\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n        // 10^41 is stored internally as a uint256 10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n        return Unsigned((a.rawValue * FP_SCALING_FACTOR).div(b.rawValue));\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.div(b));\n    }\n\n    /**\n     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a uint256 numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return div(fromUnscaledUint(a), b);\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an `Unsigned` and \"ceil's\" the quotient, reverting on overflow or\n     * division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\n        uint256 divFloor = aScaled.div(b.rawValue);\n        uint256 mod = aScaled.mod(b.rawValue);\n        if (mod != 0) {\n            return Unsigned(divFloor.add(1));\n        } else {\n            return Unsigned(divFloor);\n        }\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an unscaled uint256 and \"ceil's\" the quotient, reverting on overflow or\n     * division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        // Because it is possible that a quotient gets truncated, we can't just call \"Unsigned(a.rawValue.div(b))\"\n        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\n        // This creates the possibility of overflow if b is very large.\n        return divCeil(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n     * @dev This will \"floor\" the result.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return output is `a` to the power of `b`.\n     */\n    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\n        output = fromUnscaledUint(1);\n        for (uint256 i = 0; i < b; i = i.add(1)) {\n            output = mul(output, a);\n        }\n    }\n\n    // ------------------------------------------------- SIGNED ------------------------------------------------------\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n    // For signed values:\n    //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored\n    //   internally as int256 10^76.\n\n    function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\n        require(a.rawValue >= 0, \"Negative value provided\");\n        return Unsigned(uint256(a.rawValue));\n    }\n\n    function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\n        require(a.rawValue <= uint256(type(int256).max), \"Unsigned too large\");\n        return Signed(int256(a.rawValue));\n    }\n\n    /**\n     * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5*(10**18)`.\n     * @param a int to convert into a FixedPoint.Signed.\n     * @return the converted FixedPoint.Signed.\n     */\n    function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\n        return Signed(a.mul(SFP_SCALING_FACTOR));\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a int256.\n     * @return True if equal, or False.\n     */\n    function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue == fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if equal, or False.\n     */\n    function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue == b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue > fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue >= fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue < fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue <= fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice The minimum of `a` and `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the minimum of `a` and `b`.\n     */\n    function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return a.rawValue < b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice The maximum of `a` and `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the maximum of `a` and `b`.\n     */\n    function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return a.rawValue > b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice Adds two `Signed`s, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.add(b.rawValue));\n    }\n\n    /**\n     * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return add(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Subtracts two `Signed`s, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.sub(b.rawValue));\n    }\n\n    /**\n     * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return sub(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\n        return sub(fromUnscaledInt(a), b);\n    }\n\n    /**\n     * @notice Multiplies two `Signed`s, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        // There are two caveats with this computation:\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n        // stored internally as an int256 ~10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n        // would round to 3, but this computation produces the result 2.\n        // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\n        return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\n    }\n\n    /**\n     * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Multiplies two `Signed`s and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        int256 mulRaw = a.rawValue.mul(b.rawValue);\n        int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\n        // Manual mod because SignedSafeMath doesn't support it.\n        int256 mod = mulRaw % SFP_SCALING_FACTOR;\n        if (mod != 0) {\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n            return Signed(mulTowardsZero.add(valueToAdd));\n        } else {\n            return Signed(mulTowardsZero);\n        }\n    }\n\n    /**\n     * @notice Multiplies an `Signed` and an unscaled int256 and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the product of `a` and `b`.\n     */\n    function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\n        return Signed(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        // There are two caveats with this computation:\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n        // 10^41 is stored internally as an int256 10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n        return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\n    }\n\n    /**\n     * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b an int256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.div(b));\n    }\n\n    /**\n     * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a an int256 numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\n        return div(fromUnscaledInt(a), b);\n    }\n\n    /**\n     * @notice Divides one `Signed` by an `Signed` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\n        int256 divTowardsZero = aScaled.div(b.rawValue);\n        // Manual mod because SignedSafeMath doesn't support it.\n        int256 mod = aScaled % b.rawValue;\n        if (mod != 0) {\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n            return Signed(divTowardsZero.add(valueToAdd));\n        } else {\n            return Signed(divTowardsZero);\n        }\n    }\n\n    /**\n     * @notice Divides one `Signed` by an unscaled int256 and \"ceil's\" the quotient, reverting on overflow or\n     * division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b an int256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        // Because it is possible that a quotient gets truncated, we can't just call \"Signed(a.rawValue.div(b))\"\n        // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\n        // This creates the possibility of overflow if b is very large.\n        return divAwayFromZero(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n     * @dev This will \"floor\" the result.\n     * @param a a FixedPoint.Signed.\n     * @param b a uint256 (negative exponents are not allowed).\n     * @return output is `a` to the power of `b`.\n     */\n    function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\n        output = fromUnscaledInt(1);\n        for (uint256 i = 0; i < b; i = i.add(1)) {\n            output = mul(output, a);\n        }\n    }\n\n    // ------------------- Additional Fixed Point math functions specific to Kresko protocol -------------------\n\n    function ONE_HUNDRED_PERCENT() internal pure returns (Unsigned memory) {\n        return FixedPoint.Unsigned(1e18);\n    }\n\n    function ONE_USD() internal pure returns (Unsigned memory) {\n        return FixedPoint.Unsigned(1e18);\n    }\n\n    function toFixedPoint(uint256 value) internal pure returns (Unsigned memory) {\n        return FixedPoint.Unsigned(value);\n    }\n\n    function toFixedPoint(uint128 value) internal pure returns (Unsigned memory) {\n        return FixedPoint.Unsigned(value);\n    }\n\n    function toFixedPoint(int256 value) internal pure returns (Unsigned memory) {\n        return FixedPoint.Unsigned(uint256(value));\n    }\n}\n"
    },
    "src/contracts/libs/Meta.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable no-inline-assembly */\n\npragma solidity >=0.8.14;\n\nlibrary Meta {\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(bytes(\"EIP712Domain(string name,string version,uint256 salt,address verifyingContract)\"));\n\n    function domainSeparator(\n        string memory name,\n        string memory version\n    ) internal view returns (bytes32 domainSeparator_) {\n        domainSeparator_ = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                getChainID(),\n                address(this)\n            )\n        );\n    }\n\n    function getChainID() internal view returns (uint256 id) {\n        assembly {\n            id := chainid()\n        }\n    }\n\n    function msgSender() internal view returns (address sender_) {\n        if (msg.sender == address(this)) {\n            bytes memory array = msg.data;\n            uint256 index = msg.data.length;\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n                sender_ := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n            }\n        } else {\n            sender_ = msg.sender;\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        /// @solidity memory-safe-assembly\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "src/contracts/libs/Percentages.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.10;\n\n/**\n * @title PercentageMath library\n * @author Aave\n * @notice Provides functions to perform percentage calculations\n * @dev Percentages are defined by default with 2 decimals of precision (100.00).\n * The precision is indicated by PERCENTAGE_FACTOR\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n **/\nlibrary Percentages {\n    // Maximum percentage factor (100.00%)\n    uint256 internal constant PERCENTAGE_FACTOR = 1e4;\n\n    // Half percentage factor (50.00%)\n    uint256 internal constant HALF_PERCENTAGE_FACTOR = 0.5e4;\n\n    /**\n     * @notice Executes a percentage multiplication\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param value The value of which the percentage needs to be calculated\n     * @param percentage The percentage of the value to be calculated\n     * @return result value percentmul percentage\n     **/\n    function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256 result) {\n        // to avoid overflow, value <= (type(uint256).max - HALF_PERCENTAGE_FACTOR) / percentage\n        assembly {\n            if iszero(or(iszero(percentage), iszero(gt(value, div(sub(not(0), HALF_PERCENTAGE_FACTOR), percentage))))) {\n                revert(0, 0)\n            }\n\n            result := div(add(mul(value, percentage), HALF_PERCENTAGE_FACTOR), PERCENTAGE_FACTOR)\n        }\n    }\n\n    /**\n     * @notice Executes a percentage division\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param value The value of which the percentage needs to be calculated\n     * @param percentage The percentage of the value to be calculated\n     * @return result value percentdiv percentage\n     **/\n    function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256 result) {\n        // to avoid overflow, value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR\n        assembly {\n            if or(\n                iszero(percentage),\n                iszero(iszero(gt(value, div(sub(not(0), div(percentage, 2)), PERCENTAGE_FACTOR))))\n            ) {\n                revert(0, 0)\n            }\n\n            result := div(add(mul(value, PERCENTAGE_FACTOR), div(percentage, 2)), percentage)\n        }\n    }\n}\n"
    },
    "src/contracts/libs/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity >=0.8.14;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "src/contracts/libs/WadRay.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.10;\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @notice Provides functions to perform calculations with Wad and Ray units\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\n * with 27 digits of precision)\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n **/\nlibrary WadRay {\n    // HALF_WAD and HALF_RAY expressed with extended notation\n    // as constant with operations are not supported in Yul assembly\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant HALF_WAD = 0.5e18;\n\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant HALF_RAY = 0.5e27;\n\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n    /**\n     * @dev Multiplies two wad, rounding half up to the nearest wad\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @param b Wad\n     * @return c = a*b, in wad\n     **/\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\n        assembly {\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, b), HALF_WAD), WAD)\n        }\n    }\n\n    /**\n     * @dev Divides two wad, rounding half up to the nearest wad\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @param b Wad\n     * @return c = a/b, in wad\n     **/\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\n        assembly {\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, WAD), div(b, 2)), b)\n        }\n    }\n\n    /**\n     * @notice Multiplies two ray, rounding half up to the nearest ray\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @param b Ray\n     * @return c = a raymul b\n     **/\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\n        assembly {\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, b), HALF_RAY), RAY)\n        }\n    }\n\n    /**\n     * @notice Divides two ray, rounding half up to the nearest ray\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @param b Ray\n     * @return c = a raydiv b\n     **/\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\n        assembly {\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, RAY), div(b, 2)), b)\n        }\n    }\n\n    /**\n     * @dev Casts ray down to wad\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @return b = a converted to wad, rounded half up to the nearest wad\n     **/\n    function rayToWad(uint256 a) internal pure returns (uint256 b) {\n        assembly {\n            b := div(a, WAD_RAY_RATIO)\n            let remainder := mod(a, WAD_RAY_RATIO)\n            if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\n                b := add(b, 1)\n            }\n        }\n    }\n\n    /**\n     * @dev Converts wad up to ray\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @return b = a converted in ray\n     **/\n    function wadToRay(uint256 a) internal pure returns (uint256 b) {\n        // to avoid overflow, b/WAD_RAY_RATIO == a\n        assembly {\n            b := mul(a, WAD_RAY_RATIO)\n\n            if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/minter/facets/AccountStateFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IAccountStateFacet} from \"../interfaces/IAccountStateFacet.sol\";\nimport {Action, Fee, KrAsset, CollateralAsset, FixedPoint} from \"../MinterTypes.sol\";\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/**\n * @author Kresko\n * @title AccountStateFacet\n * @notice Views concerning account state\n */\ncontract AccountStateFacet is IAccountStateFacet {\n    using LibDecimals for uint256;\n    using LibDecimals for uint8;\n    using LibDecimals for FixedPoint.Unsigned;\n    using FixedPoint for FixedPoint.Unsigned;\n    using FixedPoint for int256;\n    using FixedPoint for uint256;\n    using WadRay for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  KrAssets                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IAccountStateFacet\n    function getMintedKreskoAssetsIndex(address _account, address _kreskoAsset) external view returns (uint256) {\n        return ms().getMintedKreskoAssetsIndex(_account, _kreskoAsset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getMintedKreskoAssets(address _account) external view returns (address[] memory) {\n        return ms().mintedKreskoAssets[_account];\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getAccountKrAssetValue(address _account) external view returns (FixedPoint.Unsigned memory) {\n        return ms().getAccountKrAssetValue(_account);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function kreskoAssetDebt(address _account, address _asset) external view returns (uint256) {\n        return ms().getKreskoAssetDebtScaled(_account, _asset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function kreskoAssetDebtPrincipal(address _account, address _asset) external view returns (uint256) {\n        return ms().getKreskoAssetDebtPrincipal(_account, _asset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function kreskoAssetDebtInterest(\n        address _account,\n        address _asset\n    ) external view returns (uint256 assetAmount, uint256 kissAmount) {\n        return ms().getKreskoAssetDebtInterest(_account, _asset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function kreskoAssetDebtInterestTotal(address _account) external view returns (uint256 kissAmount) {\n        address[] memory mintedKreskoAssets = ms().mintedKreskoAssets[_account];\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            (, uint256 kissAmountForAsset) = ms().getKreskoAssetDebtInterest(_account, mintedKreskoAssets[i]);\n            kissAmount += kissAmountForAsset;\n        }\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Collateral                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IAccountStateFacet\n    function getDepositedCollateralAssets(address _account) external view returns (address[] memory) {\n        return ms().depositedCollateralAssets[_account];\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function collateralDeposits(address _account, address _asset) external view returns (uint256) {\n        return ms().getCollateralDeposits(_account, _asset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getDepositedCollateralAssetIndex(\n        address _account,\n        address _collateralAsset\n    ) external view returns (uint256 i) {\n        return ms().getDepositedCollateralAssetIndex(_account, _collateralAsset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getAccountCollateralValue(address _account) public view returns (FixedPoint.Unsigned memory) {\n        return ms().getAccountCollateralValue(_account);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getAccountMinimumCollateralValueAtRatio(\n        address _account,\n        FixedPoint.Unsigned memory _ratio\n    ) public view returns (FixedPoint.Unsigned memory) {\n        return ms().getAccountMinimumCollateralValueAtRatio(_account, _ratio);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getAccountCollateralRatio(address _account) public view returns (FixedPoint.Unsigned memory ratio) {\n        FixedPoint.Unsigned memory collateralValue = ms().getAccountCollateralValue(_account);\n        if (collateralValue.rawValue == 0) {\n            return FixedPoint.Unsigned(0);\n        }\n        FixedPoint.Unsigned memory krAssetValue = ms().getAccountKrAssetValue(_account);\n        if (krAssetValue.rawValue == 0) {\n            return FixedPoint.Unsigned(0);\n        }\n        ratio = collateralValue.div(krAssetValue);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getCollateralAdjustedAndRealValue(\n        address _account,\n        address _asset\n    ) external view returns (FixedPoint.Unsigned memory adjustedValue, FixedPoint.Unsigned memory realValue) {\n        uint256 depositAmount = ms().getCollateralDeposits(_account, _asset);\n        return ms().getCollateralValueAndOraclePrice(_asset, depositAmount, false);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getCollateralRatiosFor(address[] calldata _accounts) external view returns (FixedPoint.Unsigned[] memory) {\n        FixedPoint.Unsigned[] memory ratios = new FixedPoint.Unsigned[](_accounts.length);\n        for (uint256 i; i < _accounts.length; i++) {\n            ratios[i] = getAccountCollateralRatio(_accounts[i]);\n        }\n        return ratios;\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function calcExpectedFee(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kreskoAssetAmount,\n        uint256 _feeType\n    ) external view returns (address[] memory, uint256[] memory) {\n        require(_feeType <= 1, Error.INVALID_FEE_TYPE);\n\n        KrAsset memory krAsset = ms().kreskoAssets[_kreskoAsset];\n\n        // Calculate the value of the fee according to the value of the krAsset\n        uint256 feeValue = krAsset.uintUSD(_kreskoAssetAmount).wadMul(\n            Fee(_feeType) == Fee.Open ? krAsset.openFee.rawValue : krAsset.closeFee.rawValue\n        );\n        // uint256 feeValue = krAsset.fixedPointUSD(_kreskoAssetAmount).mul(\n        //     Fee(_feeType) == Fee.Open ? krAsset.openFee : krAsset.closeFee\n        // );\n\n        address[] memory accountCollateralAssets = ms().depositedCollateralAssets[_account];\n\n        ExpectedFeeRuntimeInfo memory info; // Using ExpectedFeeRuntimeInfo struct to avoid StackTooDeep error\n        info.assets = new address[](accountCollateralAssets.length);\n        info.amounts = new uint256[](accountCollateralAssets.length);\n\n        // Return empty arrays if the fee value is 0.\n        if (feeValue == 0) {\n            return (info.assets, info.amounts);\n        }\n\n        for (uint256 i = accountCollateralAssets.length - 1; i >= 0; i--) {\n            address collateralAssetAddress = accountCollateralAssets[i];\n\n            uint256 depositAmount = ms().getCollateralDeposits(_account, collateralAssetAddress);\n\n            // Don't take the collateral asset's collateral factor into consideration.\n            (FixedPoint.Unsigned memory depositValue, FixedPoint.Unsigned memory oraclePrice) = ms()\n                .getCollateralValueAndOraclePrice(collateralAssetAddress, depositAmount, true);\n\n            uint256 feeValuePaid;\n            uint256 transferAmount;\n            // If feeValue < depositValue, the entire fee can be charged for this collateral asset.\n            if (feeValue < depositValue.rawValue) {\n                transferAmount = ms().collateralAssets[collateralAssetAddress].decimals.fromCollateralFixedPointAmount(\n                    feeValue.wadDiv(oraclePrice.rawValue)\n                );\n                feeValuePaid = feeValue;\n            } else {\n                transferAmount = depositAmount;\n                feeValuePaid = depositValue.rawValue;\n            }\n\n            if (transferAmount > 0) {\n                info.assets[info.collateralTypeCount] = collateralAssetAddress;\n                info.amounts[info.collateralTypeCount] = transferAmount;\n                info.collateralTypeCount = info.collateralTypeCount++;\n            }\n\n            feeValue = feeValue - feeValuePaid;\n            // If the entire fee has been paid, no more action needed.\n            if (feeValue == 0) {\n                return (info.assets, info.amounts);\n            }\n        }\n        return (info.assets, info.amounts);\n    }\n}\n"
    },
    "src/contracts/minter/facets/BurnFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IBurnFacet} from \"../interfaces/IBurnFacet.sol\";\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {DiamondModifiers, MinterModifiers} from \"../../shared/Modifiers.sol\";\nimport {Action, FixedPoint, KrAsset} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title BurnFacet\n * @notice Main end-user functionality concerning burning of kresko assets\n */\ncontract BurnFacet is DiamondModifiers, MinterModifiers, IBurnFacet {\n    using FixedPoint for FixedPoint.Unsigned;\n    using Arrays for address[];\n\n    /**\n     * @notice Burns existing Kresko assets.\n     * @param _account The address to burn kresko assets for\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _burnAmount The amount of the Kresko asset to be burned.\n     * @param _mintedKreskoAssetIndex The index of the collateral asset in the user's minted assets array.\n     * @notice Only needed if burning all principal debt of a particular collateral asset.\n     */\n    function burnKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _burnAmount,\n        uint256 _mintedKreskoAssetIndex\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        require(_burnAmount > 0, Error.ZERO_BURN);\n        MinterState storage s = ms();\n\n        if (s.safetyStateSet) {\n            ensureNotPaused(_kreskoAsset, Action.Repay);\n        }\n\n        // Get accounts principal debt\n        uint256 debtAmount = s.getKreskoAssetDebtPrincipal(_account, _kreskoAsset);\n\n        if (_burnAmount != type(uint256).max) {\n            require(_burnAmount <= debtAmount, Error.KRASSET_BURN_AMOUNT_OVERFLOW);\n            // Ensure principal left is either 0 or >= minDebtValue\n            _burnAmount = s.ensureNotDustPosition(_kreskoAsset, _burnAmount, debtAmount);\n        } else {\n            // _burnAmount of uint256 max, burn all principal debt\n            _burnAmount = debtAmount;\n        }\n\n        // If sender repays all principal debt of asset with no stability rate, remove it from minted assets array.\n        // For assets with stability rate the revomal is done when repaying interest\n        if (irs().srAssets[_kreskoAsset].asset == address(0) && _burnAmount == debtAmount) {\n            s.mintedKreskoAssets[_account].removeAddress(_kreskoAsset, _mintedKreskoAssetIndex);\n        }\n        // Charge the burn fee from collateral of _account\n        s.chargeCloseFee(_account, _kreskoAsset, _burnAmount);\n\n        // Record the burn\n        s.repay(_kreskoAsset, s.kreskoAssets[_kreskoAsset].anchor, _burnAmount, _account);\n\n        // Emit logs\n        emit MinterEvent.KreskoAssetBurned(_account, _kreskoAsset, _burnAmount);\n    }\n}\n"
    },
    "src/contracts/minter/facets/BurnHelperFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {Meta} from \"../../libs/Meta.sol\";\n\nimport {IBurnHelperFacet} from \"../interfaces/IBurnHelperFacet.sol\";\nimport {DiamondModifiers, MinterModifiers} from \"../../shared/Modifiers.sol\";\nimport {Action, FixedPoint} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title BurnHelperFacet\n * @notice Helper functions for reducing positions\n */\ncontract BurnHelperFacet is DiamondModifiers, MinterModifiers, IBurnHelperFacet {\n    using FixedPoint for FixedPoint.Unsigned;\n    using Arrays for address[];\n\n    /**\n     * @notice Burns all Kresko asset debt and repays interest.\n     * @notice Account must have enough of krAsset balance to burn and ennough KISS to cover interest\n     * @param _account The address to close the position for\n     * @param _kreskoAsset The address of the Kresko asset.\n     */\n    function closeKrAssetDebtPosition(\n        address _account,\n        address _kreskoAsset\n    ) public nonReentrant kreskoAssetExists(_kreskoAsset) onlyRoleIf(_account != Meta.msgSender(), Role.MANAGER) {\n        MinterState storage s = ms();\n        if (s.safetyStateSet) {\n            super.ensureNotPaused(_kreskoAsset, Action.Repay);\n        }\n\n        // Get accounts principal debt\n        uint256 principalDebt = s.getKreskoAssetDebtPrincipal(_account, _kreskoAsset);\n        require(principalDebt != 0, Error.ZERO_BURN);\n\n        // Charge the burn fee from collateral of _account\n        s.chargeCloseFee(_account, _kreskoAsset, principalDebt);\n\n        // Record the burn\n        s.repay(_kreskoAsset, s.kreskoAssets[_kreskoAsset].anchor, principalDebt, _account);\n        uint256 kissRepayAmount = ms().repayFullStabilityRateInterest(_account, _kreskoAsset);\n\n        // If all all principal debt of asset with NO stability rate configured\n        // -> remove it from minted assets array.\n        // For assets with stability rate the revomal is done when repaying interest\n        if (irs().srAssets[_kreskoAsset].asset == address(0)) {\n            s.mintedKreskoAssets[_account].removeAddress(\n                _kreskoAsset,\n                ms().getMintedKreskoAssetsIndex(_account, _kreskoAsset)\n            );\n        }\n\n        emit MinterEvent.DebtPositionClosed(_account, _kreskoAsset, principalDebt, kissRepayAmount);\n    }\n\n    /**\n     * @notice Attempts to close all debt positions and interest\n     * @notice Account must have enough of krAsset balance to burn and ennough KISS to cover interest\n     * @param _account The address to close the positions for\n     */\n    function batchCloseKrAssetDebtPositions(\n        address _account\n    ) external onlyRoleIf(_account != Meta.msgSender(), Role.MANAGER) {\n        address[] memory mintedKreskoAssets = ms().getMintedKreskoAssets(_account);\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            closeKrAssetDebtPosition(_account, mintedKreskoAssets[i]);\n        }\n    }\n}\n"
    },
    "src/contracts/minter/facets/ConfigurationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IERC165} from \"../../shared/IERC165.sol\";\nimport {IERC20Upgradeable} from \"../../shared/IERC20Upgradeable.sol\";\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\nimport {IKISS} from \"../../kiss/interfaces/IKISS.sol\";\n\nimport {IConfigurationFacet} from \"../interfaces/IConfigurationFacet.sol\";\n\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent, GeneralEvent} from \"../../libs/Events.sol\";\nimport {Authorization, Role} from \"../../libs/Authorization.sol\";\nimport {Meta} from \"../../libs/Meta.sol\";\n\nimport {DiamondModifiers, MinterModifiers} from \"../../shared/Modifiers.sol\";\n\nimport {ds} from \"../../diamond/DiamondStorage.sol\";\n\n// solhint-disable-next-line\nimport {MinterInitArgs, CollateralAsset, KrAsset, AggregatorV2V3Interface, FixedPoint, Constants} from \"../MinterTypes.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/**\n * @author Kresko\n * @title ConfigurationFacet\n * @notice Functionality for `Role.ADMIN` level actions.\n * @notice Can be only initialized by the deployer/owner.\n */\ncontract ConfigurationFacet is DiamondModifiers, MinterModifiers, IConfigurationFacet {\n    using FixedPoint for FixedPoint.Unsigned;\n    using FixedPoint for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Initialize                                 */\n    /* -------------------------------------------------------------------------- */\n\n    function initialize(MinterInitArgs calldata args) external onlyOwner {\n        require(ms().initializations == 0, Error.ALREADY_INITIALIZED);\n        // Temporarily set ADMIN role for deployer\n        Authorization._grantRole(Role.DEFAULT_ADMIN, msg.sender);\n        Authorization._grantRole(Role.ADMIN, msg.sender);\n\n        // Grant the admin role to admin\n        Authorization._grantRole(Role.DEFAULT_ADMIN, args.admin);\n        Authorization._grantRole(Role.ADMIN, args.admin);\n\n        /**\n         * @notice Council can be set only by this specific function.\n         * Requirements:\n         *\n         * - address `_council` must implement ERC165 and a specific multisig interfaceId.\n         * - reverts if above is not true.\n         */\n        Authorization.setupSecurityCouncil(args.council);\n\n        updateFeeRecipient(args.treasury);\n        updateMinimumCollateralizationRatio(args.minimumCollateralizationRatio);\n        updateMinimumDebtValue(args.minimumDebtValue);\n        updateLiquidationThreshold(args.liquidationThreshold);\n        updateExtOracleDecimals(args.extOracleDecimals);\n        updateMaxLiquidationMultiplier(Constants.MIN_MAX_LIQUIDATION_MULTIPLIER);\n\n        ms().initializations = 1;\n        ms().domainSeparator = Meta.domainSeparator(\"Kresko Minter\", \"V1\");\n        emit GeneralEvent.Initialized(args.admin, 1);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateFeeRecipient(address _feeRecipient) public override onlyRole(Role.ADMIN) {\n        require(_feeRecipient != address(0), Error.ADDRESS_INVALID_FEERECIPIENT);\n        ms().feeRecipient = _feeRecipient;\n        emit MinterEvent.FeeRecipientUpdated(_feeRecipient);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateLiquidationIncentiveMultiplier(\n        address _collateralAsset,\n        uint256 _liquidationIncentiveMultiplier\n    ) public override collateralAssetExists(_collateralAsset) onlyRole(Role.ADMIN) {\n        require(\n            _liquidationIncentiveMultiplier >= Constants.MIN_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_LOW\n        );\n        require(\n            _liquidationIncentiveMultiplier <= Constants.MAX_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_HIGH\n        );\n        ms().collateralAssets[_collateralAsset].liquidationIncentive = _liquidationIncentiveMultiplier.toFixedPoint();\n        emit MinterEvent.LiquidationIncentiveMultiplierUpdated(_collateralAsset, _liquidationIncentiveMultiplier);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateCFactor(\n        address _collateralAsset,\n        uint256 _cFactor\n    ) public override collateralAssetExists(_collateralAsset) onlyRole(Role.ADMIN) {\n        require(_cFactor <= FixedPoint.FP_SCALING_FACTOR, Error.COLLATERAL_INVALID_FACTOR);\n        ms().collateralAssets[_collateralAsset].factor = _cFactor.toFixedPoint();\n        emit MinterEvent.CFactorUpdated(_collateralAsset, _cFactor);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateKFactor(\n        address _kreskoAsset,\n        uint256 _kFactor\n    ) public override kreskoAssetExists(_kreskoAsset) onlyRole(Role.ADMIN) {\n        require(_kFactor >= FixedPoint.FP_SCALING_FACTOR, Error.KRASSET_INVALID_FACTOR);\n        ms().kreskoAssets[_kreskoAsset].kFactor = _kFactor.toFixedPoint();\n        emit MinterEvent.CFactorUpdated(_kreskoAsset, _kFactor);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateMinimumCollateralizationRatio(\n        uint256 _minimumCollateralizationRatio\n    ) public override onlyRole(Role.ADMIN) {\n        require(\n            _minimumCollateralizationRatio >= Constants.MIN_COLLATERALIZATION_RATIO,\n            Error.PARAM_MIN_COLLATERAL_RATIO_LOW\n        );\n        ms().minimumCollateralizationRatio = _minimumCollateralizationRatio.toFixedPoint();\n        emit MinterEvent.MinimumCollateralizationRatioUpdated(_minimumCollateralizationRatio);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateMinimumDebtValue(uint256 _minimumDebtValue) public override onlyRole(Role.ADMIN) {\n        require(_minimumDebtValue <= Constants.MAX_MIN_DEBT_VALUE, Error.PARAM_MIN_DEBT_AMOUNT_HIGH);\n        ms().minimumDebtValue = _minimumDebtValue.toFixedPoint();\n        emit MinterEvent.MinimumDebtValueUpdated(_minimumDebtValue);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateLiquidationThreshold(uint256 _liquidationThreshold) public override onlyRole(Role.ADMIN) {\n        // Liquidation threshold cannot be greater than minimum collateralization ratio\n        FixedPoint.Unsigned memory newThreshold = _liquidationThreshold.toFixedPoint();\n        require(newThreshold.isLessThanOrEqual(ms().minimumCollateralizationRatio), Error.INVALID_LT);\n\n        ms().liquidationThreshold = newThreshold;\n        emit MinterEvent.LiquidationThresholdUpdated(_liquidationThreshold);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateMaxLiquidationMultiplier(uint256 _maxLiquidationMultiplier) public override onlyRole(Role.ADMIN) {\n        require(\n            _maxLiquidationMultiplier >= Constants.MIN_MAX_LIQUIDATION_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_OVERFLOW_LOW\n        );\n        ms().maxLiquidationMultiplier = _maxLiquidationMultiplier.toFixedPoint();\n        emit MinterEvent.maxLiquidationMultiplierUpdated(_maxLiquidationMultiplier);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateAMMOracle(address _ammOracle) external onlyRole(Role.ADMIN) {\n        ms().ammOracle = _ammOracle;\n        emit MinterEvent.AMMOracleUpdated(_ammOracle);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateExtOracleDecimals(uint8 _decimals) public onlyRole(Role.ADMIN) {\n        ms().extOracleDecimals = _decimals;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 COLLATERAL                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IConfigurationFacet\n    function addCollateralAsset(\n        address _collateralAsset,\n        address _anchor,\n        uint256 _factor,\n        uint256 _liquidationIncentiveMultiplier,\n        address _priceFeedOracle,\n        address _marketStatusOracle\n    ) external nonReentrant onlyRole(Role.ADMIN) collateralAssetDoesNotExist(_collateralAsset) {\n        require(_collateralAsset != address(0), Error.ADDRESS_INVALID_COLLATERAL);\n        require(_priceFeedOracle != address(0), Error.ADDRESS_INVALID_ORACLE);\n        require(\n            AggregatorV2V3Interface(_priceFeedOracle).decimals() == ms().extOracleDecimals,\n            Error.INVALID_ORACLE_DECIMALS\n        );\n        require(_factor <= FixedPoint.FP_SCALING_FACTOR, Error.COLLATERAL_INVALID_FACTOR);\n        require(\n            _liquidationIncentiveMultiplier >= Constants.MIN_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_LOW\n        );\n        require(\n            _liquidationIncentiveMultiplier <= Constants.MAX_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_HIGH\n        );\n        bool isKrAsset = ms().kreskoAssets[_collateralAsset].exists;\n        require(\n            !isKrAsset ||\n                (IERC165(_collateralAsset).supportsInterface(type(IKISS).interfaceId)) ||\n                IERC165(_anchor).supportsInterface(type(IKreskoAssetIssuer).interfaceId),\n            Error.KRASSET_INVALID_ANCHOR\n        );\n\n        /* ---------------------------------- Save ---------------------------------- */\n        ms().collateralAssets[_collateralAsset] = CollateralAsset({\n            factor: _factor.toFixedPoint(),\n            oracle: AggregatorV2V3Interface(_priceFeedOracle),\n            liquidationIncentive: _liquidationIncentiveMultiplier.toFixedPoint(),\n            marketStatusOracle: AggregatorV2V3Interface(_marketStatusOracle),\n            anchor: _anchor,\n            exists: true,\n            decimals: IERC20Upgradeable(_collateralAsset).decimals()\n        });\n\n        emit MinterEvent.CollateralAssetAdded(\n            _collateralAsset,\n            _factor,\n            _priceFeedOracle,\n            _marketStatusOracle,\n            _anchor\n        );\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateCollateralAsset(\n        address _collateralAsset,\n        address _anchor,\n        uint256 _factor,\n        uint256 _liquidationIncentiveMultiplier,\n        address _priceFeedOracle,\n        address _marketStatusOracle\n    ) external onlyRole(Role.ADMIN) collateralAssetExists(_collateralAsset) {\n        // Setting the factor to 0 effectively sunsets a collateral asset, which is intentionally allowed.\n        require(_factor <= FixedPoint.FP_SCALING_FACTOR, Error.COLLATERAL_INVALID_FACTOR);\n        require(\n            _liquidationIncentiveMultiplier >= Constants.MIN_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_LOW\n        );\n        require(\n            _liquidationIncentiveMultiplier <= Constants.MAX_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_HIGH\n        );\n\n        /* ------------------------------ Update anchor ----------------------------- */\n        if (_anchor != address(0)) {\n            bool krAsset = ms().kreskoAssets[_collateralAsset].exists;\n            require(\n                !krAsset ||\n                    (IERC165(_collateralAsset).supportsInterface(type(IKISS).interfaceId)) ||\n                    IERC165(_anchor).supportsInterface(type(IKreskoAssetIssuer).interfaceId),\n                Error.KRASSET_INVALID_ANCHOR\n            );\n            ms().collateralAssets[_collateralAsset].anchor = _anchor;\n        }\n\n        /* -------------------------- Market status oracle -------------------------- */\n        if (_marketStatusOracle != address(0)) {\n            ms().collateralAssets[_collateralAsset].marketStatusOracle = AggregatorV2V3Interface(_marketStatusOracle);\n        }\n\n        /* ------------------------------- Price feed ------------------------------- */\n        if (_priceFeedOracle != address(0)) {\n            require(\n                AggregatorV2V3Interface(_priceFeedOracle).decimals() == ms().extOracleDecimals,\n                Error.INVALID_ORACLE_DECIMALS\n            );\n            ms().collateralAssets[_collateralAsset].oracle = AggregatorV2V3Interface(_priceFeedOracle);\n        }\n\n        /* --------------------------------- cFactor -------------------------------- */\n        ms().collateralAssets[_collateralAsset].factor = _factor.toFixedPoint();\n\n        /* ------------------------------ liqIncentive ------------------------------ */\n        ms().collateralAssets[_collateralAsset].liquidationIncentive = _liquidationIncentiveMultiplier.toFixedPoint();\n\n        emit MinterEvent.CollateralAssetUpdated(\n            _collateralAsset,\n            _factor,\n            _priceFeedOracle,\n            _marketStatusOracle,\n            _anchor\n        );\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               Kresko Assets                                */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IConfigurationFacet\n    function addKreskoAsset(\n        address _krAsset,\n        address _anchor,\n        uint256 _kFactor,\n        address _priceFeedOracle,\n        address _marketStatusOracle,\n        uint256 _supplyLimit,\n        uint256 _closeFee,\n        uint256 _openFee\n    ) external onlyRole(Role.ADMIN) kreskoAssetDoesNotExist(_krAsset) {\n        require(_kFactor >= FixedPoint.FP_SCALING_FACTOR, Error.KRASSET_INVALID_FACTOR);\n        require(_priceFeedOracle != address(0), Error.ADDRESS_INVALID_ORACLE);\n        require(_closeFee <= Constants.MAX_CLOSE_FEE, Error.PARAM_CLOSE_FEE_TOO_HIGH);\n        require(_openFee <= Constants.MAX_OPEN_FEE, Error.PARAM_OPEN_FEE_TOO_HIGH);\n        require(\n            IERC165(_krAsset).supportsInterface(type(IKISS).interfaceId) ||\n                IERC165(_krAsset).supportsInterface(type(IKreskoAsset).interfaceId),\n            Error.KRASSET_INVALID_CONTRACT\n        );\n        require(IERC165(_anchor).supportsInterface(type(IKreskoAssetIssuer).interfaceId), Error.KRASSET_INVALID_ANCHOR);\n        // The diamond needs the operator role\n        require(IKreskoAsset(_krAsset).hasRole(Role.OPERATOR, address(this)), Error.NOT_OPERATOR);\n\n        // Oracle decimals must match the configuration.\n        require(\n            AggregatorV2V3Interface(_priceFeedOracle).decimals() == ms().extOracleDecimals,\n            Error.INVALID_ORACLE_DECIMALS\n        );\n\n        /* ---------------------------------- Save ---------------------------------- */\n        ms().kreskoAssets[_krAsset] = KrAsset({\n            kFactor: _kFactor.toFixedPoint(),\n            oracle: AggregatorV2V3Interface(_priceFeedOracle),\n            marketStatusOracle: AggregatorV2V3Interface(_marketStatusOracle),\n            anchor: _anchor,\n            supplyLimit: _supplyLimit,\n            closeFee: _closeFee.toFixedPoint(),\n            openFee: _openFee.toFixedPoint(),\n            exists: true\n        });\n\n        emit MinterEvent.KreskoAssetAdded(\n            _krAsset,\n            _anchor,\n            _priceFeedOracle,\n            _marketStatusOracle,\n            _kFactor,\n            _supplyLimit,\n            _closeFee,\n            _openFee\n        );\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateKreskoAsset(\n        address _krAsset,\n        address _anchor,\n        uint256 _kFactor,\n        address _priceFeedOracle,\n        address _marketStatusOracle,\n        uint256 _supplyLimit,\n        uint256 _closeFee,\n        uint256 _openFee\n    ) external onlyRole(Role.ADMIN) kreskoAssetExists(_krAsset) {\n        require(_kFactor >= FixedPoint.FP_SCALING_FACTOR, Error.KRASSET_INVALID_FACTOR);\n        require(_closeFee <= Constants.MAX_CLOSE_FEE, Error.PARAM_CLOSE_FEE_TOO_HIGH);\n        require(_openFee <= Constants.MAX_OPEN_FEE, Error.PARAM_OPEN_FEE_TOO_HIGH);\n        require(\n            IERC165(_krAsset).supportsInterface(type(IKISS).interfaceId) ||\n                IERC165(_krAsset).supportsInterface(type(IKreskoAsset).interfaceId),\n            Error.KRASSET_INVALID_CONTRACT\n        );\n\n        KrAsset memory krAsset = ms().kreskoAssets[_krAsset];\n\n        /* --------------------------------- Anchor --------------------------------- */\n        if (address(_anchor) != address(0)) {\n            require(\n                IERC165(_anchor).supportsInterface(type(IKreskoAssetIssuer).interfaceId),\n                Error.KRASSET_INVALID_ANCHOR\n            );\n            krAsset.anchor = _anchor;\n        }\n\n        /* ------------------------------ Market status ----------------------------- */\n        if (address(_marketStatusOracle) != address(0)) {\n            krAsset.marketStatusOracle = AggregatorV2V3Interface(_marketStatusOracle);\n        }\n\n        /* ------------------------------- Price feed ------------------------------- */\n        if (address(_priceFeedOracle) != address(0)) {\n            require(\n                AggregatorV2V3Interface(_priceFeedOracle).decimals() == ms().extOracleDecimals,\n                Error.INVALID_ORACLE_DECIMALS\n            );\n            krAsset.oracle = AggregatorV2V3Interface(_priceFeedOracle);\n        }\n\n        /* -------------------------- Factors, Fees, Limits ------------------------- */\n        krAsset.kFactor = _kFactor.toFixedPoint();\n        krAsset.supplyLimit = _supplyLimit;\n        krAsset.closeFee = _closeFee.toFixedPoint();\n        krAsset.openFee = _openFee.toFixedPoint();\n\n        /* ---------------------------------- Save ---------------------------------- */\n        ms().kreskoAssets[_krAsset] = krAsset;\n\n        emit MinterEvent.KreskoAssetUpdated(\n            _krAsset,\n            _anchor,\n            _priceFeedOracle,\n            _marketStatusOracle,\n            _kFactor,\n            _supplyLimit,\n            _closeFee,\n            _openFee\n        );\n    }\n}\n"
    },
    "src/contracts/minter/facets/DepositWithdrawFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IDepositWithdrawFacet} from \"../interfaces/IDepositWithdrawFacet.sol\";\n\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\nimport {Meta} from \"../../libs/Meta.sol\";\n\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"../../shared/SafeERC20Upgradeable.sol\";\nimport {DiamondModifiers, MinterModifiers} from \"../../shared/Modifiers.sol\";\nimport {Action, FixedPoint, KrAsset} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {ICollateralReceiver} from \"../interfaces/ICollateralReceiver.sol\";\n\n/**\n * @author Kresko\n * @title DepositWithdrawFacet\n * @notice Main end-user functionality concerning collateral asset deposits and withdrawals within the Kresko protocol\n */\ncontract DepositWithdrawFacet is DiamondModifiers, MinterModifiers, IDepositWithdrawFacet {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Collateral                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Deposits collateral into the protocol.\n     * @param _account The user to deposit collateral for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _depositAmount The amount of the collateral asset to deposit.\n     */\n    function depositCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _depositAmount\n    ) external nonReentrant collateralAssetExists(_collateralAsset) {\n        if (ms().safetyStateSet) {\n            super.ensureNotPaused(_collateralAsset, Action.Deposit);\n        }\n\n        // Transfer tokens into this contract prior to any state changes as an extra measure against re-entrancy.\n        IERC20Upgradeable(_collateralAsset).safeTransferFrom(Meta.msgSender(), address(this), _depositAmount);\n\n        // Record the collateral deposit.\n        ms().recordCollateralDeposit(_account, _collateralAsset, _depositAmount);\n    }\n\n    /**\n     * @notice Withdraws sender's collateral from the protocol.\n     * @dev Requires that the post-withdrawal collateral value does not violate minimum collateral requirement.\n     * @param _account The address to withdraw assets for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\n     * @param _depositedCollateralAssetIndex The index of the collateral asset in the sender's deposited collateral\n     * assets array. Only needed if withdrawing the entire deposit of a particular collateral asset.\n     */\n    function withdrawCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _depositedCollateralAssetIndex\n    )\n        external\n        nonReentrant\n        collateralAssetExists(_collateralAsset)\n        onlyRoleIf(_account != Meta.msgSender(), Role.MANAGER)\n    {\n        if (ms().safetyStateSet) {\n            ensureNotPaused(_collateralAsset, Action.Withdraw);\n        }\n\n        uint256 collateralDeposits = ms().getCollateralDeposits(_account, _collateralAsset);\n        _withdrawAmount = (_withdrawAmount > collateralDeposits ? collateralDeposits : _withdrawAmount);\n\n        ms().verifyAndRecordCollateralWithdrawal(\n            _account,\n            _collateralAsset,\n            _withdrawAmount,\n            collateralDeposits,\n            _depositedCollateralAssetIndex\n        );\n\n        IERC20Upgradeable(_collateralAsset).safeTransfer(_account, _withdrawAmount);\n    }\n\n    /**\n     * @notice Withdraws sender's collateral from the protocol before checking minimum collateral ratio.\n     * @dev Executes post-withdraw-callback triggering onUncheckedCollateralWithdraw on the caller\n     * @dev Requires that the post-withdraw-callback collateral value does not violate minimum collateral requirement.\n     * @param _account The address to withdraw assets for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\n     * @param _depositedCollateralAssetIndex The index of the collateral asset in the sender's deposited collateral\n     * assets array. Only needed if withdrawing the entire deposit of a particular collateral asset.\n     */\n    function withdrawCollateralUnchecked(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _depositedCollateralAssetIndex,\n        bytes memory _userData\n    ) external collateralAssetExists(_collateralAsset) onlyRole(Role.MANAGER) {\n        if (ms().safetyStateSet) {\n            ensureNotPaused(_collateralAsset, Action.Withdraw);\n        }\n\n        uint256 collateralDeposits = ms().getCollateralDeposits(_account, _collateralAsset);\n        _withdrawAmount = (_withdrawAmount > collateralDeposits ? collateralDeposits : _withdrawAmount);\n\n        // perform unchecked withdrawal\n        ms().recordCollateralWithdrawal(\n            _account,\n            _collateralAsset,\n            _withdrawAmount,\n            collateralDeposits,\n            _depositedCollateralAssetIndex\n        );\n\n        // transfer the withdrawn asset to the caller\n        IERC20Upgradeable(_collateralAsset).safeTransfer(msg.sender, _withdrawAmount);\n\n        // Executes the callback on the caller after sending them the withdrawn collateral\n        ICollateralReceiver(Meta.msgSender()).onUncheckedCollateralWithdraw(\n            _account,\n            _collateralAsset,\n            _withdrawAmount,\n            _depositedCollateralAssetIndex,\n            _userData\n        );\n\n        /*\n         Perform the MCR check after the callback has been executed\n         Ensures accountCollateralValue remains over accountMinColateralValueAtRatio(MCR)\n         Emits MinterEvent.UncheckedCollateralWithdrawn\n         _withdrawAmount is 0 since deposits reduced in recordCollateralWithdrawal\n        */\n        ms().verifyAccountCollateral(_account, _collateralAsset, 0);\n    }\n}\n"
    },
    "src/contracts/minter/facets/InterestLiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IInterestLiquidationFacet} from \"../interfaces/IInterestLiquidationFacet.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibDecimals, FixedPoint} from \"../libs/LibDecimals.sol\";\nimport {LibCalculation} from \"../libs/LibCalculation.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {MinterEvent, InterestRateEvent} from \"../../libs/Events.sol\";\nimport {Meta} from \"../../libs/Meta.sol\";\n\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"../../shared/SafeERC20Upgradeable.sol\";\nimport {DiamondModifiers} from \"../../shared/Modifiers.sol\";\n\nimport {Constants, KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title InterestLiquidationFacet\n * @notice Main end-user functionality concerning liquidations of accrued KISS interest within the Kresko protocol\n */\ncontract InterestLiquidationFacet is DiamondModifiers, IInterestLiquidationFacet {\n    using Arrays for address[];\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n    using FixedPoint for FixedPoint.Unsigned;\n    using FixedPoint for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @notice Attempts to batch liquidate all KISS interest accrued for an account in a unhealthy position\n     * @notice Liquidator must have the KISS balance required with the Kresko contract approved\n     * @notice Checks liquidatable status on each iteration liquidating only what is necessary\n     * @param _account The account to attempt to liquidate.\n     * @param _collateralAssetToSeize The address of the collateral asset to be seized.\n     */\n    function batchLiquidateInterest(address _account, address _collateralAssetToSeize) external nonReentrant {\n        // Borrower cannot liquidate themselves\n        require(Meta.msgSender() != _account, Error.SELF_LIQUIDATION);\n        // Check that this account is below its minimum collateralization ratio and can be liquidated.\n        require(ms().isAccountLiquidatable(_account), Error.NOT_LIQUIDATABLE);\n        // Collateral exists\n        require(ms().collateralAssets[_collateralAssetToSeize].exists, Error.COLLATERAL_DOESNT_EXIST);\n\n        address[] memory mintedKreskoAssets = ms().getMintedKreskoAssets(_account);\n\n        // Loop all accounts minted assets and sum all accrued kiss interest\n        uint256 kissAmountToRepay;\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            address repayKreskoAsset = mintedKreskoAssets[i];\n            // Repays the full interest of this asset on behalf of the account being liquidated\n            kissAmountToRepay += ms().repayFullStabilityRateInterest(_account, repayKreskoAsset);\n            // If the liquidation repays the user's entire Kresko asset balance, remove it from minted assets array.\n            if (ms().kreskoAssetDebt[_account][repayKreskoAsset] == 0) {\n                ms().mintedKreskoAssets[_account].removeAddress(repayKreskoAsset, i);\n            }\n            // Check if the status with amount repaid is still underwater, if so no further liquidation is needed\n            if (\n                !ms().isAccountLiquidatable(\n                    _account,\n                    kissAmountToRepay.fromWadPriceToFixedPoint().mul(\n                        ms().collateralAssets[_collateralAssetToSeize].liquidationIncentive\n                    )\n                )\n            ) break;\n        }\n\n        // Emit a separate event for batch repayment itself\n        emit InterestRateEvent.StabilityRateInterestBatchRepaid(_account, kissAmountToRepay);\n\n        // Seize collateral and send to liquidator according to the repayment made\n        uint256 collateralSeizeAmount = _seizeAndTransferCollateral(\n            _account,\n            _collateralAssetToSeize,\n            ms().getDepositedCollateralAssetIndex(_account, _collateralAssetToSeize),\n            kissAmountToRepay\n        );\n\n        emit MinterEvent.BatchInterestLiquidationOccurred(\n            _account,\n            msg.sender,\n            _collateralAssetToSeize,\n            kissAmountToRepay,\n            collateralSeizeAmount\n        );\n    }\n\n    /**\n     * @notice Attempts to liquidate all KISS interest accrued for an account in a unhealthy position\n     * @notice Liquidator must have the KISS balance required with the Kresko contract approved\n     * @param _account The account to attempt to liquidate.\n     * @param _repayKreskoAsset The address of the Kresko asset to be repaid.\n     * @param _collateralAssetToSeize The address of the collateral asset to be seized.\n     */\n    function liquidateInterest(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize\n    ) external nonReentrant {\n        // Borrower cannot liquidate themselves\n        require(msg.sender != _account, Error.SELF_LIQUIDATION);\n        // krAsset exists\n        require(ms().kreskoAssets[_repayKreskoAsset].exists, Error.KRASSET_DOESNT_EXIST);\n        // Check that this account is below its minimum collateralization ratio and can be liquidated.\n        require(ms().isAccountLiquidatable(_account), Error.NOT_LIQUIDATABLE);\n        // Collateral exists\n        require(ms().collateralAssets[_collateralAssetToSeize].exists, Error.COLLATERAL_DOESNT_EXIST);\n\n        // Repays the full interest of this asset on behalf of the account being liquidated\n        uint256 kissRepayAmount = ms().repayFullStabilityRateInterest(_account, _repayKreskoAsset);\n\n        uint256 mintedKreskoAssetIndex = ms().getMintedKreskoAssetsIndex(_account, _repayKreskoAsset);\n\n        // Seize collateral and send to liquidator according to the repayment made\n        uint256 collateralAmountSeized = _seizeAndTransferCollateral(\n            _account,\n            _collateralAssetToSeize,\n            ms().getDepositedCollateralAssetIndex(_account, _collateralAssetToSeize),\n            kissRepayAmount\n        );\n\n        // If the liquidation repays the user's entire Kresko asset balance, remove it from minted assets array.\n        if (ms().kreskoAssetDebt[_account][_repayKreskoAsset] == 0) {\n            ms().mintedKreskoAssets[_account].removeAddress(_repayKreskoAsset, mintedKreskoAssetIndex);\n        }\n\n        emit MinterEvent.InterestLiquidationOccurred(\n            _account,\n            msg.sender,\n            _repayKreskoAsset,\n            kissRepayAmount, // without the liquidation bonus\n            _collateralAssetToSeize,\n            collateralAmountSeized // with the liquidation bonus\n        );\n    }\n\n    /**\n     * @notice Internal function to perform collateral seizing when interest gets liquidated\n     * @dev\n     * @param _account Account being liquidated\n     * @param _collateralAssetToSeize Collateral asset used to liquidate the debt\n     * @param _depositedCollateralAssetIndex Deposit index for the liquidated accounts collateral\n     * @param _kissRepayAmount Accrued KISS interest value being liquidated\n     */\n    function _seizeAndTransferCollateral(\n        address _account,\n        address _collateralAssetToSeize,\n        uint256 _depositedCollateralAssetIndex,\n        uint256 _kissRepayAmount\n    ) internal returns (uint256 seizeAmount) {\n        MinterState storage s = ms();\n\n        seizeAmount = s.collateralAssets[_collateralAssetToSeize].decimals.fromCollateralFixedPointAmount(\n            LibCalculation.calculateAmountToSeize(\n                s.collateralAssets[_collateralAssetToSeize].liquidationIncentive,\n                s.collateralAssets[_collateralAssetToSeize].uintPrice(),\n                _kissRepayAmount.fromWadPriceToUint()\n            )\n        );\n\n        // Collateral deposits for the seized asset of the account being liquidated\n        uint256 collateralDeposit = s.getCollateralDeposits(_account, _collateralAssetToSeize);\n\n        // Default case where deposits are greater than the seized amount\n        if (collateralDeposit > seizeAmount) {\n            // Convert the value being seized into non-rebasing value\n            s.collateralDeposits[_account][_collateralAssetToSeize] -= ms()\n                .collateralAssets[_collateralAssetToSeize]\n                .toNonRebasingAmount(seizeAmount);\n        } else {\n            // This clause means user either has collateralDeposits equal or less than the _seizeAmount\n            seizeAmount = collateralDeposit;\n            // So we set the collateralDeposits to 0\n            s.collateralDeposits[_account][_collateralAssetToSeize] = 0;\n            // And remove the asset from the deposits array.\n            s.depositedCollateralAssets[_account].removeAddress(\n                _collateralAssetToSeize,\n                _depositedCollateralAssetIndex\n            );\n        }\n\n        // Send liquidator the seized collateral.\n        IERC20Upgradeable(_collateralAssetToSeize).safeTransfer(msg.sender, seizeAmount);\n    }\n}\n"
    },
    "src/contracts/minter/facets/LiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n// solhint-disable not-rely-on-time\n\nimport {ILiquidationFacet} from \"../interfaces/ILiquidationFacet.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibDecimals, FixedPoint} from \"../libs/LibDecimals.sol\";\nimport {LibCalculation} from \"../libs/LibCalculation.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"../../shared/SafeERC20Upgradeable.sol\";\nimport {DiamondModifiers} from \"../../shared/Modifiers.sol\";\n\nimport {Constants, KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title LiquidationFacet\n * @notice Main end-user functionality concerning liquidations within the Kresko protocol\n */\ncontract LiquidationFacet is DiamondModifiers, ILiquidationFacet {\n    using Arrays for address[];\n    using LibDecimals for uint8;\n    using LibDecimals for FixedPoint.Unsigned;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n    using FixedPoint for FixedPoint.Unsigned;\n    using FixedPoint for uint256;\n    using FixedPoint for int256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @inheritdoc ILiquidationFacet\n    function liquidate(\n        address _account,\n        address _repayAsset,\n        uint256 _repayAmount,\n        address _seizeAsset,\n        uint256 _repayAssetIndex,\n        uint256 _seizeAssetIndex\n    ) external nonReentrant {\n        MinterState storage s = ms();\n\n        CollateralAsset memory collateral = s.collateralAssets[_seizeAsset];\n        KrAsset memory krAsset = s.kreskoAssets[_repayAsset];\n\n        /* ------------------------------ Sanity checks ----------------------------- */\n        {\n            // No zero repays\n            require(_repayAmount != 0, Error.ZERO_REPAY);\n            // Borrower cannot liquidate themselves\n            require(msg.sender != _account, Error.SELF_LIQUIDATION);\n            // krAsset exists\n            require(krAsset.exists, Error.KRASSET_DOESNT_EXIST);\n            // Collateral exists\n            require(collateral.exists, Error.COLLATERAL_DOESNT_EXIST);\n            // Check that this account is below its minimum collateralization ratio and can be liquidated.\n            require(s.isAccountLiquidatable(_account), Error.NOT_LIQUIDATABLE);\n        }\n\n        /* ------------------------------ Amount checks ----------------------------- */\n        // Repay amount USD = repay amount * KR asset USD exchange rate.\n        uint256 repayAmountUSD = krAsset.uintUSD(_repayAmount);\n\n        // Avoid deep stack\n        {\n            // Get the principal debt amount which is unscaled for interest.\n            uint256 krAssetDebt = s.getKreskoAssetDebtPrincipal(_account, _repayAsset);\n            // Cannot liquidate more than the account's debt\n            require(krAssetDebt >= _repayAmount, Error.KRASSET_BURN_AMOUNT_OVERFLOW);\n\n            // We limit liquidations to exactly Liquidation Threshold here.\n            uint256 maxLiquidableUSD = s.getMaxLiquidation(_account, krAsset, _seizeAsset);\n            require(repayAmountUSD <= maxLiquidableUSD, Error.LIQUIDATION_OVERFLOW);\n        }\n\n        /* ------------------------------- Charge fee ------------------------------- */\n        s.chargeCloseFee(_account, _repayAsset, _repayAmount);\n\n        /* -------------------------------- Liquidate ------------------------------- */\n        uint256 seizedAmount = _liquidateAssets(\n            ExecutionParams(\n                _account,\n                _repayAmount,\n                collateral.decimals.fromCollateralFixedPointAmount(\n                    LibCalculation.calculateAmountToSeize(\n                        collateral.liquidationIncentive,\n                        collateral.uintPrice(),\n                        repayAmountUSD\n                    )\n                ),\n                _repayAsset,\n                _repayAssetIndex,\n                _seizeAsset,\n                _seizeAssetIndex\n            )\n        );\n\n        /* ---------------------------- Balance transfer ---------------------------- */\n        // Send liquidator the seized collateral.\n        IERC20Upgradeable(_seizeAsset).safeTransfer(msg.sender, seizedAmount);\n\n        emit MinterEvent.LiquidationOccurred(\n            _account,\n            // solhint-disable-next-line avoid-tx-origin\n            tx.origin,\n            _repayAsset,\n            _repayAmount,\n            _seizeAsset,\n            seizedAmount\n        );\n    }\n\n    /// @notice Execute the liquidation\n    /// @dev Also updates stability rate and debt index\n    function _liquidateAssets(ExecutionParams memory params) internal returns (uint256 seizedAmount) {\n        MinterState storage s = ms();\n\n        /* -------------------------------------------------------------------------- */\n        /*                                 Reduce debt                                */\n        /* -------------------------------------------------------------------------- */\n        {\n            /* ----------------------------- Destroy assets ----------------------------- */\n            uint256 destroyed = IKreskoAssetIssuer(s.kreskoAssets[params.repayAsset].anchor).destroy(\n                params.repayAmount,\n                msg.sender\n            );\n            s.kreskoAssetDebt[params.account][params.repayAsset] -= destroyed;\n\n            /* ------------------------ Debt index + rate updates ----------------------- */\n\n            uint256 newDebtIndex = irs().srAssets[params.repayAsset].updateDebtIndex();\n            uint256 amountScaled = destroyed.wadToRay().rayDiv(newDebtIndex);\n\n            irs().srUserInfo[params.account][params.repayAsset].debtScaled -= uint128(amountScaled);\n            irs().srUserInfo[params.account][params.repayAsset].lastDebtIndex = uint128(newDebtIndex);\n\n            irs().srAssets[params.repayAsset].updateStabilityRate();\n        }\n\n        // If the liquidation repays entire asset debt, remove from minted assets array.\n        if (s.kreskoAssetDebt[params.account][params.repayAsset] == 0) {\n            s.mintedKreskoAssets[params.account].removeAddress(params.repayAsset, params.repayAssetIndex);\n        }\n\n        /* -------------------------------------------------------------------------- */\n        /*                              Reduce collateral                             */\n        /* -------------------------------------------------------------------------- */\n\n        uint256 collateralDeposits = s.getCollateralDeposits(params.account, params.seizedAsset);\n\n        /* ------------------------ Above collateral deposits ----------------------- */\n        if (collateralDeposits > params.seizeAmount) {\n            s.collateralDeposits[params.account][params.seizedAsset] -= ms()\n                .collateralAssets[params.seizedAsset]\n                .toNonRebasingAmount(params.seizeAmount);\n\n            return params.seizeAmount; // Passthrough value as is.\n        }\n\n        /* ------------------- Exact or below collateral deposits ------------------- */\n        // Remove the collateral deposits.\n        s.collateralDeposits[params.account][params.seizedAsset] = 0;\n        // Remove from the deposits array.\n        s.depositedCollateralAssets[params.account].removeAddress(params.seizedAsset, params.seizedAssetIndex);\n        // Seized amount is the collateral deposits.\n        return collateralDeposits;\n    }\n\n    /// @inheritdoc ILiquidationFacet\n    function isAccountLiquidatable(address _account) external view returns (bool) {\n        return ms().isAccountLiquidatable(_account);\n    }\n\n    /// @inheritdoc ILiquidationFacet\n    function getMaxLiquidation(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize\n    ) public view returns (uint256 maxLiquidatableUSD) {\n        return ms().getMaxLiquidation(_account, ms().kreskoAssets[_repayKreskoAsset], _collateralAssetToSeize);\n    }\n}\n"
    },
    "src/contracts/minter/facets/MintFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IMintFacet} from \"../interfaces/IMintFacet.sol\";\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {DiamondModifiers, MinterModifiers} from \"../../shared/Modifiers.sol\";\nimport {Action, FixedPoint, KrAsset} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title MintFacet\n * @notice Main end-user functionality concerning minting kresko assets\n */\ncontract MintFacet is DiamondModifiers, MinterModifiers, IMintFacet {\n    using FixedPoint for FixedPoint.Unsigned;\n    using Arrays for address[];\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  KrAssets                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Mints new Kresko assets.\n     * @param _account The address to mint assets for.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _mintAmount The amount of the Kresko asset to be minted.\n     */\n    function mintKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _mintAmount\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        require(_mintAmount > 0, Error.ZERO_MINT);\n\n        MinterState storage s = ms();\n        if (s.safetyStateSet) {\n            super.ensureNotPaused(_kreskoAsset, Action.Borrow);\n        }\n\n        // Enforce krAsset's total supply limit\n        KrAsset memory krAsset = s.kreskoAssets[_kreskoAsset];\n        require(krAsset.marketStatusOracle.latestMarketOpen(), Error.KRASSET_MARKET_CLOSED);\n\n        require(\n            IKreskoAsset(_kreskoAsset).totalSupply() + _mintAmount <= krAsset.supplyLimit,\n            Error.KRASSET_MAX_SUPPLY_REACHED\n        );\n\n        if (krAsset.openFee.rawValue > 0) {\n            s.chargeOpenFee(_account, _kreskoAsset, _mintAmount);\n        }\n        {\n            // Get the account's current minimum collateral value required to maintain current debts.\n            // Calculate additional collateral amount required to back requested additional mint.\n            // Verify that minter has sufficient collateral to back current debt + new requested debt.\n            require(\n                s\n                    .getAccountMinimumCollateralValueAtRatio(_account, s.minimumCollateralizationRatio)\n                    .add(s.getMinimumCollateralValueAtRatio(_kreskoAsset, _mintAmount, s.minimumCollateralizationRatio))\n                    .isLessThanOrEqual(s.getAccountCollateralValue(_account)),\n                Error.KRASSET_COLLATERAL_LOW\n            );\n        }\n\n        // The synthetic asset debt position must be greater than the minimum debt position value\n        uint256 existingDebt = s.getKreskoAssetDebtScaled(_account, _kreskoAsset);\n        require(\n            krAsset.fixedPointUSD(existingDebt + _mintAmount).isGreaterThanOrEqual(s.minimumDebtValue),\n            Error.KRASSET_MINT_AMOUNT_LOW\n        );\n\n        // If the account does not have an existing debt for this Kresko Asset,\n        // push it to the list of the account's minted Kresko Assets.\n        if (existingDebt == 0) {\n            s.mintedKreskoAssets[_account].push(_kreskoAsset);\n        }\n\n        // Record the mint.\n        s.mint(_kreskoAsset, krAsset.anchor, _mintAmount, _account);\n\n        // Emit logs\n        emit MinterEvent.KreskoAssetMinted(_account, _kreskoAsset, _mintAmount);\n    }\n}\n"
    },
    "src/contracts/minter/facets/SafetyCouncilFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {ISafetyCouncilFacet} from \"../interfaces/ISafetyCouncilFacet.sol\";\n\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {Authorization, Role} from \"../../libs/Authorization.sol\";\nimport {DiamondModifiers, MinterModifiers} from \"../../shared/Modifiers.sol\";\n\nimport {Action, SafetyState, Pause} from \"../MinterTypes.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @author Kresko\n * @title SafetyCouncilFacet - protocol safety controls\n * @notice `Role.SAFETY_COUNCIL` must be a multisig.\n */\ncontract SafetyCouncilFacet is MinterModifiers, DiamondModifiers, ISafetyCouncilFacet {\n    /**\n     * @dev Toggle paused-state of assets in a per-action basis\n     *\n     * @notice These functions are only callable by a multisig quorum.\n     * @param _assets list of addresses of krAssets and/or collateral assets\n     * @param _action One of possible user actions:\n     *  Deposit = 0\n     *  Withdraw = 1,\n     *  Repay = 2,\n     *  Borrow = 3,\n     *  Liquidate = 4\n     * @param _withDuration Set a duration for this pause - @todo: implement it if required\n     * @param _duration Duration for the pause if `_withDuration` is true\n     */\n    function toggleAssetsPaused(\n        address[] calldata _assets,\n        Action _action,\n        bool _withDuration,\n        uint256 _duration\n    ) external override onlyRole(Role.SAFETY_COUNCIL) {\n        bool enabled;\n        /// @dev loop through `_assets` - be it krAsset or collateral\n        for (uint256 i; i < _assets.length; i++) {\n            address asset = _assets[i];\n            // Revert if invalid address is supplied\n            require(\n                ms().collateralAssets[asset].exists || ms().kreskoAssets[asset].exists,\n                Error.INVALID_ASSET_SUPPLIED\n            );\n            // Get the safety state\n            SafetyState memory safetyState = ms().safetyState[asset][_action];\n            // Flip the previous value\n            bool willPause = !safetyState.pause.enabled;\n            // Set a global flag in case any asset gets set to true\n            if (willPause) {\n                enabled = true;\n            }\n            // Update the state for this asset\n            ms().safetyState[asset][_action].pause = Pause(\n                willPause,\n                block.timestamp,\n                _withDuration ? block.timestamp + _duration : 0\n            );\n            // Emit the actions taken\n            emit MinterEvent.SafetyStateChange(_action, asset, enabled ? \"paused\" : \"unpaused\");\n        }\n    }\n\n    /**\n     * @notice For external checks if a safety state has been set for any asset\n     */\n    function safetyStateSet() external view override returns (bool) {\n        return ms().safetyStateSet;\n    }\n\n    /**\n     * @notice View the state of safety measures for an asset on a per-action basis\n     * @param _asset krAsset / collateral asset\n     * @param _action One of possible user actions:\n     *\n     *  Deposit = 0\n     *  Withdraw = 1,\n     *  Repay = 2,\n     *  Borrow = 3,\n     *  Liquidate = 4\n     */\n    function safetyStateFor(address _asset, Action _action) external view override returns (SafetyState memory) {\n        return ms().safetyState[_asset][_action];\n    }\n\n    /**\n     * @notice Check if `_asset` has a pause enabled for `_action`\n     * @param _action enum `Action`\n     *  Deposit = 0\n     *  Withdraw = 1,\n     *  Repay = 2,\n     *  Borrow = 3,\n     *  Liquidate = 4\n     * @return true if `_action` is paused\n     */\n    function assetActionPaused(Action _action, address _asset) external view returns (bool) {\n        return ms().safetyState[_asset][_action].pause.enabled;\n    }\n}\n"
    },
    "src/contracts/minter/facets/StabilityRateFacet.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.14;\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {InterestRateEvent} from \"../../libs/Events.sol\";\nimport {LibStabilityRate} from \"../libs/LibStabilityRate.sol\";\nimport {LibDecimals, FixedPoint} from \"../libs/LibDecimals.sol\";\nimport {StabilityRateConfig} from \"../InterestRateState.sol\";\nimport {ms} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {IERC20Upgradeable} from \"../../shared/IERC20Upgradeable.sol\";\nimport {IStabilityRateFacet} from \"../interfaces/IStabilityRateFacet.sol\";\nimport {MinterModifiers, DiamondModifiers, Error, Role} from \"../../shared/Modifiers.sol\";\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"../../shared/SafeERC20Upgradeable.sol\";\n\n/* solhint-disable var-name-mixedcase */\n\n// Stability Rate setup params\nstruct StabilityRateParams {\n    uint128 stabilityRateBase;\n    uint128 rateSlope1;\n    uint128 rateSlope2;\n    uint128 optimalPriceRate;\n    uint128 priceRateDelta;\n}\n\n/**\n * @title Stability rate facet\n * @author Kresko\n * @notice Stability rate related views and state operations\n * @dev Uses both MinterState (ms) and InterestRateState (irs)\n */\ncontract StabilityRateFacet is MinterModifiers, DiamondModifiers {\n    using Arrays for address[];\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using WadRay for uint256;\n    using LibStabilityRate for StabilityRateConfig;\n    using LibDecimals for FixedPoint.Unsigned;\n    using LibDecimals for uint256;\n    using FixedPoint for uint256;\n    using FixedPoint for FixedPoint.Unsigned;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              ASSET STATE WRITES                            */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Initialize an asset with stability rate setup values\n     * @param _asset asset to setup\n     * @param _setup setup parameters\n     */\n    function setupStabilityRateParams(address _asset, StabilityRateParams memory _setup) external onlyRole(Role.ADMIN) {\n        require(irs().kiss != address(0), Error.KISS_NOT_SET);\n        require(irs().srAssets[_asset].asset == address(0), Error.STABILITY_RATES_ALREADY_INITIALIZED);\n        require(WadRay.RAY >= _setup.optimalPriceRate, Error.INVALID_OPTIMAL_RATE);\n        require(WadRay.RAY >= _setup.priceRateDelta, Error.INVALID_PRICE_RATE_DELTA);\n\n        irs().srAssets[_asset] = StabilityRateConfig({\n            debtIndex: uint128(WadRay.RAY),\n            stabilityRateBase: _setup.stabilityRateBase,\n            // solhint-disable not-rely-on-time\n            lastUpdateTimestamp: uint40(block.timestamp),\n            asset: _asset,\n            rateSlope1: _setup.rateSlope1,\n            rateSlope2: _setup.rateSlope2,\n            optimalPriceRate: _setup.optimalPriceRate,\n            priceRateDelta: _setup.priceRateDelta,\n            stabilityRate: uint128(WadRay.RAY)\n        });\n\n        emit InterestRateEvent.StabilityRateConfigured(\n            _asset,\n            _setup.stabilityRateBase,\n            _setup.priceRateDelta,\n            _setup.rateSlope1,\n            _setup.rateSlope2\n        );\n    }\n\n    /**\n     * @notice Configure existing stability rate values\n     * @param _asset asset to configure\n     * @param _setup setup parameters\n     */\n    function updateStabilityRateParams(\n        address _asset,\n        StabilityRateParams memory _setup\n    ) external onlyRole(Role.ADMIN) {\n        require(irs().srAssets[_asset].asset == _asset, Error.STABILITY_RATES_NOT_INITIALIZED);\n        require(WadRay.RAY >= _setup.optimalPriceRate, Error.INVALID_OPTIMAL_RATE);\n        require(WadRay.RAY >= _setup.priceRateDelta, Error.INVALID_PRICE_RATE_DELTA);\n\n        irs().srAssets[_asset].rateSlope1 = _setup.rateSlope1;\n        irs().srAssets[_asset].rateSlope2 = _setup.rateSlope2;\n        irs().srAssets[_asset].optimalPriceRate = _setup.optimalPriceRate;\n        irs().srAssets[_asset].priceRateDelta = _setup.priceRateDelta;\n        irs().srAssets[_asset].stabilityRateBase = _setup.stabilityRateBase;\n\n        emit InterestRateEvent.StabilityRateConfigured(\n            _asset,\n            _setup.stabilityRateBase,\n            _setup.priceRateDelta,\n            _setup.rateSlope1,\n            _setup.rateSlope2\n        );\n    }\n\n    /// @notice Updates the debt index and stability rates for an asset\n    /// @param _asset asset to update rate and index for\n    function updateStabilityRateAndIndexForAsset(address _asset) external {\n        irs().srAssets[_asset].updateDebtIndex();\n        irs().srAssets[_asset].updateStabilityRate();\n    }\n\n    /**\n     * @notice Sets the protocol AMM oracle address\n     * @param _kiss  The address of the oracle\n     */\n    function updateKiss(address _kiss) external onlyRole(Role.ADMIN) {\n        irs().kiss = _kiss;\n        emit InterestRateEvent.KISSUpdated(_kiss);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                REPAYMENT                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Repays part of accrued stability rate interest for a single asset\n     * @param _account Account to repay interest for\n     * @param _kreskoAsset Kresko asset to repay interest for\n     * @param _kissRepayAmount USD value to repay (KISS)\n     */\n    function repayStabilityRateInterestPartial(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kissRepayAmount\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) {\n        // Update debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n\n        // Get the accrued interest in repayment token\n        (, uint256 maxKissRepayAmount) = ms().getKreskoAssetDebtInterest(_account, _kreskoAsset);\n        require(_kissRepayAmount < maxKissRepayAmount, Error.INTEREST_REPAY_NOT_PARTIAL);\n\n        // If no interest has accrued or 0 amount was supplied as parameter - no further operations needed\n        // Do not revert because we want the preserve new debt index and stability rate\n        // Also removes the need to check if the kresko asset exists as the maxKissAmount will return 0\n        if (_kissRepayAmount == 0 || maxKissRepayAmount == 0) {\n            // Update stability rate for asset\n            irs().srAssets[_kreskoAsset].updateStabilityRate();\n            return;\n        }\n\n        // Transfer the accrued interest\n        IERC20Upgradeable(irs().kiss).safeTransferFrom(msg.sender, ms().feeRecipient, _kissRepayAmount);\n        uint256 assetAmount = _kissRepayAmount.divByPrice(ms().kreskoAssets[_kreskoAsset].uintPrice());\n        uint256 amountScaled = assetAmount.wadToRay().rayDiv(newDebtIndex);\n        // Update scaled values for the user\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled -= uint128(amountScaled);\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n        // Update stability rate for asset\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n\n        // Emit event with the account, asset and amount repaid\n        emit InterestRateEvent.StabilityRateInterestRepaid(_account, _kreskoAsset, _kissRepayAmount);\n    }\n\n    /**\n     * @notice Repays accrued stability rate interest for a single asset\n     * @param _account Account to repay interest for\n     * @param _kreskoAsset Kresko asset to repay interest for\n     * @return kissRepayAmount KISS value repaid\n     */\n    function repayFullStabilityRateInterest(\n        address _account,\n        address _kreskoAsset\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) returns (uint256 kissRepayAmount) {\n        return ms().repayFullStabilityRateInterest(_account, _kreskoAsset);\n    }\n\n    /**\n     * @notice Repays all accrued stability rate interest for an account\n     * @param _account Account to repay all asset interests for\n     * @return kissRepayAmount KISS value repaid\n     */\n    function batchRepayFullStabilityRateInterest(\n        address _account\n    ) external nonReentrant returns (uint256 kissRepayAmount) {\n        address[] memory mintedKreskoAssets = ms().getMintedKreskoAssets(_account);\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            kissRepayAmount += ms().repayFullStabilityRateInterest(_account, mintedKreskoAssets[i]);\n        }\n        emit InterestRateEvent.StabilityRateInterestBatchRepaid(_account, kissRepayAmount);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   VIEWS                                    */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Gets the current stability rate for an asset\n     * @param _asset asset to get the stability rate for\n     * @return stabilityRate the return variables of a contract’s function state variable\n     * @dev expressed in ray\n     */\n    function getStabilityRateForAsset(address _asset) external view returns (uint256 stabilityRate) {\n        return irs().srAssets[_asset].calculateStabilityRate();\n    }\n\n    /**\n     * @notice Gets the current price rate (difference between AMM <-> Oracle pricing)\n     * for an asset\n     * @param _asset asset to get the rate for\n     * @return priceRate the current\n     * @dev expressed in ray\n     */\n    function getPriceRateForAsset(address _asset) external view returns (uint256 priceRate) {\n        return irs().srAssets[_asset].getPriceRate();\n    }\n\n    /**\n     * @notice Gets the current running debt index\n     * @param _asset asset to get the index for\n     * @return debtIndex current running debt index\n     * @dev expressed in ray\n     */\n    function getDebtIndexForAsset(address _asset) external view returns (uint256 debtIndex) {\n        return irs().srAssets[_asset].getNormalizedDebtIndex();\n    }\n\n    /**\n     * @notice View stability rate configuration for an asset\n     * @param _asset asset to view configuration for\n     */\n    function getStabilityRateConfigurationForAsset(address _asset) external view returns (StabilityRateConfig memory) {\n        return irs().srAssets[_asset];\n    }\n\n    /**\n     * @notice The configured address of KISS\n     */\n    function kiss() external view returns (address) {\n        return irs().kiss;\n    }\n\n    /**\n     * @notice Get user stability rate data for an asset\n     * @param _account asset to view configuration for\n     * @param _asset asset to view configuration for\n     * @return lastDebtIndex the previous debt index for the user\n     */\n    function getLastDebtIndexForAccount(\n        address _account,\n        address _asset\n    ) external view returns (uint128 lastDebtIndex) {\n        return irs().srUserInfo[_account][_asset].lastDebtIndex;\n    }\n}\n"
    },
    "src/contracts/minter/facets/StateFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IStateFacet} from \"../interfaces/IStateFacet.sol\";\n\nimport {MinterParams, FixedPoint, KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {MinterState, ms} from \"../MinterStorage.sol\";\n\n/**\n * @author Kresko\n * @title View functions for protocol parameters and asset values\n * @dev As structs do not create views for members, we must expose most of the state values explicitly.\n */\ncontract StateFacet is IStateFacet {\n    /// @inheritdoc IStateFacet\n    function domainSeparator() external view returns (bytes32) {\n        return ms().domainSeparator;\n    }\n\n    /// @inheritdoc IStateFacet\n    function minterInitializations() external view returns (uint256) {\n        return ms().initializations;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Configurables                               */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IStateFacet\n    function feeRecipient() external view returns (address) {\n        return ms().feeRecipient;\n    }\n\n    /// @inheritdoc IStateFacet\n    function ammOracle() external view returns (address) {\n        return ms().ammOracle;\n    }\n\n    /// @inheritdoc IStateFacet\n    function extOracleDecimals() external view returns (uint8) {\n        return ms().extOracleDecimals;\n    }\n\n    /// @inheritdoc IStateFacet\n    function minimumCollateralizationRatio() external view returns (FixedPoint.Unsigned memory) {\n        return ms().minimumCollateralizationRatio;\n    }\n\n    /// @inheritdoc IStateFacet\n    function liquidationIncentiveMultiplier() external view returns (FixedPoint.Unsigned memory) {\n        return ms().liquidationIncentiveMultiplier;\n    }\n\n    /// @inheritdoc IStateFacet\n    function minimumDebtValue() external view returns (FixedPoint.Unsigned memory) {\n        return ms().minimumDebtValue;\n    }\n\n    /// @inheritdoc IStateFacet\n    function liquidationThreshold() external view returns (FixedPoint.Unsigned memory) {\n        return ms().liquidationThreshold;\n    }\n\n    /// @inheritdoc IStateFacet\n    function maxLiquidationMultiplier() external view returns (FixedPoint.Unsigned memory) {\n        return ms().maxLiquidationMultiplier;\n    }\n\n    /// @inheritdoc IStateFacet\n    function getAllParams() external view returns (MinterParams memory) {\n        MinterState storage s = ms();\n        return\n            MinterParams(\n                s.minimumCollateralizationRatio,\n                s.minimumDebtValue,\n                s.liquidationThreshold,\n                s.liquidationIncentiveMultiplier,\n                s.feeRecipient,\n                s.extOracleDecimals\n            );\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Assets                                   */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IStateFacet\n    function krAssetExists(address _kreskoAsset) external view returns (bool exists) {\n        return ms().kreskoAssets[_kreskoAsset].exists;\n    }\n\n    /// @inheritdoc IStateFacet\n    function kreskoAsset(address _kreskoAsset) external view returns (KrAsset memory asset) {\n        return ms().kreskoAsset(_kreskoAsset);\n    }\n\n    /// @inheritdoc IStateFacet\n    function collateralExists(address _collateralAsset) external view returns (bool exists) {\n        return ms().collateralAssets[_collateralAsset].exists;\n    }\n\n    /// @inheritdoc IStateFacet\n    function collateralAsset(address _collateralAsset) external view returns (CollateralAsset memory asset) {\n        return ms().collateralAssets[_collateralAsset];\n    }\n\n    /// @inheritdoc IStateFacet\n    function getCollateralValueAndOraclePrice(\n        address _collateralAsset,\n        uint256 _amount,\n        bool _ignoreCollateralFactor\n    ) external view returns (FixedPoint.Unsigned memory value, FixedPoint.Unsigned memory oraclePrice) {\n        return ms().getCollateralValueAndOraclePrice(_collateralAsset, _amount, _ignoreCollateralFactor);\n    }\n\n    /// @inheritdoc IStateFacet\n    function getKrAssetValue(\n        address _kreskoAsset,\n        uint256 _amount,\n        bool _ignoreKFactor\n    ) external view returns (FixedPoint.Unsigned memory value) {\n        return ms().getKrAssetValue(_kreskoAsset, _amount, _ignoreKFactor);\n    }\n}\n"
    },
    "src/contracts/minter/facets/UIDataProviderFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n/* solhint-disable max-line-length */\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable func-name-mixedcase */\n/* solhint-disable contract-name-camelcase */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\nimport {ds, Error, Meta} from \"../../shared/Modifiers.sol\";\nimport {InterestRateEvent} from \"../../libs/Events.sol\";\nimport {LibUI, IKrStaking, IUniswapV2Pair, IERC20Upgradeable, AggregatorV2V3Interface, ms} from \"../libs/LibUI.sol\";\n\n/**\n * @author Kresko\n * @title UIDataProviderFacet\n * @notice UI data aggregation views\n */\ncontract UIDataProviderFacet {\n    function getAccountData(\n        address _account,\n        address[] memory _tokens,\n        address _staking\n    )\n        external\n        view\n        returns (LibUI.KreskoUser memory user, LibUI.Balance[] memory balances, LibUI.StakingData[] memory stakingData)\n    {\n        user = LibUI.kreskoUser(_account);\n        balances = LibUI.getBalances(_tokens, _account);\n        stakingData = LibUI.getStakingData(_account, _staking);\n    }\n\n    function batchOracleValues(\n        address[] memory _assets,\n        address[] memory _oracles,\n        address[] memory _marketStatusOracles\n    ) public view returns (LibUI.Price[] memory result) {\n        return LibUI.batchOracleValues(_assets, _oracles, _marketStatusOracles);\n    }\n\n    function getTokenData(\n        address[] memory _allTokens,\n        address[] memory _assets,\n        address[] memory _priceFeeds,\n        address[] memory _marketStatusOracles\n    ) external view returns (LibUI.TokenMetadata[] memory metadatas, LibUI.Price[] memory prices) {\n        metadatas = new LibUI.TokenMetadata[](_allTokens.length);\n        for (uint256 i; i < _allTokens.length; i++) {\n            metadatas[i] = LibUI.TokenMetadata({\n                decimals: IERC20Upgradeable(_allTokens[i]).decimals(),\n                name: IERC20Upgradeable(_allTokens[i]).name(),\n                symbol: IERC20Upgradeable(_allTokens[i]).symbol(),\n                totalSupply: IERC20Upgradeable(_allTokens[i]).totalSupply()\n            });\n        }\n        prices = LibUI.batchOracleValues(_assets, _priceFeeds, _marketStatusOracles);\n    }\n}\n"
    },
    "src/contracts/minter/facets/UIDataProviderFacet2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n/* solhint-disable max-line-length */\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable func-name-mixedcase */\n/* solhint-disable contract-name-camelcase */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\nimport {ds, Error, Meta} from \"../../shared/Modifiers.sol\";\nimport {LibUI, IKrStaking, IUniswapV2Pair, IERC20Upgradeable, AggregatorV2V3Interface, ms} from \"../libs/LibUI.sol\";\n\n/**\n * @author Kresko\n * @title UIDataProviderFacet2\n * @notice UI data aggregation views\n */\ncontract UIDataProviderFacet2 {\n    function getGlobalData(\n        address[] memory _collateralAssets,\n        address[] memory _krAssets\n    )\n        external\n        view\n        returns (\n            LibUI.CollateralAssetInfo[] memory collateralAssets,\n            LibUI.krAssetInfo[] memory krAssets,\n            LibUI.ProtocolParams memory protocolParams\n        )\n    {\n        collateralAssets = LibUI.collateralAssetInfos(_collateralAssets);\n        krAssets = LibUI.krAssetInfos(_krAssets);\n        protocolParams = LibUI.ProtocolParams({\n            minCollateralRatio: ms().minimumCollateralizationRatio.rawValue,\n            minDebtValue: ms().minimumDebtValue.rawValue,\n            liquidationThreshold: ms().liquidationThreshold.rawValue\n        });\n    }\n\n    function getPairsData(address[] memory _pairAddresses) external view returns (LibUI.PairData[] memory result) {\n        result = new LibUI.PairData[](_pairAddresses.length);\n        for (uint256 i; i < _pairAddresses.length; i++) {\n            IUniswapV2Pair pair = IUniswapV2Pair(_pairAddresses[i]);\n            (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\n            result[i] = LibUI.PairData({\n                decimals0: IERC20Upgradeable(pair.token0()).decimals(),\n                decimals1: IERC20Upgradeable(pair.token1()).decimals(),\n                totalSupply: pair.totalSupply(),\n                reserve0: reserve0,\n                reserve1: reserve1\n            });\n        }\n    }\n}\n"
    },
    "src/contracts/minter/initializers/FacetUpgrade16052023.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {ms} from \"../MinterStorage.sol\";\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\n\ncontract FacetUpgrade16052023 {\n    function initialize() external {\n        ms().initializations += 1;\n        address DAI = 0x7ff84e6d3111327ED63eb97691Bf469C7fcE832F;\n        address WETH = 0x4200000000000000000000000000000000000006;\n        address krBTC = 0xf88721B9C87EBc86E3C91E6C98c0f646a75600f4;\n        address krETH = 0xbb37d6016f97Dd369eCB76e2A5036DacD8770f8b;\n        address krTSLA = 0x3502B0329a45011C8FEE033B8eEe6BDA89c03081;\n        address KISS = 0xC0B5aBa9F46bDf4D1bC52a4C3ab05C857aC4Ee80;\n\n        ms().collateralAssets[DAI].liquidationIncentive = FixedPoint.Unsigned(1.05 ether);\n        ms().collateralAssets[WETH].liquidationIncentive = FixedPoint.Unsigned(1.05 ether);\n        ms().collateralAssets[krBTC].liquidationIncentive = FixedPoint.Unsigned(1.05 ether);\n        ms().collateralAssets[krETH].liquidationIncentive = FixedPoint.Unsigned(1.05 ether);\n        ms().collateralAssets[krTSLA].liquidationIncentive = FixedPoint.Unsigned(1.05 ether);\n        ms().collateralAssets[KISS].liquidationIncentive = FixedPoint.Unsigned(1.05 ether);\n    }\n}\n"
    },
    "src/contracts/minter/InterestRateState.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {LibStabilityRate} from \"./libs/LibStabilityRate.sol\";\n\nusing LibStabilityRate for StabilityRateConfig global;\n\n/* solhint-disable var-name-mixedcase */\n\n// Asset data\nstruct StabilityRateConfig {\n    // Interest index for debt\n    uint128 debtIndex;\n    // Represents the optimal price rate between an oracle report and an AMM twap\n    uint128 optimalPriceRate;\n    // Slope of the variable interest curve when rate > 0 and <= optimalPriceRate.\n    // Expressed in ray\n    uint128 rateSlope1;\n    // Slope of the variable interest curve when rate > optimalPriceRate.\n    // Expressed in ray\n    uint128 rateSlope2;\n    /**\n     * Represents the excess price premium in either direction.\n     * Expressed in ray\n     * Eg. 1/20 ray = 5% price premium in either direction is considered excess\n     */\n    uint128 priceRateDelta;\n    // Current accrual rate for debt\n    uint128 stabilityRate;\n    // Base accrual rate for debt\n    uint128 stabilityRateBase;\n    // Asset to configure\n    address asset;\n    // Last update for the asset\n    uint40 lastUpdateTimestamp;\n}\n\n// User data\nstruct StabilityRateUser {\n    uint128 debtScaled;\n    uint128 lastDebtIndex;\n}\n\n// Storage layout\nstruct InterestRateState {\n    // asset address -> asset data\n    mapping(address => StabilityRateConfig) srAssets;\n    // account address -> asset address -> user data\n    mapping(address => mapping(address => StabilityRateUser)) srUserInfo;\n    // interest repayment token is KISS\n    address kiss;\n}\n\n// Storage position\nbytes32 constant INTEREST_RATE_STORAGE_POSITION = keccak256(\"kresko.interest.rate.storage\");\n\n// solhint-disable func-visibility\nfunction irs() pure returns (InterestRateState storage state) {\n    bytes32 position = INTEREST_RATE_STORAGE_POSITION;\n    assembly {\n        state.slot := position\n    }\n}\n"
    },
    "src/contracts/minter/interfaces/IAccountStateFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\nimport {Action} from \"../MinterTypes.sol\";\n\ninterface IAccountStateFacet {\n    // ExpectedFeeRuntimeInfo is used for stack size optimization\n    struct ExpectedFeeRuntimeInfo {\n        address[] assets;\n        uint256[] amounts;\n        uint256 collateralTypeCount;\n    }\n\n    /**\n     * @notice Gets an array of Kresko assets the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @return An array of addresses of Kresko assets the account has minted.\n     */\n    function getMintedKreskoAssets(address _account) external view returns (address[] memory);\n\n    /**\n     * @notice Gets an index for the Kresko asset the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @param _kreskoAsset The asset lookup address.\n     * @return index of the minted Kresko asset.\n     */\n    function getMintedKreskoAssetsIndex(address _account, address _kreskoAsset) external view returns (uint256);\n\n    /**\n     * @notice Gets the Kresko asset value in USD of a particular account.\n     * @param _account The account to calculate the Kresko asset value for.\n     * @return The Kresko asset value of a particular account.\n     */\n    function getAccountKrAssetValue(address _account) external view returns (FixedPoint.Unsigned memory);\n\n    /**\n     * @notice Get `_account` debt amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of debt for `_asset`\n     */\n    function kreskoAssetDebt(address _account, address _asset) external view returns (uint256);\n\n    /**\n     * @notice Get `_account` principal debt amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of principal debt for `_asset`\n     */\n    function kreskoAssetDebtPrincipal(address _account, address _asset) external view returns (uint256);\n\n    /**\n     * @notice Get `_account` interest amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return assetAmount the interest denominated in _asset\n     * @return kissAmount the interest denominated in KISS, ignores K-factor\n     */\n    function kreskoAssetDebtInterest(\n        address _account,\n        address _asset\n    ) external view returns (uint256 assetAmount, uint256 kissAmount);\n\n    /**\n     * @notice Get `_account` interest amount for `_asset`\n     * @param _account The account to query amount for\n     * @return kissAmount the interest denominated in KISS, ignores K-factor\n     */\n    function kreskoAssetDebtInterestTotal(address _account) external view returns (uint256 kissAmount);\n\n    /**\n     * @notice Gets the collateral value of a particular account.\n     * @dev O(# of different deposited collateral assets by account) complexity.\n     * @param _account The account to calculate the collateral value for.\n     * @return The collateral value of a particular account.\n     */\n    function getAccountCollateralValue(address _account) external view returns (FixedPoint.Unsigned memory);\n\n    /**\n     * @notice Get an account's minimum collateral value required\n     * to back a Kresko asset amount at a given collateralization ratio.\n     * @dev Accounts that have their collateral value under the minimum collateral value are considered unhealthy,\n     *      accounts with their collateral value under the liquidation threshold are considered liquidatable.\n     * @param _account The account to calculate the minimum collateral value for.\n     * @param _ratio The collateralization ratio required: higher ratio = more collateral required\n     * @return The minimum collateral value of a particular account.\n     */\n    function getAccountMinimumCollateralValueAtRatio(\n        address _account,\n        FixedPoint.Unsigned memory _ratio\n    ) external view returns (FixedPoint.Unsigned memory);\n\n    /**\n     * @notice Get a list of accounts and their collateral ratios\n     * @return ratio for an `_account`\n     */\n    function getAccountCollateralRatio(address _account) external view returns (FixedPoint.Unsigned memory ratio);\n\n    /**\n     * @notice Get a list of accounts and their collateral ratios\n     * @return ratios of the accounts\n     */\n    function getCollateralRatiosFor(address[] memory _accounts) external view returns (FixedPoint.Unsigned[] memory);\n\n    /**\n     * @notice Get the adjusted value of collateral and the real value of collateral\n     * @dev The adjusted value of collateral is the value of collateral after adjusting for the cFactor\n     * @param _account The account to get the collateral values for.\n     * @param _asset The asset to get the collateral values for.\n     * @return adjustedValue The adjusted value of the collateral.\n     * @return realValue The real value of the collateral.\n     */\n    function getCollateralAdjustedAndRealValue(\n        address _account,\n        address _asset\n    ) external view returns (FixedPoint.Unsigned memory adjustedValue, FixedPoint.Unsigned memory realValue);\n\n    /**\n     * @notice Gets an index for the collateral asset the account has deposited.\n     * @param _account The account to get the index for.\n     * @param _collateralAsset The asset lookup address.\n     * @return i = index of the minted collateral asset.\n     */\n    function getDepositedCollateralAssetIndex(\n        address _account,\n        address _collateralAsset\n    ) external view returns (uint256 i);\n\n    /**\n     * @notice Gets an array of collateral assets the account has deposited.\n     * @param _account The account to get the deposited collateral assets for.\n     * @return An array of addresses of collateral assets the account has deposited.\n     */\n    function getDepositedCollateralAssets(address _account) external view returns (address[] memory);\n\n    /**\n     * @notice Get `_account` collateral deposit amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of collateral deposited for `_asset`\n     */\n    function collateralDeposits(address _account, address _asset) external view returns (uint256);\n\n    /**\n     * @notice Calculates the expected fee to be taken from a user's deposited collateral assets,\n     *         by imitating calcFee without modifying state.\n     * @param _account The account to charge the open fee from.\n     * @param _kreskoAsset The address of the kresko asset being burned.\n     * @param _kreskoAssetAmount The amount of the kresko asset being minted.\n     * @param _feeType The fee type (open, close, etc).\n     * @return assets The collateral types as an array of addresses.\n     * @return amounts The collateral amounts as an array of uint256.\n     */\n    function calcExpectedFee(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kreskoAssetAmount,\n        uint256 _feeType\n    ) external view returns (address[] memory, uint256[] memory);\n}\n"
    },
    "src/contracts/minter/interfaces/IBurnFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface IBurnFacet {\n    function burnKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _amount,\n        uint256 _mintedKreskoAssetIndex\n    ) external;\n}\n"
    },
    "src/contracts/minter/interfaces/IBurnHelperFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\ninterface IBurnHelperFacet {\n    function batchCloseKrAssetDebtPositions(address _account) external;\n\n    function closeKrAssetDebtPosition(address _account, address _kreskoAsset) external;\n}\n"
    },
    "src/contracts/minter/interfaces/ICollateralReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface ICollateralReceiver {\n    function onUncheckedCollateralWithdraw(\n        address _account,\n        address _collateralAsset,\n        uint _withdrawalAmount,\n        uint _depositedCollateralAssetIndex,\n        bytes memory _userData\n    ) external returns (bytes memory);\n}\n"
    },
    "src/contracts/minter/interfaces/IConfigurationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {MinterInitArgs, KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\n\ninterface IConfigurationFacet {\n    function initialize(MinterInitArgs calldata args) external;\n\n    /**\n     * @notice Adds a collateral asset to the protocol.\n     * @dev Only callable by the owner and cannot be called more than once for an asset.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _anchor Underlying anchor for a krAsset collateral, needs to support IKreskoAssetAnchor.\n     * @param _factor The collateral factor of the collateral asset as a raw value for a FixedPoint.Unsigned.\n     * Must be <= 1e18.\n     * @param _liquidationIncentiveMultiplier The liquidation incentive multiplier as a FixedPoint.Unsigned.\n     * @param _priceFeedOracle The oracle address for the collateral asset's USD value.\n     * @param _marketStatusOracle The oracle address for the collateral asset's market open/closed status\n     */\n    function addCollateralAsset(\n        address _collateralAsset,\n        address _anchor,\n        uint256 _factor,\n        uint256 _liquidationIncentiveMultiplier,\n        address _priceFeedOracle,\n        address _marketStatusOracle\n    ) external;\n\n    /**\n     * @notice Adds a KreskoAsset to the protocol.\n     * @dev Only callable by the owner.\n     * @param _krAsset The address of the wrapped KreskoAsset, needs to support IKreskoAsset.\n     * @param _anchor Underlying anchor for the krAsset, needs to support IKreskoAssetAnchor.\n     * @param _kFactor The k-factor of the KreskoAsset as a raw value for a FixedPoint.Unsigned. Must be >= 1e18.\n     * @param _priceFeedOracle The oracle address for the KreskoAsset.\n     * @param _marketStatusOracle The oracle address for the KreskoAsset market status.\n     * @param _supplyLimit The initial total supply limit for the KreskoAsset.\n     * @param _closeFee The initial close fee percentage for the KreskoAsset.\n     * @param _openFee The initial open fee percentage for the KreskoAsset.\n     */\n    function addKreskoAsset(\n        address _krAsset,\n        address _anchor,\n        uint256 _kFactor,\n        address _priceFeedOracle,\n        address _marketStatusOracle,\n        uint256 _supplyLimit,\n        uint256 _closeFee,\n        uint256 _openFee\n    ) external;\n\n    /**\n     * @notice Updates a previously added collateral asset.\n     * @dev Only callable by the owner.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _anchor Underlying anchor for a krAsset collateral, needs to support IKreskoAssetAnchor.\n     * @param _factor The new collateral factor as a raw value for a FixedPoint.Unsigned. Must be <= 1e18.\n     * @param _liquidationIncentiveMultiplier The liquidation incentive multiplier as a FixedPoint.Unsigned.\n     * @param _priceFeedOracle The new oracle address for the collateral asset.\n     * @param _marketStatusOracle The oracle address for the collateral asset's market open/closed status\n     */\n    function updateCollateralAsset(\n        address _collateralAsset,\n        address _anchor,\n        uint256 _factor,\n        uint256 _liquidationIncentiveMultiplier,\n        address _priceFeedOracle,\n        address _marketStatusOracle\n    ) external;\n\n    /**\n     * @notice Updates the fee recipient.\n     * @param _feeRecipient The new fee recipient.\n     */\n    function updateFeeRecipient(address _feeRecipient) external;\n\n    /**\n     * @notice  Updates the cFactor of a KreskoAsset.\n     * @param _collateralAsset The collateral asset.\n     * @param _cFactor The new cFactor.\n     */\n    function updateCFactor(address _collateralAsset, uint256 _cFactor) external;\n\n    /**\n     * @notice Updates the kFactor of a KreskoAsset.\n     * @param _kreskoAsset The KreskoAsset.\n     * @param _kFactor The new kFactor.\n     */\n    function updateKFactor(address _kreskoAsset, uint256 _kFactor) external;\n\n    /**\n     * @notice Updates the k-factor of a previously added KreskoAsset.\n     * @dev Only callable by the owner.\n     * @param _krAsset The address of the KreskoAsset.\n     * @param _anchor Underlying anchor for a krAsset.\n     * @param _kFactor The new k-factor as a raw value for a FixedPoint.Unsigned. Must be >= 1e18.\n     * @param _priceFeedOracle The new oracle address for the KreskoAsset's USD value.\n     * @param _marketStatusOracle The oracle address for the KreskoAsset market status.\n     * @param _supplyLimit The new total supply limit for the KreskoAsset.\n     * @param _closeFee The new close fee percentage for the KreskoAsset.\n     * @param _openFee The new open fee percentage for the KreskoAsset.\n     */\n    function updateKreskoAsset(\n        address _krAsset,\n        address _anchor,\n        uint256 _kFactor,\n        address _priceFeedOracle,\n        address _marketStatusOracle,\n        uint256 _supplyLimit,\n        uint256 _closeFee,\n        uint256 _openFee\n    ) external;\n\n    /**\n     * @notice Updates the liquidation incentive multiplier.\n     * @param _collateralAsset The collateral asset to update it for.\n     * @param _liquidationIncentiveMultiplier The new liquidation incentive multiplie.\n     */\n    function updateLiquidationIncentiveMultiplier(\n        address _collateralAsset,\n        uint256 _liquidationIncentiveMultiplier\n    ) external;\n\n    /**\n     * @notice Updates the max liquidation usd overflow multiplier value.\n     * @param _maxLiquidationMultiplier Overflow value in percent, 18 decimals.\n     */\n    function updateMaxLiquidationMultiplier(uint256 _maxLiquidationMultiplier) external;\n\n    /**\n     * @dev Updates the contract's collateralization ratio.\n     * @param _minimumCollateralizationRatio The new minimum collateralization ratio as a raw value\n     * for a FixedPoint.Unsigned.\n     */\n    function updateMinimumCollateralizationRatio(uint256 _minimumCollateralizationRatio) external;\n\n    /**\n     * @dev Updates the contract's minimum debt value.\n     * @param _minimumDebtValue The new minimum debt value as a raw value for a FixedPoint.Unsigned.\n     */\n    function updateMinimumDebtValue(uint256 _minimumDebtValue) external;\n\n    /**\n     * @dev Updates the contract's liquidation threshold value\n     * @param _liquidationThreshold The new liquidation threshold value\n     */\n    function updateLiquidationThreshold(uint256 _liquidationThreshold) external;\n\n    /**\n     * @notice Sets the protocol AMM oracle address\n     * @param _ammOracle  The address of the oracle\n     */\n    function updateAMMOracle(address _ammOracle) external;\n\n    /**\n     * @notice Sets the decimal precision of external oracle\n     * @param _decimals Amount of decimals\n     */\n    function updateExtOracleDecimals(uint8 _decimals) external;\n}\n"
    },
    "src/contracts/minter/interfaces/IDepositWithdrawFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface IDepositWithdrawFacet {\n    function depositCollateral(address _account, address _collateralAsset, uint256 _amount) external;\n\n    function withdrawCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _amount,\n        uint256 _depositedCollateralAssetIndex\n    ) external;\n\n    function withdrawCollateralUnchecked(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _depositedCollateralAssetIndex,\n        bytes memory _userData\n    ) external;\n}\n"
    },
    "src/contracts/minter/interfaces/IInterestLiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface IInterestLiquidationFacet {\n    function batchLiquidateInterest(address _account, address _collateralAssetToSeize) external;\n\n    function liquidateInterest(address _account, address _repayKreskoAsset, address _collateralAssetToSeize) external;\n}\n"
    },
    "src/contracts/minter/interfaces/ILiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\n\ninterface ILiquidationFacet {\n    /**\n     * @notice Attempts to liquidate an account by repaying the portion of the account's Kresko asset\n     *         princpal debt, receiving in return a portion of the account's collateral at a discounted rate.\n     * @param _account The account to attempt to liquidate.\n     * @param _repayAsset The address of the Kresko asset to be repaid.\n     * @param _repayAmount The amount of the Kresko asset to be repaid.\n     * @param _seizeAsset The address of the collateral asset to be seized.\n     * @param _repayAssetIndex The index of the Kresko asset in the account's minted assets array.\n     * @param _seizeAssetIndex Index of the collateral asset in the account's collateral assets array.\n     */\n    function liquidate(\n        address _account,\n        address _repayAsset,\n        uint256 _repayAmount,\n        address _seizeAsset,\n        uint256 _repayAssetIndex,\n        uint256 _seizeAssetIndex\n    ) external;\n\n    /**\n     * @notice used execute _liquidateAssets.\n     * @param account The account to attempt to liquidate.\n     * @param repayAmount The amount of the Kresko asset to be repaid.\n     * @param seizeAmount The calculated amount of collateral assets to be seized.\n     * @param repayAsset The address of the Kresko asset to be repaid.\n     * @param repayIndex The index of the Kresko asset in the user's minted assets array.\n     * @param seizeAsset The address of the collateral asset to be seized.\n     * @param seizeAssetIndex The index of the collateral asset in the account's collateral assets array.\n     * @param collateralDeposits The index of the collateral asset in the account's collateral assets array.\n     */\n    struct ExecutionParams {\n        address account;\n        uint256 repayAmount;\n        uint256 seizeAmount;\n        address repayAsset;\n        uint256 repayAssetIndex;\n        address seizedAsset;\n        uint256 seizedAssetIndex;\n    }\n\n    /**\n     * @dev Calculates the total value that can be liquidated for a liquidation pair\n     * @param _account address to liquidate\n     * @param _repayKreskoAsset address of the kreskoAsset being repaid on behalf of the liquidatee\n     * @return maxLiquidatableUSD USD value that can be liquidated, 0 if the pair has no liquidatable value\n     */\n    function getMaxLiquidation(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize\n    ) external view returns (uint256 maxLiquidatableUSD);\n\n    /**\n     * @notice Calculates if an account's current collateral value is under its minimum collateral value\n     * @dev Returns true if the account's current collateral value is below the minimum collateral value\n     * required to consider the position healthy.\n     * @param _account The account to check.\n     * @return A boolean indicating if the account can be liquidated.\n     */\n    function isAccountLiquidatable(address _account) external view returns (bool);\n}\n"
    },
    "src/contracts/minter/interfaces/IMintFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface IMintFacet {\n    function mintKreskoAsset(address _account, address _kreskoAsset, uint256 _amount) external;\n}\n"
    },
    "src/contracts/minter/interfaces/ISafetyCouncilFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {Action, SafetyState, Pause} from \"../MinterTypes.sol\";\n\ninterface ISafetyCouncilFacet {\n    function toggleAssetsPaused(\n        address[] memory _assets,\n        Action _action,\n        bool _withDuration,\n        uint256 _duration\n    ) external;\n\n    function safetyStateSet() external view returns (bool);\n\n    function safetyStateFor(address _asset, Action _action) external view returns (SafetyState memory);\n}\n"
    },
    "src/contracts/minter/interfaces/IStabilityRateFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {StabilityRateParams} from \"../facets/StabilityRateFacet.sol\";\nimport {StabilityRateConfig} from \"../InterestRateState.sol\";\n\ninterface IStabilityRateFacet {\n    function setupStabilityRateParams(address _asset, StabilityRateParams memory _setup) external;\n\n    function updateStabilityRateParams(address _asset, StabilityRateParams memory _setup) external;\n\n    function updateStabilityRateAndIndexForAsset(address _asset) external;\n\n    function updateKiss(address _kiss) external;\n\n    function repayStabilityRateInterestPartial(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kissRepayAmount\n    ) external;\n\n    function repayFullStabilityRateInterest(\n        address _account,\n        address _kreskoAsset\n    ) external returns (uint256 kissRepayAmount);\n\n    function batchRepayFullStabilityRateInterest(address _account) external returns (uint256 kissRepayAmount);\n\n    function getStabilityRateForAsset(address _asset) external view returns (uint256 stabilityRate);\n\n    function getPriceRateForAsset(address _asset) external view returns (uint256 priceRate);\n\n    function getDebtIndexForAsset(address _asset) external view returns (uint256 debtIndex);\n\n    function getStabilityRateConfigurationForAsset(address _asset) external view returns (StabilityRateConfig memory);\n\n    function kiss() external view returns (address);\n\n    function getLastDebtIndexForAccount(address _account, address _asset) external view returns (uint128 lastDebtIndex);\n}\n"
    },
    "src/contracts/minter/interfaces/IStateFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\nimport {CollateralAsset, KrAsset, MinterParams} from \"../MinterTypes.sol\";\n\ninterface IStateFacet {\n    /// @notice The EIP-712 typehash for the contract's domain.\n    function domainSeparator() external view returns (bytes32);\n\n    /// @notice amount of times the minter has been initialized\n    function minterInitializations() external view returns (uint256);\n\n    /// @notice The recipient of protocol fees.\n    function feeRecipient() external view returns (address);\n\n    /// @notice The AMM oracle address.\n    function ammOracle() external view returns (address);\n\n    /// @notice Offchain oracle decimals\n    function extOracleDecimals() external view returns (uint8);\n\n    /// @notice The collateralization ratio at which positions may be liquidated.\n    function liquidationThreshold() external view returns (FixedPoint.Unsigned memory);\n\n    /// @notice The factor used to calculate the incentive a liquidator receives in the form of seized collateral.\n    function liquidationIncentiveMultiplier() external view returns (FixedPoint.Unsigned memory);\n\n    /// @notice Multiplies max liquidatable value, allowing liquidations to go over LT.\n    function maxLiquidationMultiplier() external view returns (FixedPoint.Unsigned memory);\n\n    /// @notice The minimum ratio of collateral to debt that can be taken by direct action.\n    function minimumCollateralizationRatio() external view returns (FixedPoint.Unsigned memory);\n\n    /// @notice The minimum USD value of an individual synthetic asset debt position.\n    function minimumDebtValue() external view returns (FixedPoint.Unsigned memory);\n\n    /// @notice simple check if kresko asset exists\n    function krAssetExists(address _krAsset) external view returns (bool);\n\n    /**\n     * @notice Get the state of a specific krAsset\n     * @param _asset Address of the asset.\n     * @return State of assets `KrAsset` struct\n     */\n    function kreskoAsset(address _asset) external view returns (KrAsset memory);\n\n    /// @notice Mapping of collateral asset token address to information on the collateral asset.\n    function collateralAsset(address _asset) external view returns (CollateralAsset memory);\n\n    /// @notice simple check if collateral asset exists\n    function collateralExists(address _collateralAsset) external view returns (bool);\n\n    /// @notice get all meaningful protocol parameters\n    function getAllParams() external view returns (MinterParams memory);\n\n    /**\n     * @notice Gets the USD value for a single collateral asset and amount.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _amount The amount of the collateral asset to calculate the value for.\n     * @param _ignoreCollateralFactor Boolean indicating if the asset's collateral factor should be ignored.\n     */\n    function getCollateralValueAndOraclePrice(\n        address _collateralAsset,\n        uint256 _amount,\n        bool _ignoreCollateralFactor\n    ) external view returns (FixedPoint.Unsigned memory, FixedPoint.Unsigned memory);\n\n    /**\n     * @notice Gets the USD value for a single Kresko asset and amount.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _amount The amount of the Kresko asset to calculate the value for.\n     * @param _ignoreKFactor Boolean indicating if the asset's k-factor should be ignored.\n     * @return The value for the provided amount of the Kresko asset.\n     */\n    function getKrAssetValue(\n        address _kreskoAsset,\n        uint256 _amount,\n        bool _ignoreKFactor\n    ) external view returns (FixedPoint.Unsigned memory);\n}\n"
    },
    "src/contracts/minter/interfaces/IUniswapV2Oracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface IUniswapV2Oracle {\n    function consultKrAsset(address _krAsset, uint256 _amount) external view returns (uint256 amountOut);\n\n    function consult(address _pair, address _token, uint256 _amountIn) external view returns (uint256 amountOut);\n\n    function initPair(address _pairAddress, address _krAsset, uint256 _updatePeriod) external;\n\n    function configurePair(address _pairAddress, uint256 _updatePeriod) external;\n\n    function update(address _pairAddress) external;\n\n    function krAssets(address) external returns (address);\n\n    function owner() external returns (address);\n\n    function factory() external returns (address);\n}\n"
    },
    "src/contracts/minter/libs/LibAccount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {MinterState} from \"../MinterState.sol\";\nimport {KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {RebaseMath, Rebase} from \"../../shared/Rebase.sol\";\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\n\nlibrary LibAccount {\n    using FixedPoint for FixedPoint.Unsigned;\n    using RebaseMath for uint256;\n    using WadRay for uint256;\n    using LibDecimals for FixedPoint.Unsigned;\n\n    /**\n     * @notice Gets an array of Kresko assets the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @return An array of addresses of Kresko assets the account has minted.\n     */\n    function getMintedKreskoAssets(\n        MinterState storage self,\n        address _account\n    ) internal view returns (address[] memory) {\n        return self.mintedKreskoAssets[_account];\n    }\n\n    /**\n     * @notice Gets an array of collateral assets the account has deposited.\n     * @param _account The account to get the deposited collateral assets for.\n     * @return An array of addresses of collateral assets the account has deposited.\n     */\n    function getDepositedCollateralAssets(\n        MinterState storage self,\n        address _account\n    ) internal view returns (address[] memory) {\n        return self.depositedCollateralAssets[_account];\n    }\n\n    /**\n     * @notice Get deposited collateral asset amount for an account\n     * @notice Performs rebasing conversion for KreskoAssets\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return uint256 amount of collateral for `_asset`\n     */\n    function getCollateralDeposits(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256) {\n        return self.collateralAssets[_asset].toRebasingAmount(self.collateralDeposits[_account][_asset]);\n    }\n\n    /**\n     * @notice Checks if accounts collateral value is less than required.\n     * @param _account The account to check.\n     * @return A boolean indicating if the account can be liquidated.\n     */\n    function isAccountLiquidatable(MinterState storage self, address _account) internal view returns (bool) {\n        return\n            self.getAccountCollateralValue(_account).isLessThan(\n                self.getAccountMinimumCollateralValueAtRatio(_account, self.liquidationThreshold)\n            );\n    }\n\n    /**\n     * @notice Overload for calculating liquidatable status with a future liquidated collateral value\n     * @param _account The account to check.\n     * @param _valueLiquidated Value liquidated, eg. in a batch liquidation\n     * @return bool indicating if the account can be liquidated.\n     */\n    function isAccountLiquidatable(\n        MinterState storage self,\n        address _account,\n        FixedPoint.Unsigned memory _valueLiquidated\n    ) internal view returns (bool) {\n        return\n            self.getAccountCollateralValue(_account).sub(_valueLiquidated).isLessThan(\n                self.getAccountMinimumCollateralValueAtRatio(_account, self.liquidationThreshold)\n            );\n    }\n\n    /**\n     * @notice Gets the collateral value of a particular account.\n     * @dev O(# of different deposited collateral assets by account) complexity.\n     * @param _account The account to calculate the collateral value for.\n     * @return totalCollateralValue The collateral value of a particular account.\n     */\n    function getAccountCollateralValue(\n        MinterState storage self,\n        address _account\n    ) internal view returns (FixedPoint.Unsigned memory totalCollateralValue) {\n        address[] memory assets = self.depositedCollateralAssets[_account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            (FixedPoint.Unsigned memory collateralValue, ) = self.getCollateralValueAndOraclePrice(\n                asset,\n                self.getCollateralDeposits(_account, asset),\n                false // Take the collateral factor into consideration.\n            );\n            totalCollateralValue = totalCollateralValue.add(collateralValue);\n        }\n\n        return totalCollateralValue;\n    }\n\n    /**\n     * @notice Gets the collateral value of a particular account including extra return value for specific collateral.\n     * @dev O(# of different deposited collateral assets by account) complexity.\n     * @param _account The account to calculate the collateral value for.\n     * @param _collateralAsset The collateral asset to get the collateral value.\n     * @return totalCollateralValue The collateral value of a particular account.\n     */\n    function getAccountCollateralValue(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset\n    )\n        internal\n        view\n        returns (FixedPoint.Unsigned memory totalCollateralValue, FixedPoint.Unsigned memory specificValue)\n    {\n        address[] memory assets = self.depositedCollateralAssets[_account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            (FixedPoint.Unsigned memory collateralValue, ) = self.getCollateralValueAndOraclePrice(\n                asset,\n                self.getCollateralDeposits(_account, asset),\n                false // Take the collateral factor into consideration.\n            );\n            totalCollateralValue = totalCollateralValue.add(collateralValue);\n            if (asset == _collateralAsset) {\n                specificValue = collateralValue;\n            }\n        }\n    }\n\n    /**\n     * @notice Gets accounts min collateral value required to cover debt at a given collateralization ratio.\n     * @dev 1. Account with min collateral value under MCR will not borrow.\n     *      2. Account with min collateral value under LT can be liquidated.\n     * @param _account The account to calculate the minimum collateral value for.\n     * @param _ratio The collateralization ratio to get min collateral value against.\n     * @return The min collateral value at given collateralization ratio for the account.\n     */\n    function getAccountMinimumCollateralValueAtRatio(\n        MinterState storage self,\n        address _account,\n        FixedPoint.Unsigned memory _ratio\n    ) internal view returns (FixedPoint.Unsigned memory) {\n        return self.getAccountKrAssetValue(_account).mul(_ratio);\n    }\n\n    /**\n     * @notice Gets the total KreskoAsset value in USD for an account.\n     * @param _account The account to calculate the KreskoAsset value for.\n     * @return value The KreskoAsset value of the account.\n     */\n    function getAccountKrAssetValue(\n        MinterState storage self,\n        address _account\n    ) internal view returns (FixedPoint.Unsigned memory value) {\n        address[] memory assets = self.mintedKreskoAssets[_account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            value = value.add(self.getKrAssetValue(asset, self.getKreskoAssetDebtScaled(_account, asset), false));\n        }\n        return value;\n    }\n\n    /**\n     * @notice Get accounts interested scaled debt amount for a KreskoAsset.\n     * @param _asset The asset address\n     * @param _account The account to get the amount for\n     * @return Amount of scaled debt.\n     */\n    function getKreskoAssetDebtScaled(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256) {\n        uint256 debt = self.kreskoAssets[_asset].toRebasingAmount(irs().srUserInfo[_account][_asset].debtScaled);\n        if (debt == 0) {\n            return 0;\n        }\n\n        return debt.rayMul(irs().srAssets[_asset].getNormalizedDebtIndex()).rayToWad();\n    }\n\n    /**\n     * @notice Get `_account` principal debt amount for `_asset`\n     * @dev Principal debt is rebase adjusted due to possible stock splits/reverse splits\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of principal debt for `_asset`\n     */\n    function getKreskoAssetDebtPrincipal(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256) {\n        return self.kreskoAssets[_asset].toRebasingAmount(self.kreskoAssetDebt[_account][_asset]);\n    }\n\n    /**\n     * @notice Get the total interest accrued on top of debt: Scaled Debt - Principal Debt\n     * @return assetAmount Interest denominated in _asset\n     * @return kissAmount Interest denominated in KISS. Ignores K-factor: $1 of interest = 1 KISS\n     **/\n    function getKreskoAssetDebtInterest(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256 assetAmount, uint256 kissAmount) {\n        assetAmount =\n            self.getKreskoAssetDebtScaled(_account, _asset) -\n            self.getKreskoAssetDebtPrincipal(_account, _asset);\n        kissAmount = self.getKrAssetValue(_asset, assetAmount, true).fromFixedPointPriceToWad();\n    }\n\n    /**\n     * @notice Gets an index for the Kresko asset the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @param _kreskoAsset The asset lookup address.\n     * @return i = index of the minted Kresko asset.\n     */\n    function getMintedKreskoAssetsIndex(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset\n    ) internal view returns (uint256 i) {\n        uint256 length = self.mintedKreskoAssets[_account].length;\n        require(length > 0, Error.NO_KRASSETS_MINTED);\n        for (i; i < length; i++) {\n            if (self.mintedKreskoAssets[_account][i] == _kreskoAsset) {\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Gets an index for the collateral asset the account has deposited.\n     * @param _account The account to get the index for.\n     * @param _collateralAsset The asset lookup address.\n     * @return i = index of the minted collateral asset.\n     */\n    function getDepositedCollateralAssetIndex(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset\n    ) internal view returns (uint256 i) {\n        uint256 length = self.depositedCollateralAssets[_account].length;\n        require(length > 0, Error.NO_COLLATERAL_DEPOSITS);\n        for (i; i < length; i++) {\n            if (self.depositedCollateralAssets[_account][i] == _collateralAsset) {\n                break;\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibAssetUtility.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {CollateralAsset, KrAsset} from \"../MinterTypes.sol\";\nimport {LibDecimals, FixedPoint} from \"../libs/LibDecimals.sol\";\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\n\n/**\n * @title LibAssetUtility\n * @author Kresko\n * @notice Utility functions for KrAsset and CollateralAsset structs\n */\nlibrary LibAssetUtility {\n    using FixedPoint for int256;\n    using FixedPoint for uint256;\n    using WadRay for uint256;\n    using FixedPoint for FixedPoint.Unsigned;\n    using LibDecimals for int256;\n\n    /**\n     * @notice Amount of non rebasing tokens -> amount of rebasing tokens\n     * @param self the kresko asset struct\n     * @param _nonRebasedAmount the amount to convert\n     */\n    function toRebasingAmount(KrAsset memory self, uint256 _nonRebasedAmount) internal view returns (uint256) {\n        return IKreskoAssetAnchor(self.anchor).convertToAssets(_nonRebasedAmount);\n    }\n\n    /**\n     * @notice Amount of non rebasing tokens -> amount of rebasing tokens\n     * @dev if collateral is not a kresko asset, returns the input\n     * @param self the collateral asset struct\n     * @param _nonRebasedAmount the amount to convert\n     */\n    function toRebasingAmount(CollateralAsset memory self, uint256 _nonRebasedAmount) internal view returns (uint256) {\n        if (self.anchor == address(0)) return _nonRebasedAmount;\n        return IKreskoAssetAnchor(self.anchor).convertToAssets(_nonRebasedAmount);\n    }\n\n    /**\n     * @notice Amount of rebasing tokens -> amount of non rebasing tokens\n     * @param self the kresko asset struct\n     * @param _maybeRebasedAmount the amount to convert\n     */\n    function toNonRebasingAmount(KrAsset memory self, uint256 _maybeRebasedAmount) internal view returns (uint256) {\n        return IKreskoAssetAnchor(self.anchor).convertToShares(_maybeRebasedAmount);\n    }\n\n    /**\n     * @notice Amount of rebasing tokens -> amount of non rebasing tokens\n     * @dev if collateral is not a kresko asset, returns the input\n     * @param self the collateral asset struct\n     * @param _maybeRebasedAmount the amount to convert\n     */\n    function toNonRebasingAmount(\n        CollateralAsset memory self,\n        uint256 _maybeRebasedAmount\n    ) internal view returns (uint256) {\n        if (self.anchor == address(0)) return _maybeRebasedAmount;\n        return IKreskoAssetAnchor(self.anchor).convertToShares(_maybeRebasedAmount);\n    }\n\n    /**\n     * @notice Get the oracle price of a collateral asset in uint256 with extOracleDecimals\n     */\n    function uintPrice(CollateralAsset memory self) internal view returns (uint256) {\n        return uint256(self.oracle.latestAnswer());\n    }\n\n    /**\n     * @notice Get the oracle price of a kresko asset in uint256 with extOracleDecimals\n     */\n    function uintPrice(KrAsset memory self) internal view returns (uint256) {\n        return uint256(self.oracle.latestAnswer());\n    }\n\n    /**\n     * @notice Get the oracle price of a collateral asset in uint256 with 18 decimals\n     */\n    function wadPrice(CollateralAsset memory self) internal view returns (uint256) {\n        return self.oracle.latestAnswer().oraclePriceToWad();\n    }\n\n    /**\n     * @notice Get the oracle price of a kresko asset in uint256 with 18 decimals\n     */\n    function wadPrice(KrAsset memory self) internal view returns (uint256) {\n        return self.oracle.latestAnswer().oraclePriceToWad();\n    }\n\n    /**\n     * @notice Get the oracle price of a collateral asset in FixedPoint.Unsigned\n     */\n    function fixedPointPrice(CollateralAsset memory self) internal view returns (FixedPoint.Unsigned memory) {\n        return self.oracle.latestAnswer().toFixedPoint();\n    }\n\n    /**\n     * @notice Get the oracle price of a kresko asset in FixedPoint.Unsigned\n     */\n    function fixedPointPrice(KrAsset memory self) internal view returns (FixedPoint.Unsigned memory) {\n        return self.oracle.latestAnswer().toFixedPoint();\n    }\n\n    /**\n     * @notice Get value for @param _assetAmount of @param self in uint256\n     */\n    function uintUSD(CollateralAsset memory self, uint256 _assetAmount) internal view returns (uint256) {\n        return self.uintPrice().wadMul(_assetAmount);\n    }\n\n    /**\n     * @notice Get value for @param _assetAmount of @param self in uint256\n     */\n    function uintUSD(KrAsset memory self, uint256 _assetAmount) internal view returns (uint256) {\n        return self.uintPrice().wadMul(_assetAmount);\n    }\n\n    /**\n     * @notice Get value for @param _assetAmount of @param self in FixedPoint.Unsigned\n     */\n    function fixedPointUSD(\n        CollateralAsset memory self,\n        uint256 _assetAmount\n    ) internal view returns (FixedPoint.Unsigned memory) {\n        return self.fixedPointPrice().mul(_assetAmount.toFixedPoint());\n    }\n\n    /**\n     * @notice Get value for @param _assetAmount of @param self in FixedPoint.Unsigned\n     */\n    function fixedPointUSD(\n        KrAsset memory self,\n        uint256 _assetAmount\n    ) internal view returns (FixedPoint.Unsigned memory) {\n        return self.fixedPointPrice().mul(_assetAmount.toFixedPoint());\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibCalculation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {MinterState} from \"../MinterState.sol\";\nimport {KrAsset, CollateralAsset, Constants} from \"../MinterTypes.sol\";\n\n/**\n * @title Calculation library for liquidation & fee values\n * @author Kresko\n */\nlibrary LibCalculation {\n    struct MaxLiquidationVars {\n        CollateralAsset collateral;\n        uint256 accountCollateralValue;\n        uint256 minCollateralValue;\n        uint256 seizeCollateralAccountValue;\n        uint256 maxLiquidationMultiplier;\n        uint256 minimumDebtValue;\n        uint256 liquidationThreshold;\n        uint256 debtFactor;\n    }\n\n    using Arrays for address[];\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n\n    using FixedPoint for FixedPoint.Unsigned;\n\n    /**\n     * @dev Calculates the total value that can be liquidated for a liquidation pair\n     * @param _account address to liquidate\n     * @param _repayKreskoAsset address of the kreskoAsset being repaid on behalf of the liquidatee\n     * @param _seizedCollateral The collateral asset being seized in the liquidation\n     * @return maxLiquidatableUSD USD value that can be liquidated, 0 if the pair has no liquidatable value\n     */\n    function getMaxLiquidation(\n        MinterState storage self,\n        address _account,\n        KrAsset memory _repayKreskoAsset,\n        address _seizedCollateral\n    ) internal view returns (uint256 maxLiquidatableUSD) {\n        MaxLiquidationVars memory vars = _getMaxLiquidationParams(self, _account, _repayKreskoAsset, _seizedCollateral);\n        // Account is not liquidatable\n        if (vars.accountCollateralValue >= (vars.minCollateralValue)) {\n            return 0;\n        }\n\n        maxLiquidatableUSD = _getMaxLiquidatableUSD(vars, _repayKreskoAsset);\n\n        if (vars.seizeCollateralAccountValue < maxLiquidatableUSD) {\n            return vars.seizeCollateralAccountValue;\n        } else if (maxLiquidatableUSD < vars.minimumDebtValue) {\n            return vars.minimumDebtValue;\n        }\n        return maxLiquidatableUSD;\n    }\n\n    /**\n     * @notice Calculate amount of collateral to seize during the liquidation procesself.\n     * @param _liquidationIncentiveMultiplier The liquidation incentive multiplier.\n     * @param _collateralOraclePriceUSD The address of the collateral asset to be seized.\n     * @param _kreskoAssetRepayAmountUSD Kresko asset amount being repaid in exchange for the seized collateral.\n     */\n    function calculateAmountToSeize(\n        FixedPoint.Unsigned memory _liquidationIncentiveMultiplier,\n        uint256 _collateralOraclePriceUSD,\n        uint256 _kreskoAssetRepayAmountUSD\n    ) internal pure returns (uint256) {\n        // Seize amount = (repay amount USD * liquidation incentive / collateral price USD).\n        // Denominate seize amount in collateral type\n        // Apply liquidation incentive multiplier\n        return\n            _kreskoAssetRepayAmountUSD.wadMul(_liquidationIncentiveMultiplier.rawValue).wadDiv(\n                _collateralOraclePriceUSD\n            );\n    }\n\n    /**\n     * @notice Calculates the fee to be taken from a user's deposited collateral assetself.\n     * @param _collateralAsset The collateral asset from which to take to the fee.\n     * @param _account The owner of the collateral.\n     * @param _feeValue The original value of the fee.\n     * @param _collateralAssetIndex The collateral asset's index in the user's depositedCollateralAssets array.\n     *\n     * @return transferAmount to be received as a uint256\n     * @return feeValuePaid FixedPoint.Unsigned representing the fee value paid.\n     */\n    function calcFee(\n        MinterState storage self,\n        address _collateralAsset,\n        address _account,\n        uint256 _feeValue,\n        uint256 _collateralAssetIndex\n    ) internal returns (uint256 transferAmount, uint256 feeValuePaid) {\n        uint256 depositAmount = self.getCollateralDeposits(_account, _collateralAsset);\n\n        // Don't take the collateral asset's collateral factor into consideration.\n        (FixedPoint.Unsigned memory depositValue, FixedPoint.Unsigned memory oraclePrice) = self\n            .getCollateralValueAndOraclePrice(_collateralAsset, depositAmount, true);\n\n        // If feeValue < depositValue, the entire fee can be charged for this collateral asset.\n        if (_feeValue < depositValue.rawValue) {\n            // We want to make sure that transferAmount is < depositAmount.\n            // Proof:\n            //   depositValue <= oraclePrice * depositAmount (<= due to a potential loss of precision)\n            //   feeValue < depositValue\n            // Meaning:\n            //   feeValue < oraclePrice * depositAmount\n            // Solving for depositAmount we get:\n            //   feeValue / oraclePrice < depositAmount\n            // Due to integer division:\n            //   transferAmount = floor(feeValue / oracleValue)\n            //   transferAmount <= feeValue / oraclePrice\n            // We see that:\n            //   transferAmount <= feeValue / oraclePrice < depositAmount\n            //   transferAmount < depositAmount\n            transferAmount = self.collateralAssets[_collateralAsset].decimals.fromCollateralFixedPointAmount(\n                _feeValue.wadDiv(oraclePrice.rawValue)\n            );\n            feeValuePaid = _feeValue;\n        } else {\n            // If the feeValue >= depositValue, the entire deposit\n            // should be taken as the fee.\n            transferAmount = depositAmount;\n            feeValuePaid = depositValue.rawValue;\n            // Because the entire deposit is taken, remove it from the depositCollateralAssets array.\n            self.depositedCollateralAssets[_account].removeAddress(_collateralAsset, _collateralAssetIndex);\n        }\n\n        return (transferAmount, feeValuePaid);\n    }\n\n    /**\n     * @notice Calculates the maximum USD value of a given kreskoAsset that can be liquidated given a liquidation pair\n     *\n     * 1. Calculates the value gained per USD repaid in liquidation for a given kreskoAsset\n     *\n     * debtFactor = debtFactor = k * LT / cFactor;\n     *\n     * valPerUSD = (DebtFactor - Asset closeFee - liquidationIncentive) / DebtFactor\n     *\n     * 2. Calculates the maximum amount of USD value that can be liquidated given the account's collateral value\n     *\n     * maxLiquidatableUSD = (MCV - ACV) / valPerUSD / debtFactor / cFactor * LOM\n     *\n     * @dev This function is used by getMaxLiquidation and is factored out for readability\n     * @param vars liquidation variables struct\n     * @param _repayKreskoAsset The kreskoAsset being repaid in the liquidation\n     */\n    function _getMaxLiquidatableUSD(\n        MaxLiquidationVars memory vars,\n        KrAsset memory _repayKreskoAsset\n    ) private pure returns (uint256) {\n        uint256 valuePerUSDRepaid = (vars.debtFactor -\n            vars.collateral.liquidationIncentive.rawValue -\n            _repayKreskoAsset.closeFee.rawValue).wadDiv(vars.debtFactor);\n        return\n            (vars.minCollateralValue - vars.accountCollateralValue)\n                .wadDiv(valuePerUSDRepaid)\n                .wadDiv(vars.debtFactor)\n                .wadDiv(vars.collateral.factor.rawValue)\n                .wadMul(vars.maxLiquidationMultiplier);\n    }\n\n    function _getMaxLiquidationParams(\n        MinterState storage state,\n        address _account,\n        KrAsset memory _repayKreskoAsset,\n        address _seizedCollateral\n    ) private view returns (MaxLiquidationVars memory) {\n        FixedPoint.Unsigned memory liquidationThreshold = state.liquidationThreshold;\n        FixedPoint.Unsigned memory minCollateralValue = state.getAccountMinimumCollateralValueAtRatio(\n            _account,\n            liquidationThreshold\n        );\n\n        (\n            FixedPoint.Unsigned memory accountCollateralValue,\n            FixedPoint.Unsigned memory seizeCollateralAccountValue\n        ) = state.getAccountCollateralValue(_account, _seizedCollateral);\n\n        CollateralAsset memory collateral = state.collateralAssets[_seizedCollateral];\n\n        return\n            MaxLiquidationVars({\n                collateral: collateral,\n                accountCollateralValue: accountCollateralValue.rawValue,\n                // debtFactor = k * LT / cFactor\n                debtFactor: _repayKreskoAsset.kFactor.rawValue.wadMul(liquidationThreshold.rawValue).wadDiv(\n                    collateral.factor.rawValue\n                ),\n                minCollateralValue: minCollateralValue.rawValue,\n                minimumDebtValue: state.minimumDebtValue.rawValue,\n                seizeCollateralAccountValue: seizeCollateralAccountValue.rawValue,\n                liquidationThreshold: liquidationThreshold.rawValue,\n                maxLiquidationMultiplier: Constants.MIN_MAX_LIQUIDATION_MULTIPLIER\n            });\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibCollateral.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {AggregatorV2V3Interface} from \"../../vendor/flux/interfaces/AggregatorV2V3Interface.sol\";\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {CollateralAsset} from \"../MinterTypes.sol\";\nimport {MinterState} from \"../MinterState.sol\";\n\n/**\n * @title Library for collateral related operations\n * @author Kresko\n */\nlibrary LibCollateral {\n    using FixedPoint for FixedPoint.Unsigned;\n    using LibDecimals for uint8;\n    using Arrays for address[];\n    using WadRay for uint256;\n\n    /**\n     * In case a collateral asset is also a kresko asset, convert an amount to anchor shares\n     * @param _amount amount to possibly convert\n     * @param _collateralAsset address of the collateral asset\n     */\n    function normalizeCollateralAmount(\n        MinterState storage self,\n        uint256 _amount,\n        address _collateralAsset\n    ) internal view returns (uint256 amount) {\n        CollateralAsset memory asset = self.collateralAssets[_collateralAsset];\n        if (asset.anchor != address(0)) {\n            return IKreskoAssetAnchor(asset.anchor).convertToShares(_amount);\n        }\n        return _amount;\n    }\n\n    /**\n     * @notice Get the state of a specific collateral asset\n     * @param _asset Address of the asset.\n     * @return State of assets `CollateralAsset` struct\n     */\n    function collateralAsset(MinterState storage self, address _asset) internal view returns (CollateralAsset memory) {\n        return self.collateralAssets[_asset];\n    }\n\n    /**\n     * @notice Gets the collateral value for a single collateral asset and amount.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _amount The amount of the collateral asset to calculate the collateral value for.\n     * @param _ignoreCollateralFactor Boolean indicating if the asset's collateral factor should be ignored.\n     * @return The collateral value for the provided amount of the collateral asset.\n     */\n    function getCollateralValueAndOraclePrice(\n        MinterState storage self,\n        address _collateralAsset,\n        uint256 _amount,\n        bool _ignoreCollateralFactor\n    ) internal view returns (FixedPoint.Unsigned memory, FixedPoint.Unsigned memory) {\n        CollateralAsset memory asset = self.collateralAssets[_collateralAsset];\n\n        FixedPoint.Unsigned memory fixedPointAmount = asset.decimals.toCollateralFixedPointAmount(_amount);\n        FixedPoint.Unsigned memory oraclePrice = asset.fixedPointPrice();\n        FixedPoint.Unsigned memory value = fixedPointAmount.mul(oraclePrice);\n\n        if (!_ignoreCollateralFactor) {\n            value = value.mul(asset.factor);\n        }\n        return (value, oraclePrice);\n    }\n\n    function verifyAndRecordCollateralWithdrawal(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _collateralDeposits,\n        uint256 _depositedCollateralAssetIndex\n    ) internal {\n        require(_withdrawAmount > 0, Error.ZERO_WITHDRAW);\n        require(\n            _depositedCollateralAssetIndex <= self.depositedCollateralAssets[_account].length - 1,\n            Error.ARRAY_OUT_OF_BOUNDS\n        );\n\n        // Ensure that the operation passes checks MCR checks\n        verifyAccountCollateral(self, _account, _collateralAsset, _withdrawAmount);\n\n        // Record the withdrawal.\n        self.collateralDeposits[_account][_collateralAsset] = self\n            .collateralAssets[_collateralAsset]\n            .toNonRebasingAmount(_collateralDeposits - _withdrawAmount);\n\n        // If the user is withdrawing all of the collateral asset, remove the collateral asset\n        // from the user's deposited collateral assets array.\n        if (_withdrawAmount == _collateralDeposits) {\n            self.depositedCollateralAssets[_account].removeAddress(_collateralAsset, _depositedCollateralAssetIndex);\n        }\n\n        emit MinterEvent.CollateralWithdrawn(_account, _collateralAsset, _withdrawAmount);\n    }\n\n    /**\n     * @notice Records account as having deposited an amount of a collateral asset.\n     * @dev Token transfers are expected to be done by the caller.\n     * @param _account The address of the collateral asset.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _depositAmount The amount of the collateral asset deposited.\n     */\n    function recordCollateralDeposit(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _depositAmount\n    ) internal {\n        // Because the depositedCollateralAssets[_account] is pushed to if the existing\n        // deposit amount is 0, require the amount to be > 0. Otherwise, the depositedCollateralAssets[_account]\n        // could be filled with duplicates, causing collateral to be double-counted in the collateral value.\n        require(_depositAmount > 0, Error.ZERO_DEPOSIT);\n\n        // If the account does not have an existing deposit for this collateral asset,\n        // push it to the list of the account's deposited collateral assets.\n        uint256 existingDepositAmount = self.getCollateralDeposits(_account, _collateralAsset);\n        if (existingDepositAmount == 0) {\n            self.depositedCollateralAssets[_account].push(_collateralAsset);\n        }\n        // Record the deposit.\n        unchecked {\n            self.collateralDeposits[_account][_collateralAsset] = self\n                .collateralAssets[_collateralAsset]\n                .toNonRebasingAmount(existingDepositAmount + _depositAmount);\n        }\n\n        emit MinterEvent.CollateralDeposited(_account, _collateralAsset, _depositAmount);\n    }\n\n    function recordCollateralWithdrawal(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _collateralDeposits,\n        uint256 _depositedCollateralAssetIndex\n    ) internal {\n        require(_withdrawAmount > 0, Error.ZERO_WITHDRAW);\n        require(\n            _depositedCollateralAssetIndex <= self.depositedCollateralAssets[_account].length - 1,\n            Error.ARRAY_OUT_OF_BOUNDS\n        );\n        // ensure that the handler does not attempt to withdraw more collateral than the account has\n        require(_collateralDeposits >= _withdrawAmount, Error.COLLATERAL_INSUFFICIENT_AMOUNT);\n\n        // Record the withdrawal.\n        self.collateralDeposits[_account][_collateralAsset] = self\n            .collateralAssets[_collateralAsset]\n            .toNonRebasingAmount(_collateralDeposits - _withdrawAmount);\n\n        // If the user is withdrawing all of the collateral asset, remove the collateral asset\n        // from the user's deposited collateral assets array.\n        if (_withdrawAmount == _collateralDeposits) {\n            self.depositedCollateralAssets[_account].removeAddress(_collateralAsset, _depositedCollateralAssetIndex);\n        }\n\n        emit MinterEvent.UncheckedCollateralWithdrawn(_account, _collateralAsset, _withdrawAmount);\n    }\n\n    function verifyAccountCollateral(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount\n    ) internal view {\n        // Ensure the withdrawal does not result in the account having a collateral value\n        // under the minimum collateral amount required to maintain a healthy position.\n        // I.e. the new account's collateral value must still exceed the account's minimum\n        // collateral value.\n        // Get the account's current collateral value.\n        FixedPoint.Unsigned memory accountCollateralValue = self.getAccountCollateralValue(_account);\n        // Get the collateral value that the account will lose as a result of this withdrawal.\n        (FixedPoint.Unsigned memory withdrawnCollateralValue, ) = self.getCollateralValueAndOraclePrice(\n            _collateralAsset,\n            _withdrawAmount,\n            false // Take the collateral factor into consideration.\n        );\n        // Get the account's minimum collateral value.\n        FixedPoint.Unsigned memory accountMinCollateralValue = self.getAccountMinimumCollateralValueAtRatio(\n            _account,\n            self.minimumCollateralizationRatio\n        );\n        // Require accountMinCollateralValue <= accountCollateralValue - withdrawnCollateralValue.\n        require(\n            accountMinCollateralValue.isLessThanOrEqual(accountCollateralValue.sub(withdrawnCollateralValue)),\n            Error.COLLATERAL_INSUFFICIENT_AMOUNT\n        );\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibDecimals.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {ms} from \"../MinterStorage.sol\";\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\n\n/**\n * @title Library for Kresko specific decimals\n */\nlibrary LibDecimals {\n    using FixedPoint for FixedPoint.Unsigned;\n\n    /**\n     * @notice For a given collateral asset and amount, returns a FixedPoint.Unsigned representation.\n     * @dev If the collateral asset has decimals other than 18, the amount is scaled appropriately.\n     *   If decimals > 18, there may be a loss of precision.\n     * @param _collateralAssetDecimals The collateral asset's number of decimals\n     * @param _amount The amount of the collateral asset.\n     * @return A FixedPoint.Unsigned of amount scaled according to the collateral asset's decimals.\n     */\n    function toCollateralFixedPointAmount(\n        uint256 _collateralAssetDecimals,\n        uint256 _amount\n    ) internal pure returns (FixedPoint.Unsigned memory) {\n        // Initially, use the amount as the raw value for the FixedPoint.Unsigned,\n        // which internally uses FixedPoint.FP_DECIMALS (18) decimals. Most collateral\n        // assets will have 18 decimals.\n        FixedPoint.Unsigned memory fixedPointAmount = FixedPoint.Unsigned(_amount);\n        // Handle cases where the collateral asset's decimal amount is not 18.\n        if (_collateralAssetDecimals < FixedPoint.FP_DECIMALS) {\n            // If the decimals are less than 18, multiply the amount\n            // to get the correct fixed point value.\n            // E.g. 1 full token of a 17 decimal token will  cause the\n            // initial setting of amount to be 0.1, so we multiply\n            // by 10 ** (18 - 17) = 10 to get it to 0.1 * 10 = 1.\n            return fixedPointAmount.mul(10 ** (FixedPoint.FP_DECIMALS - _collateralAssetDecimals));\n        } else if (_collateralAssetDecimals > FixedPoint.FP_DECIMALS) {\n            // If the decimals are greater than 18, divide the amount\n            // to get the correct fixed point value.\n            // Note because FixedPoint numbers are 18 decimals, this results\n            // in loss of precision. E.g. if the collateral asset has 19\n            // decimals and the deposit amount is only 1 uint, this will divide\n            // 1 by 10 ** (19 - 18), resulting in 1 / 10 = 0\n            return fixedPointAmount.div(10 ** (_collateralAssetDecimals - FixedPoint.FP_DECIMALS));\n        }\n        return fixedPointAmount;\n    }\n\n    /**\n     * @notice For a given collateral asset and fixed point amount, i.e. where a rawValue of 1e18 is equal to 1\n     *   whole token, returns the amount according to the collateral asset's decimals.\n     * @dev If the collateral asset has decimals other than 18, the amount is scaled appropriately.\n     *   If decimals < 18, there may be a loss of precision.\n     * @param _collateralAssetDecimals The collateral asset's number of decimals\n     * @param _fixedPointAmount The fixed point amount of the collateral asset.\n     * @return An amount that is compatible with the collateral asset's decimals.\n     */\n    function fromCollateralFixedPointAmount(\n        uint256 _collateralAssetDecimals,\n        uint256 _fixedPointAmount\n    ) internal pure returns (uint256) {\n        // Initially, use the rawValue, which internally uses FixedPoint.FP_DECIMALS (18) decimals\n        // Most collateral assets will have 18 decimals.\n        // Handle cases where the collateral asset's decimal amount is not 18.\n        if (_collateralAssetDecimals < FixedPoint.FP_DECIMALS) {\n            // If the decimals are less than 18, divide the depositAmount\n            // to get the correct fixed point value.\n            // E.g. 1 full token will result in amount being 1e18 at this point,\n            // so if the token has 17 decimals, divide by 10 ** (18 - 17) = 10\n            // to get a value of 1e17.\n            // This may result in a loss of precision.\n            return _fixedPointAmount / (10 ** (FixedPoint.FP_DECIMALS - _collateralAssetDecimals));\n        } else if (_collateralAssetDecimals > FixedPoint.FP_DECIMALS) {\n            // If the decimals are greater than 18, multiply the depositAmount\n            // to get the correct fixed point value.\n            // E.g. 1 full token will result in amount being 1e18 at this point,\n            // so if the token has 19 decimals, multiply by 10 ** (19 - 18) = 10\n            // to get a value of 1e19.\n            return _fixedPointAmount * (10 ** (_collateralAssetDecimals - FixedPoint.FP_DECIMALS));\n        }\n        return _fixedPointAmount;\n    }\n\n    /**\n     * @notice Divides an uint256 @param _value with @param _priceWithOracleDecimals\n     * @param _value Left side value of the division\n     * @param wadValue result with 18 decimals\n     */\n    function divByPrice(uint256 _value, uint256 _priceWithOracleDecimals) internal view returns (uint256 wadValue) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals >= 18) return _priceWithOracleDecimals;\n        return (_value / _priceWithOracleDecimals) * 10 ** (oracleDecimals);\n    }\n\n    /**\n     * @notice Converts an uint256 with extOracleDecimals into a number with 18 decimals\n     * @param _wadPrice value with extOracleDecimals\n     */\n    function fromWadPriceToUint(uint256 _wadPrice) internal view returns (uint256 priceWithOracleDecimals) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals == 18) return _wadPrice;\n        return _wadPrice / 10 ** (18 - oracleDecimals);\n    }\n\n    /**\n     * @notice Converts an 18 decimal price to a FixedPoint with extOracleDecimals\n     * @param _wadPrice value with extOracleDecimals\n     * @return priceWithOracleDecimals FixedPoint value with extOracleDecimals\n     */\n    function fromWadPriceToFixedPoint(\n        uint256 _wadPrice\n    ) internal view returns (FixedPoint.Unsigned memory priceWithOracleDecimals) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals == 18) {\n            return FixedPoint.Unsigned(_wadPrice);\n        }\n        return FixedPoint.Unsigned(_wadPrice / 10 ** (18 - oracleDecimals));\n    }\n\n    /**\n     * @notice Converts an uint256 with extOracleDecimals into a number with 18 decimals\n     * @param _priceWithOracleDecimals value with extOracleDecimals\n     * @return wadPrice price with 18 decimals\n     */\n    function oraclePriceToWad(uint256 _priceWithOracleDecimals) internal view returns (uint256 wadPrice) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals == 18) {\n            return _priceWithOracleDecimals;\n        }\n        return _priceWithOracleDecimals * 10 ** (18 - oracleDecimals);\n    }\n\n    /**\n     * @notice Converts an int256 with extOracleDecimals into a number with 18 decimals\n     * @param _priceWithOracleDecimals value with extOracleDecimals\n     * @return wadPrice price with 18 decimals\n     */\n    function oraclePriceToWad(int256 _priceWithOracleDecimals) internal view returns (uint256 wadPrice) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals >= 18) return uint256(_priceWithOracleDecimals);\n        return uint256(_priceWithOracleDecimals) * 10 ** (18 - oracleDecimals);\n    }\n\n    /**\n     * @notice Converts an int256 with extOracleDecimals into a number with 18 decimals\n     * @param _priceWithOracleDecimals value with extOracleDecimals\n     * @return wadPrice price with 18 decimals\n     */\n    function fromFixedPointPriceToWad(\n        FixedPoint.Unsigned memory _priceWithOracleDecimals\n    ) internal view returns (uint256 wadPrice) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals == 18) return _priceWithOracleDecimals.rawValue;\n        return _priceWithOracleDecimals.rawValue * 10 ** (18 - oracleDecimals);\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibKrAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {IUniswapV2Oracle} from \"../interfaces/IUniswapV2Oracle.sol\";\nimport {KrAsset} from \"../MinterTypes.sol\";\nimport {MinterState} from \"../MinterState.sol\";\n\nlibrary LibKrAsset {\n    using FixedPoint for FixedPoint.Unsigned;\n    using FixedPoint for uint256;\n    using WadRay for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Functions                                 */\n    /* -------------------------------------------------------------------------- */\n    /**\n     * @notice Get the state of a specific krAsset\n     * @param _asset Address of the asset.\n     * @return State of assets `KrAsset` struct\n     */\n    function kreskoAsset(MinterState storage self, address _asset) internal view returns (KrAsset memory) {\n        return self.kreskoAssets[_asset];\n    }\n\n    /**\n     * @notice Gets the USD value for a single Kresko asset and amount.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _amount The amount of the Kresko asset to calculate the value for.\n     * @param _ignoreKFactor Boolean indicating if the asset's k-factor should be ignored.\n     * @return The value for the provided amount of the Kresko asset.\n     */\n    function getKrAssetValue(\n        MinterState storage self,\n        address _kreskoAsset,\n        uint256 _amount,\n        bool _ignoreKFactor\n    ) internal view returns (FixedPoint.Unsigned memory) {\n        KrAsset memory krAsset = self.kreskoAssets[_kreskoAsset];\n        FixedPoint.Unsigned memory value = krAsset.fixedPointUSD(_amount);\n\n        if (!_ignoreKFactor) {\n            value = FixedPoint.Unsigned(value.rawValue.wadMul(krAsset.kFactor.rawValue));\n        }\n\n        return value;\n    }\n\n    function getKrAssetAMMPrice(\n        MinterState storage self,\n        address _kreskoAsset,\n        uint256 _amount\n    ) internal view returns (FixedPoint.Unsigned memory) {\n        if (self.ammOracle == address(0)) {\n            return FixedPoint.Unsigned(0);\n        }\n        return IUniswapV2Oracle(self.ammOracle).consultKrAsset(_kreskoAsset, _amount).toFixedPoint();\n    }\n\n    /**\n     * @notice Get the minimum collateral value required to\n     * back a Kresko asset amount at a given collateralization ratio.\n     * @param _krAsset The address of the Kresko asset.\n     * @param _amount The Kresko Asset debt amount.\n     * @return minCollateralValue is the minimum collateral value required for this Kresko Asset amount.\n     * @param _ratio The collateralization ratio required: higher ratio = more collateral required.\n     */\n    function getMinimumCollateralValueAtRatio(\n        MinterState storage self,\n        address _krAsset,\n        uint256 _amount,\n        FixedPoint.Unsigned memory _ratio\n    ) internal view returns (FixedPoint.Unsigned memory minCollateralValue) {\n        // Calculate the collateral value required to back this Kresko asset amount at the given ratio\n        return self.getKrAssetValue(_krAsset, _amount, false).mul(_ratio);\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibMint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n// solhint-disable not-rely-on-time\n// solhint-disable-next-line\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\n\nimport {LibCalculation} from \"./LibCalculation.sol\";\nimport {KrAsset} from \"../MinterTypes.sol\";\nimport {MinterState} from \"../MinterState.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\nlibrary LibMint {\n    using Arrays for address[];\n\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n\n    using FixedPoint for FixedPoint.Unsigned;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using LibCalculation for MinterState;\n\n    /// @notice Mint kresko assets with stability rate updates.\n    /// @dev Updates the principal in MinterState and stability rate adjusted values in InterestRateState\n    /// @param _kreskoAsset the asset being repaid\n    /// @param _anchor the anchor token of the asset being repaid\n    /// @param _amount the asset amount being burned\n    /// @param _account the account the debt is subtracted from\n    function mint(\n        MinterState storage self,\n        address _kreskoAsset,\n        address _anchor,\n        uint256 _amount,\n        address _account\n    ) internal {\n        // Update global debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n        // Get possibly rebalanced amount of kresko asset\n        uint256 issued = IKreskoAssetIssuer(_anchor).issue(_amount, _account);\n        // Calculate debt index scaled value\n        uint256 amountScaled = issued.wadToRay().rayDiv(newDebtIndex);\n        require(amountScaled != 0, Error.INVALID_SCALED_AMOUNT);\n        // Increase principal debt\n        self.kreskoAssetDebt[_account][_kreskoAsset] += issued;\n        // Update scaled values for the user\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled += uint128(amountScaled);\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n        // Update the global rate for the asset\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n    }\n\n    /**\n     * @notice Charges the protocol open fee based off the value of the minted asset.\n     * @dev Takes the fee from the account's collateral assets. Attempts collateral assets\n     *   in reverse order of the account's deposited collateral assets array.\n     * @param _account The account to charge the open fee from.\n     * @param _kreskoAsset The address of the kresko asset being burned.\n     * @param _kreskoAssetAmountMinted The amount of the kresko asset being minted.\n     */\n    function chargeOpenFee(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset,\n        uint256 _kreskoAssetAmountMinted\n    ) internal {\n        KrAsset memory krAsset = self.kreskoAssets[_kreskoAsset];\n        // Calculate the value of the fee according to the value of the krAssets being minted.\n        uint256 feeValue = krAsset.uintUSD(_kreskoAssetAmountMinted).wadMul(krAsset.openFee.rawValue);\n\n        // Do nothing if the fee value is 0.\n        if (feeValue == 0) {\n            return;\n        }\n\n        address[] memory accountCollateralAssets = self.depositedCollateralAssets[_account];\n        // Iterate backward through the account's deposited collateral assets to safely\n        // traverse the array while still being able to remove elements if necessary.\n        // This is because removing the last element of the array does not shift around\n        // other elements in the array.\n        for (uint256 i = accountCollateralAssets.length - 1; i >= 0; i--) {\n            address collateralAssetAddress = accountCollateralAssets[i];\n\n            (uint256 transferAmount, uint256 feeValuePaid) = self.calcFee(\n                collateralAssetAddress,\n                _account,\n                feeValue,\n                i\n            );\n\n            // Remove the transferAmount from the stored deposit for the account.\n            self.collateralDeposits[_account][collateralAssetAddress] -= self\n                .collateralAssets[collateralAssetAddress]\n                .toNonRebasingAmount(transferAmount);\n\n            // Transfer the fee to the feeRecipient.\n            IERC20Upgradeable(collateralAssetAddress).safeTransfer(self.feeRecipient, transferAmount);\n            emit MinterEvent.OpenFeePaid(_account, collateralAssetAddress, transferAmount, feeValuePaid);\n\n            feeValue = feeValue - feeValuePaid;\n            // If the entire fee has been paid, no more action needed.\n            if (feeValue == 0) {\n                return;\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibRepay.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n// solhint-disable not-rely-on-time\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {MinterEvent, InterestRateEvent} from \"../../libs/Events.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\nimport {IERC20Upgradeable} from \"../../shared/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"../../shared/SafeERC20Upgradeable.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\n\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {LibCalculation} from \"./LibCalculation.sol\";\nimport {KrAsset} from \"../MinterTypes.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {MinterState} from \"../MinterState.sol\";\n\nlibrary LibRepay {\n    using Arrays for address[];\n\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n\n    using FixedPoint for FixedPoint.Unsigned;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using LibCalculation for MinterState;\n\n    /// @notice Repay user kresko asset debt with stability rate updates.\n    /// @dev Updates the principal in MinterState and stability rate adjusted values in InterestRateState\n    /// @param _kreskoAsset the asset being repaid\n    /// @param _anchor the anchor token of the asset being repaid\n    /// @param _burnAmount the asset amount being burned\n    /// @param _account the account the debt is subtracted from\n    function repay(\n        MinterState storage self,\n        address _kreskoAsset,\n        address _anchor,\n        uint256 _burnAmount,\n        address _account\n    ) internal {\n        // Update global debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n        // Get the possibly rebalanced amount of destroyed tokens\n        uint256 destroyed = IKreskoAssetIssuer(_anchor).destroy(_burnAmount, msg.sender);\n        // Calculate the debt index scaled amount\n        uint256 amountScaled = destroyed.wadToRay().rayDiv(newDebtIndex);\n        require(amountScaled != 0, Error.INVALID_SCALED_AMOUNT);\n\n        // Decrease the principal debt\n        self.kreskoAssetDebt[_account][_kreskoAsset] -= destroyed;\n        // Decrease the scaled debt and set user asset's last debt index\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled -= uint128(amountScaled);\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n        // Update the stability rate for the asset\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n    }\n\n    /**\n     * @notice Repays accrued stability rate interest for a single asset\n     * @param _account Account to repay interest for\n     * @param _kreskoAsset Kresko asset to repay interest for\n     * @return kissRepayAmount amount repaid\n     */\n    function repayFullStabilityRateInterest(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset\n    ) internal returns (uint256 kissRepayAmount) {\n        // Update debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n        // Get the accrued interest in repayment token\n        (, kissRepayAmount) = self.getKreskoAssetDebtInterest(_account, _kreskoAsset);\n\n        // If no interest has accrued no further operations needed\n        // Do not revert because we want the preserve new debt index and stability rate\n        if (kissRepayAmount == 0) {\n            // Update stability rate for asset\n            irs().srAssets[_kreskoAsset].updateStabilityRate();\n            return 0;\n        }\n\n        // Transfer the accrued interest\n        IERC20Upgradeable(irs().kiss).safeTransferFrom(msg.sender, self.feeRecipient, kissRepayAmount);\n\n        // Update scaled values for the user\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled = uint128(\n            self.getKreskoAssetDebtPrincipal(_account, _kreskoAsset).wadToRay().rayDiv(newDebtIndex)\n        );\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n\n        // Remove from minted kresko assets if debt is cleared\n        if (self.getKreskoAssetDebtPrincipal(_account, _kreskoAsset) == 0) {\n            self.mintedKreskoAssets[_account].removeAddress(\n                _kreskoAsset,\n                self.getMintedKreskoAssetsIndex(_account, _kreskoAsset)\n            );\n        }\n\n        // Update stability rates\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n        // Emit event with the account, asset and amount repaid\n        emit InterestRateEvent.StabilityRateInterestRepaid(_account, _kreskoAsset, kissRepayAmount);\n    }\n\n    /**\n     * @notice Charges the protocol close fee based off the value of the burned asset.\n     * @dev Takes the fee from the account's collateral assets. Attempts collateral assets\n     *   in reverse order of the account's deposited collateral assets array.\n     * @param _account The account to charge the close fee from.\n     * @param _kreskoAsset The address of the kresko asset being burned.\n     * @param _burnAmount The amount of the kresko asset being burned.\n     */\n    function chargeCloseFee(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset,\n        uint256 _burnAmount\n    ) internal {\n        KrAsset memory krAsset = self.kreskoAssets[_kreskoAsset];\n        // Calculate the value of the fee according to the value of the krAssets being burned.\n        uint256 feeValue = krAsset.uintUSD(_burnAmount).wadMul(krAsset.closeFee.rawValue);\n\n        // Do nothing if the fee value is 0.\n        if (feeValue == 0) {\n            return;\n        }\n\n        address[] memory accountCollateralAssets = self.depositedCollateralAssets[_account];\n        // Iterate backward through the account's deposited collateral assets to safely\n        // traverse the array while still being able to remove elements if necessary.\n        // This is because removing the last element of the array does not shift around\n        // other elements in the array.\n\n        for (uint256 i = accountCollateralAssets.length - 1; i >= 0; i--) {\n            address collateralAssetAddress = accountCollateralAssets[i];\n\n            (uint256 transferAmount, uint256 feeValuePaid) = self.calcFee(\n                collateralAssetAddress,\n                _account,\n                feeValue,\n                i\n            );\n\n            // Remove the transferAmount from the stored deposit for the account.\n            self.collateralDeposits[_account][collateralAssetAddress] -= self\n                .collateralAssets[collateralAssetAddress]\n                .toNonRebasingAmount(transferAmount);\n\n            // Transfer the fee to the feeRecipient.\n            IERC20Upgradeable(collateralAssetAddress).safeTransfer(self.feeRecipient, transferAmount);\n            emit MinterEvent.CloseFeePaid(_account, collateralAssetAddress, transferAmount, feeValuePaid);\n\n            feeValue = feeValue - feeValuePaid;\n            // If the entire fee has been paid, no more action needed.\n            if (feeValue == 0) {\n                return;\n            }\n        }\n    }\n\n    /**\n     * @notice Check that debt repaid does not leave a dust position, if it does:\n     * return an amount that pays up to minDebtValue\n     * @param _kreskoAsset The address of the kresko asset being burned.\n     * @param _burnAmount The amount being burned\n     * @param _debtAmount The debt amount of `_account`\n     * @return amount == 0 or >= minDebtAmount\n     */\n    function ensureNotDustPosition(\n        MinterState storage self,\n        address _kreskoAsset,\n        uint256 _burnAmount,\n        uint256 _debtAmount\n    ) internal view returns (uint256 amount) {\n        // If the requested burn would put the user's debt position below the minimum\n        // debt value, close up to the minimum debt value instead.\n        FixedPoint.Unsigned memory krAssetValue = self.getKrAssetValue(_kreskoAsset, _debtAmount - _burnAmount, true);\n        if (krAssetValue.isGreaterThan(0) && krAssetValue.isLessThan(self.minimumDebtValue)) {\n            FixedPoint.Unsigned memory minDebtValue = self.minimumDebtValue.div(\n                self.kreskoAssets[_kreskoAsset].fixedPointPrice()\n            );\n            amount = _debtAmount - minDebtValue.rawValue;\n        } else {\n            amount = _burnAmount;\n        }\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibStabilityRate.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.14;\n\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\nimport {IERC20Upgradeable} from \"../../shared/IERC20Upgradeable.sol\";\n\nimport {FixedPoint} from \"../../libs/FixedPoint.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Percentages} from \"../../libs/Percentages.sol\";\nimport {LibKrAsset} from \"../libs/LibKrAsset.sol\";\n\nimport {StabilityRateConfig} from \"../InterestRateState.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @author Kresko\n * @title AMM price stability rate library, derived from Aave Protocols VariableDebtToken calculations\n * @notice Library for performing stability rate related operations\n */\nlibrary LibStabilityRate {\n    using WadRay for uint256;\n    using WadRay for uint128;\n    using Percentages for uint256;\n    using FixedPoint for FixedPoint.Unsigned;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /**\n     * @notice Cumulates the stability rate from previous update and multiplies the debt index with it.\n     * @dev Updates the updated timestamp\n     * @dev New debt index cannot overflow uint128\n     * @param self configuration for the asset\n     * @return newDebtIndex the updated index\n     */\n    function updateDebtIndex(StabilityRateConfig storage self) internal returns (uint256 newDebtIndex) {\n        if (self.asset == address(0)) return WadRay.RAY;\n\n        newDebtIndex = self.debtIndex;\n        // only cumulating if there is any assets minted and rate is over 0\n        if (IERC20Upgradeable(self.asset).totalSupply() != 0) {\n            uint256 cumulatedStabilityRate = self.calculateCompoundedInterest(block.timestamp);\n            newDebtIndex = cumulatedStabilityRate.rayMul(self.debtIndex);\n            require(newDebtIndex <= type(uint128).max, Error.DEBT_INDEX_OVERFLOW);\n            self.debtIndex = uint128(newDebtIndex);\n        }\n\n        self.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /**\n     * @notice Updates the current stability rate for an asset\n     * @dev New stability rate cannot overflow uint128\n     * @param self rate configuration for the asset\n     */\n    function updateStabilityRate(StabilityRateConfig storage self) internal {\n        if (self.asset == address(0)) return;\n\n        uint256 stabilityRate = calculateStabilityRate(self);\n        require(stabilityRate <= type(uint128).max, Error.STABILITY_RATE_OVERFLOW);\n        self.stabilityRate = uint128(stabilityRate);\n    }\n\n    /**\n     * @notice Get the current price rate between AMM and oracle pricing\n     * @dev Raw return value of ammPrice == 0 when no AMM pair exists OR liquidity of the pair does not qualify\n     * @param self rate configuration for the asset\n     * @return priceRate the current price rate\n     */\n    function getPriceRate(StabilityRateConfig storage self) internal view returns (uint256 priceRate) {\n        FixedPoint.Unsigned memory oraclePrice = ms().getKrAssetValue(self.asset, 1 ether, true);\n        FixedPoint.Unsigned memory ammPrice = ms().getKrAssetAMMPrice(self.asset, 1 ether);\n        // no pair, no effect\n        if (ammPrice.rawValue == 0) {\n            return 0;\n        }\n        return ammPrice.div(oraclePrice).div(10).rawValue;\n    }\n\n    /**\n     * @notice Calculate new stability rate from the current price rate\n     * @dev Separate calculations exist for following cases:\n     * case 1: AMM premium < optimal\n     * case 2: AMM premium > optimal\n     * @param self rate configuration for the asset\n     * @return stabilityRate the current stability rate\n     */\n    function calculateStabilityRate(StabilityRateConfig storage self) internal view returns (uint256 stabilityRate) {\n        uint256 priceRate = self.getPriceRate(); // 0.95 RAY = -5% PREMIUM, 1.05 RAY = +5% PREMIUM\n        // Return base rate if no AMM price exists\n        if (priceRate == 0) {\n            return self.stabilityRateBase;\n        }\n        bool rateIsGTOptimal = priceRate > self.optimalPriceRate;\n\n        uint256 rateDiff = rateIsGTOptimal ? priceRate - self.optimalPriceRate : self.optimalPriceRate - priceRate;\n        uint256 rateDiffAdjusted = rateDiff.rayMul(self.rateSlope2.rayDiv(self.rateSlope1 + self.priceRateDelta));\n\n        if (!rateIsGTOptimal) {\n            // Case: AMM price is lower than priceRate\n            return self.stabilityRateBase + rateDiffAdjusted;\n        } else {\n            // Case: AMM price is higher than priceRate\n            return self.stabilityRateBase.rayDiv(WadRay.RAY + rateDiffAdjusted);\n        }\n    }\n\n    /**\n     * @dev Function to calculate the interest using a compounded interest rate formula\n     * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\n     *\n     *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n     *\n     * The approximation slightly underpays liquidity providers and undercharges borrowers\n     * with the advantage of great gas cost reductions\n     * The Aave whitepaper contains reference to the approximation\n     * with a table showing the margin of error per different time periods\n     *\n     * @param self rate configuration for the asset\n     * @param _currentTimestamp The timestamp of the last update of the interest\n     * @return The interest rate compounded during the timeDelta, in ray\n     **/\n    function calculateCompoundedInterest(\n        StabilityRateConfig storage self,\n        uint256 _currentTimestamp\n    ) internal view returns (uint256) {\n        //solium-disable-next-line\n        uint256 exp = _currentTimestamp - uint256(self.lastUpdateTimestamp);\n\n        if (exp == 0) {\n            return WadRay.RAY;\n        }\n\n        uint256 expMinusOne;\n        uint256 expMinusTwo;\n        uint256 basePowerTwo;\n        uint256 basePowerThree;\n        unchecked {\n            expMinusOne = exp - 1;\n\n            expMinusTwo = exp > 2 ? exp - 2 : 0;\n\n            basePowerTwo = self.stabilityRate.rayMul(self.stabilityRate) / (SECONDS_PER_YEAR * SECONDS_PER_YEAR);\n            basePowerThree = basePowerTwo.rayMul(self.stabilityRate) / SECONDS_PER_YEAR;\n        }\n\n        uint256 secondTerm = exp * expMinusOne * basePowerTwo;\n        unchecked {\n            secondTerm /= 2;\n        }\n        uint256 thirdTerm = exp * expMinusOne * expMinusTwo * basePowerThree;\n        unchecked {\n            thirdTerm /= 6;\n        }\n\n        return WadRay.RAY + (self.stabilityRate * exp) / SECONDS_PER_YEAR + secondTerm + thirdTerm;\n    }\n\n    /**\n     * @dev Returns the ongoing normalized debt index for the borrowers\n     * A value of 1e27 means there is no interest. As time passes, the interest is accrued\n     * A value of 2*1e27 means that for each unit of debt, one unit worth of interest has been accumulated\n     * @param self rate configuration for the asset\n     * @return The normalized debt index. expressed in ray\n     **/\n    function getNormalizedDebtIndex(StabilityRateConfig storage self) internal view returns (uint256) {\n        if (self.asset == address(0)) return WadRay.RAY;\n        //solium-disable-next-line\n        if (self.lastUpdateTimestamp == uint40(block.timestamp)) {\n            //if the index was updated in the same block, no need to perform any calculation\n            return self.debtIndex;\n        }\n\n        return self.calculateCompoundedInterest(block.timestamp).rayMul(self.debtIndex);\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibUI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n// solhint-disable-next-line\nimport {IERC20Upgradeable} from \"../../shared/IERC20Upgradeable.sol\";\nimport {AggregatorV2V3Interface} from \"../../vendor/flux/interfaces/AggregatorV2V3Interface.sol\";\nimport {IUniswapV2Pair} from \"../../vendor/uniswap/v2-core/interfaces/IUniswapV2Pair.sol\";\nimport {IKrStaking} from \"../../staking/interfaces/IKrStaking.sol\";\nimport {LibDecimals, FixedPoint} from \"../libs/LibDecimals.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {IUniswapV2Oracle} from \"../interfaces/IUniswapV2Oracle.sol\";\nimport {KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {MinterState, ms} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/* solhint-disable contract-name-camelcase */\n/* solhint-disable var-name-mixedcase */\n\n/**\n * @title Library for UI related views\n * @author Kresko\n */\nlibrary LibUI {\n    using LibDecimals for uint256;\n    using FixedPoint for FixedPoint.Unsigned;\n\n    struct CollateralAssetInfoUser {\n        address assetAddress;\n        address oracleAddress;\n        address anchorAddress;\n        uint256 amount;\n        FixedPoint.Unsigned amountUSD;\n        FixedPoint.Unsigned cFactor;\n        FixedPoint.Unsigned liquidationIncentive;\n        uint8 decimals;\n        uint256 index;\n        uint256 price;\n        string symbol;\n        string name;\n    }\n\n    struct CollateralAssetInfo {\n        address assetAddress;\n        address oracleAddress;\n        address anchorAddress;\n        uint256 price;\n        uint256 value;\n        FixedPoint.Unsigned liquidationIncentive;\n        FixedPoint.Unsigned cFactor;\n        uint8 decimals;\n        string symbol;\n        string name;\n        bool marketOpen;\n    }\n\n    struct ProtocolParams {\n        uint256 minDebtValue;\n        uint256 minCollateralRatio;\n        uint256 liquidationThreshold;\n    }\n\n    struct krAssetInfo {\n        address oracleAddress;\n        address assetAddress;\n        address anchorAddress;\n        uint256 price;\n        uint256 ammPrice;\n        uint256 priceRate;\n        uint256 stabilityRate;\n        uint256 value;\n        FixedPoint.Unsigned openFee;\n        FixedPoint.Unsigned closeFee;\n        FixedPoint.Unsigned kFactor;\n        string symbol;\n        string name;\n        bool marketOpen;\n    }\n\n    struct KreskoUser {\n        krAssetInfoUser[] krAssets;\n        CollateralAssetInfoUser[] collateralAssets;\n        FixedPoint.Unsigned healthFactor;\n        FixedPoint.Unsigned debtActualUSD;\n        FixedPoint.Unsigned debtUSD;\n        FixedPoint.Unsigned collateralActualUSD;\n        FixedPoint.Unsigned collateralUSD;\n        FixedPoint.Unsigned minCollateralUSD;\n        FixedPoint.Unsigned borrowingPowerUSD;\n    }\n\n    struct PairData {\n        uint8 decimals0;\n        uint8 decimals1;\n        uint256 reserve0;\n        uint256 reserve1;\n        uint256 totalSupply;\n    }\n\n    struct GenericInfo {\n        address assetAddress;\n        FixedPoint.Unsigned kFactor;\n        FixedPoint.Unsigned cFactor;\n        uint256 price;\n        bool isKrAsset;\n        bool isCollateral;\n        uint256 debtAmount;\n        uint256 depositAmount;\n        uint256 walletBalance;\n    }\n\n    struct Price {\n        uint256 price;\n        uint256 timestamp;\n        address assetAddress;\n        uint80 roundId;\n        bool marketOpen;\n    }\n\n    struct Allowance {\n        address owner;\n        address spender;\n        uint256 allowance;\n    }\n\n    struct Balance {\n        address token;\n        uint256 balance;\n    }\n\n    struct TokenMetadata {\n        uint8 decimals;\n        string symbol;\n        string name;\n        uint256 totalSupply;\n    }\n\n    struct StakingData {\n        uint256 pid;\n        address depositToken;\n        uint256 totalDeposits;\n        uint256 allocPoint;\n        uint256[] rewardPerBlocks;\n        uint256 lastRewardBlock;\n        uint256 depositAmount;\n        address[] rewardTokens;\n        uint256[] rewardAmounts;\n    }\n\n    struct krAssetInfoUser {\n        address assetAddress;\n        address oracleAddress;\n        address anchorAddress;\n        uint256 amount;\n        uint256 amountScaled;\n        uint256 priceRate;\n        uint256 stabilityRate;\n        FixedPoint.Unsigned amountUSD;\n        uint256 index;\n        FixedPoint.Unsigned kFactor;\n        uint256 price;\n        uint256 ammPrice;\n        string symbol;\n        string name;\n        FixedPoint.Unsigned openFee;\n        FixedPoint.Unsigned closeFee;\n    }\n\n    function getBalances(address[] memory _tokens, address account) internal view returns (Balance[] memory balances) {\n        balances = new Balance[](_tokens.length);\n        for (uint256 i; i < _tokens.length; i++) {\n            balances[i] = Balance({\n                token: address(_tokens[i]),\n                balance: IERC20Upgradeable(_tokens[i]).balanceOf(account)\n            });\n        }\n    }\n\n    function getAllowances(\n        address[] memory _tokens,\n        address owner,\n        address spender\n    ) internal view returns (Allowance[] memory allowances) {\n        allowances = new Allowance[](_tokens.length);\n        for (uint256 i; i < _tokens.length; i++) {\n            allowances[i] = Allowance({\n                allowance: IERC20Upgradeable(_tokens[i]).allowance(owner, spender),\n                spender: spender,\n                owner: owner\n            });\n        }\n    }\n\n    function getStakingData(address _account, address _staking) internal view returns (StakingData[] memory result) {\n        IKrStaking staking = IKrStaking(_staking);\n        IKrStaking.Reward[] memory rewards = staking.allPendingRewards(_account);\n        result = new StakingData[](rewards.length);\n\n        for (uint256 i; i < rewards.length; i++) {\n            IKrStaking.PoolInfo memory poolInfo = staking.poolInfo(rewards[i].pid);\n            address depositTokenAddress = address(poolInfo.depositToken);\n            result[i] = StakingData({\n                pid: rewards[i].pid,\n                totalDeposits: poolInfo.depositToken.balanceOf(_staking),\n                allocPoint: poolInfo.allocPoint,\n                depositToken: depositTokenAddress,\n                depositAmount: staking.userInfo(rewards[i].pid, _account).amount,\n                rewardTokens: rewards[i].tokens,\n                rewardAmounts: rewards[i].amounts,\n                rewardPerBlocks: staking.rewardPerBlockFor(depositTokenAddress),\n                lastRewardBlock: poolInfo.lastRewardBlock\n            });\n        }\n    }\n\n    function borrowingPowerUSD(address _account) internal view returns (FixedPoint.Unsigned memory) {\n        FixedPoint.Unsigned memory minCollateral = ms().getAccountMinimumCollateralValueAtRatio(\n            _account,\n            ms().minimumCollateralizationRatio\n        );\n        FixedPoint.Unsigned memory collateral = ms().getAccountCollateralValue(_account);\n\n        if (collateral.isLessThan(minCollateral)) {\n            return FixedPoint.Unsigned(0);\n        } else {\n            return collateral.sub(minCollateral);\n        }\n    }\n\n    function batchOracleValues(\n        address[] memory _assets,\n        address[] memory _priceFeeds,\n        address[] memory _marketStatusFeeds\n    ) internal view returns (Price[] memory result) {\n        require(_marketStatusFeeds.length == _priceFeeds.length, Error.PRICEFEEDS_MUST_MATCH_STATUS_FEEDS);\n        result = new Price[](_assets.length);\n        for (uint256 i; i < _assets.length; i++) {\n            result[i] = Price({\n                price: uint256(AggregatorV2V3Interface(_priceFeeds[i]).latestAnswer()),\n                timestamp: AggregatorV2V3Interface(_priceFeeds[i]).latestTimestamp(),\n                assetAddress: _assets[i],\n                roundId: uint80(AggregatorV2V3Interface(_priceFeeds[i]).latestRound()),\n                marketOpen: AggregatorV2V3Interface(_marketStatusFeeds[i]).latestMarketOpen()\n            });\n        }\n    }\n\n    function krAssetInfos(address[] memory assetAddresses) internal view returns (krAssetInfo[] memory result) {\n        result = new krAssetInfo[](assetAddresses.length);\n        for (uint256 i; i < assetAddresses.length; i++) {\n            address assetAddress = assetAddresses[i];\n            KrAsset memory krAsset = ms().kreskoAssets[assetAddress];\n            uint256 ammPrice;\n            uint256 stabilityRate;\n            uint256 priceRate;\n            if (irs().srAssets[assetAddress].asset != address(0)) {\n                ammPrice = IUniswapV2Oracle(ms().ammOracle).consultKrAsset(assetAddress, 1 ether);\n                stabilityRate = irs().srAssets[assetAddress].calculateStabilityRate();\n                priceRate = irs().srAssets[assetAddress].getPriceRate();\n            }\n            result[i] = krAssetInfo({\n                value: ms().getKrAssetValue(assetAddress, 1 ether, false).rawValue,\n                oracleAddress: address(krAsset.oracle),\n                anchorAddress: krAsset.anchor,\n                assetAddress: assetAddress,\n                closeFee: krAsset.closeFee,\n                openFee: krAsset.openFee,\n                kFactor: krAsset.kFactor,\n                price: uint256(krAsset.oracle.latestAnswer()),\n                stabilityRate: stabilityRate,\n                priceRate: priceRate,\n                ammPrice: ammPrice,\n                marketOpen: krAsset.marketStatusOracle.latestMarketOpen(),\n                symbol: IERC20Upgradeable(assetAddress).symbol(),\n                name: IERC20Upgradeable(assetAddress).name()\n            });\n        }\n    }\n\n    function collateralAssetInfos(\n        address[] memory assetAddresses\n    ) internal view returns (CollateralAssetInfo[] memory result) {\n        result = new CollateralAssetInfo[](assetAddresses.length);\n        for (uint256 i; i < assetAddresses.length; i++) {\n            address assetAddress = assetAddresses[i];\n            CollateralAsset memory collateralAsset = ms().collateralAssets[assetAddress];\n            uint8 decimals = IERC20Upgradeable(assetAddress).decimals();\n\n            (FixedPoint.Unsigned memory value, FixedPoint.Unsigned memory price) = ms()\n                .getCollateralValueAndOraclePrice(assetAddress, 1 * 10 ** decimals, false);\n\n            result[i] = CollateralAssetInfo({\n                value: value.rawValue,\n                oracleAddress: address(collateralAsset.oracle),\n                anchorAddress: collateralAsset.anchor,\n                assetAddress: assetAddress,\n                liquidationIncentive: collateralAsset.liquidationIncentive,\n                cFactor: collateralAsset.factor,\n                decimals: decimals,\n                price: price.rawValue,\n                marketOpen: collateralAsset.marketStatusOracle.latestMarketOpen(),\n                symbol: IERC20Upgradeable(assetAddress).symbol(),\n                name: IERC20Upgradeable(assetAddress).name()\n            });\n        }\n    }\n\n    function collateralAssetInfoFor(\n        address _account\n    ) internal view returns (CollateralAssetInfoUser[] memory result, FixedPoint.Unsigned memory totalCollateralUSD) {\n        address[] memory collateralAssetAddresses = ms().getDepositedCollateralAssets(_account);\n        if (collateralAssetAddresses.length > 0) {\n            result = new CollateralAssetInfoUser[](collateralAssetAddresses.length);\n            for (uint256 i; i < collateralAssetAddresses.length; i++) {\n                address assetAddress = collateralAssetAddresses[i];\n                uint8 decimals = IERC20Upgradeable(assetAddress).decimals();\n\n                uint256 amount = ms().getCollateralDeposits(_account, assetAddress);\n\n                (FixedPoint.Unsigned memory amountUSD, FixedPoint.Unsigned memory price) = ms()\n                    .getCollateralValueAndOraclePrice(assetAddress, amount, true);\n\n                totalCollateralUSD.add(amountUSD);\n                result[i] = CollateralAssetInfoUser({\n                    amount: amount,\n                    amountUSD: amountUSD,\n                    liquidationIncentive: ms().collateralAssets[assetAddress].liquidationIncentive,\n                    anchorAddress: ms().collateralAssets[assetAddress].anchor,\n                    oracleAddress: address(ms().collateralAssets[assetAddress].oracle),\n                    assetAddress: assetAddress,\n                    cFactor: ms().collateralAssets[assetAddress].factor,\n                    decimals: decimals,\n                    index: i,\n                    price: price.rawValue,\n                    symbol: IERC20Upgradeable(assetAddress).symbol(),\n                    name: IERC20Upgradeable(assetAddress).name()\n                });\n            }\n        }\n    }\n\n    function krAssetInfoFor(\n        address _account\n    ) internal view returns (krAssetInfoUser[] memory result, FixedPoint.Unsigned memory totalDebtUSD) {\n        address[] memory krAssetAddresses = ms().mintedKreskoAssets[_account];\n        if (krAssetAddresses.length > 0) {\n            result = new krAssetInfoUser[](krAssetAddresses.length);\n            for (uint256 i; i < krAssetAddresses.length; i++) {\n                address assetAddress = krAssetAddresses[i];\n                KrAsset memory krAsset = ms().kreskoAssets[assetAddress];\n                uint256 amount = ms().getKreskoAssetDebtPrincipal(_account, assetAddress);\n                uint256 amountScaled = ms().getKreskoAssetDebtScaled(_account, assetAddress);\n\n                FixedPoint.Unsigned memory amountUSD = ms().getKrAssetValue(assetAddress, amount, true);\n                uint256 ammPrice;\n                uint256 stabilityRate;\n                uint256 priceRate;\n                if (irs().srAssets[assetAddress].asset != address(0)) {\n                    stabilityRate = irs().srAssets[assetAddress].calculateStabilityRate();\n                    priceRate = irs().srAssets[assetAddress].getPriceRate();\n                    ammPrice = IUniswapV2Oracle(ms().ammOracle).consultKrAsset(assetAddress, 1 ether);\n                }\n                totalDebtUSD.add(amountUSD);\n                result[i] = krAssetInfoUser({\n                    assetAddress: assetAddress,\n                    oracleAddress: address(krAsset.oracle),\n                    anchorAddress: krAsset.anchor,\n                    openFee: krAsset.openFee,\n                    closeFee: krAsset.closeFee,\n                    amount: amount,\n                    amountScaled: amountScaled,\n                    amountUSD: amountUSD,\n                    stabilityRate: stabilityRate,\n                    priceRate: priceRate,\n                    index: i,\n                    kFactor: krAsset.kFactor,\n                    price: uint256(krAsset.oracle.latestAnswer()),\n                    ammPrice: ammPrice,\n                    symbol: IERC20Upgradeable(assetAddress).symbol(),\n                    name: IERC20Upgradeable(assetAddress).name()\n                });\n            }\n        }\n    }\n\n    function healthFactorFor(address _account) internal view returns (FixedPoint.Unsigned memory) {\n        FixedPoint.Unsigned memory userDebt = ms().getAccountKrAssetValue(_account);\n        FixedPoint.Unsigned memory userCollateral = ms().getAccountCollateralValue(_account);\n\n        if (userDebt.isGreaterThan(0)) {\n            return userCollateral.div(userDebt);\n        } else {\n            return FixedPoint.Unsigned(0);\n        }\n    }\n\n    function kreskoUser(address _account) internal view returns (KreskoUser memory user) {\n        (krAssetInfoUser[] memory krInfos, FixedPoint.Unsigned memory totalDebtUSD) = krAssetInfoFor(_account);\n        (\n            CollateralAssetInfoUser[] memory collateralInfos,\n            FixedPoint.Unsigned memory totalCollateralUSD\n        ) = collateralAssetInfoFor(_account);\n\n        if (krInfos.length > 0 || collateralInfos.length > 0) {\n            user = KreskoUser({\n                collateralAssets: collateralInfos,\n                krAssets: krInfos,\n                borrowingPowerUSD: borrowingPowerUSD(_account),\n                healthFactor: healthFactorFor(_account),\n                debtActualUSD: totalDebtUSD,\n                debtUSD: ms().getAccountKrAssetValue(_account),\n                collateralActualUSD: totalCollateralUSD,\n                collateralUSD: ms().getAccountCollateralValue(_account),\n                minCollateralUSD: ms().getAccountMinimumCollateralValueAtRatio(\n                    _account,\n                    ms().minimumCollateralizationRatio\n                )\n            });\n        }\n    }\n}\n"
    },
    "src/contracts/minter/MinterState.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {LibKrAsset} from \"./libs/LibKrAsset.sol\";\nimport {LibAccount} from \"./libs/LibAccount.sol\";\nimport {LibCollateral} from \"./libs/LibCollateral.sol\";\nimport {LibCalculation} from \"./libs/LibCalculation.sol\";\nimport {LibRepay} from \"./libs/LibRepay.sol\";\nimport {LibMint} from \"./libs/LibMint.sol\";\nimport {FixedPoint} from \"../libs/FixedPoint.sol\";\nimport {Action, SafetyState, CollateralAsset, KrAsset} from \"./MinterTypes.sol\";\n\n/* solhint-disable state-visibility */\nusing LibCalculation for MinterState global;\nusing LibKrAsset for MinterState global;\nusing LibCollateral for MinterState global;\nusing LibAccount for MinterState global;\nusing LibRepay for MinterState global;\nusing LibMint for MinterState global;\n\n/**\n * @title Storage layout for the minter state\n * @author Kresko\n */\nstruct MinterState {\n    /* -------------------------------------------------------------------------- */\n    /*                               Initialization                               */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Initialization version\n    uint256 initializations;\n    bytes32 domainSeparator;\n    /* -------------------------------------------------------------------------- */\n    /*                           Configurable Parameters                          */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice The recipient of protocol fees.\n    address feeRecipient;\n    /// @notice The factor used to calculate the incentive a liquidator receives in the form of seized collateral.\n    FixedPoint.Unsigned liquidationIncentiveMultiplier;\n    /// @notice The minimum ratio of collateral to debt that can be taken by direct action.\n    FixedPoint.Unsigned minimumCollateralizationRatio;\n    /// @notice The minimum USD value of an individual synthetic asset debt position.\n    FixedPoint.Unsigned minimumDebtValue;\n    /// @notice The collateralization ratio at which positions may be liquidated.\n    FixedPoint.Unsigned liquidationThreshold;\n    /// @notice Flag tells if there is a need to perform safety checks on user actions\n    bool safetyStateSet;\n    /// @notice asset -> action -> state\n    mapping(address => mapping(Action => SafetyState)) safetyState;\n    /* -------------------------------------------------------------------------- */\n    /*                              Collateral Assets                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Mapping of collateral asset token address to information on the collateral asset.\n    mapping(address => CollateralAsset) collateralAssets;\n    /**\n     * @notice Mapping of account -> asset -> deposit amount\n     */\n    mapping(address => mapping(address => uint256)) collateralDeposits;\n    /// @notice Mapping of account -> collateral asset addresses deposited\n    mapping(address => address[]) depositedCollateralAssets;\n    /* -------------------------------------------------------------------------- */\n    /*                                Kresko Assets                               */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Mapping of kresko asset token address to information on the Kresko asset.\n    mapping(address => KrAsset) kreskoAssets;\n    /// @notice Mapping of account -> krAsset -> debt amount owed to the protocol\n    mapping(address => mapping(address => uint256)) kreskoAssetDebt;\n    /// @notice Mapping of account -> addresses of borrowed krAssets\n    mapping(address => address[]) mintedKreskoAssets;\n    /// @notice The AMM oracle address.\n    address ammOracle;\n    /// @notice Offchain oracle decimals\n    uint8 extOracleDecimals;\n    /// @notice Liquidation Overflow Multiplier, multiplies max liquidatable value.\n    FixedPoint.Unsigned maxLiquidationMultiplier;\n}\n"
    },
    "src/contracts/minter/MinterStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\npragma solidity >=0.8.14;\n\nimport {MinterState} from \"./MinterState.sol\";\n\n// Storage position\nbytes32 constant MINTER_STORAGE_POSITION = keccak256(\"kresko.minter.storage\");\n\nfunction ms() pure returns (MinterState storage state) {\n    bytes32 position = MINTER_STORAGE_POSITION;\n    assembly {\n        state.slot := position\n    }\n}\n"
    },
    "src/contracts/minter/MinterTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {AggregatorV2V3Interface} from \"../vendor/flux/interfaces/AggregatorV2V3Interface.sol\";\nimport {FixedPoint} from \"../libs/FixedPoint.sol\";\nimport {IKreskoAssetAnchor} from \"../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {LibAssetUtility} from \"./libs/LibAssetUtility.sol\";\n\n/* solhint-disable state-visibility */\n\n/* -------------------------------------------------------------------------- */\n/*                                  CONSTANTS                                 */\n/* -------------------------------------------------------------------------- */\n\nlibrary Constants {\n    uint256 constant ONE_HUNDRED_PERCENT = 1 ether;\n\n    uint256 constant BASIS_POINT = 1e14;\n\n    /// @dev The maximum configurable close fee.\n    uint256 constant MAX_CLOSE_FEE = 0.1 ether; // 10%\n\n    /// @dev The maximum configurable open fee.\n    uint256 constant MAX_OPEN_FEE = 0.1 ether; // 10%\n\n    /// @dev Overflow over maximum liquidatable value to allow leeway for users after one happens.\n    uint256 constant MIN_MAX_LIQUIDATION_MULTIPLIER = ONE_HUNDRED_PERCENT + BASIS_POINT; // 100.01% or .01% over\n\n    /// @dev The minimum configurable minimum collateralization ratio.\n    uint256 constant MIN_COLLATERALIZATION_RATIO = ONE_HUNDRED_PERCENT;\n\n    /// @dev The minimum configurable liquidation incentive multiplier.\n    /// This means liquidator only receives equal amount of collateral to debt repaid.\n    uint256 constant MIN_LIQUIDATION_INCENTIVE_MULTIPLIER = ONE_HUNDRED_PERCENT;\n\n    /// @dev The maximum configurable liquidation incentive multiplier.\n    /// This means liquidator receives 25% bonus collateral compared to the debt repaid.\n    uint256 constant MAX_LIQUIDATION_INCENTIVE_MULTIPLIER = 1.25 ether; // 125%\n\n    /// @dev The maximum configurable minimum debt USD value. 8 decimals.\n    uint256 constant MAX_MIN_DEBT_VALUE = 1000 gwei; // $1,000\n}\n\n/* -------------------------------------------------------------------------- */\n/*                                    ENUM                                    */\n/* -------------------------------------------------------------------------- */\n\n/**\n * @dev Protocol user facing actions\n *\n * Deposit = 0\n * Withdraw = 1,\n * Repay = 2,\n * Borrow = 3,\n * Liquidate = 4\n */\nenum Action {\n    Deposit,\n    Withdraw,\n    Repay,\n    Borrow,\n    Liquidation\n}\n/**\n * @dev Fee types\n *\n * Open = 0\n * Close = 1\n */\nenum Fee {\n    Open,\n    Close\n}\n\n/* ========================================================================== */\n/*                                   STRUCTS                                  */\n/* ========================================================================== */\n\n/**\n * @notice Initialization arguments for the protocol\n */\nstruct MinterInitArgs {\n    address admin;\n    address council;\n    address treasury;\n    uint8 extOracleDecimals;\n    uint256 minimumCollateralizationRatio;\n    uint256 minimumDebtValue;\n    uint256 liquidationThreshold;\n}\n\n/**\n * @notice Configurable parameters within the protocol\n */\n\nstruct MinterParams {\n    FixedPoint.Unsigned minimumCollateralizationRatio;\n    FixedPoint.Unsigned minimumDebtValue;\n    FixedPoint.Unsigned liquidationThreshold;\n    FixedPoint.Unsigned liquidationOverflowPercentage;\n    address feeRecipient;\n    uint8 extOracleDecimals;\n}\n\n/**\n * @notice Information on a token that is a KreskoAsset.\n * @dev Each KreskoAsset has 18 decimals.\n * @param kFactor The k-factor used for calculating the required collateral value for KreskoAsset debt.\n * @param oracle The oracle that provides the USD price of one KreskoAsset.\n * @param supplyLimit The total supply limit of the KreskoAsset.\n * @param anchor The anchor address\n * @param closeFee The percentage paid in fees when closing a debt position of this type.\n * @param openFee The percentage paid in fees when opening a debt position of this type.\n * @param exists Whether the KreskoAsset exists within the protocol.\n */\nstruct KrAsset {\n    FixedPoint.Unsigned kFactor;\n    AggregatorV2V3Interface oracle;\n    AggregatorV2V3Interface marketStatusOracle;\n    uint256 supplyLimit;\n    address anchor;\n    FixedPoint.Unsigned closeFee;\n    FixedPoint.Unsigned openFee;\n    bool exists;\n}\nusing LibAssetUtility for KrAsset global;\n/**\n * @notice Information on a token that can be used as collateral.\n * @dev Setting the factor to zero effectively makes the asset useless as collateral while still allowing\n * it to be deposited and withdrawn.\n * @param factor The collateral factor used for calculating the value of the collateral.\n * @param oracle The oracle that provides the USD price of one collateral asset.\n * @param anchor If the collateral is a KreskoAsset, the anchor address\n * @param decimals The decimals for the token, stored here to avoid repetitive external calls.\n * @param exists Whether the collateral asset exists within the protocol.\n * @param liquidationIncentive The liquidation incentive for the asset\n */\nstruct CollateralAsset {\n    FixedPoint.Unsigned factor;\n    AggregatorV2V3Interface oracle;\n    AggregatorV2V3Interface marketStatusOracle;\n    address anchor;\n    uint8 decimals;\n    bool exists;\n    FixedPoint.Unsigned liquidationIncentive;\n}\nusing LibAssetUtility for CollateralAsset global;\n\n/// @notice Configuration for pausing `Action`\nstruct Pause {\n    bool enabled;\n    uint256 timestamp0;\n    uint256 timestamp1;\n}\n\n/// @notice Safety configuration for assets\nstruct SafetyState {\n    Pause pause;\n}\n"
    },
    "src/contracts/shared/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.14;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IERC20Upgradeable} from \"./IERC20Upgradeable.sol\";\n\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable not-rely-on-time */\n/* solhint-disable func-name-mixedcase */\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @author Kresko: modified to an upgradeable\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\n\ncontract ERC20Upgradeable is Initializable, IERC20Upgradeable {\n    /* -------------------------------------------------------------------------- */\n    /*                                   Events                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /* -------------------------------------------------------------------------- */\n    /*                                ERC20 Storage                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  EIP-2612                                  */\n    /* -------------------------------------------------------------------------- */\n\n    mapping(address => uint256) public nonces;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Immutables                                 */\n    /* -------------------------------------------------------------------------- */\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    constructor() payable initializer {\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20Upgradeable_init(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) internal onlyInitializing {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    READ                                    */\n    /* -------------------------------------------------------------------------- */\n\n    function balanceOf(address _account) public view virtual returns (uint256) {\n        return _balances[_account];\n    }\n\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    function allowance(address _owner, address _spender) public view virtual returns (uint256) {\n        return _allowances[_owner][_spender];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 ERC20 Logic                                */\n    /* -------------------------------------------------------------------------- */\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _balances[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balances[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        uint256 allowed = _allowances[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) _allowances[from][msg.sender] = allowed - amount;\n\n        _balances[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               EIP-2612 Logic                               */\n    /* -------------------------------------------------------------------------- */\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            _allowances[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Internals                                 */\n    /* -------------------------------------------------------------------------- */\n\n    function _mint(address to, uint256 amount) internal virtual {\n        _totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balances[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        _balances[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "src/contracts/shared/ERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\n\nimport {SafeERC20Upgradeable} from \"./SafeERC20Upgradeable.sol\";\nimport {IKreskoAsset, IERC20Upgradeable} from \"../kreskoasset/IKreskoAsset.sol\";\nimport {ERC20Upgradeable} from \"../kreskoasset/KreskoAsset.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\n/* solhint-disable func-name-mixedcase */\n/* solhint-disable no-empty-blocks */\n/* solhint-disable func-visibility */\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @notice Kresko:\n/// Adds issue/destroy functions that are called when KreskoAssets are minted/burned through the protocol.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @author Kresko (https://www.kresko.fi)\nabstract contract ERC4626Upgradeable is ERC20Upgradeable {\n    using SafeERC20Upgradeable for IKreskoAsset;\n    using FixedPointMathLib for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Events                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event Issue(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Destroy(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Immutables                                 */\n    /* -------------------------------------------------------------------------- */\n\n    IKreskoAsset public immutable asset;\n\n    constructor(IKreskoAsset _asset) payable {\n        asset = _asset;\n    }\n\n    /**\n     * @notice Initializes the ERC4626.\n     *\n     * @param _asset The underlying (Kresko) Asset\n     * @param _name Name of the anchor token\n     * @param _symbol Symbol of the anchor token\n     * @dev decimals are read from the underlying asset\n     */\n    function __ERC4626Upgradeable_init(\n        IERC20Upgradeable _asset,\n        string memory _name,\n        string memory _symbol\n    ) internal onlyInitializing {\n        __ERC20Upgradeable_init(_name, _symbol, _asset.decimals());\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Issue & Destroy                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice When new KreskoAssets are burned:\n     * Issues the equivalent amount of anchor tokens to Kresko\n     * Issues the equivalent amount of assets to user\n     */\n    function issue(uint256 assets, address to) public virtual returns (uint256 shares) {\n        require(msg.sender == asset.kresko(), Error.ISSUER_NOT_KRESKO);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewIssue(assets)) != 0, Error.ZERO_SHARES);\n\n        // Mint shares to kresko\n        _mint(asset.kresko(), shares);\n        // Mint assets to receiver\n        asset.mint(to, assets);\n\n        emit Issue(msg.sender, to, assets, shares);\n\n        _afterDeposit(assets, shares);\n    }\n\n    /**\n     * @notice When new KreskoAssets are burned:\n     * Destroys the equivalent amount of anchor tokens from Kresko\n     * Destorys the equivalent amount of assets from user\n     */\n    function destroy(uint256 assets, address from) public virtual returns (uint256 shares) {\n        require(msg.sender == asset.kresko(), Error.REDEEMER_NOT_KRESKO);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewIssue(assets)) != 0, Error.ZERO_SHARES);\n\n        _beforeWithdraw(assets, shares);\n\n        // Burn shares from kresko\n        _burn(asset.kresko(), shares);\n        // Burn assets from user\n        asset.burn(from, assets);\n\n        emit Destroy(msg.sender, from, from, assets, shares);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              Accounting Logic                              */\n    /* -------------------------------------------------------------------------- */\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if _totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    /// @notice amount of shares for amount of @param assets\n    function previewIssue(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @notice amount of assets for amount of @param shares\n    function previewDestroy(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /// @notice amount of shares for amount of @param assets\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @notice amount of assets for amount of @param shares\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if _totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    /// @notice amount of shares for amount of @param assets\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if _totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    /// @notice amount of assets for amount of @param shares\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                       DEPOSIT/WITHDRAWAL LIMIT VIEWS                       */\n    /* -------------------------------------------------------------------------- */\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxIssue(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxDestroy(address owner) public view virtual returns (uint256) {\n        return convertToAssets(_balances[owner]);\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(_balances[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return _balances[owner];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                            INTERNAL HOOKS LOGIC                            */\n    /* -------------------------------------------------------------------------- */\n\n    function _beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function _afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n\n    /* -------------------------------------------------------------------------- */\n    /*                               EXTERNAL USE                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Deposit KreskoAssets for equivalent amount of anchor tokens\n     */\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, Error.ZERO_SHARES);\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        _afterDeposit(assets, shares);\n    }\n\n    /**\n     * @notice Withdraw KreskoAssets for equivalent amount of anchor tokens\n     * @param assets Amount of KreskoAssets to withdraw\n     * @param receiver Address to send KreskoAssets to\n     * @param owner Address to burn shares from\n     * @return shares Amount of shares burned\n     * @dev shares are burned from owner, not msg.sender\n     */\n    function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = _allowances[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) {\n                _allowances[owner][msg.sender] = allowed - shares;\n            }\n        }\n\n        _beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /**\n     * @notice Mint shares of anchor tokens for equivalent amount of KreskoAssets\n     * @param shares Amount of shares to mint\n     * @param receiver Address to send shares to\n     * @return assets Amount of KreskoAssets redeemed\n     */\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        _afterDeposit(assets, shares);\n    }\n\n    /**\n     * @notice Redeem shares of anchor for KreskoAssets\n     * @param shares Amount of shares to redeem\n     * @param receiver Address to send KreskoAssets to\n     * @param owner Address to burn shares from\n     * @return assets Amount of KreskoAssets redeemed\n     */\n    function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = _allowances[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) {\n                _allowances[owner][msg.sender] = allowed - shares;\n            }\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, Error.ZERO_ASSETS);\n\n        _beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n}\n"
    },
    "src/contracts/shared/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/contracts/shared/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\n/* solhint-disable func-name-mixedcase */\n\ninterface IERC20Upgradeable {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function allowance(address, address) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function name() external view returns (string memory);\n\n    function nonces(address) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "src/contracts/shared/Modifiers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {Authorization, Role} from \"../libs/Authorization.sol\";\nimport {Meta} from \"../libs/Meta.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\nimport {Action} from \"../minter/MinterTypes.sol\";\nimport {ms} from \"../minter/MinterStorage.sol\";\n\nimport {ENTERED, NOT_ENTERED} from \"../diamond/DiamondTypes.sol\";\nimport {ds} from \"../diamond/DiamondStorage.sol\";\n\nabstract contract DiamondModifiers {\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^Authorization: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        Authorization.checkRole(role);\n        _;\n    }\n\n    /**\n     * @notice Ensure only trusted contracts can act on behalf of `_account`\n     * @param _accountIsNotMsgSender The address of the collateral asset.\n     */\n    modifier onlyRoleIf(bool _accountIsNotMsgSender, bytes32 role) {\n        if (_accountIsNotMsgSender) {\n            Authorization.checkRole(role);\n        }\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(Meta.msgSender() == ds().contractOwner, Error.DIAMOND_INVALID_OWNER);\n        _;\n    }\n\n    modifier onlyPendingOwner() {\n        require(Meta.msgSender() == ds().pendingOwner, Error.DIAMOND_INVALID_PENDING_OWNER);\n        _;\n    }\n\n    modifier nonReentrant() {\n        require(ds().entered == NOT_ENTERED, Error.RE_ENTRANCY);\n        ds().entered = ENTERED;\n        _;\n        ds().entered = NOT_ENTERED;\n    }\n}\n\nabstract contract MinterModifiers {\n    /**\n     * @notice Reverts if a collateral asset does not exist within the protocol.\n     * @param _collateralAsset The address of the collateral asset.\n     */\n    modifier collateralAssetExists(address _collateralAsset) {\n        require(ms().collateralAssets[_collateralAsset].exists, Error.COLLATERAL_DOESNT_EXIST);\n        _;\n    }\n\n    /**\n     * @notice Reverts if a collateral asset already exists within the protocol.\n     * @param _collateralAsset The address of the collateral asset.\n     */\n    modifier collateralAssetDoesNotExist(address _collateralAsset) {\n        require(!ms().collateralAssets[_collateralAsset].exists, Error.COLLATERAL_EXISTS);\n        _;\n    }\n\n    /**\n     * @notice Reverts if a Kresko asset does not exist within the protocol. Does not revert if\n     * the Kresko asset is not mintable.\n     * @param _kreskoAsset The address of the Kresko asset.\n     */\n    modifier kreskoAssetExists(address _kreskoAsset) {\n        require(ms().kreskoAssets[_kreskoAsset].exists, Error.KRASSET_DOESNT_EXIST);\n        _;\n    }\n\n    /**\n     * @notice Reverts if the symbol of a Kresko asset already exists within the protocol.\n     * @param _kreskoAsset The address of the Kresko asset.\n     */\n    modifier kreskoAssetDoesNotExist(address _kreskoAsset) {\n        require(!ms().kreskoAssets[_kreskoAsset].exists, Error.KRASSET_EXISTS);\n        _;\n    }\n\n    /// @dev Simple check for the enabled flag\n    function ensureNotPaused(address _asset, Action _action) internal view virtual {\n        require(!ms().safetyState[_asset][_action].pause.enabled, Error.ACTION_PAUSED_FOR_ASSET);\n    }\n}\n"
    },
    "src/contracts/shared/Rebase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\n\nstruct Rebase {\n    bool positive;\n    uint256 denominator;\n}\n\nlibrary RebaseMath {\n    using FixedPointMathLib for uint256;\n\n    function unrebase(uint256 self, Rebase memory _rebase) internal pure returns (uint256) {\n        if (_rebase.denominator == 0) return self;\n        return _rebase.positive ? self.divWadDown(_rebase.denominator) : self.mulWadDown(_rebase.denominator);\n    }\n\n    function rebase(uint256 self, Rebase memory _rebase) internal pure returns (uint256) {\n        if (_rebase.denominator == 0) return self;\n        return _rebase.positive ? self.mulWadDown(_rebase.denominator) : self.divWadDown(_rebase.denominator);\n    }\n}\n"
    },
    "src/contracts/shared/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {IERC20Upgradeable} from \"./IERC20Upgradeable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "src/contracts/staking/interfaces/IKrStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IKrStaking {\n    struct UserInfo {\n        uint256 amount;\n        uint256[] rewardDebts;\n    }\n\n    struct PoolInfo {\n        IERC20 depositToken; // Address of LP token contract.\n        uint128 allocPoint; // How many allocation points assigned to this pool.\n        uint128 lastRewardBlock; // Last block number that rewards distribution occurs.\n        uint256[] accRewardPerShares; // Accumulated rewards per share, times 1e12.\n        address[] rewardTokens; // Reward tokens for this pool.\n    }\n\n    struct Reward {\n        uint256 pid;\n        address[] tokens;\n        uint256[] amounts;\n    }\n\n    function getPidFor(address _token) external view returns (uint256 pid, bool found);\n\n    function poolLength() external view returns (uint256);\n\n    function deposit(address _to, uint256 _pid, uint256 _amount) external;\n\n    function withdrawFor(address _for, uint256 _pid, uint256 _amount, address _claimRewardsTo) external;\n\n    function claimFor(address _for, uint256 _pid, address _rewardRecipient) external;\n\n    function allPendingRewards(address) external view returns (Reward[] memory);\n\n    function userInfo(uint256 _pid, address _account) external view returns (UserInfo memory);\n\n    function poolInfo(uint256 _pid) external view returns (PoolInfo memory);\n\n    function rewardPerBlockFor(address depositTokenAddress) external view returns (uint256[] memory rewardPerBlocks);\n}\n"
    },
    "src/contracts/test/Funder.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity >=0.8.14;\n\nimport {IERC20Upgradeable} from \"../shared/IERC20Upgradeable.sol\";\nimport {WETH} from \"./WETH.sol\";\nimport {IAccountStateFacet, FixedPoint} from \"../minter/interfaces/IAccountStateFacet.sol\";\n\n/* solhint-disable no-empty-blocks */\n\nstruct Token {\n    uint256 amount;\n    address token;\n}\n\ncontract Funder {\n    mapping(address => bool) public owners;\n    mapping(address => bool) public funded;\n    IAccountStateFacet public kresko;\n\n    event Funded(address indexed account);\n\n    constructor(address _kresko) {\n        owners[msg.sender] = true;\n        kresko = IAccountStateFacet(_kresko);\n    }\n\n    function toggleOwners(address[] calldata accounts) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < accounts.length; i++) {\n            owners[accounts[i]] = !owners[accounts[i]];\n        }\n    }\n\n    function isEligible(address account) public view returns (bool) {\n        return account.balance < 0.001 ether && kresko.getAccountKrAssetValue(account).rawValue > 0 && !funded[account];\n    }\n\n    function distribute(address[] calldata accounts, uint256 ethAmount) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < accounts.length; i++) {\n            if (!isEligible(accounts[i])) continue;\n\n            funded[accounts[i]] = true;\n            payable(accounts[i]).transfer(ethAmount);\n            emit Funded(accounts[i]);\n        }\n    }\n\n    function drain() external {\n        require(owners[msg.sender], \"!o\");\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}\n"
    },
    "src/contracts/test/FunderTestnetExtended.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.14;\n\nimport {MockERC20} from \"./MockERC20.sol\";\nimport {WETH} from \"./WETH.sol\";\nimport {IAccountStateFacet, FixedPoint} from \"../minter/interfaces/IAccountStateFacet.sol\";\n\n/* solhint-disable no-empty-blocks */\n\nstruct Token {\n    uint256 amount;\n    address token;\n}\n\ncontract FunderTestnetExtended {\n    mapping(address => bool) public owners;\n    mapping(address => bool) public funded;\n    IAccountStateFacet public kresko;\n    MockERC20 public tokenToFund;\n    uint256 public fundAmount = 10000 ether;\n    event Funded(address indexed account);\n\n    constructor(address _kresko, address _tokenToFund) {\n        owners[msg.sender] = true;\n        kresko = IAccountStateFacet(_kresko);\n        tokenToFund = MockERC20(_tokenToFund);\n    }\n\n    function toggleOwners(address[] calldata accounts) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < accounts.length; i++) {\n            owners[accounts[i]] = !owners[accounts[i]];\n        }\n    }\n\n    function isEligible(address account) public view returns (bool) {\n        return !funded[account];\n    }\n\n    function setFundAmount(uint256 amount) external {\n        require(owners[msg.sender], \"!o\");\n        fundAmount = amount;\n    }\n\n    function distribute() external {\n        if (!isEligible(msg.sender)) return;\n        tokenToFund.mint(msg.sender, fundAmount);\n        funded[msg.sender] = true;\n        emit Funded(msg.sender);\n    }\n\n    function drain() external {\n        require(owners[msg.sender], \"!o\");\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}\n"
    },
    "src/contracts/test/interfaces/ISmockFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface ISmockFacet {\n    event NewMessage(address indexed caller, string message);\n\n    function activate() external;\n\n    function disable() external;\n\n    function setMessage(string memory message) external;\n}\n"
    },
    "src/contracts/test/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.14;\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    mapping(address => bool) public minters;\n    address public owner;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _initialSupply\n    ) ERC20(_name, _symbol, _decimals) {\n        _mint(msg.sender, _initialSupply);\n        minters[msg.sender] = true;\n    }\n\n    function reinitializeERC20(string memory _name, string memory _symbol) external {\n        require(msg.sender == owner, \"!owner\");\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function toggleMinters(address[] calldata _minters) external {\n        require(minters[msg.sender], \"!minter\");\n        for (uint256 i; i < _minters.length; i++) {\n            minters[_minters[i]] = !minters[_minters[i]];\n        }\n    }\n\n    function mint(address to, uint256 value) public virtual {\n        require(minters[msg.sender], \"!minter\");\n        _mint(to, value);\n    }\n\n    function burn(address from, uint256 value) public virtual {\n        require(minters[msg.sender], \"!minter\");\n        _burn(from, value);\n    }\n}\n"
    },
    "src/contracts/test/SmockCollateralReceiver.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.14;\nimport {IDepositWithdrawFacet} from \"../minter/interfaces/IDepositWithdrawFacet.sol\";\nimport {ICollateralReceiver} from \"../minter/interfaces/ICollateralReceiver.sol\";\nimport {IERC20Upgradeable} from \"../shared/IERC20Upgradeable.sol\";\n\ncontract SmockCollateralReceiver is ICollateralReceiver {\n    IDepositWithdrawFacet public kresko;\n    function(address, address, uint256, bytes memory) internal callbackLogic;\n\n    address public account;\n    address public collateralAsset;\n    uint256 public withdrawalAmountRequested;\n    uint256 public withdrawalAmountReceived;\n    Params public userData;\n\n    struct Params {\n        uint256 val;\n        uint256 val1;\n        address addr;\n    }\n\n    constructor(address _kresko) {\n        kresko = IDepositWithdrawFacet(_kresko);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Callback                                  */\n    /* -------------------------------------------------------------------------- */\n\n    function onUncheckedCollateralWithdraw(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawalAmount,\n        uint256 _depositedCollateralAssetIndex,\n        bytes memory _userData\n    ) external returns (bytes memory) {\n        _depositedCollateralAssetIndex;\n        callbackLogic(_account, _collateralAsset, _withdrawalAmount, _userData);\n        return \"\";\n    }\n\n    function execute(\n        address _collateralAsset,\n        uint256 _amount,\n        function(address, address, uint256, bytes memory) internal logic\n    ) internal {\n        bytes memory data = abi.encode(_amount, 0, address(0));\n        execute(_collateralAsset, _amount, data, logic);\n    }\n\n    function execute(\n        address _collateralAsset,\n        uint256 _amount,\n        bytes memory data,\n        function(address, address, uint256, bytes memory) internal logic\n    ) internal {\n        callbackLogic = logic;\n        withdrawalAmountRequested = _amount;\n        kresko.withdrawCollateralUnchecked(msg.sender, _collateralAsset, _amount, 0, data);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               Test functions                               */\n    /* -------------------------------------------------------------------------- */\n\n    // should send correct values to the callback\n    function test(address _collateralAsset, uint256 _amount) external {\n        execute(_collateralAsset, _amount, logicBase);\n    }\n\n    function testWithdrawalAmount(address _collateralAsset, uint256 _amount) external {\n        execute(_collateralAsset, _amount, logicTestWithdrawalAmount);\n    }\n\n    // should be able to redeposit\n    function testRedeposit(address _collateralAsset, uint256 _amount) external {\n        execute(_collateralAsset, _amount, logicRedeposit);\n    }\n\n    // should be able to redeposit\n    function testInsufficientRedeposit(address _collateralAsset, uint256 _amount) external {\n        execute(_collateralAsset, _amount, logicInsufficientRedeposit);\n    }\n\n    function testDepositAlternate(address _collateralWithdraw, uint _amount, address _collateralDeposit) external {\n        bytes memory data = abi.encode(_amount, 0, _collateralDeposit);\n        execute(_collateralWithdraw, _amount, data, logicDepositAlternate);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             Callback Execution                             */\n    /* -------------------------------------------------------------------------- */\n\n    function logicDepositAlternate(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawalAmount,\n        bytes memory _userData\n    ) internal {\n        _collateralAsset;\n        userData = abi.decode(_userData, (Params));\n        withdrawalAmountReceived = _withdrawalAmount;\n        IERC20Upgradeable(userData.addr).transferFrom(_account, address(this), userData.val);\n        IERC20Upgradeable(userData.addr).approve(address(kresko), userData.val);\n        // redeposit all\n        kresko.depositCollateral(_account, userData.addr, userData.val);\n    }\n\n    function logicBase(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawalAmount,\n        bytes memory _userData\n    ) internal {\n        // just set data\n        account = _account;\n        collateralAsset = _collateralAsset;\n        withdrawalAmountReceived = _withdrawalAmount;\n        userData = abi.decode(_userData, (Params));\n    }\n\n    function logicTestWithdrawalAmount(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawalAmount,\n        bytes memory _userData\n    ) internal {\n        _userData;\n        account = _account;\n        require(\n            IERC20Upgradeable(_collateralAsset).balanceOf(address(this)) == _withdrawalAmount,\n            \"wrong amount received\"\n        );\n    }\n\n    function logicRedeposit(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawalAmount,\n        bytes memory _userData\n    ) internal {\n        _userData;\n        withdrawalAmountReceived = _withdrawalAmount;\n        IERC20Upgradeable(_collateralAsset).approve(address(kresko), _withdrawalAmount);\n        // redeposit all\n        kresko.depositCollateral(_account, _collateralAsset, _withdrawalAmount);\n    }\n\n    function logicInsufficientRedeposit(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawalAmount,\n        bytes memory _userData\n    ) internal {\n        _userData;\n        withdrawalAmountReceived = _withdrawalAmount;\n        IERC20Upgradeable(_collateralAsset).approve(address(kresko), 1);\n        // bare minimum redeposit\n        kresko.depositCollateral(_account, _collateralAsset, 1);\n    }\n}\n"
    },
    "src/contracts/test/SmockFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {ISmockFacet} from \"./interfaces/ISmockFacet.sol\";\nimport {DiamondModifiers} from \"../shared/Modifiers.sol\";\nimport {SmockStorage, Errors} from \"./SmockStorage.sol\";\n\nbytes32 constant TEST_OPERATOR_ROLE = keccak256(\"kresko.test.operator\");\n\n/**\n * @dev Use for Smock fakes / mocks.\n */\ncontract SmockFacet is DiamondModifiers, ISmockFacet {\n    uint256 public constant MESSAGE_THROTTLE = 2;\n\n    function operator() external view returns (address) {\n        return SmockStorage.state().operator;\n    }\n\n    function activate() external override onlyRole(TEST_OPERATOR_ROLE) onlyDisabled {\n        SmockStorage.activate();\n    }\n\n    function disable() external override onlyRole(TEST_OPERATOR_ROLE) onlyActive {\n        SmockStorage.disable();\n    }\n\n    function smockInitialized() external view returns (bool) {\n        return SmockStorage.state().initialized;\n    }\n\n    function setMessage(string memory message) external override onlyActive {\n        require(block.number >= SmockStorage.state().lastMessageBlock + MESSAGE_THROTTLE, \"Cant set message yet\");\n\n        SmockStorage.state().message = message;\n        SmockStorage.state().callers[msg.sender] = true;\n\n        emit SmockStorage.Call(msg.sender);\n        emit NewMessage(msg.sender, message);\n    }\n\n    modifier onlyActive() {\n        require(SmockStorage.state().isActive, Errors.ACTIVE);\n        _;\n    }\n    modifier onlyDisabled() {\n        require(!SmockStorage.state().isActive, Errors.NOT_ACTIVE);\n        _;\n    }\n}\n"
    },
    "src/contracts/test/SmockFacet2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {GeneralEvent} from \"../libs/Events.sol\";\nimport {ISmockFacet} from \"./interfaces/ISmockFacet.sol\";\nimport {TEST_OPERATOR_ROLE} from \"./SmockFacet.sol\";\nimport {SmockStorage} from \"./SmockStorage.sol\";\n\ncontract SmockFacet2 {\n    function initialize() external {\n        SmockStorage.stateExtended().extended = true;\n    }\n\n    function getOldStructValueFromExtended() external view returns (bool) {\n        return SmockStorage.stateExtended().initialized;\n    }\n\n    function getNewStructValueFromExtended() external view returns (bool) {\n        return SmockStorage.stateExtended().extended;\n    }\n}\n"
    },
    "src/contracts/test/SmockInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {GeneralEvent} from \"../libs/Events.sol\";\nimport {Authorization, ds, Role, DiamondModifiers} from \"../shared/Modifiers.sol\";\n\nimport {ISmockFacet} from \"./interfaces/ISmockFacet.sol\";\nimport {TEST_OPERATOR_ROLE} from \"./SmockFacet.sol\";\nimport {SmockStorage} from \"./SmockStorage.sol\";\n\ncontract SmockInit is DiamondModifiers {\n    function initialize(address _operator) external onlyOwner onlyRole(Role.ADMIN) {\n        require(msg.sender == ds().contractOwner, \"WithStorage: Not owner\");\n        SmockStorage.initialize(_operator);\n\n        Authorization.grantRole(TEST_OPERATOR_ROLE, _operator);\n\n        ds().supportedInterfaces[type(ISmockFacet).interfaceId] = true;\n        emit GeneralEvent.Initialized(msg.sender, 1);\n    }\n\n    function getNumber() public pure returns (uint8) {\n        return 1;\n    }\n\n    function getBool() public pure returns (bool) {\n        return false;\n    }\n\n    function upgradeState() external {\n        ds().initialized = getBool();\n    }\n}\n"
    },
    "src/contracts/test/SmockStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nlibrary Errors {\n    string public constant INITIALIZED = \"Already initialized\";\n    string public constant NOT_ACTIVE = \"SmockFacet: Not active\";\n    string public constant ACTIVE = \"SmockFacet: Active\";\n}\n\nstruct SmockState {\n    bool initialized;\n    bool isActive;\n    address operator;\n    mapping(address => bool) callers;\n    string message;\n    uint256 lastMessageBlock;\n}\n// This is not how it has to be done in reality\n// We can just extend the original\nstruct SmockState2 {\n    bool initialized;\n    bool isActive;\n    address operator;\n    mapping(address => bool) callers;\n    string message;\n    uint256 lastMessageBlock;\n    bool extended;\n}\n\nlibrary SmockStorage {\n    event Call(address indexed caller);\n\n    bytes32 public constant SMOCK_STORAGE_POSITION = keccak256(\"kresko.smock.storage\");\n\n    function initialize(address _operator) internal {\n        SmockState storage ss = state();\n        require(!ss.initialized, Errors.INITIALIZED);\n        ss.initialized = true;\n        ss.operator = _operator;\n        emit Call(msg.sender);\n    }\n\n    function state() internal pure returns (SmockState storage ss) {\n        bytes32 position = SMOCK_STORAGE_POSITION;\n        assembly {\n            ss.slot := position\n        }\n    }\n\n    // This is not how it has to be done in reality\n    function stateExtended() internal pure returns (SmockState2 storage ss) {\n        bytes32 position = SMOCK_STORAGE_POSITION;\n        assembly {\n            ss.slot := position\n        }\n    }\n\n    function activate() internal {\n        state().isActive = true;\n        state().callers[msg.sender] = true;\n        emit Call(msg.sender);\n    }\n\n    function disable() internal {\n        state().isActive = false;\n        state().callers[msg.sender] = true;\n        emit Call(msg.sender);\n    }\n}\n"
    },
    "src/contracts/test/WETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport {WETH9} from \"../vendor/WETH9.sol\";\n\ncontract WETH is WETH9 {\n    mapping(address => bool) public minters;\n\n    constructor() {\n        minters[msg.sender] = true;\n    }\n\n    function deposit(uint256 amount) public {\n        require(minters[msg.sender], \"Not a minter\");\n        balanceOf[msg.sender] += amount;\n        emit Deposit(msg.sender, amount);\n    }\n}\n"
    },
    "src/contracts/vendor/flux/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface AggregatorInterface {\n    function latestAnswer() external view returns (int256);\n\n    function latestTimestamp() external view returns (uint256);\n\n    function latestMarketOpen() external view returns (bool);\n\n    function latestRound() external view returns (uint256);\n\n    function getAnswer(uint256 roundId) external view returns (int256);\n\n    function getTimestamp(uint256 roundId) external view returns (uint256);\n\n    function getMarketOpen(uint256 roundId) external view returns (bool);\n\n    event AnswerUpdated(int256 indexed current, bool marketOpen, uint256 indexed roundId, uint256 updatedAt);\n    event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "src/contracts/vendor/flux/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "src/contracts/vendor/flux/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n    \n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            bool marketOpen,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            bool marketOpen,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "src/contracts/vendor/gnosis/IGnosisSafeL2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.14;\n\ninterface IGnosisSafeL2 {\n    function isOwner(address owner) external view returns (bool);\n\n    function getOwners() external view returns (address[] memory);\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-core/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.16;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "src/contracts/vendor/WETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.14;\n\ncontract WETH9 {\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    function deposit() public payable virtual {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public virtual {\n        require(balanceOf[msg.sender] >= wad, \"WETH9: Error\");\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public virtual returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public virtual returns (bool) {\n        require(balanceOf[src] >= wad, \"WETH9: Error\");\n\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\n            require(allowance[src][msg.sender] >= wad, \"WETH9: Error\");\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "constantOptimizer": false,
        "deduplicate": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "metadata",
          "abi",
          "storageLayout",
          "evm.methodIdentifiers",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "evm.byteCode",
          "evm.bytecode",
          "evm.deployedBytecode"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}