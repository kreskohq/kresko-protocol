{
  "language": "Solidity",
  "sources": {
    "@kreskolabs/gnosis-safe-contracts/contracts/base/Executor.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/Enum.sol\";\n\n/// @title Executor - A contract that can execute transactions\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Executor {\n    function execute(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 txGas\n    ) internal returns (bool success) {\n        if (operation == Enum.Operation.DelegateCall) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n            }\n        } else {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n            }\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/base/FallbackManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../common/SelfAuthorized.sol\";\n\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract FallbackManager is SelfAuthorized {\n    event ChangedFallbackHandler(address handler);\n\n    // keccak256(\"fallback_manager.handler.address\")\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\n\n    function internalSetFallbackHandler(address handler) internal {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, handler)\n        }\n    }\n\n    /// @dev Allows to add a contract to handle fallback calls.\n    ///      Only fallback calls without value and with data will be forwarded.\n    ///      This can only be done via a Safe transaction.\n    /// @param handler contract to handle fallback calls.\n    function setFallbackHandler(address handler) public authorized {\n        internalSetFallbackHandler(handler);\n        emit ChangedFallbackHandler(handler);\n    }\n\n    // solhint-disable-next-line payable-fallback,no-complex-fallback\n    fallback() external {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let handler := sload(slot)\n            if iszero(handler) {\n                return(0, 0)\n            }\n            calldatacopy(0, 0, calldatasize())\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            mstore(calldatasize(), shl(96, caller()))\n            // Add 20 bytes for the address appended add the end\n            let success := call(gas(), handler, 0, 0, add(calldatasize(), 20), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if iszero(success) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/base/GuardManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\nimport \"../interfaces/IERC165.sol\";\n\ninterface Guard is IERC165 {\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address msgSender\n    ) external;\n\n    function checkAfterExecution(bytes32 txHash, bool success) external;\n}\n\nabstract contract BaseGuard is Guard {\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n        return\n            interfaceId == type(Guard).interfaceId || // 0xe6d7a83a\n            interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n}\n\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract GuardManager is SelfAuthorized {\n    event ChangedGuard(address guard);\n    // keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    /// @dev Set a guard that checks transactions before execution\n    /// @param guard The address of the guard to be used or the 0 address to disable the guard\n    function setGuard(address guard) external authorized {\n        if (guard != address(0)) {\n            require(Guard(guard).supportsInterface(type(Guard).interfaceId), \"GS300\");\n        }\n        bytes32 slot = GUARD_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, guard)\n        }\n        emit ChangedGuard(guard);\n    }\n\n    function getGuard() internal view returns (address guard) {\n        bytes32 slot = GUARD_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            guard := sload(slot)\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/base/ModuleManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\nimport \"./Executor.sol\";\n\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract ModuleManager is SelfAuthorized, Executor {\n    event EnabledModule(address module);\n    event DisabledModule(address module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    address internal constant SENTINEL_MODULES = address(0x1);\n\n    mapping(address => address) internal modules;\n\n    function setupModules(address to, bytes memory data) internal {\n        require(modules[SENTINEL_MODULES] == address(0), \"GS100\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0))\n            // Setup has to complete successfully or transaction fails.\n            require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), \"GS000\");\n    }\n\n    /// @dev Allows to add a module to the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Enables the module `module` for the Safe.\n    /// @param module Module to be whitelisted.\n    function enableModule(address module) public authorized {\n        // Module address cannot be null or sentinel.\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\n        // Module cannot be added twice.\n        require(modules[module] == address(0), \"GS102\");\n        modules[module] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = module;\n        emit EnabledModule(module);\n    }\n\n    /// @dev Allows to remove a module from the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Disables the module `module` for the Safe.\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\n    /// @param module Module to be removed.\n    function disableModule(address prevModule, address module) public authorized {\n        // Validate module address and check that it corresponds to module index.\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\n        require(modules[prevModule] == module, \"GS103\");\n        modules[prevModule] = modules[module];\n        modules[module] = address(0);\n        emit DisabledModule(module);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public virtual returns (bool success) {\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"GS104\");\n        // Execute transaction without further confirmations.\n        success = execute(to, value, data, operation, gasleft());\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public returns (bool success, bytes memory returnData) {\n        success = execTransactionFromModule(to, value, data, operation);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }\n\n    /// @dev Returns if an module is enabled\n    /// @return True if the module is enabled\n    function isModuleEnabled(address module) public view returns (bool) {\n        return SENTINEL_MODULES != module && modules[module] != address(0);\n    }\n\n    /// @dev Returns array of modules.\n    /// @param start Start of the page.\n    /// @param pageSize Maximum number of modules that should be returned.\n    /// @return array Array of modules.\n    /// @return next Start of the next page.\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next) {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        address currentModule = modules[start];\n        while (currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = currentModule;\n            currentModule = modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/base/OwnerManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/SelfAuthorized.sol\";\n\n/// @title OwnerManager - Manages a set of owners and a threshold to perform actions.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract OwnerManager is SelfAuthorized {\n    event AddedOwner(address owner);\n    event RemovedOwner(address owner);\n    event ChangedThreshold(uint256 threshold);\n\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    mapping(address => address) internal owners;\n    uint256 internal ownerCount;\n    uint256 internal threshold;\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    function setupOwners(address[] memory _owners, uint256 _threshold) internal {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"GS200\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"GS201\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"GS202\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this) && currentOwner != owner, \"GS203\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"GS204\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`.\n    /// @param owner New owner address.\n    /// @param _threshold New threshold.\n    function addOwnerWithThreshold(address owner, uint256 _threshold) public authorized {\n        // Owner address cannot be null, the sentinel or the Safe itself.\n        require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this), \"GS203\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"GS204\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.\n    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\n    /// @param owner Owner address to be removed.\n    /// @param _threshold New threshold.\n    function removeOwner(\n        address prevOwner,\n        address owner,\n        uint256 _threshold\n    ) public authorized {\n        // Only allow to remove an owner, if threshold can still be reached.\n        require(ownerCount - 1 >= _threshold, \"GS201\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"GS203\");\n        require(owners[prevOwner] == owner, \"GS205\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to swap/replace an owner from the Safe with another address.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\n    /// @param oldOwner Owner address to be replaced.\n    /// @param newOwner New owner address.\n    function swapOwner(\n        address prevOwner,\n        address oldOwner,\n        address newOwner\n    ) public authorized {\n        // Owner address cannot be null, the sentinel or the Safe itself.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS && newOwner != address(this), \"GS203\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"GS204\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"GS203\");\n        require(owners[prevOwner] == oldOwner, \"GS205\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }\n\n    /// @dev Allows to update the number of required confirmations by Safe owners.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Changes the threshold of the Safe to `_threshold`.\n    /// @param _threshold New threshold.\n    function changeThreshold(uint256 _threshold) public authorized {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"GS201\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"GS202\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }\n\n    function getThreshold() public view returns (uint256) {\n        return threshold;\n    }\n\n    function isOwner(address owner) public view returns (bool) {\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\n    }\n\n    /// @dev Returns array of owners.\n    /// @return Array of Safe owners.\n    function getOwners() public view returns (address[] memory) {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while (currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index++;\n        }\n        return array;\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/Enum.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {Call, DelegateCall}\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/EtherPaymentFallback.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract EtherPaymentFallback {\n    event SafeReceived(address indexed sender, uint256 value);\n\n    /// @dev Fallback function accepts Ether transactions.\n    receive() external payable {\n        emit SafeReceived(msg.sender, msg.value);\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/SecuredTokenTransfer.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SecuredTokenTransfer - Secure token transfer\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SecuredTokenTransfer {\n    /// @dev Transfers a token and returns if it was a success\n    /// @param token Token that should be transferred\n    /// @param receiver Receiver to whom the token should be transferred\n    /// @param amount The amount of tokens that should be transferred\n    function transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal returns (bool transferred) {\n        // 0xa9059cbb - keccack(\"transfer(address,uint256)\")\n        bytes memory data = abi.encodeWithSelector(0xa9059cbb, receiver, amount);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We write the return value to scratch space.\n            // See https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory\n            let success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            switch returndatasize()\n                case 0 {\n                    transferred := success\n                }\n                case 0x20 {\n                    transferred := iszero(or(iszero(success), iszero(mload(0))))\n                }\n                default {\n                    transferred := 0\n                }\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/SelfAuthorized.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SelfAuthorized - authorizes current contract to perform actions\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SelfAuthorized {\n    function requireSelfCall() private view {\n        require(msg.sender == address(this), \"GS031\");\n    }\n\n    modifier authorized() {\n        // This is a function call as it minimized the bytecode size\n        requireSelfCall();\n        _;\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/SignatureDecoder.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SignatureDecoder - Decodes signatures that a encoded as bytes\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SignatureDecoder {\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\n    /// @notice Make sure to perform a bounds check for @param pos, to avoid out of bounds access on @param signatures\n    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\n    /// @param signatures concatenated rsv signatures\n    function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/Singleton.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Singleton - Base for singleton contracts (should always be first super contract)\n///         This contract is tightly coupled to our proxy contract (see `proxies/GnosisSafeProxy.sol`)\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract Singleton {\n    // singleton always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\n    // It should also always be ensured that the address is stored alone (uses a full word)\n    address private singleton;\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/StorageAccessible.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title StorageAccessible - generic base contract that allows callers to access all internal storage.\n/// @notice See https://github.com/gnosis/util-contracts/blob/bb5fe5fb5df6d8400998094fb1b32a178a47c3a1/contracts/StorageAccessible.sol\ncontract StorageAccessible {\n    /**\n     * @dev Reads `length` bytes of storage in the currents contract\n     * @param offset - the offset in the current contract's storage in words to start reading from\n     * @param length - the number of words (32 bytes) of data to read\n     * @return the bytes that were read.\n     */\n    function getStorageAt(uint256 offset, uint256 length) public view returns (bytes memory) {\n        bytes memory result = new bytes(length * 32);\n        for (uint256 index = 0; index < length; index++) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let word := sload(add(offset, index))\n                mstore(add(add(result, 0x20), mul(index, 0x20)), word)\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Performs a delegatecall on a targetContract in the context of self.\n     * Internally reverts execution to avoid side effects (making it static).\n     *\n     * This method reverts with data equal to `abi.encode(bool(success), bytes(response))`.\n     * Specifically, the `returndata` after a call to this method will be:\n     * `success:bool || response.length:uint256 || response:bytes`.\n     *\n     * @param targetContract Address of the contract containing the code to execute.\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\n     */\n    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let success := delegatecall(gas(), targetContract, add(calldataPayload, 0x20), mload(calldataPayload), 0, 0)\n\n            mstore(0x00, success)\n            mstore(0x20, returndatasize())\n            returndatacopy(0x40, 0, returndatasize())\n            revert(0, add(returndatasize(), 0x40))\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/external/GnosisSafeMath.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title GnosisSafeMath\n * @dev Math operations with safety checks that revert on error\n * Renamed from SafeMath to GnosisSafeMath to avoid conflicts\n * TODO: remove once open zeppelin update to solc 0.5.0\n */\nlibrary GnosisSafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @notice More details at https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/IERC165.sol\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/interfaces/ISignatureValidator.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\ncontract ISignatureValidatorConstants {\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;\n}\n\nabstract contract ISignatureValidator is ISignatureValidatorConstants {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param _data Arbitrary length data signed on the behalf of address(this)\n     * @param _signature Signature byte array associated with _data\n     *\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(bytes memory _data, bytes memory _signature) public view virtual returns (bytes4);\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/proxies/GnosisSafeProxy.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\n/// @author Richard Meissner - <richard@gnosis.io>\ninterface IProxy {\n    function masterCopy() external view returns (address);\n}\n\n/// @title GnosisSafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract GnosisSafeProxy {\n    // singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\n    address internal singleton;\n\n    /// @dev Constructor function sets address of singleton contract.\n    /// @param _singleton Singleton address.\n    constructor(address _singleton) {\n        require(_singleton != address(0), \"Invalid singleton address provided\");\n        singleton = _singleton;\n    }\n\n    /// @dev Fallback function forwards all transactions and returns all received return data.\n    fallback() external payable {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\n                mstore(0, _singleton)\n                return(0, 0x20)\n            }\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/proxies/IProxyCreationCallback.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"./GnosisSafeProxy.sol\";\n\ninterface IProxyCreationCallback {\n    function proxyCreated(\n        GnosisSafeProxy proxy,\n        address _singleton,\n        bytes calldata initializer,\n        uint256 saltNonce\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "src/contracts/diamond/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable no-complex-fallback  */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable no-empty-blocks */\n\npragma solidity >=0.8.19;\n\nimport {IDiamondCutFacet} from \"./interfaces/IDiamondCutFacet.sol\";\nimport {Authorization, Role} from \"../libs/Authorization.sol\";\nimport {GeneralEvent} from \"../libs/Events.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\nimport {initializeDiamondCut} from \"./libs/LibDiamondCut.sol\";\nimport {ds} from \"./DiamondStorage.sol\";\n\ncontract Diamond {\n    struct Initialization {\n        address initContract;\n        bytes initData;\n    }\n\n    constructor(\n        address _owner,\n        IDiamondCutFacet.FacetCut[] memory _diamondCut,\n        Initialization[] memory _initializations\n    ) {\n        ds().initialize(_owner);\n        ds().diamondCut(_diamondCut, address(0), \"\");\n        Authorization._grantRole(Role.ADMIN, _owner);\n\n        for (uint256 i = 0; i < _initializations.length; i++) {\n            initializeDiamondCut(_initializations[i].initContract, _initializations[i].initData);\n        }\n\n        emit GeneralEvent.Initialized(_owner, ds().storageVersion);\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        // get facet from function selectors\n        address facet = ds().selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), Error.DIAMOND_INVALID_FUNCTION_SIGNATURE);\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "src/contracts/diamond/DiamondModifiers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {Authorization, Role} from \"../libs/Authorization.sol\";\nimport {Meta} from \"../libs/Meta.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\nimport {Action} from \"../minter/MinterTypes.sol\";\nimport {ms} from \"../minter/MinterStorage.sol\";\n\nimport {ENTERED, NOT_ENTERED} from \"../diamond/DiamondTypes.sol\";\nimport {ds} from \"../diamond/DiamondStorage.sol\";\n\nabstract contract DiamondModifiers {\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^Authorization: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        Authorization.checkRole(role);\n        _;\n    }\n\n    /**\n     * @notice Ensure only trusted contracts can act on behalf of `_account`\n     * @param _accountIsNotMsgSender The address of the collateral asset.\n     */\n    modifier onlyRoleIf(bool _accountIsNotMsgSender, bytes32 role) {\n        if (_accountIsNotMsgSender) {\n            Authorization.checkRole(role);\n        }\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(Meta.msgSender() == ds().contractOwner, Error.DIAMOND_INVALID_OWNER);\n        _;\n    }\n\n    modifier onlyPendingOwner() {\n        require(Meta.msgSender() == ds().pendingOwner, Error.DIAMOND_INVALID_PENDING_OWNER);\n        _;\n    }\n\n    modifier nonReentrant() {\n        require(ds().entered == NOT_ENTERED, Error.RE_ENTRANCY);\n        ds().entered = ENTERED;\n        _;\n        ds().entered = NOT_ENTERED;\n    }\n}\n"
    },
    "src/contracts/diamond/DiamondState.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {EnumerableSet} from \"../libs/EnumerableSet.sol\";\nimport {FacetAddressAndPosition, FacetFunctionSelectors, RoleData, ENTERED, NOT_ENTERED} from \"./DiamondTypes.sol\";\n\nimport {LibDiamondCut} from \"./libs/LibDiamondCut.sol\";\nimport {LibOwnership} from \"./libs/LibOwnership.sol\";\n\nusing LibDiamondCut for DiamondState global;\nusing LibOwnership for DiamondState global;\n\n/* -------------------------------------------------------------------------- */\n/*                                 Main Layout                                */\n/* -------------------------------------------------------------------------- */\n\nstruct DiamondState {\n    /* -------------------------------------------------------------------------- */\n    /*                                   Proxy                                    */\n    /* -------------------------------------------------------------------------- */\n    /// @notice Maps function selector to the facet address and\n    /// the position of the selector in the facetFunctionSelectors.selectors array\n    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n    /// @notice Maps facet addresses to function selectors\n    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n    /// @notice Facet addresses\n    address[] facetAddresses;\n    /// @notice ERC165 query implementation\n    mapping(bytes4 => bool) supportedInterfaces;\n    /* -------------------------------------------------------------------------- */\n    /*                               Initialization                               */\n    /* -------------------------------------------------------------------------- */\n    /// @notice Initialization status\n    bool initialized;\n    /// @notice Domain field separator\n    bytes32 domainSeparator;\n    /* -------------------------------------------------------------------------- */\n    /*                                  Ownership                                 */\n    /* -------------------------------------------------------------------------- */\n    /// @notice Current owner of the diamond\n    address contractOwner;\n    /// @notice Pending new diamond owner\n    address pendingOwner;\n    /// @notice Storage version\n    uint8 storageVersion;\n    /// @notice address(this) replacement for FF\n    address self;\n    /* -------------------------------------------------------------------------- */\n    /*                               Access Control                               */\n    /* -------------------------------------------------------------------------- */\n    mapping(bytes32 => RoleData) _roles;\n    mapping(bytes32 => EnumerableSet.AddressSet) _roleMembers;\n    /* -------------------------------------------------------------------------- */\n    /*                                 Reentrancy                                 */\n    /* -------------------------------------------------------------------------- */\n    uint256 entered;\n}\n"
    },
    "src/contracts/diamond/DiamondStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\npragma solidity >=0.8.19;\n\nimport {DiamondState} from \"./DiamondState.sol\";\n\n// Storage position\nbytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"kresko.diamond.storage\");\n\nfunction ds() pure returns (DiamondState storage state) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n        state.slot := position\n    }\n}\n"
    },
    "src/contracts/diamond/DiamondTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n/// @dev set the initial value to 1 as we do not\n/// wanna hinder possible gas refunds by setting it to 0 on exit.\n\n/* -------------------------------------------------------------------------- */\n/*                                 Reentrancy                                 */\n/* -------------------------------------------------------------------------- */\nuint256 constant NOT_ENTERED = 1;\nuint256 constant ENTERED = 2;\n\n/* ========================================================================== */\n/*                                   STRUCTS                                  */\n/* ========================================================================== */\n\nstruct FacetAddressAndPosition {\n    address facetAddress;\n    // position in facetFunctionSelectors.functionSelectors array\n    uint96 functionSelectorPosition;\n}\n\nstruct FacetFunctionSelectors {\n    bytes4[] functionSelectors;\n    // position of facetAddress in facetAddresses array\n    uint256 facetAddressPosition;\n}\n\nstruct RoleData {\n    mapping(address => bool) members;\n    bytes32 adminRole;\n}\n"
    },
    "src/contracts/diamond/facets/AuthorizationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IAuthorizationFacet} from \"../interfaces/IAuthorizationFacet.sol\";\nimport {Authorization, Role} from \"../../libs/Authorization.sol\";\n\n/**\n * @title Enumerable access control for the EIP2535-pattern following the OZ implementation.\n * @author Kresko\n * @notice The storage area is in the main proxy diamond storage.\n * @dev Difference here is the logic library that is shared and reused, there is no state here.\n */\ncontract AuthorizationFacet is IAuthorizationFacet {\n    using Authorization for bytes32;\n\n    /// @inheritdoc IAuthorizationFacet\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address) {\n        return role.getRoleMember(index);\n    }\n\n    /// @inheritdoc IAuthorizationFacet\n    function getRoleMemberCount(bytes32 role) external view returns (uint256) {\n        return role.getRoleMemberCount();\n    }\n\n    /// @inheritdoc IAuthorizationFacet\n    function grantRole(bytes32 role, address account) external {\n        role.grantRole(account);\n    }\n\n    /// @inheritdoc IAuthorizationFacet\n    function revokeRole(bytes32 role, address account) external {\n        role.revokeRole(account);\n    }\n\n    /// @inheritdoc IAuthorizationFacet\n    function hasRole(bytes32 role, address account) external view returns (bool) {\n        return role.hasRole(account);\n    }\n\n    /// @inheritdoc IAuthorizationFacet\n    function getRoleAdmin(bytes32 role) external view returns (bytes32) {\n        return role.getRoleAdmin();\n    }\n\n    /// @inheritdoc IAuthorizationFacet\n    function renounceRole(bytes32 role, address account) external {\n        role._renounceRole(account);\n    }\n}\n"
    },
    "src/contracts/diamond/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {IDiamondCutFacet} from \"../interfaces/IDiamondCutFacet.sol\";\nimport {DiamondModifiers, Role} from \"../DiamondModifiers.sol\";\nimport {initializeDiamondCut} from \"../libs/LibDiamondCut.sol\";\nimport {ds} from \"../DiamondStorage.sol\";\n\n/**\n * @title EIP2535-pattern upgrades.\n * @author Kresko\n * @notice The storage area is in the main proxy diamond storage.\n */\ncontract DiamondCutFacet is IDiamondCutFacet, DiamondModifiers {\n    /// @inheritdoc IDiamondCutFacet\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external onlyRole(Role.ADMIN) {\n        ds().diamondCut(_diamondCut, _init, _calldata);\n    }\n\n    /// @inheritdoc IDiamondCutFacet\n    function upgradeState(address _init, bytes calldata _calldata) external onlyRole(Role.ADMIN) {\n        initializeDiamondCut(_init, _calldata);\n    }\n}\n"
    },
    "src/contracts/diamond/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {IDiamondLoupeFacet} from \"../interfaces/IDiamondLoupeFacet.sol\";\nimport {ds, DiamondState} from \"../DiamondStorage.sol\";\n\ncontract DiamondLoupeFacet is IDiamondLoupeFacet {\n    /// @inheritdoc IDiamondLoupeFacet\n    function facets() external view override returns (Facet[] memory facets_) {\n        DiamondState storage s = ds();\n        uint256 numFacets = s.facetAddresses.length;\n        facets_ = new Facet[](numFacets);\n        for (uint256 i; i < numFacets; i++) {\n            address facetAddress_ = s.facetAddresses[i];\n            facets_[i].facetAddress = facetAddress_;\n            facets_[i].functionSelectors = s.facetFunctionSelectors[facetAddress_].functionSelectors;\n        }\n    }\n\n    /// @inheritdoc IDiamondLoupeFacet\n    function facetFunctionSelectors(\n        address _facet\n    ) external view override returns (bytes4[] memory facetFunctionSelectors_) {\n        facetFunctionSelectors_ = ds().facetFunctionSelectors[_facet].functionSelectors;\n    }\n\n    /// @inheritdoc IDiamondLoupeFacet\n    function facetAddresses() external view override returns (address[] memory facetAddresses_) {\n        facetAddresses_ = ds().facetAddresses;\n    }\n\n    /// @inheritdoc IDiamondLoupeFacet\n    function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\n        facetAddress_ = ds().selectorToFacetAndPosition[_functionSelector].facetAddress;\n    }\n}\n"
    },
    "src/contracts/diamond/facets/DiamondOwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {IDiamondOwnershipFacet} from \"../interfaces/IDiamondOwnershipFacet.sol\";\nimport {DiamondModifiers} from \"../DiamondModifiers.sol\";\nimport {ds} from \"../DiamondStorage.sol\";\n\ncontract DiamondOwnershipFacet is IDiamondOwnershipFacet, DiamondModifiers {\n    /* -------------------------------------------------------------------------- */\n    /*                                    Write                                   */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IDiamondOwnershipFacet\n    function transferOwnership(address _newOwner) external override onlyOwner {\n        ds().initiateOwnershipTransfer(_newOwner);\n    }\n\n    /// @inheritdoc IDiamondOwnershipFacet\n    function acceptOwnership() external override onlyPendingOwner {\n        ds().finalizeOwnershipTransfer();\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Read                                    */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IDiamondOwnershipFacet\n    function owner() external view override returns (address owner_) {\n        return ds().contractOwner;\n    }\n\n    /// @inheritdoc IDiamondOwnershipFacet\n    function pendingOwner() external view override returns (address pendingOwner_) {\n        return ds().pendingOwner;\n    }\n\n    /// @inheritdoc IDiamondOwnershipFacet\n    function initialized() external view returns (bool initialized_) {\n        return ds().initialized;\n    }\n}\n"
    },
    "src/contracts/diamond/facets/ERC165Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {Error} from \"../../libs/Errors.sol\";\nimport {DiamondModifiers, Role} from \"../DiamondModifiers.sol\";\nimport {IERC165Facet} from \"../interfaces/IERC165Facet.sol\";\nimport {ds, DiamondState} from \"../DiamondStorage.sol\";\n\ncontract ERC165Facet is IERC165Facet, DiamondModifiers {\n    /// @inheritdoc IERC165Facet\n    function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\n        return ds().supportedInterfaces[_interfaceId];\n    }\n\n    /// @inheritdoc IERC165Facet\n    function setERC165(\n        bytes4[] calldata interfaceIds,\n        bytes4[] calldata interfaceIdsToRemove\n    ) external onlyRole(Role.ADMIN) {\n        DiamondState storage s = ds();\n\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            s.supportedInterfaces[interfaceIds[i]] = true;\n        }\n\n        for (uint256 i = 0; i < interfaceIdsToRemove.length; i++) {\n            s.supportedInterfaces[interfaceIdsToRemove[i]] = false;\n        }\n    }\n}\n"
    },
    "src/contracts/diamond/interfaces/IAuthorizationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface IAuthorizationFacet {\n    /**\n     * @dev OpenZeppelin\n     * Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * @notice WARNING:\n     * When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block.\n     *\n     * See the following forum post for more information:\n     * - https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296\n     *\n     * @dev Kresko\n     *\n     * TL;DR above:\n     *\n     * - If you iterate the EnumSet outside a single block scope you might get different results.\n     * - Since when EnumSet member is deleted it is replaced with the highest index.\n     * @return address with the `role`\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     * @notice See warning in {getRoleMember} if combining these two\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * @notice To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Returns true if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * @notice Requirements\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * @notice Requirements\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n}\n"
    },
    "src/contracts/diamond/interfaces/IDiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\nimport {DiamondEvent} from \"../../libs/Events.sol\";\n\ninterface IDiamondCutFacet {\n    /// @dev  Add=0, Replace=1, Remove=2\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /**\n     *@notice Add/replace/remove any number of functions, optionally execute a function with delegatecall\n     * @param _diamondCut Contains the facet addresses and function selectors\n     * @param _init The address of the contract or facet to execute _calldata\n     * @param _calldata A function call, including function selector and arguments\n     *                  _calldata is executed with delegatecall on _init\n     */\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n\n    /**\n     * @notice Use an initializer contract without doing modifications\n     * @param _init The address of the contract or facet to execute _calldata\n     * @param _calldata A function call, including function selector and arguments\n     * - _calldata is executed with delegatecall on _init\n     */\n    function upgradeState(address _init, bytes calldata _calldata) external;\n}\n"
    },
    "src/contracts/diamond/interfaces/IDiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupeFacet {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "src/contracts/diamond/interfaces/IDiamondOwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n/// @title Contract Ownership\ninterface IDiamondOwnershipFacet {\n    /**\n     * @notice Get the address of the owner\n     * @return owner_ The address of the owner.\n     */\n    function owner() external view returns (address owner_);\n\n    /**\n     * @notice Get the address of pending owner\n     * @return pendingOwner_ The address of the pending owner.\n     **/\n    function pendingOwner() external view returns (address pendingOwner_);\n\n    /**\n     * @notice Initiate ownership transfer to a new address\n     * @notice caller must be the current contract owner\n     * @notice the new owner cannot be address(0)\n     * @notice emits a {AuthEvent.PendingOwnershipTransfer} event\n     * @param _newOwner address that is set as the pending new owner\n     */\n    function transferOwnership(address _newOwner) external;\n\n    /**\n     * @notice Transfer the ownership to the new pending owner\n     * @notice caller must be the pending owner\n     * @notice emits a {AuthEvent.OwnershipTransferred} event\n     */\n    function acceptOwnership() external;\n\n    /**\n     * @notice Check if the contract is initialized\n     * @return initialized_ bool True if the contract is initialized, false otherwise.\n     */\n    function initialized() external view returns (bool initialized_);\n}\n"
    },
    "src/contracts/diamond/interfaces/IERC165Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\nimport {DiamondEvent} from \"../../libs/Events.sol\";\n\ninterface IERC165Facet {\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @dev Interface identification is specified in ERC-165. This function\n     *  uses less than 30,000 gas.\n     * @return `true` if the contract implements `interfaceID` and\n     *  `interfaceID` is not 0xffffffff, `false` otherwise\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    /**\n     * @notice set or unset ERC165 using DiamondStorage.supportedInterfaces\n     * @param interfaceIds list of interface id to set as supported\n     * @param interfaceIdsToRemove list of interface id to unset as supported.\n     * Technically, you can remove support of ERC165 by having the IERC165 id itself being part of that array.\n     */\n    function setERC165(bytes4[] calldata interfaceIds, bytes4[] calldata interfaceIdsToRemove) external;\n}\n"
    },
    "src/contracts/diamond/libs/LibDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\nimport {IDiamondCutFacet} from \"../interfaces/IDiamondCutFacet.sol\";\n\nimport {Meta} from \"../../libs/Meta.sol\";\nimport {DiamondEvent} from \"../../libs/Events.sol\";\nimport {DiamondState} from \"../DiamondState.sol\";\n\n// solhint-disable-next-line func-visibility\nfunction initializeDiamondCut(address _init, bytes memory _calldata) {\n    if (_init == address(0)) {\n        require(_calldata.length == 0, \"DiamondCut: _init is address(0) but_calldata is not empty\");\n    } else {\n        require(_calldata.length > 0, \"DiamondCut: _calldata is empty but _init is not address(0)\");\n        Meta.enforceHasContractCode(_init, \"DiamondCut: _init address has no code\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up the error\n                revert(string(error));\n            } else {\n                revert(\"DiamondCut: _init function reverted\");\n            }\n        }\n    }\n}\n\nlibrary LibDiamondCut {\n    /* -------------------------------------------------------------------------- */\n    /*                              Diamond Functions                             */\n    /* -------------------------------------------------------------------------- */\n\n    function diamondCut(\n        DiamondState storage self,\n        IDiamondCutFacet.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCutFacet.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCutFacet.FacetCutAction.Add) {\n                self.addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCutFacet.FacetCutAction.Replace) {\n                self.replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCutFacet.FacetCutAction.Remove) {\n                self.removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"DiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondEvent.DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(\n        DiamondState storage self,\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(_functionSelectors.length > 0, \"DiamondCut: No selectors in facet to cut\");\n        require(_facetAddress != address(0), \"DiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(self.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            self.addFacet(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = self.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"DiamondCut: Can't add function that already exists\");\n            self.addFunction(selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(\n        DiamondState storage self,\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(_functionSelectors.length > 0, \"DiamondCut: No selectors in facet to cut\");\n        require(_facetAddress != address(0), \"DiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(self.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            self.addFacet(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = self.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"DiamondCut: Can't replace function with same function\");\n            self.removeFunction(oldFacetAddress, selector);\n            self.addFunction(selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(\n        DiamondState storage self,\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(_functionSelectors.length > 0, \"DiamondCut: No selectors in facet to cut\");\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"DiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = self.selectorToFacetAndPosition[selector].facetAddress;\n            self.removeFunction(oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondState storage self, address _facetAddress) internal {\n        Meta.enforceHasContractCode(_facetAddress, \"DiamondCut: New facet has no code\");\n        self.facetFunctionSelectors[_facetAddress].facetAddressPosition = self.facetAddresses.length;\n        self.facetAddresses.push(_facetAddress);\n    }\n\n    function addFunction(\n        DiamondState storage self,\n        bytes4 _selector,\n        uint96 _selectorPosition,\n        address _facetAddress\n    ) internal {\n        self.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        self.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        self.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondState storage self, address _facetAddress, bytes4 _selector) internal {\n        require(_facetAddress != address(0), \"DiamondCut: Can't remove function that doesn't exist\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = self.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = self.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = self.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            self.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            self.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        self.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete self.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = self.facetAddresses.length - 1;\n            uint256 facetAddressPosition = self.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = self.facetAddresses[lastFacetAddressPosition];\n                self.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                self.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            self.facetAddresses.pop();\n            delete self.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n}\n"
    },
    "src/contracts/diamond/libs/LibOwnership.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {IERC165} from \"../../shared/IERC165.sol\";\nimport {IDiamondCutFacet} from \"../interfaces/IDiamondCutFacet.sol\";\nimport {IDiamondLoupeFacet} from \"../interfaces/IDiamondLoupeFacet.sol\";\nimport {IDiamondOwnershipFacet} from \"../interfaces/IDiamondOwnershipFacet.sol\";\nimport {IAuthorizationFacet} from \"../interfaces/IAuthorizationFacet.sol\";\n\nimport {GeneralEvent, AuthEvent} from \"../../libs/Events.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Meta} from \"../../libs/Meta.sol\";\n\nimport {NOT_ENTERED} from \"../DiamondTypes.sol\";\nimport {DiamondState} from \"../DiamondState.sol\";\n\nlibrary LibOwnership {\n    /* -------------------------------------------------------------------------- */\n    /*                         Initialization & Ownership                         */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Ownership initializer\n    /// @notice Only called on the first deployment\n    function initialize(DiamondState storage self, address _owner) internal {\n        require(!self.initialized, Error.ALREADY_INITIALIZED);\n        self.entered = NOT_ENTERED;\n        self.initialized = true;\n        self.storageVersion++;\n        self.contractOwner = _owner;\n\n        self.supportedInterfaces[type(IDiamondLoupeFacet).interfaceId] = true;\n        self.supportedInterfaces[type(IERC165).interfaceId] = true;\n        self.supportedInterfaces[type(IDiamondCutFacet).interfaceId] = true;\n        self.supportedInterfaces[type(IDiamondOwnershipFacet).interfaceId] = true;\n        self.supportedInterfaces[type(IAuthorizationFacet).interfaceId] = true;\n\n        emit GeneralEvent.Deployed(_owner, self.storageVersion);\n        emit AuthEvent.OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Initiate ownership transfer to a new address\n     * @param _newOwner address that is set as the pending new owner\n     * @notice caller must be the current contract owner\n     */\n    function initiateOwnershipTransfer(DiamondState storage self, address _newOwner) internal {\n        require(Meta.msgSender() == self.contractOwner, Error.DIAMOND_INVALID_OWNER);\n        require(_newOwner != address(0), \"DS: Owner cannot be 0-address\");\n\n        self.pendingOwner = _newOwner;\n\n        emit AuthEvent.PendingOwnershipTransfer(self.contractOwner, _newOwner);\n    }\n\n    /**\n     * @dev Transfer the ownership to the new pending owner\n     * @notice caller must be the pending owner\n     */\n    function finalizeOwnershipTransfer(DiamondState storage self) internal {\n        address sender = Meta.msgSender();\n        require(sender == self.pendingOwner, Error.DIAMOND_INVALID_PENDING_OWNER);\n        self.contractOwner = self.pendingOwner;\n        self.pendingOwner = address(0);\n\n        emit AuthEvent.OwnershipTransferred(self.contractOwner, sender);\n    }\n}\n"
    },
    "src/contracts/kiss/interfaces/IKISS.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {IERC20Permit} from \"../../shared/IERC20Permit.sol\";\n\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\nimport {IERC165} from \"../../shared/IERC165.sol\";\n\ninterface IKISS is IKreskoAssetIssuer, IERC165 {\n    /* -------------------------------------------------------------------------- */\n    /*                                   Events                                   */\n    /* -------------------------------------------------------------------------- */\n    event NewOperatorInitialized(address indexed pendingNewOperator, uint256 unlockTimestamp);\n    event NewOperator(address indexed newOperator);\n    event NewMaxOperators(uint256 newMaxOperators);\n    event NewPendingOperatorWaitPeriod(uint256 newPeriod);\n\n    function pendingOperatorUnlockTime() external returns (uint256);\n\n    function pendingOperator() external returns (address);\n\n    function maxOperators() external returns (uint256);\n\n    /**\n     * @notice This function adds KISS to circulation\n     * Caller must be a contract and have the OPERATOR_ROLE\n     * @param _to address to mint tokens to\n     * @param _amount amount to mint\n     * @return amount minted\n     */\n    function issue(uint256 _amount, address _to) external returns (uint256);\n\n    /**\n     * @notice Use operator role for minting, so override the parent\n     * Caller must be a contract and have the OPERATOR_ROLE\n     * @param _to address to mint tokens to\n     * @param _amount amount to mint\n     * @dev Does not return a value\n     */\n    function mint(address _to, uint256 _amount) external;\n\n    /**\n     * @notice This function removes KISS from circulation\n     * Caller must be a contract and have the OPERATOR_ROLE\n     * @param _from address to burn tokens from\n     * @param destroyed amount burned\n     * @inheritdoc IKreskoAssetIssuer\n     */\n    function destroy(uint256 _amount, address _from) external returns (uint256 destroyed);\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function pause() external;\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function unpause() external;\n\n    /**\n     * @notice Set a new waiting period for a new operator\n     *\n     * Must be at least 15 minutes\n     *\n     * @param _newPeriod the period, in seconds\n     */\n    function setPendingOperatorWaitPeriod(uint256 _newPeriod) external;\n\n    /**\n     * @notice Allows ADMIN_ROLE to change the maximum operators\n     * @param _maxOperators new maximum amount of operators\n     */\n    function setMaxOperators(uint256 _maxOperators) external;\n\n    /**\n     * @notice Overrides `AccessControl.grantRole` for following:\n     * * Implement a cooldown period of `pendingOperatorWaitPeriod` minutes for setting a new OPERATOR_ROLE\n     * * EOA cannot be granted the operator role\n     *\n     * @notice OPERATOR_ROLE can still be revoked without this cooldown period\n     * @notice PAUSER_ROLE can still be granted without this cooldown period\n     * @param _role role to grant\n     * @param _to address to grant role for\n     */\n    function grantRole(bytes32 _role, address _to) external;\n}\n"
    },
    "src/contracts/kiss/KISS.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n// solhint-disable-next-line\nimport {AccessControlEnumerableUpgradeable, AccessControlUpgradeable, IAccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"../shared/ERC20Upgradeable.sol\";\nimport {IKreskoAssetIssuer} from \"../kreskoasset/IKreskoAssetIssuer.sol\";\nimport {IKISS, IERC165} from \"./interfaces/IKISS.sol\";\nimport {Role} from \"../libs/Authorization.sol\";\nimport {Error} from \"../libs/Errors.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @title Kresko Integrated Stable System\n * This is a non-rebasing Kresko Asset, intended to be paired to a stable-value underlying.\n * @author Kresko\n */\ncontract KISS is IKISS, ERC20Upgradeable, PausableUpgradeable, AccessControlEnumerableUpgradeable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant OPERATOR_ROLE = 0x112e48a576fb3a75acc75d9fcf6e0bc670b27b1dbcd2463502e10e68cf57d6fd;\n\n    modifier onlyContract() {\n        require(msg.sender.code.length > 0, Error.CALLER_NOT_CONTRACT);\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Layout                                   */\n    /* -------------------------------------------------------------------------- */\n\n    uint256 public pendingOperatorWaitPeriod;\n    uint256 public pendingOperatorUnlockTime;\n    uint256 public maxOperators;\n    address public pendingOperator;\n    address public kresko;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Writes                                   */\n    /* -------------------------------------------------------------------------- */\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        uint8 dec_,\n        address admin_,\n        address kresko_\n    ) external initializer {\n        // Few sanity checks, we do not want EOA's here\n        require(kresko_.code.length > 0, Error.KRESKO_NOT_CONTRACT);\n        // require(admin_.code.length > 0, Error.ADMIN_NOT_A_CONTRACT);\n\n        // ERC20\n        name = name_;\n        symbol = symbol_;\n        decimals = dec_;\n        kresko = kresko_;\n\n        // 2 operators needed at the time of writing, the volative market and the stable market.\n        maxOperators = 2;\n\n        // 15 minutes to wait before the operator can accept the role, this is the minimum value that can be set.\n        pendingOperatorWaitPeriod = 15 minutes;\n\n        // Setup the admin\n        _setupRole(Role.DEFAULT_ADMIN, admin_);\n        _setupRole(Role.ADMIN, admin_);\n\n        // Setup the protocol\n        kresko = kresko_;\n        _setupRole(Role.OPERATOR, kresko_);\n        _setupRole(MINTER_ROLE, kresko_);\n        _setupRole(PAUSER_ROLE, kresko_);\n\n        // Deployer does not need roles, uncomment for mainnet\n        renounceRole(MINTER_ROLE, msg.sender);\n        renounceRole(PAUSER_ROLE, msg.sender);\n        // renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public pure override(AccessControlEnumerableUpgradeable, IERC165) returns (bool) {\n        return\n            interfaceId != 0xffffffff &&\n            (interfaceId == type(IKISS).interfaceId ||\n                interfaceId == type(IKreskoAssetIssuer).interfaceId ||\n                interfaceId == 0x01ffc9a7 ||\n                interfaceId == 0x36372b07);\n    }\n\n    /// @inheritdoc IKISS\n    function issue(\n        uint256 _amount,\n        address _to\n    ) public override onlyContract onlyRole(Role.OPERATOR) returns (uint256) {\n        _mint(_to, _amount);\n        return _amount;\n    }\n\n    /// @inheritdoc IKISS\n    function mint(address _to, uint256 _amount) public onlyContract onlyRole(Role.OPERATOR) {\n        _mint(_to, _amount);\n    }\n\n    /// @inheritdoc IKISS\n    function destroy(uint256 _amount, address _from) external onlyContract onlyRole(Role.OPERATOR) returns (uint256) {\n        _burn(_from, _amount);\n        return _amount;\n    }\n\n    /// @inheritdoc IKISS\n    function pause() public onlyContract onlyRole(Role.ADMIN) {\n        super._pause();\n    }\n\n    /// @inheritdoc IKISS\n    function unpause() public onlyContract onlyRole(Role.ADMIN) {\n        _unpause();\n    }\n\n    /// @inheritdoc IKISS\n    function setPendingOperatorWaitPeriod(uint256 _newPeriod) external onlyRole(Role.ADMIN) {\n        require(_newPeriod >= 15 minutes, Error.OPERATOR_WAIT_PERIOD_TOO_SHORT);\n        pendingOperatorWaitPeriod = _newPeriod;\n        emit NewPendingOperatorWaitPeriod(_newPeriod);\n    }\n\n    /// @inheritdoc IKISS\n    function setMaxOperators(uint256 _maxOperators) external onlyRole(Role.ADMIN) {\n        maxOperators = _maxOperators;\n        emit NewMaxOperators(_maxOperators);\n    }\n\n    /// @inheritdoc IKISS\n    function grantRole(\n        bytes32 _role,\n        address _to\n    ) public override(IKISS, AccessControlUpgradeable, IAccessControlUpgradeable) onlyRole(Role.ADMIN) {\n        // Default behavior\n        if (_role != Role.OPERATOR) {\n            _grantRole(_role, _to);\n            return;\n        }\n\n        // Handle the operator role\n        require(_to.code.length > 0, Error.OPERATOR_NOT_CONTRACT);\n        if (pendingOperator != address(0)) {\n            // Ensure cooldown period\n            require(pendingOperatorUnlockTime < block.timestamp, Error.OPERATOR_WAIT_PERIOD_NOT_OVER);\n            // Grant role\n            _grantRole(Role.OPERATOR, pendingOperator);\n            emit NewOperator(_msgSender());\n            // Reset pending owner\n            // No need to touch the timestamp (next call will just trigger the cooldown period)\n            pendingOperator = address(0);\n        } else if (pendingOperatorUnlockTime != 0) {\n            // Do not allow more than `maxOperators` of operators\n            require(getRoleMemberCount(Role.OPERATOR) < maxOperators, Error.OPERATOR_LIMIT_REACHED);\n            // Set the timestamp for the cooldown period\n            pendingOperatorUnlockTime = block.timestamp + pendingOperatorWaitPeriod;\n            // Set the pending oeprator, execution to upper if clause next call as this pending operator is set\n            pendingOperator = _to;\n            emit NewOperatorInitialized(_to, pendingOperatorUnlockTime);\n        } else {\n            // Initialize operator for the first time\n            _grantRole(Role.OPERATOR, _to);\n            emit NewOperator(_to);\n            // Set the timestamp, execution will not come here again\n            pendingOperatorUnlockTime = block.timestamp;\n        }\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Views                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IKreskoAssetIssuer\n    function convertToShares(uint256 assets) external pure returns (uint256) {\n        return assets;\n    }\n\n    /// @inheritdoc IKreskoAssetIssuer\n    function convertToAssets(uint256 shares) external pure returns (uint256) {\n        return shares;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  internal                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        super._beforeTokenTransfer(from, to, amount);\n        require(!paused(), \"KISS: Paused\");\n    }\n}\n"
    },
    "src/contracts/kreskoasset/ERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.19;\n\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\n\nimport {SafeERC20} from \"../shared/SafeERC20.sol\";\nimport {IKreskoAsset, IERC20Permit} from \"./IKreskoAsset.sol\";\nimport {IERC4626Upgradeable} from \"./IERC4626Upgradeable.sol\";\nimport {ERC20Upgradeable} from \"./KreskoAsset.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\n/* solhint-disable func-name-mixedcase */\n/* solhint-disable no-empty-blocks */\n/* solhint-disable func-visibility */\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @notice Kresko:\n/// Adds issue/destroy functions that are called when KreskoAssets are minted/burned through the protocol.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @author Kresko (https://www.kresko.fi)\nabstract contract ERC4626Upgradeable is IERC4626Upgradeable, ERC20Upgradeable {\n    using SafeERC20 for IKreskoAsset;\n    using FixedPointMathLib for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Events                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event Issue(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Destroy(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Immutables                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IERC4626Upgradeable\n    IKreskoAsset public immutable asset;\n\n    constructor(IKreskoAsset _asset) payable {\n        asset = _asset;\n    }\n\n    /**\n     * @notice Initializes the ERC4626.\n     *\n     * @param _asset The underlying (Kresko) Asset\n     * @param _name Name of the anchor token\n     * @param _symbol Symbol of the anchor token\n     * @dev decimals are read from the underlying asset\n     */\n    function __ERC4626Upgradeable_init(\n        IERC20Permit _asset,\n        string memory _name,\n        string memory _symbol\n    ) internal onlyInitializing {\n        __ERC20Upgradeable_init(_name, _symbol, _asset.decimals());\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Issue & Destroy                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice When new KreskoAssets are burned:\n     * Issues the equivalent amount of anchor tokens to Kresko\n     * Issues the equivalent amount of assets to user\n     */\n    function issue(uint256 assets, address to) public virtual returns (uint256 shares) {\n        require(msg.sender == asset.kresko(), Error.ISSUER_NOT_KRESKO);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewIssue(assets)) != 0, Error.ZERO_SHARES);\n\n        // Mint shares to kresko\n        _mint(asset.kresko(), shares);\n        // Mint assets to receiver\n        asset.mint(to, assets);\n\n        emit Issue(msg.sender, to, assets, shares);\n\n        _afterDeposit(assets, shares);\n    }\n\n    /**\n     * @notice When new KreskoAssets are burned:\n     * Destroys the equivalent amount of anchor tokens from Kresko\n     * Destorys the equivalent amount of assets from user\n     */\n    function destroy(uint256 assets, address from) public virtual returns (uint256 shares) {\n        require(msg.sender == asset.kresko(), Error.REDEEMER_NOT_KRESKO);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewIssue(assets)) != 0, Error.ZERO_SHARES);\n\n        _beforeWithdraw(assets, shares);\n\n        // Burn shares from kresko\n        _burn(asset.kresko(), shares);\n        // Burn assets from user\n        asset.burn(from, assets);\n\n        emit Destroy(msg.sender, from, from, assets, shares);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              Accounting Logic                              */\n    /* -------------------------------------------------------------------------- */\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if _totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    /// @notice amount of shares for amount of @param assets\n    function previewIssue(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @notice amount of assets for amount of @param shares\n    function previewDestroy(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /// @notice amount of shares for amount of @param assets\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @notice amount of assets for amount of @param shares\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if _totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    /// @notice amount of shares for amount of @param assets\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if _totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    /// @notice amount of assets for amount of @param shares\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                       DEPOSIT/WITHDRAWAL LIMIT VIEWS                       */\n    /* -------------------------------------------------------------------------- */\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxIssue(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxDestroy(address owner) public view virtual returns (uint256) {\n        return convertToAssets(_balances[owner]);\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(_balances[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return _balances[owner];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                            INTERNAL HOOKS LOGIC                            */\n    /* -------------------------------------------------------------------------- */\n\n    function _beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function _afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n\n    /* -------------------------------------------------------------------------- */\n    /*                               EXTERNAL USE                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IERC4626Upgradeable\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, Error.ZERO_SHARES);\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        _afterDeposit(assets, shares);\n    }\n\n    /// @inheritdoc IERC4626Upgradeable\n    function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = _allowances[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) {\n                _allowances[owner][msg.sender] = allowed - shares;\n            }\n        }\n\n        _beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /// @inheritdoc IERC4626Upgradeable\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        _afterDeposit(assets, shares);\n    }\n\n    /// @inheritdoc IERC4626Upgradeable\n    function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = _allowances[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) {\n                _allowances[owner][msg.sender] = allowed - shares;\n            }\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, Error.ZERO_ASSETS);\n\n        _beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n}\n"
    },
    "src/contracts/kreskoasset/IERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.19;\n\nimport {IKreskoAsset} from \"./IKreskoAsset.sol\";\n\ninterface IERC4626Upgradeable {\n    /**\n     * @notice The underlying Kresko Asset\n     */\n    function asset() external view returns (IKreskoAsset);\n\n    /**\n     * @notice Deposit KreskoAssets for equivalent amount of anchor tokens\n     * @param assets Amount of KreskoAssets to deposit\n     * @param receiver Address to send shares to\n     * @return shares Amount of shares minted\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @notice Withdraw KreskoAssets for equivalent amount of anchor tokens\n     * @param assets Amount of KreskoAssets to withdraw\n     * @param receiver Address to send KreskoAssets to\n     * @param owner Address to burn shares from\n     * @return shares Amount of shares burned\n     * @dev shares are burned from owner, not msg.sender\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    function maxDeposit(address) external view returns (uint256);\n\n    function maxMint(address) external view returns (uint256 assets);\n\n    function maxRedeem(address owner) external view returns (uint256 assets);\n\n    function maxWithdraw(address owner) external view returns (uint256 assets);\n\n    /**\n     * @notice Mint shares of anchor tokens for equivalent amount of KreskoAssets\n     * @param shares Amount of shares to mint\n     * @param receiver Address to send shares to\n     * @return assets Amount of KreskoAssets redeemed\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @notice Track the underlying amount\n     * @return Total supply for the underlying\n     */\n    function totalAssets() external view returns (uint256);\n\n    /**\n     * @notice Redeem shares of anchor for KreskoAssets\n     * @param shares Amount of shares to redeem\n     * @param receiver Address to send KreskoAssets to\n     * @param owner Address to burn shares from\n     * @return assets Amount of KreskoAssets redeemed\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "src/contracts/kreskoasset/IKreskoAsset.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IAccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\";\nimport {IERC20Permit} from \"../shared/IERC20Permit.sol\";\nimport {IERC165} from \"../shared/IERC165.sol\";\n\ninterface IKreskoAsset is IERC20Permit, IAccessControlEnumerableUpgradeable, IERC165 {\n    /**\n     * @notice Rebase information\n     * @param positive supply increasing/reducing rebase\n     * @param denominator the denumerator for the operator, 1 ether = 1\n     */\n    struct Rebase {\n        bool positive;\n        uint256 denominator;\n    }\n\n    /**\n     * @notice Initializes a KreskoAsset ERC20 token.\n     * @dev Intended to be operated by the Kresko smart contract.\n     * @param _name The name of the KreskoAsset.\n     * @param _symbol The symbol of the KreskoAsset.\n     * @param _decimals Decimals for the asset.\n     * @param _admin The adminstrator of this contract.\n     * @param _kresko The protocol, can perform mint and burn.\n     */\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _admin,\n        address _kresko\n    ) external;\n\n    function kresko() external view returns (address);\n\n    function rebaseInfo() external view returns (Rebase memory);\n\n    function isRebased() external view returns (bool);\n\n    /**\n     * @notice Perform a rebase, changing the denumerator and its operator\n     * @param _denominator the denumerator for the operator, 1 ether = 1\n     * @param _positive supply increasing/reducing rebase\n     * @param _pools UniswapV2Pair address to sync so we wont get rekt by skim() calls.\n     * @dev denumerator values 0 and 1 ether will disable the rebase\n     */\n    function rebase(uint256 _denominator, bool _positive, address[] calldata _pools) external;\n\n    /**\n     * @notice Updates ERC20 metadata for the token in case eg. a ticker change\n     * @param _name new name for the asset\n     * @param _symbol new symbol for the asset\n     * @param _version number that must be greater than latest emitted `Initialized` version\n     */\n    function reinitializeERC20(string memory _name, string memory _symbol, uint8 _version) external;\n\n    /**\n     * @notice Returns the total supply of the token.\n     * @notice This amount is adjusted by rebases.\n     * @inheritdoc IERC20Permit\n     */\n    function totalSupply() external view override(IERC20Permit) returns (uint256);\n\n    /**\n     * @notice Returns the balance of @param _account\n     * @notice This amount is adjusted by rebases.\n     * @inheritdoc IERC20Permit\n     */\n    function balanceOf(address _account) external view override(IERC20Permit) returns (uint256);\n\n    /// @inheritdoc IERC20Permit\n    function allowance(address _owner, address _account) external view override(IERC20Permit) returns (uint256);\n\n    /// @inheritdoc IERC20Permit\n    function approve(address spender, uint256 amount) external override returns (bool);\n\n    /// @inheritdoc IERC20Permit\n    function transfer(address _to, uint256 _amount) external override(IERC20Permit) returns (bool);\n\n    /// @inheritdoc IERC20Permit\n    function transferFrom(address _from, address _to, uint256 _amount) external override(IERC20Permit) returns (bool);\n\n    /**\n     * @notice Mints tokens to an address.\n     * @dev Only callable by operator.\n     * @dev Internal balances are always unrebased, events emitted are not.\n     * @param _to The address to mint tokens to.\n     * @param _amount The amount of tokens to mint.\n     */\n    function mint(address _to, uint256 _amount) external;\n\n    /**\n     * @notice Burns tokens from an address.\n     * @dev Only callable by operator.\n     * @dev Internal balances are always unrebased, events emitted are not.\n     * @param _from The address to burn tokens from.\n     * @param _amount The amount of tokens to burn.\n     */\n    function burn(address _from, uint256 _amount) external;\n}\n"
    },
    "src/contracts/kreskoasset/IKreskoAssetAnchor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IAccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\";\nimport {IERC165} from \"../shared/IERC165.sol\";\nimport {IERC20Permit} from \"../shared/IERC20Permit.sol\";\nimport {IKreskoAssetIssuer} from \"./IKreskoAssetIssuer.sol\";\nimport {IKreskoAsset} from \"./IKreskoAsset.sol\";\nimport {IERC4626Upgradeable} from \"./IERC4626Upgradeable.sol\";\n\ninterface IKreskoAssetAnchor is\n    IKreskoAssetIssuer,\n    IERC4626Upgradeable,\n    IERC20Permit,\n    IAccessControlEnumerableUpgradeable,\n    IERC165\n{\n    function totalAssets() external view override(IERC4626Upgradeable) returns (uint256);\n\n    /**\n     * @notice Initializes the Kresko Asset Anchor.\n     *\n     * @param _asset The underlying (Kresko) Asset\n     * @param _name Name of the anchor token\n     * @param _symbol Symbol of the anchor token\n     * @param _admin The adminstrator of this contract.\n     * @dev Decimals are not supplied as they are read from the underlying Kresko Asset\n     */\n    function initialize(IKreskoAsset _asset, string memory _name, string memory _symbol, address _admin) external;\n\n    /**\n     * @notice Updates ERC20 metadata for the token in case eg. a ticker change\n     * @param _name new name for the asset\n     * @param _symbol new symbol for the asset\n     * @param _version number that must be greater than latest emitted `Initialized` version\n     */\n    function reinitializeERC20(string memory _name, string memory _symbol, uint8 _version) external;\n}\n"
    },
    "src/contracts/kreskoasset/IKreskoAssetIssuer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n/// @title KreskoAsset issuer interface\n/// @author Kresko\n/// @notice Contract that can issue/destroy Kresko Assets through Kresko\n/// @dev This interface is used by KISS & KreskoAssetAnchor\ninterface IKreskoAssetIssuer {\n    /**\n     * @notice Mints @param _assets of krAssets for @param _to,\n     * @notice Mints relative @return _shares of wkrAssets\n     */\n    function issue(uint256 _assets, address _to) external returns (uint256 shares);\n\n    /**\n     * @notice Burns @param _assets of krAssets from @param _from,\n     * @notice Burns relative @return _shares of wkrAssets\n     */\n    function destroy(uint256 _assets, address _from) external returns (uint256 shares);\n\n    /**\n     * @notice Returns the total amount of anchor tokens out\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @notice Returns the total amount of krAssets out\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n}\n"
    },
    "src/contracts/kreskoasset/KreskoAsset.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n// solhint-disable-next-line\nimport {AccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Role} from \"../libs/Authorization.sol\";\nimport {Error} from \"../libs/Errors.sol\";\nimport {ERC20Upgradeable} from \"../shared/ERC20Upgradeable.sol\";\nimport {IERC165} from \"../shared/IERC165.sol\";\nimport {RebaseMath} from \"./Rebase.sol\";\nimport {IKreskoAsset} from \"./IKreskoAsset.sol\";\nimport {IUniswapV2Pair} from \"../vendor/uniswap/v2-core/interfaces/IUniswapV2Pair.sol\";\n\n/**\n * @title Kresko Synthethic Asset - rebasing ERC20.\n * @author Kresko\n *\n * @notice Rebases to adjust for stock splits and reverse stock splits\n *\n * @notice Minting, burning and rebasing can only be performed by the `Role.OPERATOR`\n */\n\ncontract KreskoAsset is ERC20Upgradeable, AccessControlEnumerableUpgradeable, IKreskoAsset {\n    using RebaseMath for uint256;\n\n    bool public isRebased;\n    address public kresko;\n    Rebase private _rebaseInfo;\n\n    /// @inheritdoc IKreskoAsset\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _admin,\n        address _kresko\n    ) external initializer {\n        // ERC20\n        __ERC20Upgradeable_init(_name, _symbol, _decimals);\n\n        // This does nothing but doesn't hurt to make sure it's called\n        __AccessControlEnumerable_init();\n\n        // Setup the admin\n        _setupRole(Role.DEFAULT_ADMIN, msg.sender);\n        _setupRole(Role.ADMIN, msg.sender);\n\n        _setupRole(Role.DEFAULT_ADMIN, _admin);\n        _setupRole(Role.ADMIN, _admin);\n\n        // Setup the protocol\n        _setupRole(Role.OPERATOR, _kresko);\n        kresko = _kresko;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Read                                    */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControlEnumerableUpgradeable, IERC165) returns (bool) {\n        return (interfaceId != 0xffffffff &&\n            (interfaceId == type(IKreskoAsset).interfaceId ||\n                interfaceId == 0x01ffc9a7 ||\n                interfaceId == 0x36372b07 ||\n                super.supportsInterface(interfaceId)));\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function rebaseInfo() external view override returns (Rebase memory) {\n        return _rebaseInfo;\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function totalSupply() public view override(ERC20Upgradeable, IKreskoAsset) returns (uint256) {\n        return !isRebased ? _totalSupply : _totalSupply.rebase(_rebaseInfo);\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function balanceOf(address _account) public view override(ERC20Upgradeable, IKreskoAsset) returns (uint256) {\n        uint256 balance = _balances[_account];\n        return !isRebased ? balance : balance.rebase(_rebaseInfo);\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function allowance(\n        address _owner,\n        address _account\n    ) public view override(ERC20Upgradeable, IKreskoAsset) returns (uint256) {\n        return _allowances[_owner][_account];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Write                                   */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IKreskoAsset\n    function reinitializeERC20(\n        string memory _name,\n        string memory _symbol,\n        uint8 _version\n    ) external onlyRole(Role.ADMIN) reinitializer(_version) {\n        __ERC20Upgradeable_init(_name, _symbol, decimals);\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function approve(address spender, uint256 amount) public override(ERC20Upgradeable, IKreskoAsset) returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function transfer(address _to, uint256 _amount) public override(ERC20Upgradeable, IKreskoAsset) returns (bool) {\n        return _transfer(msg.sender, _to, _amount);\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) public override(ERC20Upgradeable, IKreskoAsset) returns (bool) {\n        uint256 allowed = allowance(_from, msg.sender); // Saves gas for unlimited approvals.\n\n        if (allowed != type(uint256).max) {\n            require(_amount <= allowed, Error.NOT_ENOUGH_ALLOWANCE);\n            _allowances[_from][msg.sender] -= _amount;\n        }\n\n        return _transfer(_from, _to, _amount);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Restricted                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IKreskoAsset\n    function rebase(uint256 _denominator, bool _positive, address[] calldata _pools) external onlyRole(Role.ADMIN) {\n        require(_denominator >= 1 ether, Error.REBASING_DENOMINATOR_LOW);\n        if (_denominator == 1 ether) {\n            isRebased = false;\n            _rebaseInfo = Rebase(false, 0);\n        } else {\n            isRebased = true;\n            _rebaseInfo = Rebase(_positive, _denominator);\n        }\n        uint256 length = _pools.length;\n        for (uint256 i; i < length; ) {\n            IUniswapV2Pair(_pools[i]).sync();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function mint(address _to, uint256 _amount) external onlyRole(Role.OPERATOR) {\n        uint256 normalizedAmount = !isRebased ? _amount : _amount.unrebase(_rebaseInfo);\n        _totalSupply += normalizedAmount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balances[_to] += normalizedAmount;\n        }\n        // Emit user input amount, not the maybe unrebased amount.\n        emit Transfer(address(0), _to, _amount);\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function burn(address _from, uint256 _amount) external onlyRole(Role.OPERATOR) {\n        uint256 normalizedAmount = !isRebased ? _amount : _amount.unrebase(_rebaseInfo);\n\n        _balances[_from] -= normalizedAmount;\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            _totalSupply -= normalizedAmount;\n        }\n\n        emit Transfer(_from, address(0), _amount);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Internal                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /// @dev Internal balances are always unrebased, events emitted are not.\n    function _transfer(address _from, address _to, uint256 _amount) internal returns (bool) {\n        require(_amount <= balanceOf(_from), Error.NOT_ENOUGH_BALANCE);\n        uint256 normalizedAmount = !isRebased ? _amount : _amount.unrebase(_rebaseInfo);\n\n        _balances[_from] -= normalizedAmount;\n        unchecked {\n            _balances[_to] += normalizedAmount;\n        }\n\n        // Emit user input amount, not the maybe unrebased amount.\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n}\n"
    },
    "src/contracts/kreskoasset/KreskoAssetAnchor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {AccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\n\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\nimport {Role} from \"../libs/Authorization.sol\";\n\nimport {IKreskoAssetIssuer} from \"./IKreskoAssetIssuer.sol\";\nimport {IKreskoAssetAnchor} from \"./IKreskoAssetAnchor.sol\";\nimport {ERC4626Upgradeable, IKreskoAsset} from \"./ERC4626Upgradeable.sol\";\nimport {IERC165} from \"../shared/IERC165.sol\";\n\n/* solhint-disable no-empty-blocks */\n\n/**\n * @title Kresko Asset Anchor\n * Pro-rata representation of the underlying kresko asset.\n * Based on ERC-4626 by Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n *\n * @notice Main purpose of this token is to represent a static amount of the possibly rebased underlying KreskoAsset.\n * Main use-cases are normalized book-keeping, bridging and integration with external contracts.\n *\n * @notice Shares means amount of this token.\n * @notice Assets mean amount of KreskoAssets.\n * @author Kresko\n */\ncontract KreskoAssetAnchor is ERC4626Upgradeable, IKreskoAssetAnchor, AccessControlEnumerableUpgradeable {\n    /* -------------------------------------------------------------------------- */\n    /*                                 Immutables                                 */\n    /* -------------------------------------------------------------------------- */\n    constructor(IKreskoAsset _asset) payable ERC4626Upgradeable(_asset) {}\n\n    /// @inheritdoc IKreskoAssetAnchor\n    function initialize(\n        IKreskoAsset _asset,\n        string memory _name,\n        string memory _symbol,\n        address _admin\n    ) external initializer {\n        // ERC4626\n        __ERC4626Upgradeable_init(_asset, _name, _symbol);\n\n        // This does nothing but doesn't hurt to make sure it's called\n        __AccessControlEnumerable_init();\n\n        // Default admin setup\n        _setupRole(Role.DEFAULT_ADMIN, _admin);\n        _setupRole(Role.ADMIN, _admin);\n\n        _setupRole(Role.DEFAULT_ADMIN, msg.sender);\n        _setupRole(Role.ADMIN, msg.sender);\n\n        // Setup the operator, which is the protocol linked to the main asset\n        _setupRole(Role.OPERATOR, asset.kresko());\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControlEnumerableUpgradeable, IERC165) returns (bool) {\n        return\n            interfaceId != 0xffffffff &&\n            (interfaceId == type(IKreskoAssetAnchor).interfaceId ||\n                interfaceId == type(IKreskoAssetIssuer).interfaceId ||\n                interfaceId == 0x01ffc9a7 ||\n                interfaceId == 0x36372b07 ||\n                super.supportsInterface(interfaceId));\n    }\n\n    /// @inheritdoc IKreskoAssetAnchor\n    function reinitializeERC20(\n        string memory _name,\n        string memory _symbol,\n        uint8 _version\n    ) external onlyRole(Role.ADMIN) reinitializer(_version) {\n        __ERC20Upgradeable_init(_name, _symbol, decimals);\n    }\n\n    /// @inheritdoc IKreskoAssetAnchor\n    function totalAssets() public view virtual override(IKreskoAssetAnchor, ERC4626Upgradeable) returns (uint256) {\n        return asset.totalSupply();\n    }\n\n    /// @inheritdoc IKreskoAssetIssuer\n    function convertToAssets(\n        uint256 shares\n    ) public view virtual override(ERC4626Upgradeable, IKreskoAssetIssuer) returns (uint256 assets) {\n        return super.convertToAssets(shares);\n    }\n\n    /// @inheritdoc IKreskoAssetIssuer\n    function convertToShares(\n        uint256 assets\n    ) public view virtual override(ERC4626Upgradeable, IKreskoAssetIssuer) returns (uint256 shares) {\n        return super.convertToShares(assets);\n    }\n\n    /// @inheritdoc IKreskoAssetIssuer\n    function issue(\n        uint256 _assets,\n        address _to\n    ) public virtual override(ERC4626Upgradeable, IKreskoAssetIssuer) onlyRole(Role.OPERATOR) returns (uint256 shares) {\n        shares = super.issue(_assets, _to);\n    }\n\n    /// @inheritdoc IKreskoAssetIssuer\n    function destroy(\n        uint256 _assets,\n        address _from\n    ) public virtual override(ERC4626Upgradeable, IKreskoAssetIssuer) onlyRole(Role.OPERATOR) returns (uint256 shares) {\n        shares = super.destroy(_assets, _from);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                            INTERNAL HOOKS LOGIC                            */\n    /* -------------------------------------------------------------------------- */\n\n    function _beforeWithdraw(uint256 assets, uint256 shares) internal virtual override {\n        super._beforeWithdraw(assets, shares);\n    }\n\n    function _afterDeposit(uint256 assets, uint256 shares) internal virtual override {\n        super._afterDeposit(assets, shares);\n    }\n}\n"
    },
    "src/contracts/kreskoasset/Rebase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport {IKreskoAsset} from \"../kreskoasset/IKreskoAsset.sol\";\n\nlibrary RebaseMath {\n    using FixedPointMathLib for uint256;\n\n    /**\n     * @notice Unrebase a value by a given rebase struct.\n     * @param self The value to unrebase.\n     * @param _rebase The rebase struct.\n     * @return The unrebased value.\n     */\n    function unrebase(uint256 self, IKreskoAsset.Rebase memory _rebase) internal pure returns (uint256) {\n        if (_rebase.denominator == 0) return self;\n        return _rebase.positive ? self.divWadDown(_rebase.denominator) : self.mulWadDown(_rebase.denominator);\n    }\n\n    /**\n     * @notice Rebase a value by a given rebase struct.\n     * @param self The value to rebase.\n     * @param _rebase The rebase struct.\n     * @return The rebased value.\n     */\n    function rebase(uint256 self, IKreskoAsset.Rebase memory _rebase) internal pure returns (uint256) {\n        if (_rebase.denominator == 0) return self;\n        return _rebase.positive ? self.mulWadDown(_rebase.denominator) : self.divWadDown(_rebase.denominator);\n    }\n}\n"
    },
    "src/contracts/libs/Arrays.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.19;\n\nimport {Error} from \"./Errors.sol\";\n\n/**\n * @title Library for operations on arrays\n */\nlibrary Arrays {\n    /**\n     * @dev Removes an element by copying the last element to the element to remove's place and removing\n     * the last element.\n     * @param _addresses The address array containing the item to be removed.\n     * @param _elementToRemove The element to be removed.\n     * @param _elementIndex The index of the element to be removed.\n     */\n    function removeAddress(address[] storage _addresses, address _elementToRemove, uint256 _elementIndex) internal {\n        require(_addresses[_elementIndex] == _elementToRemove, Error.ARRAY_OUT_OF_BOUNDS);\n\n        uint256 lastIndex = _addresses.length - 1;\n        // If the index to remove is not the last one, overwrite the element at the index\n        // with the last element.\n        if (_elementIndex != lastIndex) {\n            _addresses[_elementIndex] = _addresses[lastIndex];\n        }\n        // Remove the last element.\n        _addresses.pop();\n    }\n}\n"
    },
    "src/contracts/libs/Authorization.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.19;\n\nimport {IGnosisSafeL2} from \"../vendor/gnosis/IGnosisSafeL2.sol\";\nimport {Strings} from \"./Strings.sol\";\nimport {AuthEvent} from \"./Events.sol\";\nimport {EnumerableSet} from \"./EnumerableSet.sol\";\nimport {Error} from \"./Errors.sol\";\nimport {Meta} from \"./Meta.sol\";\nimport {ds} from \"../diamond/DiamondStorage.sol\";\n\n/* solhint-disable state-visibility */\n\n/**\n * @title Shared library for access control\n * @author Kresko\n */\n\n/* -------------------------------------------------------------------------- */\n/*                                    Roles                                   */\n/* -------------------------------------------------------------------------- */\n\nlibrary Role {\n    /// @dev role that grants other roles\n    bytes32 constant DEFAULT_ADMIN = 0x00;\n    /// @dev  keccak256(\"kresko.roles.minter.admin\")\n    bytes32 constant ADMIN = 0xb9dacdf02281f2e98ddbadaaf44db270b3d5a916342df47c59f77937a6bcd5d8;\n    /// @dev keccak256(\"kresko.roles.minter.operator\")\n    bytes32 constant OPERATOR = 0x112e48a576fb3a75acc75d9fcf6e0bc670b27b1dbcd2463502e10e68cf57d6fd;\n    /// @dev keccak256(\"kresko.roles.minter.manager\")\n    bytes32 constant MANAGER = 0x46925e0f0cc76e485772167edccb8dc449d43b23b55fc4e756b063f49099e6a0;\n    /// @dev keccak256(\"kresko.roles.minter.safety.council\")\n    bytes32 constant SAFETY_COUNCIL = 0x9c387ecf1663f9144595993e2c602b45de94bf8ba3a110cb30e3652d79b581c0;\n}\n\nlibrary Authorization {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    function hasRole(bytes32 role, address account) internal view returns (bool) {\n        return ds()._roles[role].members[account];\n    }\n\n    function getRoleMemberCount(bytes32 role) internal view returns (uint256) {\n        return ds()._roleMembers[role].length();\n    }\n\n    /**\n     * @dev Revert with a standard message if `Meta.msgSender` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function checkRole(bytes32 role) internal view {\n        _checkRole(role, Meta.msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) internal view returns (bytes32) {\n        return ds()._roles[role].adminRole;\n    }\n\n    function getRoleMember(bytes32 role, uint256 index) internal view returns (address) {\n        return ds()._roleMembers[role].at(index);\n    }\n\n    /**\n     * @notice Checks if the target contract implements the ERC165 interfaceId for the multisig.\n     *\n     */\n    function setupSecurityCouncil(address _councilAddress) internal {\n        require(getRoleMemberCount(Role.SAFETY_COUNCIL) == 0, Error.SAFETY_COUNCIL_EXISTS);\n        require(IGnosisSafeL2(_councilAddress).isOwner(msg.sender), Error.ADDRESS_INVALID_SAFETY_COUNCIL);\n\n        ds()._roles[Role.SAFETY_COUNCIL].members[_councilAddress] = true;\n        ds()._roleMembers[Role.SAFETY_COUNCIL].add(_councilAddress);\n\n        emit AuthEvent.RoleGranted(Role.SAFETY_COUNCIL, _councilAddress, Meta.msgSender());\n    }\n\n    function transferSecurityCouncil(address _newCouncil) internal {\n        hasRole(Role.SAFETY_COUNCIL, msg.sender);\n        require(IGnosisSafeL2(_newCouncil).getOwners().length >= 5, Error.MULTISIG_NOT_ENOUGH_OWNERS);\n\n        // As this is called by the multisig - just check that it's not an EOA\n        ds()._roles[Role.SAFETY_COUNCIL].members[msg.sender] = false;\n        ds()._roleMembers[Role.SAFETY_COUNCIL].remove(msg.sender);\n\n        ds()._roles[Role.SAFETY_COUNCIL].members[_newCouncil] = true;\n        ds()._roleMembers[Role.SAFETY_COUNCIL].add(_newCouncil);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) internal {\n        checkRole(getRoleAdmin(role));\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) internal {\n        checkRole(getRoleAdmin(role));\n        _revokeRole(role, account);\n        ds()._roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function _renounceRole(bytes32 role, address account) internal {\n        require(account == Meta.msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        ds()._roles[role].adminRole = adminRole;\n        emit AuthEvent.RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * @notice Cannot grant the role `SAFETY_COUNCIL` - must be done via explicit function.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal ensureNotSafetyCouncil(role) {\n        if (!hasRole(role, account)) {\n            ds()._roles[role].members[account] = true;\n            ds()._roleMembers[role].add(account);\n            emit AuthEvent.RoleGranted(role, account, Meta.msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal {\n        if (hasRole(role, account)) {\n            ds()._roles[role].members[account] = false;\n            ds()._roleMembers[role].remove(account);\n            emit AuthEvent.RoleRevoked(role, account, Meta.msgSender());\n        }\n    }\n\n    /**\n     * @dev Ensure we use the explicit `grantSafetyCouncilRole` function.\n     */\n    modifier ensureNotSafetyCouncil(bytes32 role) {\n        require(role != Role.SAFETY_COUNCIL, Error.ADDRESS_INVALID_SAFETY_COUNCIL);\n        _;\n    }\n}\n"
    },
    "src/contracts/libs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity >=0.8.19;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "src/contracts/libs/Errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity <0.9.0;\n\n/* solhint-disable max-line-length */\n\n/**\n * @author Kresko\n * @title Error codes\n * @notice Kresko-specific revert return values and their explanation\n * @dev First number indicates the domain for the error\n */\nlibrary Error {\n    /* -------------------------------------------------------------------------- */\n    /*                                    Diamond                                 */\n    /* -------------------------------------------------------------------------- */\n\n    // Preserve readability for the diamond proxy\n    string public constant DIAMOND_INVALID_FUNCTION_SIGNATURE = \"krDiamond: function does not exist\";\n    string public constant DIAMOND_INVALID_PENDING_OWNER = \"krDiamond: Must be pending contract owner\";\n    string public constant DIAMOND_INVALID_OWNER = \"krDiamond: Must be diamond owner\";\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   1. General                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant NOT_OWNER = \"100\"; // The sender must be owner\n    string public constant NOT_OPERATOR = \"101\"; // The sender must be operator\n    string public constant ZERO_WITHDRAW = \"102\"; // Withdraw must be greater than 0\n    string public constant ZERO_DEPOSIT = \"103\"; // Deposit must be greater than 0\n    string public constant ZERO_ADDRESS = \"104\"; // Address provided cannot be address(0)\n    string public constant ALREADY_INITIALIZED = \"105\"; // Contract has already been initialized\n    string public constant RE_ENTRANCY = \"106\"; // Function does not allow re-entrant calls\n    string public constant NOT_ENOUGH_BALANCE = \"107\"; // Transfer of rebasing token exceeds value\n    string public constant NOT_ENOUGH_ALLOWANCE = \"108\"; // TransferFrom of rebasing token exceeds allowance\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   2. Minter                                 */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant NOT_LIQUIDATABLE = \"200\"; // Account has collateral deposits exceeding minCollateralValue\n    string public constant ZERO_MINT = \"201\"; // Mint amount must be greater than 0\n    string public constant ZERO_BURN = \"202\"; // Burn amount must be greater than 0\n    string public constant ADDRESS_INVALID_ORACLE = \"203\"; // Oracle address cant be set to address(0)\n    string public constant ADDRESS_INVALID_NRWT = \"204\"; // Underlying rebasing token address cant be set to address(0)\n    string public constant ADDRESS_INVALID_FEERECIPIENT = \"205\"; // Fee recipient address cant be set to address(0)\n    string public constant ADDRESS_INVALID_COLLATERAL = \"206\"; // Collateral address cant be set to address(0)\n    string public constant COLLATERAL_EXISTS = \"207\"; // Collateral has already been added into the protocol\n    string public constant COLLATERAL_INVALID_FACTOR = \"208\"; // cFactor must be greater than 1FP\n    string public constant COLLATERAL_WITHDRAW_OVERFLOW = \"209\"; // Withdraw amount cannot reduce accounts collateral value under minCollateralValue\n    string public constant KRASSET_INVALID_FACTOR = \"210\"; // kFactor must be greater than 1FP\n    string public constant KRASSET_BURN_AMOUNT_OVERFLOW = \"211\"; // Repaying more than account has debt\n    string public constant KRASSET_EXISTS = \"212\"; // KrAsset is already added\n    string public constant PARAM_CLOSE_FEE_TOO_HIGH = \"213\"; // \"Close fee exceeds MAX_CLOSE_FEE\"\n    string public constant PARAM_LIQUIDATION_INCENTIVE_LOW = \"214\"; // \"Liquidation incentive less than MIN_LIQUIDATION_INCENTIVE_MULTIPLIER\"\n    string public constant PARAM_LIQUIDATION_INCENTIVE_HIGH = \"215\"; // \"Liquidation incentive greater than MAX_LIQUIDATION_INCENTIVE_MULTIPLIER\"\n    string public constant PARAM_MIN_COLLATERAL_RATIO_LOW = \"216\"; // Minimum collateral ratio less than MIN_COLLATERALIZATION_RATIO\n    string public constant PARAM_MIN_DEBT_AMOUNT_HIGH = \"217\"; // Minimum debt param argument exceeds MAX_MIN_DEBT_VALUE\n    string public constant COLLATERAL_DOESNT_EXIST = \"218\"; // Collateral does not exist within the protocol\n    string public constant KRASSET_DOESNT_EXIST = \"219\"; // KrAsset does not exist within the protocol\n    string public constant KRASSET_NOT_MINTABLE = \"220\"; // KrAsset is not mintable\n    string public constant KRASSET_SYMBOL_EXISTS = \"221\"; // KrAsset with this symbol is already within the protocl\n    string public constant KRASSET_COLLATERAL_LOW = \"222\"; // Collateral deposits do not cover the amount being minted\n    string public constant KRASSET_MINT_AMOUNT_LOW = \"223\"; // Debt position must be greater than the minimum debt position value\n    string public constant KRASSET_MAX_SUPPLY_REACHED = \"224\"; // KrAsset being minted has reached its current supply limit\n    string public constant SELF_LIQUIDATION = \"225\"; // Account cannot liquidate itself\n    string public constant ZERO_REPAY = \"226\"; // Cannot liquidate zero value\n    string public constant STALE_PRICE = \"227\"; // Price for the asset is stale\n    string public constant LIQUIDATION_OVERFLOW = \"228\"; // Repaying more USD value than allowed\n    string public constant ADDRESS_INVALID_SAFETY_COUNCIL = \"229\"; // Account responsible for the safety council role must be a multisig\n    string public constant SAFETY_COUNCIL_EXISTS = \"230\"; // Only one council role can exist\n    string public constant NOT_SAFETY_COUNCIL = \"231\"; // Sender must have the role `Role.SAFETY_COUNCIL`\n    string public constant ACTION_PAUSED_FOR_ASSET = \"232\"; // This action is currently paused for this asset\n    string public constant INVALID_ASSET_SUPPLIED = \"233\"; // Asset supplied is not a collateral nor a krAsset\n    string public constant KRASSET_NOT_ANCHOR = \"234\"; // Address is not the anchor for the krAsset\n    string public constant INVALID_LT = \"235\"; // Liquidation threshold is greater than minimum collateralization ratio\n    string public constant COLLATERAL_INSUFFICIENT_AMOUNT = \"236\"; // Insufficient amount of collateral to complete the operation\n    string public constant MULTISIG_NOT_ENOUGH_OWNERS = \"237\"; // Multisig has invalid amount of owners\n    string public constant PARAM_OPEN_FEE_TOO_HIGH = \"238\"; // \"Close fee exceeds MAX_OPEN_FEE\"\n    string public constant INVALID_FEE_TYPE = \"239\"; // \"Invalid fee type\n    string public constant KRASSET_INVALID_ANCHOR = \"240\"; // krAsset anchor does not support the correct interfaceId\n    string public constant KRASSET_INVALID_CONTRACT = \"241\"; // krAsset does not support the correct interfaceId\n    string public constant KRASSET_MARKET_CLOSED = \"242\"; // KrAsset's market is currently closed\n    string public constant NO_KRASSETS_MINTED = \"243\"; // Account has no active KreskoAsset positions\n    string public constant NO_COLLATERAL_DEPOSITS = \"244\"; // Account has no active Collateral deposits\n    string public constant INVALID_ORACLE_DECIMALS = \"245\"; // Oracle decimals do not match extOracleDecimals\n    string public constant PARAM_LIQUIDATION_OVERFLOW_LOW = \"246\"; // Liquidation overflow is less than MIN_LIQUIDATION_OVERFLOW\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   3. Staking                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant REWARD_PER_BLOCK_MISSING = \"300\"; // Each reward token must have a reward per block value\n    string public constant REWARD_TOKENS_MISSING = \"301\"; // Pool must include an array of reward token addresses\n    string public constant POOL_EXISTS = \"302\"; // Pool with this deposit token already exists\n    string public constant POOL_DOESNT_EXIST = \"303\"; // Pool with this deposit token does not exist\n    string public constant ADDRESS_INVALID_REWARD_RECIPIENT = \"304\"; // Reward recipient cant be address(0)\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   4. Libraries                             */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant ARRAY_OUT_OF_BOUNDS = \"400\"; // Array out of bounds error\n    string public constant PRICEFEEDS_MUST_MATCH_STATUS_FEEDS = \"401\"; // Supplied price feeds must match status feeds in length\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   5. KrAsset                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant REBASING_DENOMINATOR_LOW = \"500\"; // denominator of rebases must be >= 1\n    string public constant ISSUER_NOT_KRESKO = \"501\"; // issue must be done by kresko\n    string public constant REDEEMER_NOT_KRESKO = \"502\"; // redeem must be done by kresko\n    string public constant DESTROY_OVERFLOW = \"503\"; // trying to destroy more than allowed\n    string public constant ISSUE_OVERFLOW = \"504\"; // trying to destroy more than allowed\n    string public constant MINT_OVERFLOW = \"505\"; // trying to destroy more than allowed\n    string public constant DEPOSIT_OVERFLOW = \"506\"; // trying to destroy more than allowed\n    string public constant REDEEM_OVERFLOW = \"507\"; // trying to destroy more than allowed\n    string public constant WITHDRAW_OVERFLOW = \"508\"; // trying to destroy more than allowed\n    string public constant ZERO_SHARES = \"509\"; // amount of shares must be greater than 0\n    string public constant ZERO_ASSETS = \"510\"; // amount of assets must be greater than 0\n    string public constant INVALID_SCALED_AMOUNT = \"511\"; // amount of debt scaled must be greater than 0\n\n    /* -------------------------------------------------------------------------- */\n    /*                              6. STABILITY RATES                            */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant STABILITY_RATES_ALREADY_INITIALIZED = \"601\"; // stability rates for the asset are already initialized\n    string public constant INVALID_OPTIMAL_RATE = \"602\"; // the optimal price rate configured is less than 1e27 for the asset\n    string public constant INVALID_PRICE_RATE_DELTA = \"603\"; // the price rate delta configured is less than 1e27 for the asset\n    string public constant STABILITY_RATES_NOT_INITIALIZED = \"604\"; // the stability rates for the asset are not initialized\n    string public constant STABILITY_RATE_OVERFLOW = \"605\"; // the stability rates is > max uint128\n    string public constant DEBT_INDEX_OVERFLOW = \"606\"; // the debt index is > max uint128\n    string public constant KISS_NOT_SET = \"607\"; // the debt index is > max uint128\n    string public constant STABILITY_RATE_REPAYMENT_AMOUNT_ZERO = \"608\"; // interest being repaid cannot be 0\n    string public constant STABILITY_RATE_INTEREST_IS_ZERO = \"609\"; // account must have accrued interest to repay it\n    string public constant INTEREST_REPAY_NOT_PARTIAL = \"610\"; // account must have accrued interest to repay it\n\n    /* -------------------------------------------------------------------------- */\n    /*                              7. AMM ORACLE                                 */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant PAIR_ADDRESS_IS_ZERO = \"701\"; // Pair address to configure cannot be zero\n    string public constant INVALID_UPDATE_PERIOD = \"702\"; // Update period must be greater than the minimum\n    string public constant PAIR_ALREADY_EXISTS = \"703\"; // Pair with the address is already initialized\n    string public constant PAIR_DOES_NOT_EXIST = \"704\"; // Pair supplied does not exist\n    string public constant INVALID_LIQUIDITY = \"706\"; // Pair initializaition requires that the pair has liquidity\n    string public constant UPDATE_PERIOD_NOT_FINISHED = \"707\"; // Update can only be called once per update period\n    string public constant INVALID_PAIR = \"708\"; // Pair being consulted does not have the token that the price was requested for\n    string public constant CALLER_NOT_ADMIN = \"709\"; // Caller must be the admin\n    string public constant CONSTRUCTOR_INVALID_ADMIN = \"710\"; // Admin cannot be zero address in the constructor\n    string public constant CONSTRUCTOR_INVALID_FACTORY = \"711\"; // Factory cannot be the zero address\n    string public constant NO_INCENTIVES_LEFT = \"712\"; // No incentives left for updating the price\n\n    /* -------------------------------------------------------------------------- */\n    /*                              8. KISS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant OPERATOR_WAIT_PERIOD_NOT_OVER = \"800\"; // Operator role has a cooldown period which has not passed\n    string public constant OPERATOR_LIMIT_REACHED = \"801\"; // More minters cannot be assigned before existing one is removed\n    string public constant CALLER_NOT_CONTRACT = \"802\"; // Caller of the function must be a contract\n    string public constant OPERATOR_NOT_CONTRACT = \"803\"; // Operator role can only be granted to a contract\n    string public constant KRESKO_NOT_CONTRACT = \"804\"; // Operator role can only be granted to a contract\n    string public constant ADMIN_NOT_A_CONTRACT = \"805\"; // Operator role can only be granted to a contract\n    string public constant OPERATOR_WAIT_PERIOD_TOO_SHORT = \"806\"; // Operator assignment cooldown period must be greater than 15 minutes\n}\n"
    },
    "src/contracts/libs/Events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IDiamondCutFacet} from \"../diamond/interfaces/IDiamondCutFacet.sol\";\nimport {Action} from \"../minter/MinterTypes.sol\";\n\n/* solhint-disable var-name-mixedcase */\n\n/**\n * @author Kresko\n * @title Events\n * @notice Event definitions\n */\n\nlibrary GeneralEvent {\n    /**\n     * @dev Triggered when the contract has been deployed\n     */\n    event Deployed(address indexed owner, uint8 version);\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(address indexed operator, uint8 version);\n}\n\nlibrary DiamondEvent {\n    event DiamondCut(IDiamondCutFacet.FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n\nlibrary MinterEvent {\n    /* -------------------------------------------------------------------------- */\n    /*                                 Collateral                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Emitted when a collateral asset is added to the protocol.\n     * @dev Can only be emitted once for a given collateral asset.\n     * @param collateralAsset The address of the collateral asset.\n     * @param factor The collateral factor.\n     * @param oracle The address of the oracle.\n     * @param marketStatusOracle The address of the market status oracle.\n     * @param liquidationIncentive The liquidation incentive\n     */\n    event CollateralAssetAdded(\n        address indexed collateralAsset,\n        uint256 factor,\n        address indexed oracle,\n        address indexed marketStatusOracle,\n        address anchor,\n        uint256 liquidationIncentive\n    );\n\n    /**\n     * @notice Emitted when a collateral asset is updated.\n     * @param collateralAsset The address of the collateral asset.\n     * @param factor The collateral factor.\n     * @param oracle The oracle address.\n     * @param marketStatusOracle The address of the market status oracle.\n     * @param liquidationIncentive The liquidation incentive\n     */\n    event CollateralAssetUpdated(\n        address indexed collateralAsset,\n        uint256 factor,\n        address indexed oracle,\n        address indexed marketStatusOracle,\n        address anchor,\n        uint256 liquidationIncentive\n    );\n\n    /**\n     * @notice Emitted when an account deposits collateral.\n     * @param account The address of the account depositing collateral.\n     * @param collateralAsset The address of the collateral asset.\n     * @param amount The amount of the collateral asset that was deposited.\n     */\n    event CollateralDeposited(address indexed account, address indexed collateralAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when an account withdraws collateral.\n     * @param account The address of the account withdrawing collateral.\n     * @param collateralAsset The address of the collateral asset.\n     * @param amount The amount of the collateral asset that was withdrawn.\n     */\n    event CollateralWithdrawn(address indexed account, address indexed collateralAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when AMM helper withdraws account collateral without MCR checks.\n     * @param account The address of the account withdrawing collateral.\n     * @param collateralAsset The address of the collateral asset.\n     * @param amount The amount of the collateral asset that was withdrawn.\n     */\n    event UncheckedCollateralWithdrawn(address indexed account, address indexed collateralAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when AMM oracle is set.\n     * @param ammOracle The address of the AMM oracle.\n     */\n    event AMMOracleUpdated(address indexed ammOracle);\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Kresko Assets                               */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Emitted when a KreskoAsset is added to the protocol.\n     * @dev Can only be emitted once for a given Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param anchor anchor token\n     * @param kFactor The k-factor.\n     * @param oracle The address of the oracle.\n     * @param marketStatusOracle The address of the market status oracle.\n     * @param supplyLimit The total supply limit.\n     * @param closeFee The close fee percentage.\n     * @param openFee The open fee percentage.\n     */\n    event KreskoAssetAdded(\n        address indexed kreskoAsset,\n        address anchor,\n        address indexed oracle,\n        address indexed marketStatusOracle,\n        uint256 kFactor,\n        uint256 supplyLimit,\n        uint256 closeFee,\n        uint256 openFee\n    );\n\n    /**\n     * @notice Emitted when a Kresko asset's oracle is updated.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param kFactor The k-factor.\n     * @param oracle The address of the oracle.\n     * @param marketStatusOracle The address of the market status oracle.\n     * @param supplyLimit The total supply limit.\n     * @param closeFee The close fee percentage.\n     * @param openFee The open fee percentage.\n     */\n    event KreskoAssetUpdated(\n        address indexed kreskoAsset,\n        address anchor,\n        address indexed oracle,\n        address indexed marketStatusOracle,\n        uint256 kFactor,\n        uint256 supplyLimit,\n        uint256 closeFee,\n        uint256 openFee\n    );\n\n    /**\n     * @notice Emitted when an account mints a Kresko asset.\n     * @param account The address of the account minting the Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param amount The amount of the KreskoAsset that was minted.\n     */\n    event KreskoAssetMinted(address indexed account, address indexed kreskoAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when an account burns a Kresko asset.\n     * @param account The address of the account burning the Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param amount The amount of the KreskoAsset that was burned.\n     */\n    event KreskoAssetBurned(address indexed account, address indexed kreskoAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when an account burns a Kresko asset.\n     * @param account The address of the account burning the Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param amount The amount of the KreskoAsset that was burned.\n     * @param interestRepaid The amount of the KISS repaid due to interest accrual\n     */\n    event DebtPositionClosed(\n        address indexed account,\n        address indexed kreskoAsset,\n        uint256 amount,\n        uint256 interestRepaid\n    );\n\n    /**\n     * @notice Emitted when cFactor is updated for a collateral asset.\n     * @param collateralAsset The address of the collateral asset.\n     * @param cFactor The new cFactor\n     */\n    event CFactorUpdated(address indexed collateralAsset, uint256 cFactor);\n    /**\n     * @notice Emitted when kFactor is updated for a KreskoAsset.\n     * @param kreskoAsset The address of the KreskoAsset.\n     * @param kFactor The new kFactor\n     */\n    event KFactorUpdated(address indexed kreskoAsset, uint256 kFactor);\n\n    /**\n     * @notice Emitted when an account pays a close fee with a collateral asset upon burning a KreskoAsset.\n     * @dev This can be emitted multiple times for a single KreskoAsset burn.\n     * @param account The address of the account burning the KreskoAsset.\n     * @param paymentCollateralAsset The address of the collateral asset used to pay the close fee.\n     * @param paymentAmount The amount of the payment collateral asset that was paid.\n     * @param paymentValue The USD value of the payment.\n     */\n    event CloseFeePaid(\n        address indexed account,\n        address indexed paymentCollateralAsset,\n        uint256 paymentAmount,\n        uint256 paymentValue\n    );\n\n    /**\n     * @notice Emitted when an account pays an open fee with a collateral asset upon minting a KreskoAsset.\n     * @dev This can be emitted multiple times for a single KreskoAsset mint.\n     * @param account The address of the account minting the KreskoAsset.\n     * @param paymentCollateralAsset The address of the collateral asset used to pay the open fee.\n     * @param paymentAmount The amount of the payment collateral asset that was paid.\n     * @param paymentValue The USD value of the payment.\n     */\n    event OpenFeePaid(\n        address indexed account,\n        address indexed paymentCollateralAsset,\n        uint256 paymentAmount,\n        uint256 paymentValue\n    );\n\n    /**\n     * @notice Emitted when a liquidation occurs.\n     * @param account The address of the account being liquidated.\n     * @param liquidator The account performing the liquidation.\n     * @param repayKreskoAsset The address of the KreskoAsset being paid back to the protocol by the liquidator.\n     * @param repayAmount The amount of the repay KreskoAsset being paid back to the protocol by the liquidator.\n     * @param seizedCollateralAsset The address of the collateral asset being seized from the account by the liquidator.\n     * @param collateralSent The amount of the seized collateral asset being seized from the account by the liquidator.\n     */\n    event LiquidationOccurred(\n        address indexed account,\n        address indexed liquidator,\n        address indexed repayKreskoAsset,\n        uint256 repayAmount,\n        address seizedCollateralAsset,\n        uint256 collateralSent\n    );\n\n    /**\n     * @notice Emitted when a liquidation of interest occurs.\n     * @param account The address of the account being liquidated.\n     * @param liquidator The account performing the liquidation.\n     * @param repayKreskoAsset The address of the KreskoAsset being paid back to the protocol by the liquidator.\n     * @param repayUSD The value of the repay KreskoAsset being paid back to the protocol by the liquidator.\n     * @param seizedCollateralAsset The address of the collateral asset being seized from the account by the liquidator.\n     * @param collateralSent The amount of the seized collateral asset being seized from the account by the liquidator.\n     */\n    event InterestLiquidationOccurred(\n        address indexed account,\n        address indexed liquidator,\n        address indexed repayKreskoAsset,\n        uint256 repayUSD,\n        address seizedCollateralAsset,\n        uint256 collateralSent\n    );\n    /**\n     * @notice Emitted when a batch liquidation of interest occurs.\n     * @param account The address of the account being liquidated.\n     * @param liquidator The account performing the liquidation.\n     * @param seizedCollateralAsset The address of the collateral asset being seized from the account by the liquidator.\n     * @param repayUSD The value of the repay KreskoAsset being paid back to the protocol by the liquidator.\n     * @param collateralSent The amount of the seized collateral asset being seized from the account by the liquidator.\n     */\n    event BatchInterestLiquidationOccurred(\n        address indexed account,\n        address indexed liquidator,\n        address indexed seizedCollateralAsset,\n        uint256 repayUSD,\n        uint256 collateralSent\n    );\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Parameters                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Emitted when a safety state is triggered for an asset\n     * @param action Target action\n     * @param asset Asset affected\n     * @param description change description\n     */\n    event SafetyStateChange(Action indexed action, address indexed asset, string indexed description);\n\n    /**\n     * @notice Emitted when the fee recipient is updated.\n     * @param feeRecipient The new fee recipient.\n     */\n    event FeeRecipientUpdated(address indexed feeRecipient);\n\n    /**\n     * @notice Emitted when the liquidation incentive multiplier is updated.\n     * @param asset The collateral asset being updated.\n     * @param liquidationIncentiveMultiplier The new liquidation incentive multiplier raw value.\n     */\n    event LiquidationIncentiveMultiplierUpdated(address indexed asset, uint256 liquidationIncentiveMultiplier);\n\n    /**\n     * @notice Emitted when the liquidation overflow multiplier is updated.\n     * @param maxLiquidationMultiplier The new liquidation overflow multiplier value.\n     */\n    event maxLiquidationMultiplierUpdated(uint256 maxLiquidationMultiplier);\n\n    /**\n     * @notice Emitted when the minimum collateralization ratio is updated.\n     * @param minimumCollateralizationRatio The new minimum collateralization ratio raw value.\n     */\n    event MinimumCollateralizationRatioUpdated(uint256 minimumCollateralizationRatio);\n\n    /**\n     * @notice Emitted when the minimum debt value updated.\n     * @param minimumDebtValue The new minimum debt value.\n     */\n    event MinimumDebtValueUpdated(uint256 minimumDebtValue);\n\n    /**\n     * @notice Emitted when the liquidation threshold value is updated\n     * @param liquidationThreshold The new liquidation threshold value.\n     */\n    event LiquidationThresholdUpdated(uint256 liquidationThreshold);\n}\n\nlibrary StakingEvent {\n    event LiquidityAndStakeAdded(address indexed to, uint256 indexed amount, uint256 indexed pid);\n    event LiquidityAndStakeRemoved(address indexed to, uint256 indexed amount, uint256 indexed pid);\n    event Deposit(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event ClaimRewards(address indexed user, address indexed rewardToken, uint256 indexed amount);\n    event ClaimRewardsMulti(address indexed to);\n}\n\nlibrary AuthEvent {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event PendingOwnershipTransfer(address indexed previousOwner, address indexed newOwner);\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n}\n\nlibrary InterestRateEvent {\n    /**\n     * @dev Emitted when @param account repaid their @param asset interest @param value\n     */\n    event StabilityRateConfigured(\n        address indexed asset,\n        uint256 stabilityRateBase,\n        uint256 priceRateDelta,\n        uint256 rateSlope1,\n        uint256 rateSlope2\n    );\n    /**\n     * @dev Emitted when @param account repaid their @param asset interest @param value\n     */\n    event StabilityRateInterestRepaid(address indexed account, address indexed asset, uint256 value);\n    /**\n     * @dev Emitted when @param account repaid all interest @param value\n     */\n    event StabilityRateInterestBatchRepaid(address indexed account, uint256 value);\n\n    /**\n     * @notice Emitted when KISS address is set.\n     * @param KISS The address of KISS.\n     */\n    event KISSUpdated(address indexed KISS);\n}\n"
    },
    "src/contracts/libs/Meta.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable no-inline-assembly */\n\npragma solidity >=0.8.19;\n\nlibrary Meta {\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(bytes(\"EIP712Domain(string name,string version,uint256 salt,address verifyingContract)\"));\n\n    function domainSeparator(\n        string memory name,\n        string memory version\n    ) internal view returns (bytes32 domainSeparator_) {\n        domainSeparator_ = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                getChainID(),\n                address(this)\n            )\n        );\n    }\n\n    function getChainID() internal view returns (uint256 id) {\n        assembly {\n            id := chainid()\n        }\n    }\n\n    function msgSender() internal view returns (address sender_) {\n        if (msg.sender == address(this)) {\n            bytes memory array = msg.data;\n            uint256 index = msg.data.length;\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n                sender_ := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n            }\n        } else {\n            sender_ = msg.sender;\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        /// @solidity memory-safe-assembly\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "src/contracts/libs/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity >=0.8.19;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "src/contracts/libs/WadRay.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.10;\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @notice Provides functions to perform calculations with Wad and Ray units\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\n * with 27 digits of precision)\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n **/\nlibrary WadRay {\n    // HALF_WAD and HALF_RAY expressed with extended notation\n    // as constant with operations are not supported in Yul assembly\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant HALF_WAD = 0.5e18;\n\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant HALF_RAY = 0.5e27;\n\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n    /**\n     * @dev Multiplies two wad, rounding half up to the nearest wad\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @param b Wad\n     * @return c = a*b, in wad\n     **/\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\n        assembly {\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, b), HALF_WAD), WAD)\n        }\n    }\n\n    /**\n     * @dev Divides two wad, rounding half up to the nearest wad\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @param b Wad\n     * @return c = a/b, in wad\n     **/\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\n        assembly {\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, WAD), div(b, 2)), b)\n        }\n    }\n\n    /**\n     * @notice Multiplies two ray, rounding half up to the nearest ray\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @param b Ray\n     * @return c = a raymul b\n     **/\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\n        assembly {\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, b), HALF_RAY), RAY)\n        }\n    }\n\n    /**\n     * @notice Divides two ray, rounding half up to the nearest ray\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @param b Ray\n     * @return c = a raydiv b\n     **/\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\n        assembly {\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, RAY), div(b, 2)), b)\n        }\n    }\n\n    /**\n     * @dev Casts ray down to wad\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @return b = a converted to wad, rounded half up to the nearest wad\n     **/\n    function rayToWad(uint256 a) internal pure returns (uint256 b) {\n        assembly {\n            b := div(a, WAD_RAY_RATIO)\n            let remainder := mod(a, WAD_RAY_RATIO)\n            if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\n                b := add(b, 1)\n            }\n        }\n    }\n\n    /**\n     * @dev Converts wad up to ray\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @return b = a converted in ray\n     **/\n    function wadToRay(uint256 a) internal pure returns (uint256 b) {\n        // to avoid overflow, b/WAD_RAY_RATIO == a\n        assembly {\n            b := mul(a, WAD_RAY_RATIO)\n\n            if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/minter/amm-oracle/IUniswapV2OracleCompat.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\nimport {IERC20Minimal} from \"../../vendor/uniswap/v2-core/interfaces/IERC20Minimal.sol\";\nimport {IUniswapV2Factory} from \"../../vendor/uniswap/v2-periphery/libraries/UniswapV2Library.sol\";\n\n/// @notice without UQ values\ninterface IUniswapV2OracleCompat {\n    event NewAdmin(address indexed newAdmin);\n    event NewMinUpdatePeriod(uint256 newMinUpdatePeriod);\n    event NewPair(address indexed pair, address indexed token0, address indexed token1, uint256 updatePeriod);\n    event PairUpdated(address indexed pair, address indexed token0, address indexed token1, uint256 updatePeriod);\n\n    event NewKrAssetPair(address indexed krAsset, address indexed pairAddress);\n\n    /// @notice returns the connected univ2 factory\n    function factory() external view returns (IUniswapV2Factory);\n\n    /// @notice returns the incentive token for the incentivized update\n    function incentiveToken() external view returns (IERC20Minimal);\n\n    /// @notice returns the amount of incentive tokens sent using the incentivized update\n    function incentiveAmount() external view returns (uint256);\n\n    /// @notice returns the current admin of the oracle\n    function admin() external view returns (address);\n\n    /// @notice returns the TWAP time period in seconds\n    function minUpdatePeriod() external view returns (uint256);\n\n    /// @notice returns the pair address for a given krAsset\n    function krAssets(address) external returns (address);\n\n    /**\n     *\n     * @param _newIncentiveToken new incentive token for updater\n     * @param amount amount of incentive tokens\n     */\n    function setIncentiveToken(address _newIncentiveToken, uint256 amount) external;\n\n    /**\n     * @notice Configures existing values of an AMM pair\n     * @param _pairAddress Pair address\n     * @param _updatePeriod Update period (TWAP)\n     */\n    function configurePair(address _pairAddress, uint256 _updatePeriod) external;\n\n    /**\n     * @notice Get the AMM price for an amount of krAsset\n     * @param _kreskoAsset Kresko asset address\n     * @param _amountIn Amount of Kresko Asset to get value for\n     */\n    function consultKrAsset(address _kreskoAsset, uint256 _amountIn) external view returns (uint256 amountOut);\n\n    /**\n     * @notice General consult function, gets a value for `_amountIn` of `_token` in terms of `_tokenOut`\n     * @param _pairAddress Address of the pair that contains the token\n     * @param _token Address of the token to get value for\n     * @param _amountIn Amount of token to get value for\n     * @return amountOut Amount of tokenOut that `_amountIn` of `_token` is worth\n     */\n    function consult(address _pairAddress, address _token, uint256 _amountIn) external view returns (uint256 amountOut);\n\n    /**\n     * @notice Initializes an Uniswap V2 pair to be tracked by this oracle.\n     *\n     * The criteria for a pair to be tracked:\n     * The pair must not already be tracked by this oracle.\n     * The pair must exist.\n     * The pair must have reserves.\n     * The update period must be greater than the minimum update period.\n     * @param _pairAddress Liquidity token address for the pair\n     * @param _krAsset Kresko Asset in the pair we want to add helper functionality for\n     * @param _updatePeriod The update period (TWAP) for this AMM pair\n     *\n     */\n    function initPair(address _pairAddress, address _krAsset, uint256 _updatePeriod) external;\n\n    /**\n     * @notice Updates the oracle values for a pair\n     * @param _pairAddress Pair address\n     */\n    function update(address _pairAddress) external;\n\n    /**\n     * @notice Sets a new admin\n     * @param _newAdmin New admin address\n     */\n    function setAdmin(address _newAdmin) external;\n\n    /**\n     * @notice Set a new min update period\n     * @param _minUpdatePeriod The new minimum period that can be set for a pair\n     */\n    function setMinUpdatePeriod(uint256 _minUpdatePeriod) external;\n\n    /**\n     * @notice Move any missent tokens\n     * @param _erc20 drain any sent tokens\n     * @param _to drain any sent tokens\n     */\n    function drainERC20(address _erc20, address _to) external;\n\n    /**\n     * Update pair data with incentives sent\n     * @param _kreskoAsset Kresko Asset in the pair we want to update pair data for\n     */\n    function updateWithIncentive(address _kreskoAsset) external;\n}\n"
    },
    "src/contracts/minter/collateral-pool/CollateralPoolState.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {LibCollateralPool} from \"./libs/LibCollateralPool.sol\";\nimport {LibSwap} from \"./libs/LibSwap.sol\";\nimport {LibAmounts} from \"./libs/LibAmounts.sol\";\nimport {IPositionsFacet} from \"./position/interfaces/IPositionsFacet.sol\";\n\n/* solhint-disable var-name-mixedcase */\n\nusing LibCollateralPool for CollateralPoolState global;\nusing LibAmounts for CollateralPoolState global;\nusing LibSwap for CollateralPoolState global;\n\nstruct PoolCollateral {\n    uint256 liquidationIncentive;\n    uint128 liquidityIndex;\n    uint8 decimals;\n}\n\nstruct PoolKrAsset {\n    uint256 protocolFee; // Taken from the open/close fee. Goes to protocol.\n    uint256 openFee;\n    uint256 closeFee;\n    uint256 supplyLimit;\n}\n\n// Storage layout\nstruct CollateralPoolState {\n    /// @notice The minimum ratio of collateral to debt that can be taken by direct action.\n    uint256 minimumCollateralizationRatio;\n    /// @notice The collateralization ratio at which positions may be liquidated.\n    uint256 liquidationThreshold;\n    /// @notice Mapping of krAsset -> pooled debt\n    mapping(address => uint256) debt;\n    /// @notice Mapping of collateral -> pooled deposits\n    mapping(address => uint256) totalDeposits;\n    /// @notice Mapping of asset -> swap owned collateral deposits\n    mapping(address => uint256) swapDeposits;\n    /// @notice Mapping of account -> collateral -> collateral deposits.\n    mapping(address => mapping(address => uint256)) deposits;\n    /// @notice Mapping of account -> collateral -> principal collateral deposits.\n    mapping(address => mapping(address => uint256)) depositsPrincipal;\n    /// @notice Mapping of collateral -> PoolCollateral\n    mapping(address => PoolCollateral) poolCollateral;\n    /// @notice Mapping of krAsset -> PoolKreskoAsset\n    mapping(address => PoolKrAsset) poolKrAsset;\n    /// @notice Mapping of asset -> asset -> swap enabled\n    mapping(address => mapping(address => bool)) isSwapEnabled;\n    /// @notice Mapping of asset -> enabled\n    mapping(address => bool) isEnabled;\n    /// @notice Array of collateral assets that can be deposited\n    address[] collaterals;\n    /// @notice Array of kresko assets that can be minted and swapped.\n    address[] krAssets;\n    /// @notice User swap fee receiver\n    address swapFeeRecipient;\n    /// @notice Positions NFT\n    IPositionsFacet positions;\n}\n\n// Storage position\nbytes32 constant COLLATEREAL_POOL_STORAGE_POSITION = keccak256(\"kresko.collateral.pool.storage\");\n\n// solhint-disable func-visibility\nfunction cps() pure returns (CollateralPoolState storage state) {\n    bytes32 position = COLLATEREAL_POOL_STORAGE_POSITION;\n    assembly {\n        state.slot := position\n    }\n}\n"
    },
    "src/contracts/minter/collateral-pool/facets/CollateralPoolConfigFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {SafeERC20, IERC20Permit} from \"../../../shared/SafeERC20.sol\";\nimport {MinterModifiers} from \"../../../minter/MinterModifiers.sol\";\nimport {DiamondModifiers, Role} from \"../../../diamond/DiamondModifiers.sol\";\nimport {ms} from \"../../MinterStorage.sol\";\nimport {cps} from \"../CollateralPoolState.sol\";\nimport {Constants} from \"../../MinterTypes.sol\";\nimport {Arrays} from \"../../../libs/Arrays.sol\";\nimport {WadRay} from \"../../../libs/WadRay.sol\";\nimport {ICollateralPoolConfigFacet, PoolCollateral, PoolKrAsset} from \"../interfaces/ICollateralPoolConfigFacet.sol\";\n\ncontract CollateralPoolConfigFacet is ICollateralPoolConfigFacet, DiamondModifiers, MinterModifiers {\n    using SafeERC20 for IERC20Permit;\n    using Arrays for address[];\n\n    /// @inheritdoc ICollateralPoolConfigFacet\n    function initialize(CollateralPoolConfig memory _config) external onlyOwner {\n        require(_config.mcr >= Constants.MIN_COLLATERALIZATION_RATIO, \"mcr-too-low\");\n        require(_config.lt >= Constants.MIN_COLLATERALIZATION_RATIO, \"lt-too-low\");\n        require(_config.lt <= _config.mcr, \"lt-too-high\");\n        require(_config.swapFeeRecipient != address(0), \"invalid-fee-receiver\");\n        require(address(_config.positions) != address(0), \"invalid-positions\");\n\n        cps().minimumCollateralizationRatio = _config.mcr;\n        cps().liquidationThreshold = _config.lt;\n        cps().swapFeeRecipient = _config.swapFeeRecipient;\n        cps().positions = _config.positions;\n    }\n\n    /// @inheritdoc ICollateralPoolConfigFacet\n    function getCollateralPoolConfig() external view override returns (CollateralPoolConfig memory) {\n        return\n            CollateralPoolConfig({\n                swapFeeRecipient: cps().swapFeeRecipient,\n                mcr: cps().minimumCollateralizationRatio,\n                lt: cps().liquidationThreshold,\n                positions: cps().positions\n            });\n    }\n\n    /// @inheritdoc ICollateralPoolConfigFacet\n    function setPoolMinimumCollateralizationRatio(uint256 _mcr) external onlyRole(Role.ADMIN) {\n        require(_mcr >= Constants.MIN_COLLATERALIZATION_RATIO, \"mcr-too-low\");\n        cps().minimumCollateralizationRatio = _mcr;\n    }\n\n    /// @inheritdoc ICollateralPoolConfigFacet\n    function setPoolLiquidationThreshold(uint256 _lt) external onlyRole(Role.ADMIN) {\n        require(_lt >= Constants.MIN_COLLATERALIZATION_RATIO, \"mcr-too-low\");\n        require(_lt <= cps().minimumCollateralizationRatio, \"lt-too-high\");\n        cps().liquidationThreshold = _lt;\n    }\n\n    /// @inheritdoc ICollateralPoolConfigFacet\n    function enablePoolCollaterals(\n        address[] calldata _enabledCollaterals,\n        PoolCollateral[] memory _configurations\n    ) external onlyRole(Role.ADMIN) {\n        require(_enabledCollaterals.length == _configurations.length, \"collateral-length-mismatch\");\n        for (uint256 i; i < _enabledCollaterals.length; i++) {\n            // Checks\n            require(ms().collateralAssets[_enabledCollaterals[i]].uintPrice() != 0, \"collateral-no-price\");\n            require(\n                _configurations[i].liquidationIncentive >= Constants.MIN_LIQUIDATION_INCENTIVE_MULTIPLIER,\n                \"li-too-low\"\n            );\n            require(\n                _configurations[i].liquidationIncentive <= Constants.MAX_LIQUIDATION_INCENTIVE_MULTIPLIER,\n                \"li-too-high\"\n            );\n            require(cps().poolCollateral[_enabledCollaterals[i]].liquidityIndex == 0, \"collateral-already-enabled\");\n\n            // We don't care what values are set for decimals or liquidityIndex. Overriding.\n            _configurations[i].decimals = IERC20Permit(_enabledCollaterals[i]).decimals();\n            _configurations[i].liquidityIndex = uint128(WadRay.RAY);\n\n            // Save to state\n            cps().poolCollateral[_enabledCollaterals[i]] = _configurations[i];\n            cps().isEnabled[_enabledCollaterals[i]] = true;\n            cps().collaterals.push(_enabledCollaterals[i]);\n        }\n    }\n\n    /// @inheritdoc ICollateralPoolConfigFacet\n    function enablePoolKrAssets(\n        address[] calldata _enabledKrAssets,\n        PoolKrAsset[] memory _configurations\n    ) external onlyRole(Role.ADMIN) {\n        require(_enabledKrAssets.length == _configurations.length, \"krasset-length-mismatch\");\n        for (uint256 i; i < _enabledKrAssets.length; i++) {\n            // Checks\n            require(ms().kreskoAssets[_enabledKrAssets[i]].uintPrice() != 0, \"krasset-no-price\");\n            require(cps().poolKrAsset[_enabledKrAssets[i]].supplyLimit == 0, \"krasset-already-enabled\");\n            require(_configurations[i].supplyLimit > 0, \"krasset-supply-limit-zero\");\n            require(\n                _configurations[i].protocolFee <= Constants.MAX_COLLATERAL_POOL_PROTOCOL_FEE,\n                \"krasset-protocol-fee-too-high\"\n            );\n\n            // Save to state\n            cps().poolKrAsset[_enabledKrAssets[i]] = _configurations[i];\n            cps().isEnabled[_enabledKrAssets[i]] = true;\n            cps().krAssets.push(_enabledKrAssets[i]);\n        }\n    }\n\n    /// @inheritdoc ICollateralPoolConfigFacet\n    function updatePoolKrAsset(address _asset, PoolKrAsset calldata _configuration) external onlyRole(Role.ADMIN) {\n        cps().poolKrAsset[_asset] = _configuration;\n    }\n\n    /// @inheritdoc ICollateralPoolConfigFacet\n    function updatePoolCollateral(address _asset, uint256 _newLiquiditationIncentive) external onlyRole(Role.ADMIN) {\n        require(_newLiquiditationIncentive >= Constants.MIN_LIQUIDATION_INCENTIVE_MULTIPLIER, \"li-too-low\");\n        require(_newLiquiditationIncentive <= Constants.MAX_LIQUIDATION_INCENTIVE_MULTIPLIER, \"li-too-high\");\n        cps().poolCollateral[_asset].liquidationIncentive = _newLiquiditationIncentive;\n    }\n\n    /// @inheritdoc ICollateralPoolConfigFacet\n    function disablePoolCollaterals(address[] calldata _disabledAssets) external onlyRole(Role.ADMIN) {\n        require(_disabledAssets.length > 0, \"collateral-disable-length-0\");\n        address[] memory enabledCollaterals = cps().collaterals;\n        bool didDisable;\n        // Loopdy by disabled assets in.\n        for (uint256 i; i < _disabledAssets.length; i++) {\n            address disabledAsset = _disabledAssets[i];\n            // Remove the assets from enabled list.\n            for (uint256 j; j < enabledCollaterals.length; j++) {\n                if (disabledAsset == enabledCollaterals[j]) {\n                    cps().isEnabled[disabledAsset] = false;\n                    didDisable = true;\n                }\n            }\n        }\n        require(didDisable, \"collateral-disable-not-found\");\n    }\n\n    /// @inheritdoc ICollateralPoolConfigFacet\n    function disablePoolKrAssets(address[] calldata _disabledAssets) external onlyRole(Role.ADMIN) {\n        require(_disabledAssets.length > 0, \"krasset-disable-length-0\");\n        address[] memory enabledKrAssets = cps().krAssets;\n        bool didDisable;\n        // Loopdy by disabled assets in.\n        for (uint256 i; i < _disabledAssets.length; i++) {\n            address disabledAsset = _disabledAssets[i];\n            // Remove the assets from enabled list.\n            for (uint256 j; j < enabledKrAssets.length; j++) {\n                if (disabledAsset == enabledKrAssets[j]) {\n                    cps().isEnabled[disabledAsset] = false;\n                    didDisable = true;\n                }\n            }\n        }\n        require(didDisable, \"krasset-disable-not-found\");\n    }\n\n    /// @inheritdoc ICollateralPoolConfigFacet\n    function removePoolCollaterals(address[] calldata _removedAssets) external onlyRole(Role.ADMIN) {\n        require(_removedAssets.length > 0, \"collateral-remove-length-0\");\n        address[] memory enabledCollaterals = cps().collaterals;\n        bool didRemove;\n        // Loopdy by disabled assets in.\n        for (uint256 i; i < _removedAssets.length; i++) {\n            address removedAsset = _removedAssets[i];\n            // Remove the assets from enabled list.\n            for (uint256 j; j < enabledCollaterals.length; j++) {\n                if (removedAsset == enabledCollaterals[j]) {\n                    require(cps().totalDeposits[removedAsset] == 0, \"remove-collateral-has-deposits\");\n                    cps().isEnabled[removedAsset] = false;\n                    cps().collaterals.removeAddress(removedAsset, j);\n                    didRemove = true;\n                }\n            }\n        }\n        require(didRemove, \"collateral-remove-not-found\");\n    }\n\n    /// @inheritdoc ICollateralPoolConfigFacet\n    function removePoolKrAssets(address[] calldata _removedAssets) external onlyRole(Role.ADMIN) {\n        require(_removedAssets.length > 0, \"krasset-disable-length-0\");\n        address[] memory enabledKrAssets = cps().krAssets;\n        bool didRemove;\n        // Loopdy by disabled assets in.\n        for (uint256 i; i < _removedAssets.length; i++) {\n            address removedAsset = _removedAssets[i];\n            cps().isEnabled[removedAsset] = false;\n            // Remove the assets from enabled list.\n            for (uint256 j; j < enabledKrAssets.length; j++) {\n                if (removedAsset == enabledKrAssets[j]) {\n                    // Make sure the asset has no debt.\n                    require(cps().debt[removedAsset] == 0, \"remove-krasset-has-debt\");\n                    cps().krAssets.removeAddress(removedAsset, j);\n                    didRemove = true;\n                }\n            }\n        }\n        require(didRemove, \"krasset-remove-not-found\");\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Swap                                    */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc ICollateralPoolConfigFacet\n    function setFees(\n        address _krAsset,\n        uint256 _openFee,\n        uint256 _closeFee,\n        uint256 _protocolFee\n    ) external onlyRole(Role.ADMIN) {\n        cps().poolKrAsset[_krAsset].openFee = _openFee;\n        cps().poolKrAsset[_krAsset].closeFee = _closeFee;\n        cps().poolKrAsset[_krAsset].protocolFee = _protocolFee;\n        emit FeeSet(_krAsset, _openFee, _closeFee, _protocolFee);\n    }\n\n    /// @inheritdoc ICollateralPoolConfigFacet\n    function setSwapPairs(PairSetter[] calldata _pairs) external onlyRole(Role.ADMIN) {\n        for (uint256 i; i < _pairs.length; i++) {\n            cps().isSwapEnabled[_pairs[i].assetIn][_pairs[i].assetOut] = _pairs[i].enabled;\n            cps().isSwapEnabled[_pairs[i].assetOut][_pairs[i].assetIn] = _pairs[i].enabled;\n            emit PairSet(_pairs[i].assetIn, _pairs[i].assetOut, _pairs[i].enabled);\n            emit PairSet(_pairs[i].assetOut, _pairs[i].assetIn, _pairs[i].enabled);\n        }\n    }\n\n    /// @inheritdoc ICollateralPoolConfigFacet\n    function setSwapPairsSingle(PairSetter calldata _pair) external onlyRole(Role.ADMIN) {\n        cps().isSwapEnabled[_pair.assetIn][_pair.assetOut] = _pair.enabled;\n        emit PairSet(_pair.assetIn, _pair.assetOut, _pair.enabled);\n    }\n}\n"
    },
    "src/contracts/minter/collateral-pool/facets/CollateralPoolFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {SafeERC20, IERC20Permit} from \"../../../shared/SafeERC20.sol\";\nimport {DiamondModifiers} from \"../../../diamond/DiamondModifiers.sol\";\nimport {ms} from \"../../MinterStorage.sol\";\nimport {CollateralAsset, KrAsset} from \"../../MinterTypes.sol\";\nimport {ICollateralPoolFacet} from \"../interfaces/ICollateralPoolFacet.sol\";\nimport {cps} from \"../CollateralPoolState.sol\";\nimport {LibAmounts} from \"../libs/LibAmounts.sol\";\nimport {LibCalculation} from \"../../libs/LibCalculation.sol\";\nimport {LibDecimals} from \"../../libs/LibDecimals.sol\";\nimport {Error} from \"../../../libs/Errors.sol\";\nimport {WadRay} from \"../../../libs/WadRay.sol\";\n\ncontract CollateralPoolFacet is ICollateralPoolFacet, DiamondModifiers {\n    using SafeERC20 for IERC20Permit;\n    using WadRay for uint256;\n    using LibDecimals for uint8;\n\n    /// @inheritdoc ICollateralPoolFacet\n    function poolDeposit(address _account, address _collateralAsset, uint256 _amount) external nonReentrant {\n        // Transfer tokens into this contract prior to any state changes as an extra measure against re-entrancy.\n        IERC20Permit(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n\n        // Record the collateral deposit.\n        cps().recordCollateralDeposit(_account, _collateralAsset, _amount);\n\n        emit CollateralPoolDeposit(_account, _collateralAsset, _amount);\n    }\n\n    /// @inheritdoc ICollateralPoolFacet\n    function poolWithdraw(address _account, address _collateralAsset, uint256 _amount) external nonReentrant {\n        // When principal deposits are less or equal to requested amount. We send full deposit + fees in this case.\n        (uint256 collateralOut, uint256 feesOut) = cps().recordCollateralWithdrawal(\n            msg.sender,\n            _collateralAsset,\n            _amount\n        );\n\n        // ensure that global pool is left with CR over MCR.\n        require(cps().checkRatio(cps().minimumCollateralizationRatio), \"withdraw-mcr-violation\");\n\n        // Send out the collateral.\n        IERC20Permit(_collateralAsset).safeTransfer(_account, collateralOut + feesOut);\n\n        // Emit event.\n        emit CollateralPoolWithdraw(_account, _collateralAsset, collateralOut, feesOut);\n    }\n\n    /// @inheritdoc ICollateralPoolFacet\n    function poolRepay(address _repayKrAsset, uint256 _repayAmount, address _seizeCollateral) external nonReentrant {\n        require(cps().debt[_repayKrAsset] >= 0, \"repay-no-debt\");\n        require(cps().debt[_repayKrAsset] >= _repayAmount, \"repay-too-much\");\n        require(cps().swapDeposits[_seizeCollateral] >= 0, \"repay-no-assets-available\");\n\n        uint256 seizedAmount = ms().kreskoAssets[_repayKrAsset].uintUSD(_repayAmount).wadDiv(\n            ms().collateralAssets[_seizeCollateral].uintPrice()\n        );\n        require(cps().swapDeposits[_seizeCollateral] >= seizedAmount, \"repay-too-much\");\n\n        cps().debt[_repayKrAsset] -= ms().repaySwap(_repayKrAsset, _repayAmount, msg.sender);\n\n        uint256 amountOutInternal = LibAmounts.getCollateralAmountWrite(_repayKrAsset, seizedAmount);\n        cps().swapDeposits[_seizeCollateral] -= amountOutInternal;\n        cps().totalDeposits[_seizeCollateral] -= amountOutInternal;\n\n        // solhint-disable-next-line avoid-tx-origin\n        emit CollateralPoolRepayment(tx.origin, _repayKrAsset, _repayAmount, _seizeCollateral, seizedAmount);\n    }\n\n    function poolIsLiquidatable() external view returns (bool) {\n        return cps().isLiquidatable();\n    }\n\n    /// @inheritdoc ICollateralPoolFacet\n    function poolLiquidate(\n        address _repayKrAsset,\n        uint256 _repayAmount,\n        address _seizeCollateral\n    ) external nonReentrant {\n        require(_repayAmount > 0, \"liquidate-zero-amount\");\n        require(cps().debt[_repayKrAsset] >= _repayAmount, \"liquidate-too-much\");\n        require(cps().isLiquidatable(), \"not-liquidatable\");\n\n        KrAsset memory krAsset = ms().kreskoAssets[_repayKrAsset];\n        CollateralAsset memory collateral = ms().collateralAssets[_seizeCollateral];\n        uint256 repayAmountUSD = krAsset.uintUSD(_repayAmount);\n\n        require(\n            ms().getMaxLiquidation(address(0), krAsset, _seizeCollateral) >= repayAmountUSD,\n            Error.LIQUIDATION_OVERFLOW\n        );\n\n        uint256 seizeAmount = collateral.decimals.fromWad(\n            LibCalculation.calculateAmountToSeize(\n                collateral.liquidationIncentive,\n                collateral.uintPrice(),\n                repayAmountUSD\n            )\n        );\n\n        cps().debt[_repayKrAsset] -= ms().repaySwap(_repayKrAsset, _repayAmount, msg.sender);\n        cps().adjustSeizedCollateral(_seizeCollateral, seizeAmount);\n\n        IERC20Permit(_seizeCollateral).safeTransfer(msg.sender, seizeAmount);\n\n        emit CollateralPoolLiquidationOccured(\n            // solhint-disable-next-line avoid-tx-origin\n            tx.origin,\n            _repayKrAsset,\n            _repayAmount,\n            _seizeCollateral,\n            seizeAmount\n        );\n    }\n}\n"
    },
    "src/contracts/minter/collateral-pool/facets/CollateralPoolStateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {ICollateralPoolStateFacet} from \"../interfaces/ICollateralPoolStateFacet.sol\";\nimport {cps, PoolCollateral, PoolKrAsset} from \"../CollateralPoolState.sol\";\nimport {ms} from \"../../MinterStorage.sol\";\nimport {WadRay} from \"../../../libs/WadRay.sol\";\n\n/**\n * @title CollateralPoolStateFacet\n * @author Kresko\n * @notice  This facet is used to view the state of the collateral pool.\n */\ncontract CollateralPoolStateFacet is ICollateralPoolStateFacet {\n    using WadRay for uint256;\n\n    /// @inheritdoc ICollateralPoolStateFacet\n    function getPoolAccountDepositsWithFees(\n        address _account,\n        address _collateralAsset\n    ) external view returns (uint256) {\n        return cps().getAccountDepositsWithFees(_account, _collateralAsset);\n    }\n\n    /// @inheritdoc ICollateralPoolStateFacet\n    function getPoolAccountPrincipalDeposits(\n        address _account,\n        address _collateralAsset\n    ) external view returns (uint256) {\n        return cps().getAccountPrincipalDeposits(_account, _collateralAsset);\n    }\n\n    /// @inheritdoc ICollateralPoolStateFacet\n    function getPoolAccountDepositsValue(\n        address _account,\n        address _collateralAsset,\n        bool _ignoreFactors\n    ) external view returns (uint256) {\n        uint256 principalDeposits = cps().getAccountPrincipalDeposits(_account, _collateralAsset);\n        uint256 scaledDeposits = cps().getAccountDepositsWithFees(_account, _collateralAsset);\n\n        (uint256 assetValue, ) = ms().getCollateralValueAndOraclePrice(\n            _collateralAsset,\n            principalDeposits > scaledDeposits ? scaledDeposits : principalDeposits,\n            _ignoreFactors\n        );\n\n        return assetValue;\n    }\n\n    /// @inheritdoc ICollateralPoolStateFacet\n    function getPoolAccountDepositsValueWithFees(\n        address _account,\n        address _collateralAsset\n    ) external view returns (uint256) {\n        (uint256 assetValue, ) = ms().getCollateralValueAndOraclePrice(\n            _collateralAsset,\n            cps().getAccountDepositsWithFees(_account, _collateralAsset),\n            true\n        );\n\n        return assetValue;\n    }\n\n    /// @inheritdoc ICollateralPoolStateFacet\n    function getPoolAccountTotalDepositsValue(address _account, bool _ignoreFactors) external view returns (uint256) {\n        return cps().getAccountTotalDepositValuePrincipal(_account, _ignoreFactors);\n    }\n\n    /// @inheritdoc ICollateralPoolStateFacet\n    function getPoolAccountTotalDepositsValueWithFees(address _account) external view returns (uint256) {\n        return cps().getAccountTotalDepositValueWithFees(_account);\n    }\n\n    /// @inheritdoc ICollateralPoolStateFacet\n    function getPoolDeposits(address _collateralAsset) external view returns (uint256) {\n        return cps().getPoolDeposits(_collateralAsset);\n    }\n\n    /// @inheritdoc ICollateralPoolStateFacet\n    function getPoolDepositsValue(address _collateralAsset, bool _ignoreFactors) external view returns (uint256) {\n        (uint256 assetValue, ) = ms().getCollateralValueAndOraclePrice(\n            _collateralAsset,\n            cps().getPoolDeposits(_collateralAsset),\n            _ignoreFactors\n        );\n\n        return assetValue;\n    }\n\n    /// @inheritdoc ICollateralPoolStateFacet\n    function getPoolSwapDeposits(address _collateralAsset) external view returns (uint256) {\n        return cps().getPoolSwapDeposits(_collateralAsset);\n    }\n\n    /// @inheritdoc ICollateralPoolStateFacet\n    function getPoolDebt(address _kreskoAsset) external view returns (uint256) {\n        return ms().getKreskoAssetAmount(_kreskoAsset, cps().debt[_kreskoAsset]);\n    }\n\n    /// @inheritdoc ICollateralPoolStateFacet\n    function getPoolDebtValue(address _kreskoAsset, bool _ignoreFactors) external view returns (uint256) {\n        return\n            ms().getKrAssetValue(\n                _kreskoAsset,\n                ms().getKreskoAssetAmount(_kreskoAsset, cps().debt[_kreskoAsset]),\n                _ignoreFactors\n            );\n    }\n\n    /// @inheritdoc ICollateralPoolStateFacet\n    function getPoolCollateral(address _collateralAsset) external view returns (PoolCollateral memory) {\n        return cps().poolCollateral[_collateralAsset];\n    }\n\n    /// @inheritdoc ICollateralPoolStateFacet\n    function getPoolCollateralAssets() external view returns (address[] memory) {\n        return cps().collaterals;\n    }\n\n    /// @inheritdoc ICollateralPoolStateFacet\n    function getPoolKrAsset(address _krAsset) external view returns (PoolKrAsset memory) {\n        return cps().poolKrAsset[_krAsset];\n    }\n\n    /// @inheritdoc ICollateralPoolStateFacet\n    function getPoolKrAssets() external view returns (address[] memory) {\n        return cps().krAssets;\n    }\n\n    /// @inheritdoc ICollateralPoolStateFacet\n    function getPoolStats(\n        bool _ignoreFactors\n    ) external view returns (uint256 collateralValue, uint256 debtValue, uint256 cr) {\n        collateralValue = cps().getTotalPoolDepositValue(_ignoreFactors);\n        debtValue = cps().getTotalPoolKrAssetValueAtRatio(\n            _ignoreFactors ? 1 ether : cps().minimumCollateralizationRatio,\n            _ignoreFactors\n        );\n        if (debtValue == 0) return (collateralValue, debtValue, 0);\n        cr = collateralValue.wadDiv(debtValue);\n    }\n\n    /// @inheritdoc ICollateralPoolStateFacet\n    function getPoolSwapFeeRecipient() external view returns (address) {\n        return cps().swapFeeRecipient;\n    }\n\n    /// @inheritdoc ICollateralPoolStateFacet\n    function getPoolAssetIsEnabled(address _asset) external view returns (bool) {\n        return cps().isEnabled[_asset];\n    }\n\n    /// @inheritdoc ICollateralPoolStateFacet\n    function getPoolIsSwapEnabled(address _assetIn, address _assetOut) external view returns (bool) {\n        return cps().isSwapEnabled[_assetIn][_assetOut];\n    }\n}\n"
    },
    "src/contracts/minter/collateral-pool/facets/CollateralPoolSwapFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {SafeERC20, IERC20Permit} from \"../../../shared/SafeERC20.sol\";\nimport {DiamondModifiers} from \"../../../diamond/DiamondModifiers.sol\";\nimport {ms} from \"../../MinterStorage.sol\";\nimport {WadRay} from \"../../../libs/WadRay.sol\";\nimport {ICollateralPoolSwapFacet} from \"../interfaces/ICollateralPoolSwapFacet.sol\";\nimport {cps} from \"../CollateralPoolState.sol\";\nimport {Position, NewPosition} from \"../position/state/PositionsStorage.sol\";\n\ncontract CollateralPoolSwapFacet is ICollateralPoolSwapFacet, DiamondModifiers {\n    using SafeERC20 for IERC20Permit;\n    using WadRay for uint256;\n\n    /// @inheritdoc ICollateralPoolSwapFacet\n    function cumulateIncome(address _incomeAsset, uint256 _amount) public nonReentrant {\n        require(cps().poolCollateral[_incomeAsset].liquidityIndex != 0, \"not-collateral\");\n        require(cps().isEnabled[_incomeAsset], \"collateral-not-enabled\");\n        require(cps().totalDeposits[_incomeAsset] > 0, \"no-deposits\");\n        IERC20Permit(_incomeAsset).safeTransferFrom(msg.sender, address(this), _amount);\n        cps().cumulateIncome(_incomeAsset, _amount);\n\n        emit Income(_incomeAsset, _amount);\n    }\n\n    function getPrice(address _asset) external view returns (uint256 price) {\n        if (address(ms().kreskoAssets[_asset].oracle) != address(0)) {\n            price = ms().kreskoAssets[_asset].uintPrice();\n        } else {\n            price = ms().collateralAssets[_asset].uintPrice();\n        }\n        require(price != 0, \"price-0\");\n    }\n\n    /// @inheritdoc ICollateralPoolSwapFacet\n    function previewSwap(\n        address _assetIn,\n        address _assetOut,\n        uint256 _amountIn,\n        uint256 _leverage\n    ) external view returns (uint256 amountOut, uint256 feeAmount, uint256 feeAmountProtocol) {\n        // Check that assets can be swapped, get the fee percentages.\n        (uint256 feePercentage, uint256 protocolFee) = cps().checkAssets(_assetIn, _assetOut);\n\n        // Get the fees from amount received.\n        feeAmount = _amountIn.wadMul(_leverage).wadMul(feePercentage);\n        uint256 valueIn = ms().kreskoAssets[_assetIn].uintUSD(_amountIn - feeAmount);\n\n        amountOut = valueIn.wadDiv(ms().kreskoAssets[_assetOut].uintPrice()).wadMul(_leverage);\n        feeAmountProtocol = feeAmount.wadMul(protocolFee);\n        feeAmount -= feeAmountProtocol;\n    }\n\n    /// @inheritdoc ICollateralPoolSwapFacet\n    function swap(\n        address _receiver,\n        address _assetIn,\n        address _assetOut,\n        uint256 _amountIn,\n        uint256 _amountOutMin\n    ) external nonReentrant {\n        require(_amountIn > 0, \"swap-amount-zero\");\n\n        // Transfer assets into this contract.\n        IERC20Permit(_assetIn).safeTransferFrom(msg.sender, address(this), _amountIn);\n        address receiver = _receiver == address(0) ? msg.sender : _receiver;\n\n        emit Swap(\n            msg.sender,\n            _assetIn,\n            _assetOut,\n            _amountIn,\n            _swap(receiver, _assetIn, _assetOut, _amountIn, _amountOutMin)\n        );\n    }\n\n    /// @inheritdoc ICollateralPoolSwapFacet\n    function swapIntoLeverage(\n        address _sender,\n        NewPosition memory _pos\n    ) external nonReentrant returns (uint256 amountAFeeReduced, uint256 amountBOut) {\n        require(msg.sender == address(cps().positions), \"closeLever-not-caller\");\n        require(_pos.account != address(0), \"receiver-invalid\");\n        require(_pos.amountA > 0, \"swap-amount-zero\");\n\n        // Transfer collateral assets into this contract.\n        IERC20Permit(_pos.assetA).safeTransferFrom(_sender, address(this), _pos.amountA);\n\n        // Creating the position, sending it to leverPositions.\n        (amountAFeeReduced, amountBOut) = _swapIntoLeverage(\n            _pos.assetA,\n            _pos.assetB,\n            _pos.amountA,\n            _pos.amountBMin,\n            _pos.leverage\n        );\n\n        emit Swap(msg.sender, _pos.assetA, _pos.assetB, _pos.amountA, amountBOut);\n    }\n\n    // Closes a position, called by positions on closing a leveraged position.\n    function swapOutOfLeverage(\n        Position memory _pos,\n        address _liquidator\n    ) external nonReentrant returns (uint256 amountAOut) {\n        require(msg.sender == address(cps().positions), \"closeLever-not-caller\");\n\n        bool isProfit;\n        // Swap out leveraged debt back to collateral.\n        (amountAOut, isProfit) = _swapOutOfLeverage(_pos);\n\n        emit Swap(msg.sender, _pos.assetB, _pos.assetA, _pos.amountB, amountAOut);\n\n        // this is a position being closed by someone else\n        // it has crossed either the liquidation threshold or the close threshold\n        if (_liquidator != address(0)) {\n            uint256 incentiveAOut = amountAOut.wadMul(\n                isProfit ? _pos.closeIncentive : _pos.liquidationIncentive // from total\n            );\n            IERC20Permit(_pos.assetA).safeTransfer(_liquidator, incentiveAOut);\n            amountAOut -= incentiveAOut;\n        }\n\n        IERC20Permit(_pos.assetA).safeTransfer(_pos.account, amountAOut);\n    }\n\n    function positionDepositA(address _to, uint256 _amountA, Position memory _pos) external nonReentrant {\n        require(msg.sender == address(cps().positions), \"deposit-not-caller\");\n        IERC20Permit(_pos.assetA).safeTransferFrom(_to, address(this), _amountA);\n        cps().handleAssetsIn(_pos.assetA, _amountA, address(this));\n    }\n\n    function positionWithdrawA(address _from, uint256 _amountA, Position memory _pos) external nonReentrant {\n        require(msg.sender == address(cps().positions), \"deposit-not-caller\");\n        cps().handleAssetsOut(_pos.assetA, ms().kreskoAssets[_pos.assetA].uintUSD(_amountA), _from);\n    }\n\n    /**\n     * @notice Swaps assets in the collateral pool.\n     * @param _receiver The address to receive the swapped assets.\n     * @param _assetIn The asset to swap in.\n     * @param _assetOut The asset to swap out.\n     * @param _amountIn The amount of `_assetIn` to swap in.\n     * @param _amountOutMin The minimum amount of `_assetOut` to receive.\n     */\n    function _swap(\n        address _receiver,\n        address _assetIn,\n        address _assetOut,\n        uint256 _amountIn,\n        uint256 _amountOutMin\n    ) internal returns (uint256 amountOut) {\n        // Check that assets can be swapped, get the fee percentages.\n        (uint256 feePercentage, uint256 protocolFee) = cps().checkAssets(_assetIn, _assetOut);\n        // Get the fees from amount received.\n        uint256 feeAmount = _amountIn.wadMul(feePercentage);\n\n        // Assets received pay off debt and/or increase \"swap\" owned collateral.\n        uint256 valueIn = cps().handleAssetsIn(\n            _assetIn,\n            _amountIn - feeAmount, // Work with fee reduced amount from here.\n            address(this)\n        );\n\n        // Assets sent out are newly minted debt and/or \"swap\" owned collateral.\n        amountOut = cps().handleAssetsOut(_assetOut, valueIn, _receiver);\n\n        // State modifications done, check MCR and slippage.\n        _checkAndPayFee(_assetIn, amountOut, _amountOutMin, feeAmount, protocolFee);\n    }\n\n    /**\n     * @notice Swaps into a leveraged amount of `_assetOut`.\n     * @notice Receiver of assets is leverPositions.\n     * @param _assetA The asset that was provided.\n     * @param _assetB The asset that was leveraged.\n     * @param _amountAIn The amount of assetIn to swap.\n     * @param _amountBOutMin The minimum amount of assetOut to receive. For slippage protection.\n     * @param _leverage The leverage of the position.\n     * @return amountAIn The amount of assetA actually swapped after fees.\n     * @return amountBOut The amount of assetB actually received.\n     */\n    function _swapIntoLeverage(\n        address _assetA,\n        address _assetB,\n        uint256 _amountAIn,\n        uint256 _amountBOutMin,\n        uint256 _leverage\n    ) internal returns (uint256 amountAIn, uint256 amountBOut) {\n        // Check that assets can be swapped, get the fee percentages.\n        (uint256 feePercentage, uint256 protocolFee) = cps().checkAssets(_assetA, _assetB);\n        // Get the fees adjusted for leverage taken.\n        uint256 feeAmountA = _amountAIn.wadMul(_leverage).wadMul(feePercentage);\n\n        amountAIn = _amountAIn - feeAmountA; // Work with fee reduced amount from here.\n\n        // Not leverage adjusted.\n        uint256 valueAIn = cps().handleAssetsIn(_assetA, amountAIn, address(this)).wadMul(_leverage);\n\n        // We multiply value by leverage to get the amount of debt to mint.\n        amountBOut = cps().handleAssetsOut(_assetB, valueAIn, address(cps().positions));\n\n        _checkAndPayFee(_assetA, amountBOut, _amountBOutMin, feeAmountA, protocolFee);\n    }\n\n    /**\n     * @notice Swaps a leveraged position back to unleveraged amount of provided asset.\n     * @param _pos The position to swap out.\n     */\n    function _swapOutOfLeverage(Position memory _pos) internal returns (uint256 amountAOut, bool isProfit) {\n        // Check that assets can be swapped, get the fee percentages.\n        (uint256 feePercentage, uint256 protocolFee) = cps().checkAssets(_pos.assetB, _pos.assetA);\n\n        // We reduce value out here, as it was increased on the way in.\n        uint256 valueBIn = cps().handleAssetsIn(_pos.assetB, _pos.amountB, address(cps().positions));\n\n        amountAOut = cps().handleAssetsOut(_pos.assetA, valueBIn.wadDiv(_pos.leverage), address(this));\n\n        // Get the fees adjusted for leveraged taken.\n        uint256 feeAmountA = amountAOut.wadMul(feePercentage.wadMul(_pos.leverage));\n\n        amountAOut = amountAOut - feeAmountA;\n        uint256 principalAmountA = _pos.amountA - feeAmountA;\n\n        // We do not need to check for CR, it will always go up.\n        _payFee(_pos.assetA, feeAmountA, protocolFee);\n\n        if (amountAOut > principalAmountA) {\n            uint256 profits = (amountAOut - principalAmountA).wadMul(_pos.leverage - 1 ether); // 1x profit when swapping from.\n\n            // increase by profit\n            return (cps().handleProfitsOut(_pos.assetA, amountAOut, profits, _pos.account), true);\n        } else if (amountAOut < principalAmountA) {\n            uint256 losses = (principalAmountA - amountAOut).wadMul(_pos.leverage - 1 ether);\n            cps().handleAssetsIn(_pos.assetA, losses, address(this));\n\n            // decrease by losses\n            return (amountAOut - losses, false);\n        }\n    }\n\n    function _checkAndPayFee(\n        address _feeAsset,\n        uint256 _amountOut,\n        uint256 _amountOutMin,\n        uint256 _feeAmount,\n        uint256 _protocolFee\n    ) private {\n        // State modifications done, check MCR and slippage.\n        require(_amountOut >= _amountOutMin, \"lev-swap-slippage\");\n        require(cps().checkRatio(cps().minimumCollateralizationRatio), \"lev-swap-mcr-violation\");\n        _payFee(_feeAsset, _feeAmount, _protocolFee);\n    }\n\n    function _payFee(address _feeAsset, uint256 _feeAmount, uint256 _protocolFee) private {\n        uint256 protocolFeeTaken = _feeAmount.wadMul(_protocolFee);\n        _feeAmount -= protocolFeeTaken;\n\n        // Send fees to the fee receivers.\n        IERC20Permit(_feeAsset).safeTransfer(cps().swapFeeRecipient, _feeAmount);\n        IERC20Permit(_feeAsset).safeTransfer(ms().feeRecipient, protocolFeeTaken);\n\n        emit SwapFee(_feeAsset, _feeAmount, protocolFeeTaken);\n    }\n}\n"
    },
    "src/contracts/minter/collateral-pool/interfaces/ICollateralPoolConfigFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {PoolKrAsset, PoolCollateral} from \"../CollateralPoolState.sol\";\nimport {IPositionsFacet} from \"../position/interfaces/IPositionsFacet.sol\";\n\ninterface ICollateralPoolConfigFacet {\n    /**\n     * @notice Collateral pool configuration.\n     * @param _swapFeeRecipient The swap fee recipient.\n     * @param _mcr The minimum collateralization ratio.\n     * @param _lt The liquidation threshold.\n     */\n    struct CollateralPoolConfig {\n        address swapFeeRecipient;\n        uint256 mcr;\n        uint256 lt;\n        IPositionsFacet positions;\n    }\n    // Emitted when a swap pair is disabled / enabled.\n    event PairSet(address indexed assetIn, address indexed assetOut, bool enabled);\n    // Emitted when a kresko asset fee is updated.\n    event FeeSet(address indexed _asset, uint256 openFee, uint256 closeFee, uint256 protocolFee);\n\n    // Emitted when a collateral is updated.\n    event PoolCollateralUpdated(address indexed _asset, uint256 liquidationThreshold);\n\n    // Emitted when a kresko asset is updated.\n    event PoolKrAssetUpdated(\n        address indexed _asset,\n        uint256 openFee,\n        uint256 closeFee,\n        uint256 protocolFee,\n        uint256 supplyLimit\n    );\n\n    // Used for setting swap pairs enabled or disabled in the pool.\n    struct PairSetter {\n        address assetIn;\n        address assetOut;\n        bool enabled;\n    }\n\n    /**\n     * @notice Initialize the collateral pool.\n     * Callable by diamond owner only.\n     * @param _config The configuration for the pool.\n     */\n    function initialize(CollateralPoolConfig memory _config) external;\n\n    /// @notice Get the pool configuration.\n    function getCollateralPoolConfig() external view returns (CollateralPoolConfig memory);\n\n    /// @notice Set the pool minimum collateralization ratio.\n    function setPoolMinimumCollateralizationRatio(uint256 _mcr) external;\n\n    /// @notice Set the pool liquidation threshold.\n    function setPoolLiquidationThreshold(uint256 _lt) external;\n\n    /**\n     * @notice Enable kresko assets in the pool.\n     * Only callable by admin.\n     * @param _enabledKrAssets The list of KreskoAssets to enable\n     * @param _configurations The configurations for the KreskoAssets. Must match length above.\n     */\n    function enablePoolKrAssets(address[] memory _enabledKrAssets, PoolKrAsset[] memory _configurations) external;\n\n    /**\n     * @notice Enable collaterals in the pool.\n     * Only callable by admin.\n     * @param _enabledCollaterals The list of collaterals to enable\n     * @param _configurations The configurations for the collaterals. Must match length above.\n     */\n    function enablePoolCollaterals(\n        address[] calldata _enabledCollaterals,\n        PoolCollateral[] memory _configurations\n    ) external;\n\n    /**\n     * @notice Update the KreskoAsset pool configuration.\n     * Only callable by admin.\n     * @param _asset The KreskoAsset to update\n     * @param _configuration The configuration.\n     * emits PoolKrAssetUpdated\n     */\n    function updatePoolKrAsset(address _asset, PoolKrAsset calldata _configuration) external;\n\n    /**\n     * @notice Update the collateral configuration.\n     * Only callable by admin.\n     * @param _asset The KreskoAsset to update\n     * @param _newLiquidationIncentive The new liquidation incentive.\n     * emits PoolCollateralUpdated\n     */\n    function updatePoolCollateral(address _asset, uint256 _newLiquidationIncentive) external;\n\n    /**\n     * @notice Disabled swaps and deposits for collaterals in the pool.\n     * Only callable by admin.\n     * @param _disabledAssets The list of collaterals to disable\n     */\n    function disablePoolCollaterals(address[] calldata _disabledAssets) external;\n\n    /**\n     * @notice Disabled swaps for krAssets in the pool.\n     * Only callable by admin.\n     * @param _disabledAssets The list of krAssets to disable\n     */\n    function disablePoolKrAssets(address[] calldata _disabledAssets) external;\n\n    /**\n     * @notice Completely removes collaterals from the pool.\n     * Only callable by admin.\n     * _removedAssets must not have any deposits.\n     * @param _removedAssets The list of collaterals to remove\n     */\n    function removePoolCollaterals(address[] calldata _removedAssets) external;\n\n    /**\n     * @notice Completely remove KreskoAssets from the pool\n     * Only callable by admin.\n     * _removedAssets must not have any debt.\n     * @param _removedAssets The list of KreskoAssets to remove\n     */\n    function removePoolKrAssets(address[] calldata _removedAssets) external;\n\n    /**\n     * @notice Set whether pairs are enabled or not. Both ways.\n     * Only callable by admin.\n     * @param _setters The configurations to set.\n     */\n    function setSwapPairs(PairSetter[] calldata _setters) external;\n\n    /**\n     * @notice Set whether a swap pair is enabled or not.\n     * Only callable by admin.\n     * @param _setter The configuration to set\n     */\n    function setSwapPairsSingle(PairSetter calldata _setter) external;\n\n    /**\n     * @notice Sets the fees for a kresko asset\n     * @dev Only callable by admin.\n     * @param _krAsset The kresko asset to set fees for.\n     * @param _openFee The new open fee.\n     * @param _closeFee The new close fee.\n     * @param _protocolFee The protocol fee share.\n     */\n    function setFees(address _krAsset, uint256 _openFee, uint256 _closeFee, uint256 _protocolFee) external;\n}\n"
    },
    "src/contracts/minter/collateral-pool/interfaces/ICollateralPoolFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface ICollateralPoolFacet {\n    event CollateralPoolDeposit(address indexed depositor, address indexed collateralAsset, uint256 amount);\n    event CollateralPoolWithdraw(\n        address indexed withdrawer,\n        address indexed collateralAsset,\n        uint256 amount,\n        uint256 feeAmount\n    );\n    event CollateralPoolRepayment(\n        address indexed repayer,\n        address indexed repayKreskoAsset,\n        uint256 repayAmount,\n        address indexed receiveKreskoAsset,\n        uint256 receiveAmount\n    );\n\n    event CollateralPoolLiquidationOccured(\n        address indexed liquidator,\n        address indexed repayKreskoAsset,\n        uint256 repayAmount,\n        address indexed seizeCollateral,\n        uint256 seizeAmount\n    );\n\n    /**\n     * @notice Deposit collateral for account to the collateral pool.\n     * @param _account The account to deposit for.\n     * @param _collateralAsset The collateral asset to deposit.\n     * @param _amount The amount to deposit.\n     */\n    function poolDeposit(address _account, address _collateralAsset, uint256 _amount) external;\n\n    /**\n     * @notice Withdraw collateral for account from the collateral pool.\n     * @param _account The account to withdraw for.\n     * @param _collateralAsset The collateral asset to withdraw.\n     * @param _amount The amount to withdraw.\n     */\n    function poolWithdraw(address _account, address _collateralAsset, uint256 _amount) external;\n\n    /**\n     * @notice Repay debt for no fees or slippage.\n     * @notice Only uses swap deposits, if none available, reverts.\n     * @param _repayKrAsset The asset to repay the debt in.\n     * @param _repayAmount The amount of the asset to repay the debt with.\n     * @param _seizeCollateral The collateral asset to seize.\n     */\n    function poolRepay(address _repayKrAsset, uint256 _repayAmount, address _seizeCollateral) external;\n\n    /**\n     * @notice Liquidate the collateral pool.\n     * @notice Adjusts everyones deposits if swap deposits do not cover the seized amount.\n     * @param _repayKrAsset The asset to repay the debt in.\n     * @param _repayAmount The amount of the asset to repay the debt with.\n     * @param _seizeCollateral The collateral asset to seize.\n     */\n    function poolLiquidate(address _repayKrAsset, uint256 _repayAmount, address _seizeCollateral) external;\n}\n"
    },
    "src/contracts/minter/collateral-pool/interfaces/ICollateralPoolStateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {PoolCollateral, PoolKrAsset, CollateralPoolState} from \"../CollateralPoolState.sol\";\n\ninterface ICollateralPoolStateFacet {\n    /**\n     * @notice Get the collateral pool balance for `_account`.\n     * @param _account The account.\n     * @param _collateralAsset The collateral asset.\n     */\n    function getPoolAccountDepositsWithFees(address _account, address _collateralAsset) external view returns (uint256);\n\n    /**\n     * @notice Get the total collateral principal for `_account`\n     * @param _account The account.\n     * @param _collateralAsset The collateral asset\n     */\n    function getPoolAccountPrincipalDeposits(\n        address _account,\n        address _collateralAsset\n    ) external view returns (uint256);\n\n    /**\n     * @notice Get the  collateral deposit value for `_account`\n     * @param _account The account.\n     * @param _collateralAsset The collateral asset\n     * @param _ignoreFactors Ignore factors when calculating collateral value.\n     */\n    function getPoolAccountDepositsValue(\n        address _account,\n        address _collateralAsset,\n        bool _ignoreFactors\n    ) external view returns (uint256);\n\n    /**\n     * @notice Get the full value of account and fees for `_account`\n     * @param _account The account.\n     * @param _collateralAsset The collateral asset\n     */\n    function getPoolAccountDepositsValueWithFees(\n        address _account,\n        address _collateralAsset\n    ) external view returns (uint256);\n\n    /**\n     * @notice Get the total collateral deposit value for `_account`\n     * @param _account The account.\n     * @param _ignoreFactors Ignore factors when calculating collateral value.\n     */\n    function getPoolAccountTotalDepositsValue(address _account, bool _ignoreFactors) external view returns (uint256);\n\n    /**\n     * @notice Get the full value of account and fees for `_account`\n     * @param _account The account.\n     */\n    function getPoolAccountTotalDepositsValueWithFees(address _account) external view returns (uint256);\n\n    /**\n     * @notice Get the total collateral deposits for `_collateralAsset`\n     * @param _collateralAsset The collateral asset\n     */\n    function getPoolDeposits(address _collateralAsset) external view returns (uint256);\n\n    /**\n     * @notice Get the total collateral deposit value for `_collateralAsset`\n     * @param _collateralAsset The collateral asset\n     * @param _ignoreFactors Ignore factors when calculating collateral and debt value.\n     */\n    function getPoolDepositsValue(address _collateralAsset, bool _ignoreFactors) external view returns (uint256);\n\n    /**\n     * @notice Get the total collateral swap deposits for `_collateralAsset`\n     * @param _collateralAsset The collateral asset\n     */\n    function getPoolSwapDeposits(address _collateralAsset) external view returns (uint256);\n\n    /**\n     * @notice Get the collateral debt amount for `_kreskoAsset`\n     * @param _kreskoAsset The KreskoAsset\n     */\n    function getPoolDebt(address _kreskoAsset) external returns (uint256);\n\n    /**\n     * @notice Get the collateral debt value for `_kreskoAsset`\n     * @param _kreskoAsset The KreskoAsset\n     * @param _ignoreFactors Ignore factors when calculating collateral and debt value.\n     */\n    function getPoolDebtValue(address _kreskoAsset, bool _ignoreFactors) external returns (uint256);\n\n    /**\n     * @notice Get the collateral configuration for `_collateralAsset`\n     * @param _collateralAsset The collateral asset\n     */\n    function getPoolCollateral(address _collateralAsset) external returns (PoolCollateral memory);\n\n    /**\n     * @notice Get all pool CollateralAssets\n     */\n    function getPoolCollateralAssets() external returns (address[] memory);\n\n    /**\n     * @notice Get the collateral configuration for `_krAsset`\n     * @param _krAsset The collateral asset\n     */\n    function getPoolKrAsset(address _krAsset) external returns (PoolKrAsset memory);\n\n    /**\n     * @notice Get all pool KreskoAssets\n     */\n    function getPoolKrAssets() external returns (address[] memory);\n\n    /**\n     * @notice Get pool collateral value, debt value and resulting CR.\n     * @param _ignoreFactors Ignore factors when calculating collateral and debt value.\n     */\n    function getPoolStats(\n        bool _ignoreFactors\n    ) external returns (uint256 collateralValue, uint256 debtValue, uint256 cr);\n\n    /**\n     * @notice Get the swap fee recipient\n     */\n    function getPoolSwapFeeRecipient() external returns (address);\n\n    /**\n     * @notice Get enabled state of asset\n     */\n    function getPoolAssetIsEnabled(address _asset) external returns (bool);\n\n    /**\n     * @notice Get whether swap is enabled from `_assetIn` to `_assetOut`\n     * @param _assetIn The asset to swap from\n     * @param _assetOut The asset to swap to\n     */\n    function getPoolIsSwapEnabled(address _assetIn, address _assetOut) external view returns (bool);\n}\n"
    },
    "src/contracts/minter/collateral-pool/interfaces/ICollateralPoolSwapFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {Position, NewPosition} from \"../position/state/PositionsStorage.sol\";\n\ninterface ICollateralPoolSwapFacet {\n    event Swap(\n        address indexed who,\n        address indexed assetIn,\n        address indexed assetOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    event SwapFee(address indexed assetIn, uint256 feeAmount, uint256 protocolFeeAmount);\n\n    event Income(address asset, uint256 amount);\n\n    /// @notice Get a price for an asset. It is `extOracleDecimals()` of precision.\n    function getPrice(address _asset) external view returns (uint256 price);\n\n    /**\n     * @notice Preview the amount out received.\n     * @param _assetIn The asset to pay with.\n     * @param _assetOut The asset to receive.\n     * @param _amountIn The amount of _assetIn to pay.\n     * @param _leverage The leverage to use. 1e18 = 1x, 2e18 = 2x, etc.\n     * @return amountOut The amount of `_assetOut` to receive according to `_amountIn`.\n     */\n    function previewSwap(\n        address _assetIn,\n        address _assetOut,\n        uint256 _amountIn,\n        uint256 _leverage\n    ) external view returns (uint256 amountOut, uint256 feeAmount, uint256 protocolFee);\n\n    /**\n     * @notice Swap kresko assets with KISS using the shared collateral pool.\n     * Uses oracle pricing of _amountIn to determine how much _assetOut to send.\n     * @param _account The receiver of amount out.\n     * @param _assetIn The asset to pay with.\n     * @param _assetOut The asset to receive.\n     * @param _amountIn The amount of _assetIn to pay.\n     * @param _amountOutMin The minimum amount of _assetOut to receive, this is due to possible oracle price change.\n     */\n    function swap(\n        address _account,\n        address _assetIn,\n        address _assetOut,\n        uint256 _amountIn,\n        uint256 _amountOutMin\n    ) external;\n\n    /// @notice deposit collateral into a position\n    function positionDepositA(address _to, uint256 _amountA, Position memory _pos) external;\n\n    /// @notice withdraw collateral from a position\n    function positionWithdrawA(address _from, uint256 _amountA, Position memory _pos) external;\n\n    /**\n     * @notice Swap in to leverage. This is only callable by the positions NFT.\n     * @param _sender The account that funds the position.\n     * @param _pos The position to swap into.\n     * @return amountAInAfterFee Amount in after fees are paid.\n     * @return amountBOut Amount of `_assetOut` received.\n     */\n    function swapIntoLeverage(\n        address _sender,\n        NewPosition memory _pos\n    ) external returns (uint256 amountAInAfterFee, uint256 amountBOut);\n\n    /**\n     * @notice Swaps out of leverage. This is only callable by the positions NFT.\n     * @notice Called by the position contract.\n     * @param _pos The position to swap out of.\n     * @param _liquidator The incentive receiver if position is liquidated or closed by external caller.\n     * @return amountAOut The amount of `_assetOut` to receive.\n     */\n    function swapOutOfLeverage(Position memory _pos, address _liquidator) external returns (uint256 amountAOut);\n\n    /**\n     * @notice Accumulates fees to deposits as a fixed, instantaneous income.\n     * @param _incomeAsset the income asset\n     * @param _amount amount to accumulate\n     */\n    function cumulateIncome(address _incomeAsset, uint256 _amount) external;\n}\n"
    },
    "src/contracts/minter/collateral-pool/libs/LibAmounts.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {CollateralPoolState} from \"../CollateralPoolState.sol\";\nimport {ms} from \"../../MinterStorage.sol\";\nimport {WadRay} from \"../../../libs/WadRay.sol\";\n\nlibrary LibAmounts {\n    using WadRay for uint256;\n    using WadRay for uint128;\n    using LibAmounts for CollateralPoolState;\n\n    /**\n     * @notice Get accounts interested scaled debt amount for a KreskoAsset.\n     * @param _asset The asset address\n     * @param _account The account to get the amount for\n     * @return Amount of scaled debt.\n     */\n    function getAccountDepositsWithFees(\n        CollateralPoolState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256) {\n        uint256 deposits = getCollateralAmountRead(_asset, self.deposits[_account][_asset]);\n        if (deposits == 0) {\n            return 0;\n        }\n        return deposits.rayMul(self.poolCollateral[_asset].liquidityIndex).rayToWad();\n    }\n\n    /**\n     * @notice Get accounts principle collateral deposits.\n     * @param _account The account to get the amount for\n     * @param _collateralAsset The collateral asset address\n     * @return Amount of scaled debt.\n     */\n    function getAccountPrincipalDeposits(\n        CollateralPoolState storage self,\n        address _account,\n        address _collateralAsset\n    ) internal view returns (uint256) {\n        uint256 deposits = self.getAccountDepositsWithFees(_account, _collateralAsset);\n        uint256 depositsPrincipal = getCollateralAmountRead(\n            _collateralAsset,\n            self.depositsPrincipal[_account][_collateralAsset]\n        );\n\n        if (deposits == 0) {\n            return 0;\n        } else if (deposits < depositsPrincipal) {\n            return deposits;\n        }\n        return depositsPrincipal;\n    }\n\n    /**\n     * @notice Get pool collateral deposits of an asset.\n     * @param _asset The asset address\n     * @return Amount of scaled debt.\n     */\n    function getPoolDeposits(CollateralPoolState storage self, address _asset) internal view returns (uint256) {\n        return getCollateralAmountRead(_asset, self.totalDeposits[_asset]);\n    }\n\n    /**\n     * @notice Get \"swap\" collateral deposits.\n     * @param _asset The asset address\n     * @return Amount of scaled debt.\n     */\n    function getPoolSwapDeposits(CollateralPoolState storage self, address _asset) internal view returns (uint256) {\n        return getCollateralAmountRead(_asset, self.swapDeposits[_asset]);\n    }\n\n    /**\n     * @notice Get collateral asset amount for saving, it will be unrebased if the asset is a KreskoAsset\n     * @param _asset The asset address\n     * @param _amount The asset amount\n     * @return possiblyUnrebasedAmount The possibly unrebased amount\n     */\n    function getCollateralAmountWrite(\n        address _asset,\n        uint256 _amount\n    ) internal view returns (uint256 possiblyUnrebasedAmount) {\n        return ms().collateralAssets[_asset].toNonRebasingAmount(_amount);\n    }\n\n    /**\n     * @notice Get collateral asset amount for viewing, since if the asset is a KreskoAsset, it can be rebased.\n     * @param _asset The asset address\n     * @param _amount The asset amount\n     * @return possiblyRebasedAmount amount of collateral for `_asset`\n     */\n    function getCollateralAmountRead(\n        address _asset,\n        uint256 _amount\n    ) internal view returns (uint256 possiblyRebasedAmount) {\n        return ms().collateralAssets[_asset].toRebasingAmount(_amount);\n    }\n}\n"
    },
    "src/contracts/minter/collateral-pool/libs/LibCollateralPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {SafeERC20, IERC20Permit} from \"../../../shared/SafeERC20.sol\";\nimport {WadRay} from \"../../../libs/WadRay.sol\";\nimport {LibAmounts} from \"./LibAmounts.sol\";\nimport {cps, CollateralPoolState} from \"../CollateralPoolState.sol\";\nimport {ms} from \"../../MinterStorage.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @author Kresko\n * @title Internal functions for shared collateral pool.\n */\nlibrary LibCollateralPool {\n    using WadRay for uint256;\n    using WadRay for uint128;\n    using LibAmounts for CollateralPoolState;\n    using LibCollateralPool for CollateralPoolState;\n\n    /**\n     * @notice Records a deposit of collateral asset.\n     * @dev Saves principal, scaled and global deposit amounts.\n     * @param _account depositor\n     * @param _collateralAsset the collateral asset\n     * @param _depositAmount amount of collateral asset to deposit\n     */\n    function recordCollateralDeposit(\n        CollateralPoolState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _depositAmount\n    ) internal {\n        require(self.isEnabled[_collateralAsset], \"asset-disabled\");\n        uint256 depositAmount = LibAmounts.getCollateralAmountWrite(_collateralAsset, _depositAmount);\n        unchecked {\n            // Save global deposits.\n            self.totalDeposits[_collateralAsset] += depositAmount;\n            // Save principal deposits.\n            self.depositsPrincipal[_account][_collateralAsset] += depositAmount;\n            // Save scaled deposits.\n            self.deposits[_account][_collateralAsset] += depositAmount.wadToRay().rayDiv(\n                self.poolCollateral[_collateralAsset].liquidityIndex\n            );\n        }\n    }\n\n    /**\n     * @notice Records a withdrawal of collateral asset.\n     * @param self Collateral Pool State\n     * @param _account withdrawer\n     * @param _collateralAsset collateral asset\n     * @param collateralOut The actual amount of collateral withdrawn\n     */\n    function recordCollateralWithdrawal(\n        CollateralPoolState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _amount\n    ) internal returns (uint256 collateralOut, uint256 feesOut) {\n        // Do not check for isEnabled, always allow withdrawals.\n\n        // Get accounts principal deposits.\n        uint256 depositsPrincipal = self.getAccountPrincipalDeposits(_account, _collateralAsset);\n\n        if (depositsPrincipal >= _amount) {\n            // == Principal can cover possibly rebased `_amount` requested.\n            // 1. We send out the requested amount.\n            collateralOut = _amount;\n            // 2. No fees.\n            // 3. Possibly un-rebased amount for internal bookeeping.\n            uint256 withdrawAmountInternal = LibAmounts.getCollateralAmountWrite(_collateralAsset, _amount);\n            unchecked {\n                // 4. Reduce global deposits.\n                self.totalDeposits[_collateralAsset] -= withdrawAmountInternal;\n                // 5. Reduce principal deposits.\n                self.depositsPrincipal[_account][_collateralAsset] -= withdrawAmountInternal;\n                // 6. Reduce scaled deposits.\n                self.deposits[_account][_collateralAsset] -= withdrawAmountInternal.wadToRay().rayDiv(\n                    self.poolCollateral[_collateralAsset].liquidityIndex\n                );\n            }\n        } else {\n            // == Principal can't cover possibly rebased `_amount` requested, send full collateral available.\n            // 1. We send all collateral.\n            collateralOut = depositsPrincipal;\n            // 2. With fees.\n            feesOut = self.getAccountDepositsWithFees(_account, _collateralAsset) - depositsPrincipal;\n            // 3. Ensure this is actually the case.\n            require(feesOut > 0, \"withdrawal-violation\");\n            // 4. Wipe account collateral deposits.\n            self.depositsPrincipal[_account][_collateralAsset] = 0;\n            self.deposits[_account][_collateralAsset] = 0;\n            // 5. Reduce global by ONLY by the principal, fees are not collateral.\n            self.totalDeposits[_collateralAsset] -= LibAmounts.getCollateralAmountWrite(\n                _collateralAsset,\n                depositsPrincipal\n            );\n        }\n    }\n\n    /**\n     * @notice Checks whether the collateral ratio is equal to or above to ratio supplied.\n     * @param self Collateral Pool State\n     * @param _collateralRatio ratio to check\n     */\n    function checkRatio(CollateralPoolState storage self, uint256 _collateralRatio) internal view returns (bool) {\n        return\n            self.getTotalPoolDepositValue(\n                false // dont ignore cFactor\n            ) >= self.getTotalPoolKrAssetValueAtRatio(_collateralRatio, false); // dont ignore kFactors or MCR;\n    }\n\n    /**\n     * @notice Checks whether the collateral ratio is equal to or above to ratio supplied after withdrawal.\n     * @param self Collateral Pool State\n     * @param _collateralAsset collateral asset\n     * @param _withdrawalAmount amount of collateral asset to withdraw\n     * @param _collateralRatio ratio to check\n     */\n    function checkRatio(\n        CollateralPoolState storage self,\n        address _collateralAsset,\n        uint256 _withdrawalAmount,\n        uint256 _collateralRatio\n    ) internal view returns (bool) {\n        // total collateral and withdrawal value\n        (uint256 totalValue, uint256 withdrawalValue) = self.getTotalPoolDepositValue(\n            _collateralAsset,\n            _withdrawalAmount,\n            false // dont ignore cFactor\n        );\n        return totalValue - withdrawalValue >= self.getTotalPoolKrAssetValueAtRatio(_collateralRatio, false); // dont ignore collaterRatio.\n    }\n\n    /**\n     * @notice Checks whether the shared debt pool can be liquidated.\n     * @param self Collateral Pool State\n     */\n    function isLiquidatable(CollateralPoolState storage self) internal view returns (bool) {\n        return !self.checkRatio(self.liquidationThreshold);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             Value Calculations                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Returns the value of the krAsset held in the pool at a ratio.\n     * @param self Collateral Pool State\n     * @param _ratio ratio\n     * @param _ignorekFactor ignore kFactor\n     * @return value in USD\n     */\n    function getTotalPoolKrAssetValueAtRatio(\n        CollateralPoolState storage self,\n        uint256 _ratio,\n        bool _ignorekFactor\n    ) internal view returns (uint256 value) {\n        address[] memory assets = self.krAssets;\n        for (uint256 i; i < assets.length; i++) {\n            address asset = assets[i];\n            value += ms().getKrAssetValue(asset, ms().getKreskoAssetAmount(asset, self.debt[asset]), _ignorekFactor);\n        }\n\n        // We dont need to multiply this.\n        if (_ratio == 1 ether) {\n            return value;\n        }\n\n        return value.wadMul(_ratio);\n    }\n\n    /**\n     * @notice Calculates the total collateral value of collateral assets in the pool.\n     * @param self Collateral Pool State\n     * @param _ignoreFactors whether to ignore factors\n     * @return value in USD\n     */\n    function getTotalPoolDepositValue(\n        CollateralPoolState storage self,\n        bool _ignoreFactors\n    ) internal view returns (uint256 value) {\n        address[] memory assets = self.collaterals;\n        for (uint256 i; i < assets.length; i++) {\n            address asset = assets[i];\n            (uint256 assetValue, ) = ms().getCollateralValueAndOraclePrice(\n                asset,\n                self.getPoolDeposits(asset),\n                _ignoreFactors\n            );\n            value += assetValue;\n        }\n    }\n\n    /**\n     * @notice Returns the value of the collateral asset in the pool and the value of the amount.\n     * Saves gas for getting the values in the same execution.\n     * @param _collateralAsset collateral asset\n     * @param _amount amount of collateral asset\n     * @param _ignoreFactors whether to ignore cFactor and kFactor\n     */\n    function getTotalPoolDepositValue(\n        CollateralPoolState storage self,\n        address _collateralAsset,\n        uint256 _amount,\n        bool _ignoreFactors\n    ) internal view returns (uint256 totalValue, uint256 amountValue) {\n        address[] memory assets = self.collaterals;\n        for (uint256 i; i < assets.length; i++) {\n            address asset = assets[i];\n            (uint256 assetValue, uint256 price) = ms().getCollateralValueAndOraclePrice(\n                asset,\n                self.getPoolDeposits(asset),\n                _ignoreFactors\n            );\n\n            totalValue += assetValue;\n            if (asset == _collateralAsset) {\n                amountValue = _amount.wadMul(\n                    _ignoreFactors ? price : price.wadMul(ms().collateralAssets[asset].factor)\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the value of the collateral assets in the pool for `_account`.\n     * @param _account account\n     * @param _ignoreFactors whether to ignore cFactor and kFactor\n     */\n    function getAccountTotalDepositValuePrincipal(\n        CollateralPoolState storage self,\n        address _account,\n        bool _ignoreFactors\n    ) internal view returns (uint256 totalValue) {\n        address[] memory assets = self.collaterals;\n        for (uint256 i; i < assets.length; i++) {\n            address asset = assets[i];\n            (uint256 assetValue, ) = ms().getCollateralValueAndOraclePrice(\n                asset,\n                self.getAccountPrincipalDeposits(_account, asset),\n                _ignoreFactors\n            );\n\n            totalValue += assetValue;\n        }\n    }\n\n    /**\n     * @notice Returns the value of the collateral assets in the pool for `_account` with fees.\n     * @notice Ignores all factors.\n     * @param _account account\n     */\n    function getAccountTotalDepositValueWithFees(\n        CollateralPoolState storage self,\n        address _account\n    ) internal view returns (uint256 totalValue) {\n        address[] memory assets = self.collaterals;\n        for (uint256 i; i < assets.length; i++) {\n            address asset = assets[i];\n            (uint256 assetValue, ) = ms().getCollateralValueAndOraclePrice(\n                asset,\n                self.getAccountDepositsWithFees(_account, asset),\n                true\n            );\n\n            totalValue += assetValue;\n        }\n    }\n\n    /// @notice This function seizes collateral from the shared pool\n    /// @notice Adjusts everyones deposits if swap deposits do not cover the amount.\n    function adjustSeizedCollateral(\n        CollateralPoolState storage self,\n        address _seizeAsset,\n        uint256 _seizeAmount\n    ) internal {\n        uint256 swapDeposits = self.getPoolSwapDeposits(_seizeAsset); // current \"swap\" collateral\n\n        if (swapDeposits >= _seizeAmount) {\n            uint256 amountOutInternal = LibAmounts.getCollateralAmountWrite(_seizeAsset, _seizeAmount);\n            // swap deposits cover the amount\n            self.swapDeposits[_seizeAsset] -= amountOutInternal;\n            self.totalDeposits[_seizeAsset] -= amountOutInternal;\n        } else {\n            // swap deposits do not cover the amount\n            uint256 amountToCover = _seizeAmount - swapDeposits;\n            self.swapDeposits[_seizeAsset] = 0;\n\n            // reduce everyones deposits by the same ratio\n            self.poolCollateral[_seizeAsset].liquidityIndex -= uint128(\n                amountToCover.wadToRay().rayDiv(self.getPoolDeposits(_seizeAsset).wadToRay())\n            );\n\n            self.totalDeposits[_seizeAsset] -= LibAmounts.getCollateralAmountWrite(_seizeAsset, amountToCover);\n        }\n    }\n\n    // /**\n    //  * @notice Returns the krAsset value of a single asset in the pool.\n    //  * Performs possible rebasing conversions for the pool balance.\n    //  * @param self Collateral Pool State\n    //  * @param _kreskoAsset krAsset\n    //  * @param _ignorekFactor whether to ignore the k factor\n    //  * @return value The krAsset value in USD\n    //  */\n    // function getPoolKrAssetValue(\n    //     CollateralPoolState storage self,\n    //     address _kreskoAsset,\n    //     bool _ignorekFactor\n    // ) internal view returns (uint256 value) {\n\n    // }\n\n    // /**\n    //  * @notice Get the current price rate between AMM and oracle pricing\n    //  * @dev Raw return value of ammPrice == 0 when no AMM pair exists OR liquidity of the pair does not qualify\n    //  * @param self rate configuration for the asset\n    //  * @return priceRate the current price rate\n    //  */\n    // function getPriceRate(StabilityRateConfig storage self) internal view returns (uint256 priceRate) {\n    //     FixedPoint.Unsigned memory oraclePrice = ms().getKrAssetValue(self.asset, 1 ether, true);\n    //     FixedPoint.Unsigned memory ammPrice = ms().getKrAssetAMMPrice(self.asset, 1 ether);\n    //     // no pair, no effect\n    //     if (ammPrice.rawValue == 0) {\n    //         return 0;\n    //     }\n    //     return ammPrice.div(oraclePrice).div(10).rawValue;\n    // }\n}\n"
    },
    "src/contracts/minter/collateral-pool/libs/LibSwap.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {SafeERC20, IERC20Permit} from \"../../../shared/SafeERC20.sol\";\n\nimport {WadRay} from \"../../../libs/WadRay.sol\";\nimport {Error} from \"../../../libs/Errors.sol\";\n\nimport {LibAmounts} from \"./LibAmounts.sol\";\nimport {cps, CollateralPoolState, PoolKrAsset} from \"../CollateralPoolState.sol\";\nimport {ms} from \"../../MinterStorage.sol\";\nimport {irs} from \"../../InterestRateState.sol\";\nimport \"hardhat/console.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @author Kresko\n * @title Internal functions for shared collateral pool.\n */\nlibrary LibSwap {\n    using WadRay for uint256;\n    using WadRay for uint128;\n    using SafeERC20 for IERC20Permit;\n\n    /**\n     * @notice Check that assets can be swapped.\n     * @return feePercentage fee percentage for this swap\n     */\n    function checkAssets(\n        CollateralPoolState storage self,\n        address _assetIn,\n        address _assetOut\n    ) internal view returns (uint256 feePercentage, uint256 protocolFee) {\n        require(self.isSwapEnabled[_assetIn][_assetOut], \"swap-disabled\");\n        require(self.isEnabled[_assetIn], \"asset-in-disabled\");\n        require(self.isEnabled[_assetOut], \"asset-out-disabled\");\n        require(_assetIn != _assetOut, \"same-asset\");\n        PoolKrAsset memory assetIn = self.poolKrAsset[_assetIn];\n        PoolKrAsset memory assetOut = self.poolKrAsset[_assetOut];\n\n        feePercentage = assetOut.openFee + assetIn.closeFee;\n        protocolFee = assetIn.protocolFee + assetOut.protocolFee;\n    }\n\n    /**\n     * @notice Records the assets received from account in a swap.\n     * Burning any existing shared debt or increasing collateral deposits.\n     * @param _assetIn The asset received.\n     * @param _amountIn The amount of the asset received.\n     * @param _assetsFrom The account that holds the assets to burn.\n     * @return valueIn The value of the assets received into the protocol, used to calculate assets out.\n     */\n    function handleAssetsIn(\n        CollateralPoolState storage self,\n        address _assetIn,\n        uint256 _amountIn,\n        address _assetsFrom\n    ) internal returns (uint256 valueIn) {\n        uint256 debt = ms().getKreskoAssetAmount(_assetIn, self.debt[_assetIn]);\n        valueIn = ms().getKrAssetValue(_assetIn, _amountIn, true); // ignore kFactor here\n\n        uint256 collateralIn; // assets used increase \"swap\" owned collateral\n        uint256 debtOut; // assets used to burn debt\n\n        // Bookkeeping\n        if (debt >= _amountIn) {\n            // == Debt is equal to or greater than the amount.\n            // 1. Burn full amount received.\n            debtOut = _amountIn;\n            // 2. No increase in collateral.\n        } else if (debt < _amountIn) {\n            // == Debt is less than the amount received.\n            // 1. Burn full debt.\n            debtOut = debt;\n            // 2. Increase collateral by remainder.\n            collateralIn = _amountIn - debt;\n        } else {\n            // == Debt is 0.\n            // 1. Burn nothing.\n            // 2. Increase collateral by full amount.\n            collateralIn = _amountIn;\n        }\n\n        if (collateralIn > 0) {\n            uint256 collateralInInternal = LibAmounts.getCollateralAmountWrite(_assetIn, collateralIn);\n            // 1. Increase collateral deposits.\n            self.totalDeposits[_assetIn] += collateralInInternal;\n            // 2. Increase \"swap\" collateral.\n            self.swapDeposits[_assetIn] += collateralInInternal;\n        }\n\n        if (debtOut > 0) {\n            // 1. Burn debt that was repaid from the assets received.\n            self.debt[_assetIn] -= ms().repaySwap(_assetIn, debtOut, _assetsFrom);\n        }\n\n        require(_amountIn == debtOut + collateralIn, \"assets-in-mismatch\");\n    }\n\n    /**\n     * @notice Records the assets to send out in a swap.\n     * Increasing debt of the pool by minting new assets when required.\n     * @param _assetOut The asset to send out.\n     * @param _valueIn The value received in.\n     * @param _assetsTo The asset receiver.\n     * @return amountOut The amount of the asset out.\n     */\n    function handleAssetsOut(\n        CollateralPoolState storage self,\n        address _assetOut,\n        uint256 _valueIn,\n        address _assetsTo\n    ) internal returns (uint256 amountOut) {\n        // Calculate amount to send out from value received in.\n        amountOut = _valueIn.wadDiv(ms().kreskoAssets[_assetOut].uintPrice());\n        // Well, should be more than 0.\n        require(amountOut > 0, \"amount-out-is-zero\");\n\n        uint256 swapDeposits = self.getPoolSwapDeposits(_assetOut); // current \"swap\" collateral\n\n        uint256 collateralOut; // decrease in \"swap\" collateral\n        uint256 debtIn; // new debt required to mint\n\n        // Bookkeeping\n        if (swapDeposits == 0) {\n            // == No \"swap\" owned collateral available.\n            // 1. Issue full amount as debt.\n            debtIn = amountOut;\n            // 2. No decrease in collateral.\n        } else if (swapDeposits >= amountOut) {\n            // == \"Swap\" owned collateral exceeds requested amount\n            // 1. No debt issued.\n            // 2. Decrease collateral by full amount.\n            collateralOut = amountOut;\n        } else {\n            // == \"Swap\" owned collateral is less than requested amount.\n            // 1. Issue debt for remainder.\n            debtIn = amountOut - swapDeposits;\n            // 2. Reduce \"swap\" owned collateral to zero.\n            collateralOut = swapDeposits;\n        }\n        if (collateralOut > 0) {\n            uint256 amountOutInternal = LibAmounts.getCollateralAmountWrite(_assetOut, collateralOut);\n            // 1. Decrease collateral deposits.\n            self.totalDeposits[_assetOut] -= amountOutInternal;\n            // 2. Decrease \"swap\" owned collateral.\n            self.swapDeposits[_assetOut] -= amountOutInternal;\n            if (_assetsTo != address(this)) {\n                // 3. Transfer collateral to receiver if it is not this contract.\n                IERC20Permit(_assetOut).safeTransfer(_assetsTo, collateralOut);\n            }\n        }\n\n        if (debtIn > 0) {\n            // 1. Issue required debt to the pool, minting new assets to receiver.\n            self.debt[_assetOut] += ms().mintSwap(_assetOut, debtIn, _assetsTo);\n        }\n\n        require(amountOut == debtIn + collateralOut, \"amount-out-mismatch\");\n    }\n\n    function handleProfitsOut(\n        CollateralPoolState storage self,\n        address _assetOut,\n        uint256 _balanceOut,\n        uint256 _profitsOut,\n        address _assetsTo\n    ) internal returns (uint256 transferOut) {\n        // Well, should be more than 0.\n        require(_profitsOut > 0, \"amount-out-is-zero\");\n        require(_assetsTo != address(this), \"profit-to-this\");\n\n        uint256 swapDeposits = self.getPoolSwapDeposits(_assetOut); // current \"swap\" collateral\n\n        uint256 collateralOut; // decrease in \"swap\" collateral\n        uint256 debtIn; // new debt required to mint\n\n        // Bookkeeping\n        if (swapDeposits == 0) {\n            // == No \"swap\" owned collateral available.\n            // 1. Issue full amount as debt.\n            debtIn = _profitsOut;\n            // 2. No decrease in collateral.\n        } else if (swapDeposits >= _profitsOut) {\n            // == \"Swap\" owned collateral exceeds requested amount\n            // 1. No debt issued.\n            // 2. Decrease collateral by full amount.\n            collateralOut = _profitsOut;\n        } else {\n            // == \"Swap\" owned collateral is less than requested amount.\n            // 1. Issue debt for remainder.\n            debtIn = _profitsOut - swapDeposits;\n            // 2. Reduce \"swap\" owned collateral to zero.\n            collateralOut = swapDeposits;\n        }\n        if (collateralOut > 0) {\n            uint256 amountOutInternal = LibAmounts.getCollateralAmountWrite(_assetOut, collateralOut);\n            // 1. Decrease collateral deposits.\n            self.totalDeposits[_assetOut] -= amountOutInternal;\n            // 2. Decrease \"swap\" owned collateral.\n            self.swapDeposits[_assetOut] -= amountOutInternal;\n        }\n        if (debtIn > 0) {\n            // 1. Issue required debt to the pool, minting new assets to receiver.\n            self.debt[_assetOut] += ms().mintSwap(_assetOut, debtIn, _assetsTo);\n        }\n\n        require(_profitsOut == debtIn + collateralOut, \"profit-out-mismatch\");\n        transferOut = collateralOut > 0 ? _balanceOut + collateralOut : _balanceOut;\n    }\n\n    /**\n     * @notice Accumulates fees to deposits as a fixed, instantaneous income.\n     * @param _collateralAsset asset\n     * @param _amount amount to accumulate\n     * @return nextLiquidityIndex The next liquidity index of the reserve\n     */\n    function cumulateIncome(\n        CollateralPoolState storage self,\n        address _collateralAsset,\n        uint256 _amount\n    ) internal returns (uint256 nextLiquidityIndex) {\n        //next liquidity index is calculated this way: `((amount / totalLiquidity) + 1) * liquidityIndex`\n        //division `amount / totalLiquidity` done in ray for precision\n        uint256 result = (_amount.wadToRay().rayDiv(self.getPoolDeposits(_collateralAsset).wadToRay()) + WadRay.RAY)\n            .rayMul(self.poolCollateral[_collateralAsset].liquidityIndex);\n        self.poolCollateral[_collateralAsset].liquidityIndex = uint128(result);\n        return result;\n    }\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/facets/ERC721Facet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity <=0.8.19;\n\nimport {ERC721} from \"../state/ERC721Storage.sol\";\nimport {IERC721Permit} from \"../interfaces/IERC721Permit.sol\";\nimport {IERC1271} from \"../interfaces/IERC1271.sol\";\nimport {pos} from \"../state/PositionsStorage.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\ncontract ERC721Facet is IERC721Permit {\n    using AddressUpgradeable for address;\n    /// @dev The hash of the name used in the permit signature verification\n    bytes32 private immutable nameHash;\n\n    /// @dev The hash of the version string used in the permit signature verification\n    bytes32 private immutable versionHash;\n\n    constructor() {\n        nameHash = keccak256(\"Kresko Positions\");\n        versionHash = keccak256(\"1\");\n    }\n\n    /// @inheritdoc IERC721Permit\n    /// @dev Value is equal to keccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant override PERMIT_TYPEHASH =\n        0x49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad;\n\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n                    0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                    nameHash,\n                    versionHash,\n                    getChainId(),\n                    address(this)\n                )\n            );\n    }\n\n    function permit(\n        address spender,\n        uint256 tokenId,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable override {\n        require(_blockTimestamp() <= deadline, \"Permit expired\");\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR(),\n                keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, pos().getAndIncrementNonce(tokenId), deadline))\n            )\n        );\n        address owner = ERC721().ownerOf(tokenId);\n        require(spender != owner, \"ERC721Permit: approval to current owner\");\n\n        if (AddressUpgradeable.isContract(owner)) {\n            require(IERC1271(owner).isValidSignature(digest, abi.encodePacked(r, s, v)) == 0x1626ba7e, \"Unauthorized\");\n        } else {\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(recoveredAddress != address(0), \"Invalid signature\");\n            require(recoveredAddress == owner, \"Unauthorized\");\n        }\n\n        ERC721().approve(spender, tokenId);\n    }\n\n    function name() external view returns (string memory) {\n        return ERC721().name;\n    }\n\n    function symbol() external view returns (string memory) {\n        return ERC721().symbol;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return ERC721().balances[_owner];\n    }\n\n    function ownerOf(uint256 _tokenId) external view returns (address) {\n        return ERC721().owners[_tokenId];\n    }\n\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\n        ERC721().safeTransferFrom(_from, _to, _tokenId);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _tokenId) external {\n        //solhint-disable-next-line max-line-length\n        require(ERC721().isApprovedOrOwner(msg.sender, _tokenId), \"ERC721: caller is not token owner or approved\");\n\n        ERC721().transfer(_from, _to, _tokenId);\n    }\n\n    function approve(address _approved, uint256 _tokenId) public {\n        ERC721().approve(_approved, _tokenId);\n    }\n\n    function getApproved(uint256 _tokenId) external view returns (address operator) {\n        return ERC721().getApproved(_tokenId);\n    }\n\n    function setApprovalForAll(address _operator, bool _approved) external {\n        ERC721().setApprovalForAll(_operator, _approved);\n    }\n\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n        return ERC721().isApprovedForAll(_owner, _operator);\n    }\n\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) external {\n        ERC721().safeTransferFrom(_from, _to, _tokenId, _data);\n    }\n\n    function _blockTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    function getChainId() internal view returns (uint256 chainId) {\n        assembly {\n            chainId := chainid()\n        }\n    }\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/facets/LayerZeroFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity <=0.8.19;\n\nimport {ERC721} from \"../state/ERC721Storage.sol\";\nimport {IONFT721CoreUpgradeable} from \"../interfaces/IONFT721CoreUpgradeable.sol\";\nimport {IONFT721Upgradeable} from \"../interfaces/IONFT721Upgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC721MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {ILayerZeroEndpointUpgradeable} from \"../interfaces/ILayerZeroEndpointUpgradeable.sol\";\nimport {ILayerZeroReceiverUpgradeable} from \"../interfaces/ILayerZeroReceiverUpgradeable.sol\";\nimport {ILayerZeroUserApplicationConfigUpgradeable} from \"../interfaces/ILayerZeroUserApplicationConfigUpgradeable.sol\";\nimport {lz, LibLZ, StoredCredit} from \"../state/LZStorage.sol\";\nimport {Meta} from \"../../../../libs/Meta.sol\";\nimport {ds} from \"../../../../diamond/DiamondStorage.sol\";\nimport {IERC165Facet} from \"../../../../diamond/interfaces/IERC165Facet.sol\";\nimport {BytesLib} from \"../libs/BytesLib.sol\";\nimport {ExcessivelySafeCall} from \"../libs/ExcessivelySafeCall.sol\";\nimport {DiamondModifiers} from \"../../../../diamond/DiamondModifiers.sol\";\n\ncontract LayerZeroFacet is\n    IERC165Facet,\n    IONFT721CoreUpgradeable,\n    ILayerZeroReceiverUpgradeable,\n    ILayerZeroUserApplicationConfigUpgradeable,\n    DiamondModifiers\n{\n    using BytesLib for bytes;\n    using ExcessivelySafeCall for address;\n\n    function setupLayerZero(uint256 _minGasToTransfer, ILayerZeroEndpointUpgradeable _lzEndpoint) external onlyOwner {\n        require(_minGasToTransfer != 0, LibLZ.MINGASZERO);\n        lz().minGasToTransferAndStore = _minGasToTransfer;\n\n        require(address(_lzEndpoint) != address(0), LibLZ.INVALID_ENDPOINT);\n        lz().lzEndpoint = _lzEndpoint;\n    }\n\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address,\n        uint _configType\n    ) external view returns (bytes memory) {\n        return lz().lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint _configType,\n        bytes calldata _config\n    ) external override onlyOwner {\n        lz().lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    /// @inheritdoc IERC165Facet\n    function supportsInterface(\n        bytes4 interfaceId\n    ) external view override(IERC165Facet, IERC165Upgradeable) returns (bool) {\n        return\n            (interfaceId != 0xffffffff && interfaceId == type(IERC721Upgradeable).interfaceId) ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            interfaceId == type(IONFT721Upgradeable).interfaceId ||\n            interfaceId == type(IONFT721CoreUpgradeable).interfaceId ||\n            ds().supportedInterfaces[interfaceId];\n    }\n\n    /// @inheritdoc IERC165Facet\n    function setERC165(bytes4[] calldata interfaceIds, bytes4[] calldata interfaceIdsToRemove) external onlyOwner {\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            ds().supportedInterfaces[interfaceIds[i]] = true;\n        }\n\n        for (uint256 i = 0; i < interfaceIdsToRemove.length; i++) {\n            ds().supportedInterfaces[interfaceIdsToRemove[i]] = false;\n        }\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lz().lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lz().lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lz().lzEndpoint.setReceiveVersion(_version);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _srcChainId, bytes calldata _path) external onlyOwner {\n        lz().trustedRemoteLookup[_srcChainId] = _path;\n        emit LibLZ.SetTrustedRemote(_srcChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        lz().trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit LibLZ.SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = lz().trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, \"LzApp: no trusted path record\");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        lz().precrime = _precrime;\n        emit LibLZ.SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, \"LzApp: invalid minGas\");\n        lz().minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit LibLZ.SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        lz().payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = lz().trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n\n    function setMinGasToTransferAndStore(uint256 _minGasToTransferAndStore) external onlyOwner {\n        require(_minGasToTransferAndStore > 0, LibLZ.MIN_GAS_NOT_ZERO);\n        lz().minGasToTransferAndStore = _minGasToTransferAndStore;\n    }\n\n    // ensures enough gas in adapter params to handle batch transfer gas amounts on the dst\n    function setDstChainIdToTransferGas(uint16 _dstChainId, uint256 _dstChainIdToTransferGas) external onlyOwner {\n        require(_dstChainIdToTransferGas > 0, LibLZ.MIN_GAS_NOT_ZERO);\n        lz().dstChainIdToTransferGas[_dstChainId] = _dstChainIdToTransferGas;\n    }\n\n    // limit on src the amount of tokens to batch send\n    function setDstChainIdToBatchLimit(uint16 _dstChainId, uint256 _dstChainIdToBatchLimit) external onlyOwner {\n        require(_dstChainIdToBatchLimit > 0, LibLZ.MIN_GAS_NOT_ZERO);\n        lz().dstChainIdToBatchLimit[_dstChainId] = _dstChainIdToBatchLimit;\n    }\n\n    function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint _tokenId,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) external payable virtual override {\n        require(_from == ds().contractOwner, \"not supported yet\");\n        lz().send(\n            _from,\n            _dstChainId,\n            _toAddress,\n            _toSingletonArray(_tokenId),\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    function sendBatchFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint[] memory _tokenIds,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) external payable virtual override {\n        require(_from == ds().contractOwner, \"not supported yet\");\n        lz().send(_from, _dstChainId, _toAddress, _tokenIds, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    // Public function for anyone to clear and deliver the remaining batch sent tokenIds\n    function clearCredits(bytes memory _payload) external {\n        require(msg.sender == ds().contractOwner, \"not supported yet\");\n        bytes32 hashedPayload = keccak256(_payload);\n        require(lz().storedCredits[hashedPayload].creditsRemain, LibLZ.NO_CREDITS_STORED);\n\n        (, uint[] memory tokenIds) = abi.decode(_payload, (bytes, uint[]));\n\n        uint nextIndex = lz().creditTill(\n            lz().storedCredits[hashedPayload].srcChainId,\n            lz().storedCredits[hashedPayload].toAddress,\n            lz().storedCredits[hashedPayload].index,\n            tokenIds\n        );\n        require(nextIndex > lz().storedCredits[hashedPayload].index, LibLZ.NO_GAS_REMAINING);\n\n        if (nextIndex == tokenIds.length) {\n            // cleared the credits, delete the element\n            delete lz().storedCredits[hashedPayload];\n            emit CreditCleared(hashedPayload);\n        } else {\n            // store the next index to mint\n            lz().storedCredits[hashedPayload] = StoredCredit(\n                lz().storedCredits[hashedPayload].srcChainId,\n                lz().storedCredits[hashedPayload].toAddress,\n                nextIndex,\n                true\n            );\n        }\n    }\n\n    function estimateSendFee(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint _tokenId,\n        bool _useZro,\n        bytes memory _adapterParams\n    ) public view virtual override returns (uint nativeFee, uint zroFee) {\n        return lz().estimateFees(_dstChainId, _toAddress, _toSingletonArray(_tokenId), _useZro, _adapterParams);\n    }\n\n    function estimateSendBatchFee(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint[] memory _tokenIds,\n        bool _useZro,\n        bytes memory _adapterParams\n    ) public view virtual override returns (uint nativeFee, uint zroFee) {\n        return lz().estimateFees(_dstChainId, _toAddress, _tokenIds, _useZro, _adapterParams);\n    }\n\n    function _toSingletonArray(uint element) internal pure returns (uint[] memory) {\n        uint[] memory array = new uint[](1);\n        array[0] = element;\n        return array;\n    }\n\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(Meta.msgSender() == address(lz().lzEndpoint), \"LzApp: invalid endpoint caller\");\n\n        bytes memory trustedRemote = lz().trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(\n            _srcAddress.length == trustedRemote.length &&\n                trustedRemote.length > 0 &&\n                keccak256(_srcAddress) == keccak256(trustedRemote),\n            \"LzApp: invalid source sending contract\"\n        );\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // overriding the virtual function in LzReceiver\n    function _blockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal {\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(\n            gasleft(),\n            150,\n            abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload)\n        );\n        // try-catch all errors/exceptions\n        if (!success) {\n            lz().failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n            emit LibLZ.MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) external {\n        // only internal transaction\n        require(Meta.msgSender() == address(this), \"NonblockingLzApp: caller must be LzApp\");\n        lz().nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    function retryMessage(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) external payable virtual {\n        // assert there is message to retry\n        bytes32 payloadHash = lz().failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), \"NonblockingLzApp: no stored message\");\n        require(keccak256(_payload) == payloadHash, \"NonblockingLzApp: invalid payload\");\n        // clear the stored message\n        lz().failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        lz().nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n        emit LibLZ.RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\n    }\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/facets/PositionsConfigFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity <=0.8.19;\n\nimport {ds} from \"../../../../diamond/DiamondStorage.sol\";\nimport {DiamondModifiers} from \"../../../../diamond/DiamondModifiers.sol\";\nimport {Error} from \"../../../../libs/Errors.sol\";\nimport {lz} from \"../state/LZStorage.sol\";\nimport {ERC721} from \"../state/ERC721Storage.sol\";\nimport {pos, LibPositions, PositionsInitializer} from \"../state/PositionsStorage.sol\";\nimport {ICollateralPoolSwapFacet} from \"../../interfaces/ICollateralPoolSwapFacet.sol\";\n\ncontract PositionsConfigFacet is DiamondModifiers {\n    function initialize(PositionsInitializer memory _init) external {\n        ds().contractOwner = msg.sender;\n        require(ds().storageVersion == 1, Error.ALREADY_INITIALIZED);\n        // check erc721\n        require(bytes(_init.name).length > 0 && bytes(_init.symbol).length > 0, LibPositions.INVALID_NAME);\n        ERC721().name = _init.name;\n        ERC721().symbol = _init.symbol;\n        // check liq threshold\n        require(_init.liquidationThreshold > -1e18, LibPositions.INVALID_LT);\n        require(_init.liquidationThreshold < 0.001e18, LibPositions.INVALID_LT);\n        pos().liquidationThreshold = _init.liquidationThreshold;\n        // check close threshold\n        require(_init.closeThreshold <= 100e18, LibPositions.INVALID_LT); // 10,000% profit\n        require(_init.closeThreshold >= 0.001e18, LibPositions.INVALID_LT); // 1% profit\n        pos().closeThreshold = _init.closeThreshold;\n        // check min/max lev\n        require(_init.maxLeverage <= 500e18, LibPositions.INVALID_MAX_LEVERAGE);\n        require(_init.maxLeverage >= 1e18, LibPositions.INVALID_MAX_LEVERAGE);\n        require(_init.minLeverage >= 0.01e18, LibPositions.INVALID_MAX_LEVERAGE);\n        require(_init.minLeverage < _init.maxLeverage, LibPositions.INVALID_MAX_LEVERAGE);\n        pos().minLeverage = _init.minLeverage;\n        pos().maxLeverage = _init.maxLeverage;\n        // check kresko\n        require(address(_init.kresko) != address(0), LibPositions.INVALID_KRESKO);\n        pos().kresko = _init.kresko;\n        ds().storageVersion = 1;\n    }\n\n    function getPositionsConfig() external view returns (PositionsInitializer memory) {\n        return\n            PositionsInitializer({\n                kresko: pos().kresko,\n                name: ERC721().name,\n                symbol: ERC721().symbol,\n                liquidationThreshold: pos().liquidationThreshold,\n                closeThreshold: pos().closeThreshold,\n                maxLeverage: pos().maxLeverage,\n                minLeverage: pos().minLeverage\n            });\n    }\n\n    function setLiquidationThreshold(int128 _threshold) external onlyOwner {\n        require(_threshold <= 1e18, LibPositions.INVALID_LT);\n        require(_threshold >= 0.1e18, LibPositions.INVALID_LT);\n\n        pos().liquidationThreshold = _threshold;\n    }\n\n    function setCloseThreshold(int128 _threshold) external onlyOwner {\n        require(_threshold <= 1e18, LibPositions.INVALID_LT);\n        require(_threshold >= 0.01e18, LibPositions.INVALID_LT);\n\n        pos().closeThreshold = _threshold;\n    }\n\n    function setMaxLeverage(uint256 _maxLeverage) external onlyOwner {\n        require(_maxLeverage <= 500e18, LibPositions.INVALID_MAX_LEVERAGE);\n        require(_maxLeverage >= 1e18, LibPositions.INVALID_MAX_LEVERAGE);\n\n        pos().maxLeverage = _maxLeverage;\n    }\n\n    function setMinLeverage(uint256 _minLeverage) external onlyOwner {\n        require(_minLeverage >= 0.01e18, LibPositions.INVALID_MAX_LEVERAGE);\n\n        pos().minLeverage = _minLeverage;\n    }\n\n    function setKresko(ICollateralPoolSwapFacet _kresko) external onlyOwner {\n        require(address(_kresko) != address(0), LibPositions.INVALID_KRESKO);\n\n        pos().kresko = _kresko;\n    }\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/facets/PositionsFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity <=0.8.19;\nimport {ds} from \"../../../../diamond/DiamondStorage.sol\";\nimport {DiamondModifiers} from \"../../../../diamond/DiamondModifiers.sol\";\nimport {WadRay} from \"../../../../libs/WadRay.sol\";\nimport {ERC721} from \"../state/ERC721Storage.sol\";\nimport {pos, LibPositions, NewPosition, Position} from \"../state/PositionsStorage.sol\";\nimport {IPositionsFacet} from \"../interfaces/IPositionsFacet.sol\";\nimport {IERC20Permit} from \"../../../../shared/IERC20Permit.sol\";\n\ncontract PositionsFacet is IPositionsFacet, DiamondModifiers {\n    using WadRay for uint256;\n    modifier check(uint256 _id) {\n        address owner = ERC721().ownerOf(_id);\n        require(\n            msg.sender == owner || ERC721().isApprovedForAll(owner, msg.sender),\n            LibPositions.ERROR_POSITION_NOT_OWNED_BY_CALLER\n        );\n        _;\n    }\n\n    /// @inheritdoc IPositionsFacet\n    function createPosition(NewPosition memory _position) external returns (uint256 positionId) {\n        (uint256 amountAFeeReduced, uint256 amountBOut) = pos().kresko.swapIntoLeverage(msg.sender, _position);\n        positionId = ERC721().currentId++;\n\n        pos().positions[positionId] = Position({\n            account: _position.account,\n            assetA: _position.assetA,\n            assetB: _position.assetB,\n            amountA: amountAFeeReduced,\n            amountB: amountBOut,\n            leverage: _position.leverage,\n            valueBCache: pos().kresko.getPrice(_position.assetB).wadMul(amountBOut),\n            liquidationIncentive: 0.05 ether,\n            closeIncentive: 0.01 ether,\n            creationTimestamp: block.timestamp,\n            lastUpdateTimestamp: block.timestamp,\n            nonce: 0\n        });\n\n        ERC721().safeMint(_position.account, positionId, \"\");\n    }\n\n    /// @inheritdoc IPositionsFacet\n    function closePosition(uint256 _id) external {\n        // check ownership\n        address owner = ERC721().ownerOf(_id);\n        if (msg.sender != owner) {\n            // allow closing and liquidations from external accounts\n\n            if (pos().isLiquidatable(_id) || pos().isCloseable(_id)) {\n                pos().kresko.swapOutOfLeverage(pos().positions[_id], msg.sender);\n                ERC721().burn(_id);\n                return;\n            }\n            require(\n                msg.sender == owner || ERC721().isApprovedForAll(owner, msg.sender),\n                LibPositions.ERROR_POSITION_NOT_OWNED_BY_CALLER\n            );\n        }\n\n        pos().kresko.swapOutOfLeverage(pos().positions[_id], address(0));\n        ERC721().burn(_id);\n    }\n\n    /// @inheritdoc IPositionsFacet\n    function buy(uint256 _id, uint256 _amountA, uint256 _amountBMin) external override check(_id) {\n        (uint256 amountAAfterFee, uint256 amountBOut) = pos().kresko.swapIntoLeverage(\n            msg.sender,\n            NewPosition({\n                account: pos().positions[_id].account,\n                assetA: pos().positions[_id].assetA,\n                assetB: pos().positions[_id].assetB,\n                leverage: pos().positions[_id].leverage,\n                amountA: _amountA,\n                amountBMin: _amountBMin\n            })\n        );\n\n        pos().positions[_id].amountA += amountAAfterFee;\n        pos().positions[_id].amountB += amountBOut;\n        pos().positions[_id].valueBCache += pos().kresko.getPrice(pos().positions[_id].assetB).wadMul(amountBOut);\n        pos().positions[_id].lastUpdateTimestamp = block.timestamp;\n    }\n\n    /// @inheritdoc IPositionsFacet\n    function deposit(uint256 _id, uint256 _amountA) external override {\n        require(ERC721().exists(_id), \"!exists\");\n        uint256 change = _amountA.wadDiv(pos().positions[_id].amountA);\n        pos().kresko.positionDepositA(msg.sender, _amountA, pos().positions[_id]);\n\n        pos().positions[_id].amountA += _amountA;\n        pos().positions[_id].lastUpdateTimestamp = block.timestamp;\n        pos().positions[_id].leverage = pos().getLeverage(_id);\n\n        require(pos().positions[_id].leverage - change >= 1 ether, \"!leverage-too-low\");\n    }\n\n    /// @inheritdoc IPositionsFacet\n    function withdraw(uint256 _id, uint256 _amountA) external override check(_id) {\n        pos().kresko.positionWithdrawA(pos().positions[_id].account, _amountA, pos().positions[_id]);\n\n        int256 change = int256(_amountA.wadDiv(pos().positions[_id].amountA));\n        require(pos().getRatio(_id) - change >= pos().liquidationThreshold, \"!leverage-too-high\");\n\n        pos().positions[_id].amountA -= _amountA;\n        pos().positions[_id].lastUpdateTimestamp = block.timestamp;\n        pos().positions[_id].leverage = pos().getLeverage(_id);\n    }\n\n    /// @inheritdoc IPositionsFacet\n    function buyback(uint256 _id, uint256 _amountB) external override check(_id) {\n        if (_amountB >= pos().positions[_id].amountB) {\n            _amountB = pos().positions[_id].amountB;\n            ERC721().burn(_id);\n        }\n\n        uint256 change = _amountB.wadDiv(pos().positions[_id].amountB);\n        Position memory temp = pos().positions[_id];\n        temp.amountB = temp.amountB.wadMul(change);\n        temp.amountA = temp.amountA.wadMul(change);\n\n        pos().kresko.swapOutOfLeverage(temp, address(0));\n\n        pos().positions[_id].amountA -= temp.amountA;\n        pos().positions[_id].amountB -= temp.amountB;\n        pos().positions[_id].valueBCache -= pos().kresko.getPrice(pos().positions[_id].assetB).wadMul(_amountB);\n        pos().positions[_id].lastUpdateTimestamp = block.timestamp;\n    }\n\n    /// @inheritdoc IPositionsFacet\n    function getPosition(uint256 _id) external view returns (Position memory, int128 currentLeverage) {\n        return (pos().getPosition(_id), int128(pos().getRatio(_id)));\n    }\n\n    /// @inheritdoc IPositionsFacet\n    function isLiquidatable(uint256[] calldata _ids) external view override returns (bool[] memory results) {\n        results = new bool[](_ids.length);\n        for (uint256 i; i < _ids.length; i++) {\n            results[i] = pos().isLiquidatable(_ids[i]);\n        }\n    }\n\n    function getRatioOf(uint256 _id) external view returns (int128) {\n        return int128(pos().getRatio(_id));\n    }\n\n    /// @inheritdoc IPositionsFacet\n    function isClosable(uint256[] calldata _ids) external view override returns (bool[] memory results) {\n        results = new bool[](_ids.length);\n        for (uint256 i; i < _ids.length; i++) {\n            results[i] = pos().isCloseable(_ids[i]);\n        }\n    }\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Interface for verifying contract-based account signatures\n/// @notice Interface that verifies provided signature for the data\n/// @dev Interface defined by EIP-1271\ninterface IERC1271 {\n    /// @notice Returns whether the provided signature is valid for the provided data\n    /// @dev MUST return the bytes4 magic value 0x1626ba7e when function passes.\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5).\n    /// MUST allow external calls.\n    /// @param hash Hash of the data to be signed\n    /// @param signature Signature byte array associated with _data\n    /// @return magicValue The bytes4 magic value 0x1626ba7e\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/interfaces/IERC721Permit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity <=0.8.19;\n\nimport {IERC721} from \"./IERC721.sol\";\n\n/// @title ERC721 with permit\n/// @notice Extension to ERC721 that includes a permit function for signature based approvals\ninterface IERC721Permit is IERC721 {\n    /// @notice The permit typehash used in the permit signature\n    /// @return The typehash for the permit\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    /// @notice The domain separator used in the permit signature\n    /// @return The domain seperator used in encoding of permit signature\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    /// @notice Approve of a specific token ID for spending by spender via signature\n    /// @param spender The account that is being approved\n    /// @param tokenId The ID of the token that is being approved for spending\n    /// @param deadline The deadline timestamp by which the call must be mined for the approve to work\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function permit(address spender, uint256 tokenId, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external payable;\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/interfaces/ILayerZeroEndpointUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\nimport \"./ILayerZeroUserApplicationConfigUpgradeable.sol\";\n\ninterface ILayerZeroEndpointUpgradeable is ILayerZeroUserApplicationConfigUpgradeable {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint64 _nonce,\n        uint _gasLimit,\n        bytes calldata _payload\n    ) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParam\n    ) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address _userApplication,\n        uint _configType\n    ) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/interfaces/ILayerZeroReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\ninterface ILayerZeroReceiverUpgradeable {\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n    // @param _srcChainId - the source endpoint identifier\n    // @param _srcAddress - the source sending contract address from the source chain\n    // @param _nonce - the ordered message nonce\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/interfaces/ILayerZeroUserApplicationConfigUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\ninterface ILayerZeroUserApplicationConfigUpgradeable {\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/interfaces/IONFT721CoreUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\n\n/**\n * @dev Interface of the ONFT Core Upgradeable standard\n */\ninterface IONFT721CoreUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `_tokenIds[]` are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\n     * `_nonce` is the outbound nonce from\n     */\n    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes indexed _toAddress, uint[] _tokenIds);\n    event ReceiveFromChain(\n        uint16 indexed _srcChainId,\n        bytes indexed _srcAddress,\n        address indexed _toAddress,\n        uint[] _tokenIds\n    );\n\n    /**\n     * @dev Emitted when `_payload` was received from lz, but not enough gas to deliver all tokenIds\n     */\n    event CreditStored(bytes32 _hashedPayload, bytes _payload);\n    /**\n     * @dev Emitted when `_hashedPayload` has been completely delivered\n     */\n    event CreditCleared(bytes32 _hashedPayload);\n\n    /**\n     * @dev send token `_tokenId` to (`_dstChainId`, `_toAddress`) from `_from`\n     * `_toAddress` can be any size depending on the `dstChainId`.\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\n     */\n    function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint _tokenId,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    /**\n     * @dev send tokens `_tokenIds[]` to (`_dstChainId`, `_toAddress`) from `_from`\n     * `_toAddress` can be any size depending on the `dstChainId`.\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\n     */\n    function sendBatchFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint[] calldata _tokenIds,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    /**\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\n     * _dstChainId - L0 defined chain id to send tokens too\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\n     * _tokenId - token Id to transfer\n     * _useZro - indicates to use zro to pay L0 fees\n     * _adapterParams - flexible bytes array to indicate messaging adapter services in L0\n     */\n    function estimateSendFee(\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint _tokenId,\n        bool _useZro,\n        bytes calldata _adapterParams\n    ) external view returns (uint nativeFee, uint zroFee);\n\n    /**\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\n     * _dstChainId - L0 defined chain id to send tokens too\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\n     * _tokenIds[] - token Ids to transfer\n     * _useZro - indicates to use zro to pay L0 fees\n     * _adapterParams - flexible bytes array to indicate messaging adapter services in L0\n     */\n    function estimateSendBatchFee(\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint[] calldata _tokenIds,\n        bool _useZro,\n        bytes calldata _adapterParams\n    ) external view returns (uint nativeFee, uint zroFee);\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/interfaces/IONFT721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\nimport {IONFT721CoreUpgradeable} from \"./IONFT721CoreUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\n/**\n * @dev Interface of the ONFT Upgradeable standard\n */\ninterface IONFT721Upgradeable is IONFT721CoreUpgradeable, IERC721Upgradeable {\n\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/interfaces/IPositionsFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity <=0.8.19;\nimport {NewPosition, Position} from \"../state/PositionsStorage.sol\";\n\ninterface IPositionsFacet {\n    /**\n     * @notice Creates a new leveraged position\n     * @param _position The parameters of the new position\n     * @return id The ID of the new position\n     */\n    function createPosition(NewPosition memory _position) external returns (uint256 id);\n\n    /**\n     * @notice Close a leveraged position\n     * @param _id The ID of the position to close\n     */\n    function closePosition(uint256 _id) external;\n\n    /**\n     * @notice Deposit collateral into a leveraged position.\n     * @param _id The ID of the position to deposit collateral into.\n     * @param _amount The amount of collateral to deposit.\n     */\n    function deposit(uint256 _id, uint256 _amount) external;\n\n    /**\n     * @notice Withdraw collateral from a leveraged position\n     * @param _id The ID of the position to withdraw collateral from\n     * @param _amount The amount of collateral to withdraw\n     */\n    function withdraw(uint256 _id, uint256 _amount) external;\n\n    /**\n     * @notice Borrow more assets to a position, keeps the leverage.\n     * @param _id The ID of the position to borrow more from\n     * @param _sellAmount The amount of collateral to sell\n     * @param _buyAmount The min amount of asset to buy\n     */\n    function buy(uint256 _id, uint256 _sellAmount, uint256 _buyAmount) external;\n\n    /**\n     * @notice Repay borrowed asset in a position\n     * @param _id The ID of the position to repay borrowed asset to\n     * @param _amount The amount of borrowed asset\n     */\n    function buyback(uint256 _id, uint256 _amount) external;\n\n    /// @notice returns the info of a position for `_id`\n    /// @return position the position when last modified\n    /// @return profitPercentage the current profit of the position\n    function getPosition(uint256 _id) external view returns (Position memory, int128 profitPercentage);\n\n    /**\n     * @notice Get the liquidatable status of a lever positions\n     * @param _ids The IDs of the positions\n     * @return array of liquidatable results\n     */\n    function isLiquidatable(uint256[] calldata _ids) external view returns (bool[] memory);\n\n    /// @notice returns the closable status for positions\n    function isClosable(uint256[] calldata _ids) external view returns (bool[] memory);\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/libs/BitLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\n// mostSignificantBitPosition taken from: https://github.com/Uniswap/solidity-lib/blob/master/contracts/libraries/BitMath.sol\n// countSetBits based off: https://en.wikipedia.org/wiki/Hamming_weight\n\nlibrary BitLib {\n    uint256 constant m1 = 0x5555555555555555555555555555555555555555555555555555555555555555;\n    uint256 constant m2 = 0x3333333333333333333333333333333333333333333333333333333333333333;\n    uint256 constant m4 = 0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F;\n    uint256 constant m8 = 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF;\n    uint256 constant m16 = 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF;\n    uint256 constant m32 = 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF;\n    uint256 constant m64 = 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF;\n    uint256 constant m128 = 0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n    function mostSignificantBitPosition(uint256 x) internal pure returns (uint8 r) {\n        if (x == 0) return 0;\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n\n    function countSetBits(uint x) internal pure returns (uint256) {\n        x = (x & m1) + ((x >> 1) & m1);\n        x = (x & m2) + ((x >> 2) & m2);\n        x = (x & m4) + ((x >> 4) & m4);\n        x = (x & m8) + ((x >> 8) & m8);\n        x = (x & m16) + ((x >> 16) & m16);\n        x = (x & m32) + ((x >> 32) & m32);\n        x = (x & m64) + ((x >> 64) & m64);\n        x = (x & m128) + ((x >> 128) & m128);\n        return x;\n    }\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/libs/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1, \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {\n\n                        } eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/libs/ExcessivelySafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.7.6;\n\nlibrary ExcessivelySafeCall {\n    uint256 constant LOW_28_MASK = 0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                0, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n                _gas, // gas\n                _target, // recipient\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(bytes4 _newSelector, bytes memory _buf) internal pure {\n        require(_buf.length >= 4);\n        uint256 _mask = LOW_28_MASK;\n        assembly {\n            // load the first word of\n            let _word := mload(add(_buf, 0x20))\n            // mask out the top 4 bytes\n            // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/libs/LibERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {StringsUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {ERC721, ERC721Storage} from \"../state/ERC721Storage.sol\";\nimport {LibLZ} from \"./LibLZ.sol\";\nimport {Meta} from \"../../../../libs/Meta.sol\";\n\nlibrary LibERC721 {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    using LibERC721 for ERC721Storage;\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(\n        ERC721Storage storage self,\n        address owner,\n        address operator\n    ) internal view returns (bool) {\n        return self.operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(ERC721Storage storage self, address operator, bool approved) internal {\n        require(msg.sender != operator, \"ERC721: approve to caller\");\n        self.operatorApprovals[msg.sender][operator] = approved;\n    }\n\n    function isApprovedOrOwner(\n        ERC721Storage storage self,\n        address spender,\n        uint256 tokenId\n    ) internal view returns (bool) {\n        address owner = self.ownerOf(tokenId);\n        return (spender == owner || self.isApprovedForAll(owner, spender) || self.getApproved(tokenId) == spender);\n    }\n\n    function debitFrom(ERC721Storage storage self, address _from, uint16, bytes memory, uint _tokenId) internal {\n        require(self.isApprovedOrOwner(Meta.msgSender(), _tokenId), LibLZ.INVALID_CALLER);\n        require(self.ownerOf(_tokenId) == _from, LibLZ.INVALID_TOKEN_OWNER);\n        self.transfer(_from, address(this), _tokenId);\n    }\n\n    function creditTo(ERC721Storage storage self, uint16, address _toAddress, uint _tokenId) internal {\n        bool tokenExists = self.exists(_tokenId);\n        require(!tokenExists || (tokenExists && self.ownerOf(_tokenId) == address(this)));\n        if (!tokenExists) {\n            self.safeMint(_toAddress, _tokenId, \"\");\n        } else {\n            self.transfer(address(this), _toAddress, _tokenId);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(ERC721Storage storage self, uint256 tokenId) internal view returns (address) {\n        self.requireMinted(tokenId);\n\n        return self.tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function safeMint(ERC721Storage storage self, address to, uint256 tokenId, bytes memory data) internal {\n        _mint(self, to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    function _mint(ERC721Storage storage self, address to, uint256 tokenId) private {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!self.exists(tokenId), \"ERC721: token already minted\");\n\n        self.beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!self.exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            self.balances[to] += 1;\n        }\n\n        self.owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        self.afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function burn(ERC721Storage storage self, uint256 tokenId) internal {\n        address owner = self.ownerOf(tokenId);\n\n        self.beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = self.ownerOf(tokenId);\n\n        // Clear approvals\n        delete self.tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            self.balances[owner] -= 1;\n        }\n        delete self.owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        self.afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    function ownerOf(ERC721Storage storage self, uint256 tokenId) internal view returns (address) {\n        address owner = self.owners[tokenId];\n        require(owner != address(0), \"ERC721 :address zero is not a valid owner\");\n        return owner;\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function requireMinted(ERC721Storage storage self, uint256 tokenId) internal view {\n        require(self.exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /** @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(msg.sender, from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(ERC721Storage storage self, address to, uint256 tokenId) internal {\n        self.tokenApprovals[tokenId] = to;\n        emit Approval(self.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(ERC721Storage storage self, address owner, address operator, bool approved) internal {\n        require(owner != operator, \"ERC721: approve to caller\");\n        self.operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    function safeTransferFrom(ERC721Storage storage self, address from, address to, uint256 tokenId) internal {\n        self.safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        ERC721Storage storage self,\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal {\n        require(self.isApprovedOrOwner(msg.sender, tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(self, from, to, tokenId, data);\n    }\n\n    function _safeTransfer(\n        ERC721Storage storage self,\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private {\n        transfer(self, from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(ERC721Storage storage self, address from, address to, uint256 tokenId) internal {\n        require(self.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        self.beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(self.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete self.tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            self.balances[from] -= 1;\n            self.balances[to] += 1;\n        }\n        self.owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        self.afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function exists(ERC721Storage storage self, uint256 tokenId) internal view returns (bool) {\n        return self.owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function beforeTokenTransfer(\n        ERC721Storage storage self,\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function afterTokenTransfer(\n        ERC721Storage storage self,\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        ERC721().balances[account] += amount;\n    }\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/libs/LibLZ.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity <=0.8.19;\nimport {BytesLib} from \"../libs/BytesLib.sol\";\nimport {Meta} from \"../../../../libs/Meta.sol\";\nimport {ERC721} from \"../state/ERC721Storage.sol\";\nimport {lz, LZStorage, StoredCredit, AirdropParams, CallParams} from \"../state/LZStorage.sol\";\n\nlibrary LibLZ {\n    using BytesLib for bytes;\n    ///@dev Emitted when `_payload` was received from lz, but not enough gas to deliver all tokenIds\n    event CreditStored(bytes32 _hashedPayload, bytes _payload);\n\n    /// @dev Emitted when `_hashedPayload` has been completely delivered\n    event CreditCleared(bytes32 _hashedPayload);\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\n\n    /// @dev Emitted when `_tokenIds[]` are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\n    /// `_nonce` is the outbound nonce from\n    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes indexed _toAddress, uint[] _tokenIds);\n    event ReceiveFromChain(\n        uint16 indexed _srcChainId,\n        bytes indexed _srcAddress,\n        address indexed _toAddress,\n        uint[] _tokenIds\n    );\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    uint16 internal constant FUNCTION_TYPE_SEND = 1;\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint256 internal constant DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    string internal constant MINGASZERO = \"2\"; // ONFT721: minGasToTransferAndStore must be > 0\"\n    string internal constant TOKENIDS_EMPTY = \"1\"; // LzApp: tokenIds[] is empty\n    string internal constant BATCH_LIMIT_EXCEEDED = \"3\"; // \"ONFT721: batch size exceeds dst batch limit\"\n    string internal constant NO_CREDITS_STORED = \"4\"; // \"ONFT721: no credits stored\"\n    string internal constant NO_GAS_REMAINING = \"5\"; // \"ONFT721: not enough gas to process credit transfer\"\n    string internal constant MIN_GAS_NOT_ZERO = \"6\"; // \"ONFT721: minGasToTransferAndStore must be > 0\"\n    string internal constant INVALID_CALLER = \"7\"; // \"ONFT721: send caller is not owner nor approved\"\n    string internal constant INVALID_TOKEN_OWNER = \"8\"; // \"ONFT721: send from incorrect owner\"\n    string internal constant INVALID_ENDPOINT = \"9\"; // Endpoint cannot be 0\n\n    function estimateFees(\n        LZStorage storage self,\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint[] memory _tokenIds,\n        bool _useZro,\n        bytes memory _adapterParams\n    ) internal view returns (uint256, uint256) {\n        bytes memory payload = abi.encode(_toAddress, _tokenIds);\n        return self.lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function send(\n        LZStorage storage self,\n        address _from,\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint[] memory _tokenIds,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) internal {\n        // allow 1 by default\n        require(_tokenIds.length > 0, \"tokenIds[] is empty\");\n        require(\n            _tokenIds.length == 1 || _tokenIds.length <= self.dstChainIdToBatchLimit[_dstChainId],\n            \"batch size exceeds dst batch limit\"\n        );\n\n        for (uint i = 0; i < _tokenIds.length; i++) {\n            ERC721().debitFrom(_from, _dstChainId, _toAddress, _tokenIds[i]);\n        }\n\n        bytes memory payload = abi.encode(_toAddress, _tokenIds);\n\n        checkGasLimit(\n            self,\n            _dstChainId,\n            FUNCTION_TYPE_SEND,\n            _adapterParams,\n            self.dstChainIdToTransferGas[_dstChainId] * _tokenIds.length\n        );\n        _lzSend(self, _dstChainId, payload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n        emit SendToChain(_dstChainId, _from, _toAddress, _tokenIds);\n    }\n\n    function _lzSend(\n        LZStorage storage self,\n        uint16 _dstChainId,\n        bytes memory _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams,\n        uint _nativeFee\n    ) internal {\n        bytes memory trustedRemote = self.trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, \"LzApp: destination chain is not a trusted source\");\n        self.checkPayloadSize(_dstChainId, _payload.length);\n        self.lzEndpoint.send{value: _nativeFee}(\n            _dstChainId,\n            trustedRemote,\n            _payload,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    function nonblockingLzReceive(\n        LZStorage storage self,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 /*_nonce*/,\n        bytes memory _payload\n    ) internal {\n        // decode and load the toAddress\n        (bytes memory toAddressBytes, uint[] memory tokenIds) = abi.decode(_payload, (bytes, uint[]));\n\n        address toAddress;\n        assembly {\n            toAddress := mload(add(toAddressBytes, 20))\n        }\n\n        uint nextIndex = self.creditTill(_srcChainId, toAddress, 0, tokenIds);\n        if (nextIndex < tokenIds.length) {\n            // not enough gas to complete transfers, store to be cleared in another tx\n            bytes32 hashedPayload = keccak256(_payload);\n            self.storedCredits[hashedPayload] = StoredCredit(_srcChainId, toAddress, nextIndex, true);\n            emit CreditStored(hashedPayload, _payload);\n        }\n\n        emit ReceiveFromChain(_srcChainId, _srcAddress, toAddress, tokenIds);\n    }\n\n    // When a srcChain has the ability to transfer more chainIds in a single tx than the dst can do.\n    // Needs the ability to iterate and stop if the minGasToTransferAndStore is not met\n    function creditTill(\n        LZStorage storage self,\n        uint16 _srcChainId,\n        address _toAddress,\n        uint _startIndex,\n        uint[] memory _tokenIds\n    ) internal returns (uint256) {\n        uint i = _startIndex;\n        while (i < _tokenIds.length) {\n            // if not enough gas to process, store this index for next loop\n            if (gasleft() < self.minGasToTransferAndStore) break;\n\n            ERC721().creditTo(_srcChainId, _toAddress, _tokenIds[i]);\n            i++;\n        }\n\n        // indicates the next index to send of tokenIds,\n        // if i == tokenIds.length, we are finished\n        return i;\n    }\n\n    function checkGasLimit(\n        LZStorage storage self,\n        uint16 _dstChainId,\n        uint16 _type,\n        bytes memory _adapterParams,\n        uint _extraGas\n    ) internal view {\n        uint providedGasLimit = getGasLimit(_adapterParams);\n        uint minGasLimit = self.minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, \"LzApp: minGasLimit not set\");\n        require(providedGasLimit >= minGasLimit, \"LzApp: gas limit is too low\");\n    }\n\n    function getGasLimit(bytes memory _adapterParams) internal pure returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, \"LzApp: invalid adapterParams\");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function checkPayloadSize(LZStorage storage self, uint16 _dstChainId, uint _payloadSize) internal view {\n        uint payloadSizeLimit = self.payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) {\n            // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, \"LzApp: payload size is too large\");\n    }\n\n    function buildAdapterParams(\n        AirdropParams memory _airdropParams,\n        uint _uaGasLimit\n    ) internal pure returns (bytes memory adapterParams) {\n        if (_airdropParams.airdropAmount == 0 && _airdropParams.airdropAddress == bytes32(0x0)) {\n            adapterParams = buildDefaultAdapterParams(_uaGasLimit);\n        } else {\n            adapterParams = buildAirdropAdapterParams(_uaGasLimit, _airdropParams);\n        }\n    }\n\n    // Build Adapter Params\n    function buildDefaultAdapterParams(uint _uaGas) internal pure returns (bytes memory) {\n        // txType 1\n        // bytes  [2       32      ]\n        // fields [txType  extraGas]\n        return abi.encodePacked(uint16(1), _uaGas);\n    }\n\n    function buildAirdropAdapterParams(uint _uaGas, AirdropParams memory _params) internal pure returns (bytes memory) {\n        require(_params.airdropAmount > 0, \"Airdrop amount must be greater than 0\");\n        require(_params.airdropAddress != bytes32(0x0), \"Airdrop address must be set\");\n\n        // txType 2\n        // bytes  [2       32        32            bytes[]         ]\n        // fields [txType  extraGas  dstNativeAmt  dstNativeAddress]\n        return abi.encodePacked(uint16(2), _uaGas, _params.airdropAmount, _params.airdropAddress);\n    }\n\n    // Decode Adapter Params\n    function decodeAdapterParams(\n        bytes memory _adapterParams\n    ) internal pure returns (uint16 txType, uint uaGas, uint airdropAmount, address payable airdropAddress) {\n        require(_adapterParams.length == 34 || _adapterParams.length > 66, \"Invalid adapterParams\");\n        assembly {\n            txType := mload(add(_adapterParams, 2))\n            uaGas := mload(add(_adapterParams, 34))\n        }\n        require(txType == 1 || txType == 2, \"Unsupported txType\");\n        require(uaGas > 0, \"Gas too low\");\n\n        if (txType == 2) {\n            assembly {\n                airdropAmount := mload(add(_adapterParams, 66))\n                airdropAddress := mload(add(_adapterParams, 86))\n            }\n        }\n    }\n\n    //---------------------------------------------------------------------------\n    // Address type handling\n    function bytes32ToAddress(bytes32 _bytes32Address) internal pure returns (address _address) {\n        return address(uint160(uint(_bytes32Address)));\n    }\n\n    function addressToBytes32(address _address) internal pure returns (bytes32 _bytes32Address) {\n        return bytes32(uint(uint160(_address)));\n    }\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/libs/LibPositions.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity <=0.8.19;\nimport {WadRay} from \"../../../../libs/WadRay.sol\";\nimport {pos, PositionStorage, Position} from \"../state/PositionsStorage.sol\";\n\nlibrary LibPositions {\n    using WadRay for uint256;\n    using LibPositions for PositionStorage;\n\n    string internal constant INVALID_LT = \"PC0\";\n    string internal constant INVALID_MAX_LEVERAGE = \"PC1\";\n    string internal constant INVALID_KRESKO = \"PC2\";\n    string internal constant ERROR_NOT_OWNER = \"PC3\";\n    string internal constant ERROR_POSITION_NOT_OWNED_BY_CALLER = \"PC4\";\n    string internal constant ERROR_POSITION_NOT_FOUND = \"PC5\";\n    string internal constant INVALID_NAME = \"PC6\";\n    string internal constant LEVERAGE_TOO_HIGH = \"PC7\";\n    string internal constant LEVERAGE_TOO_LOW = \"PC8\";\n\n    function getPosition(PositionStorage storage self, uint256 _id) internal view returns (Position memory) {\n        return self.positions[_id];\n    }\n\n    function getLeverage(PositionStorage storage self, uint256 _id) internal view returns (uint256 leverage) {\n        Position memory position = self.positions[_id];\n        uint256 priceA = self.kresko.getPrice(position.assetA);\n        uint256 priceB = self.kresko.getPrice(position.assetB);\n\n        if (priceA == 0 || priceB == 0 || position.amountA == 0) return 0;\n\n        return position.amountB.wadMul(priceB).wadDiv(position.amountA.wadMul(priceA));\n    }\n\n    function getRatio(PositionStorage storage self, uint256 _id) internal view returns (int256 ratio) {\n        return int256(self.getLeverage(_id)) - int256(self.positions[_id].leverage);\n    }\n\n    function isLiquidatable(PositionStorage storage self, uint256 _id) internal view returns (bool) {\n        return self.getRatio(_id) <= self.liquidationThreshold;\n    }\n\n    function isCloseable(PositionStorage storage self, uint256 _id) internal view returns (bool) {\n        return self.getRatio(_id) >= self.closeThreshold;\n    }\n\n    function getAndIncrementNonce(PositionStorage storage self, uint256 id) internal returns (uint256) {\n        return uint256(self.positions[id].nonce++);\n    }\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/state/ERC721Storage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {LibERC721} from \"../libs/LibERC721.sol\";\n\nstruct ERC721Storage {\n    uint256 currentId;\n    // Token name\n    string name;\n    // Token symbol\n    string symbol;\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) owners;\n    // Mapping owner address to token count\n    mapping(address => uint256) balances;\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) tokenApprovals;\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) operatorApprovals;\n    string baseURI;\n}\n\n// Storage position\nbytes32 constant ERC721_STORAGE_POSITION = keccak256(\"kresko.positions.erc721.storage\");\n\nfunction ERC721() pure returns (ERC721Storage storage state) {\n    bytes32 position = ERC721_STORAGE_POSITION;\n    assembly {\n        state.slot := position\n    }\n}\n\nusing LibERC721 for ERC721Storage global;\n"
    },
    "src/contracts/minter/collateral-pool/position/state/LZStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\nimport {ILayerZeroEndpointUpgradeable} from \"../interfaces/ILayerZeroEndpointUpgradeable.sol\";\nimport {ILayerZeroUserApplicationConfigUpgradeable} from \"../interfaces/ILayerZeroUserApplicationConfigUpgradeable.sol\";\nimport {LibLZ} from \"../libs/LibLZ.sol\";\n\nusing LibLZ for LZStorage global;\n\nstruct StoredCredit {\n    uint16 srcChainId;\n    address toAddress;\n    uint256 index; // which index of the tokenIds remain\n    bool creditsRemain;\n}\n\nstruct CallParams {\n    address payable refundAddress;\n    address zroPaymentAddress;\n}\n\nstruct AirdropParams {\n    uint airdropAmount;\n    bytes32 airdropAddress;\n}\n\nstruct LZStorage {\n    uint256 minGasToTransferAndStore; // min amount of gas required to transfer, and also store the payload\n    mapping(uint16 => uint256) dstChainIdToBatchLimit;\n    mapping(uint16 => uint256) dstChainIdToTransferGas; // per transfer amount of gas required to mint/transfer on the dst\n    mapping(bytes32 => StoredCredit) storedCredits;\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) failedMessages;\n    ILayerZeroEndpointUpgradeable lzEndpoint;\n    mapping(uint16 => bytes) trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) minDstGasLookup;\n    mapping(uint16 => uint) payloadSizeLimitLookup;\n    address precrime;\n}\n\nbytes32 constant LZ_STORAGE_POSITION = keccak256(\"kresko.positions.lz.storage\");\n\nfunction lz() pure returns (LZStorage storage state) {\n    bytes32 position = LZ_STORAGE_POSITION;\n    assembly {\n        state.slot := position\n    }\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/state/PositionsStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {LibPositions} from \"../libs/LibPositions.sol\";\nimport {ICollateralPoolSwapFacet} from \"../../interfaces/ICollateralPoolSwapFacet.sol\";\n\nstruct NewPosition {\n    address account;\n    address assetA;\n    address assetB;\n    uint256 amountA;\n    uint256 amountBMin;\n    uint256 leverage;\n}\n\nstruct Position {\n    address account;\n    address assetA;\n    address assetB;\n    uint256 amountA;\n    uint256 amountB;\n    uint256 valueBCache;\n    uint256 leverage;\n    uint256 liquidationIncentive;\n    uint256 closeIncentive;\n    uint256 creationTimestamp;\n    uint256 lastUpdateTimestamp;\n    uint256 nonce;\n}\n\nstruct PositionsInitializer {\n    ICollateralPoolSwapFacet kresko;\n    string name;\n    string symbol;\n    int128 liquidationThreshold;\n    int128 closeThreshold;\n    uint256 maxLeverage;\n    uint256 minLeverage;\n}\n\nstruct PositionStorage {\n    ICollateralPoolSwapFacet kresko;\n    uint256 minLeverage;\n    uint256 maxLeverage;\n    int128 liquidationThreshold;\n    int128 closeThreshold;\n    mapping(uint256 => Position) positions;\n}\n\nusing LibPositions for PositionStorage global;\n\n// Storage position\nbytes32 constant POSITIONS_STORAGE = keccak256(\"kresko.positions.positions.storage\");\n\nfunction pos() pure returns (PositionStorage storage state) {\n    bytes32 position = POSITIONS_STORAGE;\n    assembly {\n        state.slot := position\n    }\n}\n"
    },
    "src/contracts/minter/collateral-pool/position/test/MinimalKresko.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity <=0.8.19;\n\nimport {IPositionsFacet} from \"../interfaces/IPositionsFacet.sol\";\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract MinimalKresko {\n    IPositionsFacet positions;\n    mapping(address => uint256) public prices;\n\n    constructor(IPositionsFacet _positions) {\n        positions = _positions;\n    }\n}\n"
    },
    "src/contracts/minter/facets/AccountStateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IAccountStateFacet} from \"../interfaces/IAccountStateFacet.sol\";\nimport {Fee, KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/**\n * @author Kresko\n * @title AccountStateFacet\n * @notice Views concerning account state\n */\ncontract AccountStateFacet is IAccountStateFacet {\n    using LibDecimals for uint256;\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  KrAssets                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IAccountStateFacet\n    function getMintedKreskoAssetsIndex(address _account, address _kreskoAsset) external view returns (uint256) {\n        return ms().getMintedKreskoAssetsIndex(_account, _kreskoAsset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getMintedKreskoAssets(address _account) external view returns (address[] memory) {\n        return ms().mintedKreskoAssets[_account];\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getAccountKrAssetValue(address _account) external view returns (uint256) {\n        return ms().getAccountKrAssetValue(_account);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function kreskoAssetDebt(address _account, address _asset) external view returns (uint256) {\n        return ms().getKreskoAssetDebtScaled(_account, _asset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function kreskoAssetDebtPrincipal(address _account, address _asset) external view returns (uint256) {\n        return ms().getKreskoAssetDebtPrincipal(_account, _asset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function kreskoAssetDebtInterest(\n        address _account,\n        address _asset\n    ) external view returns (uint256 assetAmount, uint256 kissAmount) {\n        return ms().getKreskoAssetDebtInterest(_account, _asset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function kreskoAssetDebtInterestTotal(address _account) external view returns (uint256 kissAmount) {\n        address[] memory mintedKreskoAssets = ms().mintedKreskoAssets[_account];\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            (, uint256 kissAmountForAsset) = ms().getKreskoAssetDebtInterest(_account, mintedKreskoAssets[i]);\n            kissAmount += kissAmountForAsset;\n        }\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Collateral                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IAccountStateFacet\n    function getDepositedCollateralAssets(address _account) external view returns (address[] memory) {\n        return ms().depositedCollateralAssets[_account];\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function collateralDeposits(address _account, address _asset) external view returns (uint256) {\n        return ms().getCollateralDeposits(_account, _asset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getDepositedCollateralAssetIndex(\n        address _account,\n        address _collateralAsset\n    ) external view returns (uint256 i) {\n        return ms().getDepositedCollateralAssetIndex(_account, _collateralAsset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getAccountCollateralValue(address _account) public view returns (uint256) {\n        return ms().getAccountCollateralValue(_account);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getAccountMinimumCollateralValueAtRatio(address _account, uint256 _ratio) public view returns (uint256) {\n        return ms().getAccountMinimumCollateralValueAtRatio(_account, _ratio);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getAccountCollateralRatio(address _account) public view returns (uint256 ratio) {\n        uint256 collateralValue = ms().getAccountCollateralValue(_account);\n        if (collateralValue == 0) {\n            return 0;\n        }\n        uint256 krAssetValue = ms().getAccountKrAssetValue(_account);\n        if (krAssetValue == 0) {\n            return 0;\n        }\n        ratio = collateralValue.wadDiv(krAssetValue);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getCollateralAdjustedAndRealValue(\n        address _account,\n        address _asset\n    ) external view returns (uint256 adjustedValue, uint256 realValue) {\n        uint256 depositAmount = ms().getCollateralDeposits(_account, _asset);\n        return ms().getCollateralValueAndOraclePrice(_asset, depositAmount, false);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getCollateralRatiosFor(address[] calldata _accounts) external view returns (uint256[] memory) {\n        uint256[] memory ratios = new uint256[](_accounts.length);\n        for (uint256 i; i < _accounts.length; i++) {\n            ratios[i] = getAccountCollateralRatio(_accounts[i]);\n        }\n        return ratios;\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function calcExpectedFee(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kreskoAssetAmount,\n        uint256 _feeType\n    ) external view returns (address[] memory, uint256[] memory) {\n        require(_feeType <= 1, Error.INVALID_FEE_TYPE);\n\n        KrAsset memory krAsset = ms().kreskoAssets[_kreskoAsset];\n\n        // Calculate the value of the fee according to the value of the krAsset\n        uint256 feeValue = krAsset.uintUSD(_kreskoAssetAmount).wadMul(\n            Fee(_feeType) == Fee.Open ? krAsset.openFee : krAsset.closeFee\n        );\n\n        address[] memory accountCollateralAssets = ms().depositedCollateralAssets[_account];\n\n        ExpectedFeeRuntimeInfo memory info; // Using ExpectedFeeRuntimeInfo struct to avoid StackTooDeep error\n        info.assets = new address[](accountCollateralAssets.length);\n        info.amounts = new uint256[](accountCollateralAssets.length);\n\n        // Return empty arrays if the fee value is 0.\n        if (feeValue == 0) {\n            return (info.assets, info.amounts);\n        }\n\n        for (uint256 i = accountCollateralAssets.length - 1; i >= 0; i--) {\n            address collateralAssetAddress = accountCollateralAssets[i];\n\n            uint256 depositAmount = ms().getCollateralDeposits(_account, collateralAssetAddress);\n\n            // Don't take the collateral asset's collateral factor into consideration.\n            (uint256 depositValue, uint256 oraclePrice) = ms().getCollateralValueAndOraclePrice(\n                collateralAssetAddress,\n                depositAmount,\n                true\n            );\n\n            uint256 feeValuePaid;\n            uint256 transferAmount;\n            // If feeValue < depositValue, the entire fee can be charged for this collateral asset.\n            if (feeValue < depositValue) {\n                transferAmount = ms().collateralAssets[collateralAssetAddress].decimals.fromWad(\n                    feeValue.wadDiv(oraclePrice)\n                );\n                feeValuePaid = feeValue;\n            } else {\n                transferAmount = depositAmount;\n                feeValuePaid = depositValue;\n            }\n\n            if (transferAmount > 0) {\n                info.assets[info.collateralTypeCount] = collateralAssetAddress;\n                info.amounts[info.collateralTypeCount] = transferAmount;\n                info.collateralTypeCount = info.collateralTypeCount++;\n            }\n\n            feeValue = feeValue - feeValuePaid;\n            // If the entire fee has been paid, no more action needed.\n            if (feeValue == 0) {\n                return (info.assets, info.amounts);\n            }\n        }\n        return (info.assets, info.amounts);\n    }\n}\n"
    },
    "src/contracts/minter/facets/BurnFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IBurnFacet} from \"../interfaces/IBurnFacet.sol\";\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {MinterModifiers} from \"../MinterModifiers.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\nimport {Action} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title BurnFacet\n * @notice Main end-user functionality concerning burning of kresko assets\n */\ncontract BurnFacet is DiamondModifiers, MinterModifiers, IBurnFacet {\n    using Arrays for address[];\n\n    /// @inheritdoc IBurnFacet\n    function burnKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _burnAmount,\n        uint256 _mintedKreskoAssetIndex\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        require(_burnAmount > 0, Error.ZERO_BURN);\n        MinterState storage s = ms();\n\n        if (s.safetyStateSet) {\n            ensureNotPaused(_kreskoAsset, Action.Repay);\n        }\n\n        // Get accounts principal debt\n        uint256 debtAmount = s.getKreskoAssetDebtPrincipal(_account, _kreskoAsset);\n\n        if (_burnAmount != type(uint256).max) {\n            require(_burnAmount <= debtAmount, Error.KRASSET_BURN_AMOUNT_OVERFLOW);\n            // Ensure principal left is either 0 or >= minDebtValue\n            _burnAmount = s.ensureNotDustPosition(_kreskoAsset, _burnAmount, debtAmount);\n        } else {\n            // _burnAmount of uint256 max, burn all principal debt\n            _burnAmount = debtAmount;\n        }\n\n        // If sender repays all principal debt of asset with no stability rate, remove it from minted assets array.\n        // For assets with stability rate the revomal is done when repaying interest\n        if (irs().srAssets[_kreskoAsset].asset == address(0) && _burnAmount == debtAmount) {\n            s.mintedKreskoAssets[_account].removeAddress(_kreskoAsset, _mintedKreskoAssetIndex);\n        }\n        // Charge the burn fee from collateral of _account\n        s.chargeCloseFee(_account, _kreskoAsset, _burnAmount);\n\n        // Record the burn\n        s.burn(_kreskoAsset, s.kreskoAssets[_kreskoAsset].anchor, _burnAmount, _account);\n\n        // Emit logs\n        emit MinterEvent.KreskoAssetBurned(_account, _kreskoAsset, _burnAmount);\n    }\n}\n"
    },
    "src/contracts/minter/facets/BurnHelperFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {IBurnHelperFacet} from \"../interfaces/IBurnHelperFacet.sol\";\nimport {MinterModifiers} from \"../MinterModifiers.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\nimport {Action} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title BurnHelperFacet\n * @notice Helper functions for reducing positions\n */\ncontract BurnHelperFacet is IBurnHelperFacet, DiamondModifiers, MinterModifiers {\n    using Arrays for address[];\n\n    /// @inheritdoc IBurnHelperFacet\n    function closeKrAssetDebtPosition(\n        address _account,\n        address _kreskoAsset\n    ) public nonReentrant kreskoAssetExists(_kreskoAsset) onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        MinterState storage s = ms();\n        if (s.safetyStateSet) {\n            super.ensureNotPaused(_kreskoAsset, Action.Repay);\n        }\n\n        // Get accounts principal debt\n        uint256 principalDebt = s.getKreskoAssetDebtPrincipal(_account, _kreskoAsset);\n        require(principalDebt != 0, Error.ZERO_BURN);\n\n        // Charge the burn fee from collateral of _account\n        s.chargeCloseFee(_account, _kreskoAsset, principalDebt);\n\n        // Record the burn\n        s.burn(_kreskoAsset, s.kreskoAssets[_kreskoAsset].anchor, principalDebt, _account);\n        uint256 kissRepayAmount = ms().repayFullStabilityRateInterest(_account, _kreskoAsset);\n\n        // If all all principal debt of asset with NO stability rate configured\n        // -> remove it from minted assets array.\n        // For assets with stability rate the revomal is done when repaying interest\n        if (irs().srAssets[_kreskoAsset].asset == address(0)) {\n            s.mintedKreskoAssets[_account].removeAddress(\n                _kreskoAsset,\n                ms().getMintedKreskoAssetsIndex(_account, _kreskoAsset)\n            );\n        }\n\n        emit MinterEvent.DebtPositionClosed(_account, _kreskoAsset, principalDebt, kissRepayAmount);\n    }\n\n    /// @inheritdoc IBurnHelperFacet\n    function batchCloseKrAssetDebtPositions(\n        address _account\n    ) external onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        address[] memory mintedKreskoAssets = ms().getMintedKreskoAssets(_account);\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            closeKrAssetDebtPosition(_account, mintedKreskoAssets[i]);\n        }\n    }\n}\n"
    },
    "src/contracts/minter/facets/ConfigurationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IERC165} from \"../../shared/IERC165.sol\";\nimport {IERC20Permit} from \"../../shared/IERC20Permit.sol\";\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\nimport {IKISS} from \"../../kiss/interfaces/IKISS.sol\";\n\nimport {IConfigurationFacet} from \"../interfaces/IConfigurationFacet.sol\";\n\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent, GeneralEvent} from \"../../libs/Events.sol\";\nimport {Authorization, Role} from \"../../libs/Authorization.sol\";\nimport {Meta} from \"../../libs/Meta.sol\";\n\nimport {MinterModifiers} from \"../MinterModifiers.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\n\nimport {ds} from \"../../diamond/DiamondStorage.sol\";\n\nimport {MinterInitArgs, CollateralAsset, KrAsset, AggregatorV2V3Interface, Constants} from \"../MinterTypes.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/**\n * @author Kresko\n * @title ConfigurationFacet\n * @notice Functionality for `Role.ADMIN` level actions.\n * @notice Can be only initialized by the deployer/owner.\n */\ncontract ConfigurationFacet is DiamondModifiers, MinterModifiers, IConfigurationFacet {\n    /* -------------------------------------------------------------------------- */\n    /*                                 Initialize                                 */\n    /* -------------------------------------------------------------------------- */\n\n    function initialize(MinterInitArgs calldata args) external onlyOwner {\n        require(ms().initializations == 0, Error.ALREADY_INITIALIZED);\n        // Temporarily set ADMIN role for deployer\n        Authorization._grantRole(Role.DEFAULT_ADMIN, msg.sender);\n        Authorization._grantRole(Role.ADMIN, msg.sender);\n\n        // Grant the admin role to admin\n        Authorization._grantRole(Role.DEFAULT_ADMIN, args.admin);\n        Authorization._grantRole(Role.ADMIN, args.admin);\n\n        /**\n         * @notice Council can be set only by this specific function.\n         * Requirements:\n         *\n         * - address `_council` must implement ERC165 and a specific multisig interfaceId.\n         * - reverts if above is not true.\n         */\n        Authorization.setupSecurityCouncil(args.council);\n\n        updateFeeRecipient(args.treasury);\n        updateMinimumCollateralizationRatio(args.minimumCollateralizationRatio);\n        updateMinimumDebtValue(args.minimumDebtValue);\n        updateLiquidationThreshold(args.liquidationThreshold);\n        updateExtOracleDecimals(args.extOracleDecimals);\n        updateMaxLiquidationMultiplier(Constants.MIN_MAX_LIQUIDATION_MULTIPLIER);\n\n        ms().initializations = 1;\n        ms().domainSeparator = Meta.domainSeparator(\"Kresko Minter\", \"V1\");\n        emit GeneralEvent.Initialized(args.admin, 1);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateFeeRecipient(address _feeRecipient) public override onlyRole(Role.ADMIN) {\n        require(_feeRecipient != address(0), Error.ADDRESS_INVALID_FEERECIPIENT);\n        ms().feeRecipient = _feeRecipient;\n        emit MinterEvent.FeeRecipientUpdated(_feeRecipient);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateLiquidationIncentiveMultiplier(\n        address _collateralAsset,\n        uint256 _liquidationIncentiveMultiplier\n    ) public override collateralAssetExists(_collateralAsset) onlyRole(Role.ADMIN) {\n        require(\n            _liquidationIncentiveMultiplier >= Constants.MIN_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_LOW\n        );\n        require(\n            _liquidationIncentiveMultiplier <= Constants.MAX_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_HIGH\n        );\n        ms().collateralAssets[_collateralAsset].liquidationIncentive = _liquidationIncentiveMultiplier;\n        emit MinterEvent.LiquidationIncentiveMultiplierUpdated(_collateralAsset, _liquidationIncentiveMultiplier);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateCFactor(\n        address _collateralAsset,\n        uint256 _cFactor\n    ) public override collateralAssetExists(_collateralAsset) onlyRole(Role.ADMIN) {\n        require(_cFactor <= Constants.ONE_HUNDRED_PERCENT, Error.COLLATERAL_INVALID_FACTOR);\n        ms().collateralAssets[_collateralAsset].factor = _cFactor;\n        emit MinterEvent.CFactorUpdated(_collateralAsset, _cFactor);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateKFactor(\n        address _kreskoAsset,\n        uint256 _kFactor\n    ) public override kreskoAssetExists(_kreskoAsset) onlyRole(Role.ADMIN) {\n        require(_kFactor >= Constants.ONE_HUNDRED_PERCENT, Error.KRASSET_INVALID_FACTOR);\n        ms().kreskoAssets[_kreskoAsset].kFactor = _kFactor;\n        emit MinterEvent.CFactorUpdated(_kreskoAsset, _kFactor);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateMinimumCollateralizationRatio(\n        uint256 _minimumCollateralizationRatio\n    ) public override onlyRole(Role.ADMIN) {\n        require(\n            _minimumCollateralizationRatio >= Constants.MIN_COLLATERALIZATION_RATIO,\n            Error.PARAM_MIN_COLLATERAL_RATIO_LOW\n        );\n        ms().minimumCollateralizationRatio = _minimumCollateralizationRatio;\n        emit MinterEvent.MinimumCollateralizationRatioUpdated(_minimumCollateralizationRatio);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateMinimumDebtValue(uint256 _minimumDebtValue) public override onlyRole(Role.ADMIN) {\n        require(_minimumDebtValue <= Constants.MAX_MIN_DEBT_VALUE, Error.PARAM_MIN_DEBT_AMOUNT_HIGH);\n        ms().minimumDebtValue = _minimumDebtValue;\n        emit MinterEvent.MinimumDebtValueUpdated(_minimumDebtValue);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateLiquidationThreshold(uint256 _liquidationThreshold) public override onlyRole(Role.ADMIN) {\n        // Liquidation threshold cannot be greater than minimum collateralization ratio\n\n        require(_liquidationThreshold <= ms().minimumCollateralizationRatio, Error.INVALID_LT);\n\n        ms().liquidationThreshold = _liquidationThreshold;\n        emit MinterEvent.LiquidationThresholdUpdated(_liquidationThreshold);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateMaxLiquidationMultiplier(uint256 _maxLiquidationMultiplier) public override onlyRole(Role.ADMIN) {\n        require(\n            _maxLiquidationMultiplier >= Constants.MIN_MAX_LIQUIDATION_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_OVERFLOW_LOW\n        );\n        ms().maxLiquidationMultiplier = _maxLiquidationMultiplier;\n        emit MinterEvent.maxLiquidationMultiplierUpdated(_maxLiquidationMultiplier);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateAMMOracle(address _ammOracle) external onlyRole(Role.ADMIN) {\n        ms().ammOracle = _ammOracle;\n        emit MinterEvent.AMMOracleUpdated(_ammOracle);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateExtOracleDecimals(uint8 _decimals) public onlyRole(Role.ADMIN) {\n        ms().extOracleDecimals = _decimals;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 COLLATERAL                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IConfigurationFacet\n    function addCollateralAsset(\n        address _collateralAsset,\n        CollateralAsset memory _config\n    ) external nonReentrant onlyRole(Role.ADMIN) collateralAssetDoesNotExist(_collateralAsset) {\n        require(_collateralAsset != address(0), Error.ADDRESS_INVALID_COLLATERAL);\n        require(address(_config.marketStatusOracle) != address(0), Error.ADDRESS_INVALID_ORACLE);\n        require(_config.oracle.decimals() == ms().extOracleDecimals, Error.INVALID_ORACLE_DECIMALS);\n        require(_config.factor <= Constants.ONE_HUNDRED_PERCENT, Error.COLLATERAL_INVALID_FACTOR);\n        require(\n            _config.liquidationIncentive >= Constants.MIN_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_LOW\n        );\n        require(\n            _config.liquidationIncentive <= Constants.MAX_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_HIGH\n        );\n        bool isKrAsset = ms().kreskoAssets[_collateralAsset].exists;\n        require(\n            !isKrAsset ||\n                (IERC165(_collateralAsset).supportsInterface(type(IKISS).interfaceId)) ||\n                IERC165(_config.anchor).supportsInterface(type(IKreskoAssetIssuer).interfaceId),\n            Error.KRASSET_INVALID_ANCHOR\n        );\n\n        /* ---------------------------------- Save ---------------------------------- */\n        ms().collateralAssets[_collateralAsset] = CollateralAsset({\n            factor: _config.factor,\n            oracle: _config.oracle,\n            liquidationIncentive: _config.liquidationIncentive,\n            marketStatusOracle: _config.marketStatusOracle,\n            anchor: _config.anchor,\n            exists: true,\n            decimals: IERC20Permit(_collateralAsset).decimals()\n        });\n\n        emit MinterEvent.CollateralAssetAdded(\n            _collateralAsset,\n            _config.factor,\n            address(_config.oracle),\n            address(_config.marketStatusOracle),\n            _config.anchor,\n            _config.liquidationIncentive\n        );\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateCollateralAsset(\n        address _collateralAsset,\n        CollateralAsset memory _config\n    ) external onlyRole(Role.ADMIN) collateralAssetExists(_collateralAsset) {\n        // Setting the factor to 0 effectively sunsets a collateral asset, which is intentionally allowed.\n        require(_config.factor <= Constants.ONE_HUNDRED_PERCENT, Error.COLLATERAL_INVALID_FACTOR);\n        require(\n            _config.liquidationIncentive >= Constants.MIN_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_LOW\n        );\n        require(\n            _config.liquidationIncentive <= Constants.MAX_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_HIGH\n        );\n\n        /* ------------------------------ Update anchor ----------------------------- */\n        if (_config.anchor != address(0)) {\n            bool krAsset = ms().kreskoAssets[_collateralAsset].exists;\n            require(\n                !krAsset ||\n                    (IERC165(_collateralAsset).supportsInterface(type(IKISS).interfaceId)) ||\n                    IERC165(_config.anchor).supportsInterface(type(IKreskoAssetIssuer).interfaceId),\n                Error.KRASSET_INVALID_ANCHOR\n            );\n            ms().collateralAssets[_collateralAsset].anchor = _config.anchor;\n        }\n\n        /* -------------------------- Market status oracle -------------------------- */\n        if (address(_config.marketStatusOracle) != address(0)) {\n            ms().collateralAssets[_collateralAsset].marketStatusOracle = _config.marketStatusOracle;\n        }\n\n        /* ------------------------------- Price feed ------------------------------- */\n        if (address(_config.oracle) != address(0)) {\n            require(_config.oracle.decimals() == ms().extOracleDecimals, Error.INVALID_ORACLE_DECIMALS);\n            ms().collateralAssets[_collateralAsset].oracle = _config.oracle;\n            require(ms().collateralAssets[_collateralAsset].uintPrice() != 0, Error.ADDRESS_INVALID_ORACLE);\n        }\n\n        /* --------------------------------- cFactor -------------------------------- */\n        ms().collateralAssets[_collateralAsset].factor = _config.factor;\n\n        /* ------------------------------ liqIncentive ------------------------------ */\n        ms().collateralAssets[_collateralAsset].liquidationIncentive = _config.liquidationIncentive;\n\n        emit MinterEvent.CollateralAssetUpdated(\n            _collateralAsset,\n            _config.factor,\n            address(ms().collateralAssets[_collateralAsset].oracle),\n            address(ms().collateralAssets[_collateralAsset].marketStatusOracle),\n            ms().collateralAssets[_collateralAsset].anchor,\n            _config.liquidationIncentive\n        );\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               Kresko Assets                                */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IConfigurationFacet\n    function addKreskoAsset(\n        address _krAsset,\n        KrAsset memory _config\n    ) external onlyRole(Role.ADMIN) kreskoAssetDoesNotExist(_krAsset) {\n        require(_config.kFactor >= Constants.ONE_HUNDRED_PERCENT, Error.KRASSET_INVALID_FACTOR);\n        require(_config.closeFee <= Constants.MAX_CLOSE_FEE, Error.PARAM_CLOSE_FEE_TOO_HIGH);\n        require(_config.openFee <= Constants.MAX_OPEN_FEE, Error.PARAM_OPEN_FEE_TOO_HIGH);\n        require(\n            IERC165(_krAsset).supportsInterface(type(IKISS).interfaceId) ||\n                IERC165(_krAsset).supportsInterface(type(IKreskoAsset).interfaceId),\n            Error.KRASSET_INVALID_CONTRACT\n        );\n        require(\n            IERC165(_config.anchor).supportsInterface(type(IKreskoAssetIssuer).interfaceId),\n            Error.KRASSET_INVALID_ANCHOR\n        );\n        // The diamond needs the operator role\n        require(IKreskoAsset(_krAsset).hasRole(Role.OPERATOR, address(this)), Error.NOT_OPERATOR);\n\n        // Oracle decimals must match the configuration.\n        require(_config.oracle.decimals() == ms().extOracleDecimals, Error.INVALID_ORACLE_DECIMALS);\n\n        /* ---------------------------------- Save ---------------------------------- */\n        ms().kreskoAssets[_krAsset] = KrAsset({\n            kFactor: _config.kFactor,\n            oracle: _config.oracle,\n            marketStatusOracle: _config.marketStatusOracle,\n            anchor: _config.anchor,\n            supplyLimit: _config.supplyLimit,\n            closeFee: _config.closeFee,\n            openFee: _config.openFee,\n            exists: true\n        });\n\n        emit MinterEvent.KreskoAssetAdded(\n            _krAsset,\n            _config.anchor,\n            address(_config.oracle),\n            address(_config.marketStatusOracle),\n            _config.kFactor,\n            _config.supplyLimit,\n            _config.closeFee,\n            _config.openFee\n        );\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateKreskoAsset(\n        address _krAsset,\n        KrAsset memory _config\n    ) external onlyRole(Role.ADMIN) kreskoAssetExists(_krAsset) {\n        require(_config.kFactor >= Constants.ONE_HUNDRED_PERCENT, Error.KRASSET_INVALID_FACTOR);\n        require(_config.closeFee <= Constants.MAX_CLOSE_FEE, Error.PARAM_CLOSE_FEE_TOO_HIGH);\n        require(_config.openFee <= Constants.MAX_OPEN_FEE, Error.PARAM_OPEN_FEE_TOO_HIGH);\n        require(\n            IERC165(_krAsset).supportsInterface(type(IKISS).interfaceId) ||\n                IERC165(_krAsset).supportsInterface(type(IKreskoAsset).interfaceId),\n            Error.KRASSET_INVALID_CONTRACT\n        );\n\n        KrAsset memory krAsset = ms().kreskoAssets[_krAsset];\n\n        /* --------------------------------- Anchor --------------------------------- */\n        if (_config.anchor != address(0)) {\n            require(\n                IERC165(_config.anchor).supportsInterface(type(IKreskoAssetIssuer).interfaceId),\n                Error.KRASSET_INVALID_ANCHOR\n            );\n            krAsset.anchor = _config.anchor;\n        }\n\n        /* ------------------------------ Market status ----------------------------- */\n        if (address(_config.marketStatusOracle) != address(0)) {\n            krAsset.marketStatusOracle = _config.marketStatusOracle;\n        }\n\n        /* ------------------------------- Price feed ------------------------------- */\n        if (address(_config.oracle) != address(0)) {\n            require(_config.oracle.decimals() == ms().extOracleDecimals, Error.INVALID_ORACLE_DECIMALS);\n            krAsset.oracle = _config.oracle;\n            require(krAsset.uintPrice() != 0, Error.ADDRESS_INVALID_ORACLE);\n        }\n\n        /* -------------------------- Factors, Fees, Limits ------------------------- */\n        krAsset.kFactor = _config.kFactor;\n        krAsset.supplyLimit = _config.supplyLimit;\n        krAsset.closeFee = _config.closeFee;\n        krAsset.openFee = _config.openFee;\n\n        /* ---------------------------------- Save ---------------------------------- */\n        ms().kreskoAssets[_krAsset] = krAsset;\n\n        emit MinterEvent.KreskoAssetUpdated(\n            _krAsset,\n            krAsset.anchor,\n            address(krAsset.oracle),\n            address(krAsset.marketStatusOracle),\n            krAsset.kFactor,\n            krAsset.supplyLimit,\n            krAsset.closeFee,\n            krAsset.openFee\n        );\n    }\n}\n"
    },
    "src/contracts/minter/facets/DepositWithdrawFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IDepositWithdrawFacet} from \"../interfaces/IDepositWithdrawFacet.sol\";\n\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\n\nimport {SafeERC20, IERC20Permit} from \"../../shared/SafeERC20.sol\";\nimport {MinterModifiers} from \"../MinterModifiers.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\nimport {Action, KrAsset} from \"../MinterTypes.sol\";\nimport {ms} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {ICollateralReceiver} from \"../interfaces/ICollateralReceiver.sol\";\n\n/**\n * @author Kresko\n * @title DepositWithdrawFacet\n * @notice Main end-user functionality concerning collateral asset deposits and withdrawals within the Kresko protocol\n */\ncontract DepositWithdrawFacet is DiamondModifiers, MinterModifiers, IDepositWithdrawFacet {\n    using SafeERC20 for IERC20Permit;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Collateral                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IDepositWithdrawFacet\n    function depositCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _depositAmount\n    ) external nonReentrant collateralAssetExists(_collateralAsset) {\n        if (ms().safetyStateSet) {\n            super.ensureNotPaused(_collateralAsset, Action.Deposit);\n        }\n\n        // Transfer tokens into this contract prior to any state changes as an extra measure against re-entrancy.\n        IERC20Permit(_collateralAsset).safeTransferFrom(msg.sender, address(this), _depositAmount);\n\n        // Record the collateral deposit.\n        ms().recordCollateralDeposit(_account, _collateralAsset, _depositAmount);\n    }\n\n    /// @inheritdoc IDepositWithdrawFacet\n    function withdrawCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _depositedCollateralAssetIndex\n    ) external nonReentrant collateralAssetExists(_collateralAsset) onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        if (ms().safetyStateSet) {\n            ensureNotPaused(_collateralAsset, Action.Withdraw);\n        }\n\n        uint256 collateralDeposits = ms().getCollateralDeposits(_account, _collateralAsset);\n        _withdrawAmount = (_withdrawAmount > collateralDeposits ? collateralDeposits : _withdrawAmount);\n\n        ms().verifyAndRecordCollateralWithdrawal(\n            _account,\n            _collateralAsset,\n            _withdrawAmount,\n            collateralDeposits,\n            _depositedCollateralAssetIndex\n        );\n\n        IERC20Permit(_collateralAsset).safeTransfer(_account, _withdrawAmount);\n    }\n\n    /// @inheritdoc IDepositWithdrawFacet\n    function withdrawCollateralUnchecked(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _depositedCollateralAssetIndex,\n        bytes memory _userData\n    ) external collateralAssetExists(_collateralAsset) onlyRole(Role.MANAGER) {\n        if (ms().safetyStateSet) {\n            ensureNotPaused(_collateralAsset, Action.Withdraw);\n        }\n\n        uint256 collateralDeposits = ms().getCollateralDeposits(_account, _collateralAsset);\n        _withdrawAmount = (_withdrawAmount > collateralDeposits ? collateralDeposits : _withdrawAmount);\n\n        // perform unchecked withdrawal\n        ms().recordCollateralWithdrawal(\n            _account,\n            _collateralAsset,\n            _withdrawAmount,\n            collateralDeposits,\n            _depositedCollateralAssetIndex\n        );\n\n        // transfer the withdrawn asset to the caller\n        IERC20Permit(_collateralAsset).safeTransfer(msg.sender, _withdrawAmount);\n\n        // Executes the callback on the caller after sending them the withdrawn collateral\n        ICollateralReceiver(msg.sender).onUncheckedCollateralWithdraw(\n            _account,\n            _collateralAsset,\n            _withdrawAmount,\n            _depositedCollateralAssetIndex,\n            _userData\n        );\n\n        /*\n         Perform the MCR check after the callback has been executed\n         Ensures accountCollateralValue remains over accountMinColateralValueAtRatio(MCR)\n         Emits MinterEvent.UncheckedCollateralWithdrawn\n         _withdrawAmount is 0 since deposits reduced in recordCollateralWithdrawal\n        */\n        ms().verifyAccountCollateral(_account, _collateralAsset, 0);\n    }\n}\n"
    },
    "src/contracts/minter/facets/InterestLiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IInterestLiquidationFacet} from \"../interfaces/IInterestLiquidationFacet.sol\";\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {LibCalculation} from \"../libs/LibCalculation.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {MinterEvent, InterestRateEvent} from \"../../libs/Events.sol\";\nimport {SafeERC20, IERC20Permit} from \"../../shared/SafeERC20.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\nimport {KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title InterestLiquidationFacet\n * @notice Main end-user functionality concerning liquidations of accrued KISS interest within the Kresko protocol\n */\ncontract InterestLiquidationFacet is DiamondModifiers, IInterestLiquidationFacet {\n    using Arrays for address[];\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n    using SafeERC20 for IERC20Permit;\n\n    /// @inheritdoc IInterestLiquidationFacet\n    function batchLiquidateInterest(address _account, address _collateralAssetToSeize) external nonReentrant {\n        // Borrower cannot liquidate themselves\n        require(msg.sender != _account, Error.SELF_LIQUIDATION);\n        // Check that this account is below its minimum collateralization ratio and can be liquidated.\n        require(ms().isAccountLiquidatable(_account), Error.NOT_LIQUIDATABLE);\n        // Collateral exists\n        require(ms().collateralAssets[_collateralAssetToSeize].exists, Error.COLLATERAL_DOESNT_EXIST);\n\n        address[] memory mintedKreskoAssets = ms().getMintedKreskoAssets(_account);\n\n        // Loop all accounts minted assets and sum all accrued kiss interest\n        uint256 kissAmountToRepay;\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            address repayKreskoAsset = mintedKreskoAssets[i];\n            // Repays the full interest of this asset on behalf of the account being liquidated\n            kissAmountToRepay += ms().repayFullStabilityRateInterest(_account, repayKreskoAsset);\n            // If the liquidation repays the user's entire Kresko asset balance, remove it from minted assets array.\n            if (ms().kreskoAssetDebt[_account][repayKreskoAsset] == 0) {\n                ms().mintedKreskoAssets[_account].removeAddress(repayKreskoAsset, i);\n            }\n            // Check if the status with amount repaid is still underwater, if so no further liquidation is needed\n            if (\n                !ms().isAccountLiquidatable(\n                    _account,\n                    kissAmountToRepay.fromWadPriceToUint().wadMul(\n                        ms().collateralAssets[_collateralAssetToSeize].liquidationIncentive\n                    )\n                )\n            ) break;\n        }\n\n        // Emit a separate event for batch repayment itself\n        emit InterestRateEvent.StabilityRateInterestBatchRepaid(_account, kissAmountToRepay);\n\n        // Seize collateral and send to liquidator according to the repayment made\n        uint256 collateralSeizeAmount = _seizeAndTransferCollateral(\n            _account,\n            _collateralAssetToSeize,\n            ms().getDepositedCollateralAssetIndex(_account, _collateralAssetToSeize),\n            kissAmountToRepay\n        );\n\n        emit MinterEvent.BatchInterestLiquidationOccurred(\n            _account,\n            msg.sender,\n            _collateralAssetToSeize,\n            kissAmountToRepay,\n            collateralSeizeAmount\n        );\n    }\n\n    /// @inheritdoc IInterestLiquidationFacet\n    function liquidateInterest(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize\n    ) external nonReentrant {\n        // Borrower cannot liquidate themselves\n        require(msg.sender != _account, Error.SELF_LIQUIDATION);\n        // krAsset exists\n        require(ms().kreskoAssets[_repayKreskoAsset].exists, Error.KRASSET_DOESNT_EXIST);\n        // Check that this account is below its minimum collateralization ratio and can be liquidated.\n        require(ms().isAccountLiquidatable(_account), Error.NOT_LIQUIDATABLE);\n        // Collateral exists\n        require(ms().collateralAssets[_collateralAssetToSeize].exists, Error.COLLATERAL_DOESNT_EXIST);\n\n        // Repays the full interest of this asset on behalf of the account being liquidated\n        uint256 kissRepayAmount = ms().repayFullStabilityRateInterest(_account, _repayKreskoAsset);\n\n        uint256 mintedKreskoAssetIndex = ms().getMintedKreskoAssetsIndex(_account, _repayKreskoAsset);\n\n        // Seize collateral and send to liquidator according to the repayment made\n        uint256 collateralAmountSeized = _seizeAndTransferCollateral(\n            _account,\n            _collateralAssetToSeize,\n            ms().getDepositedCollateralAssetIndex(_account, _collateralAssetToSeize),\n            kissRepayAmount\n        );\n\n        // If the liquidation repays the user's entire Kresko asset balance, remove it from minted assets array.\n        if (ms().kreskoAssetDebt[_account][_repayKreskoAsset] == 0) {\n            ms().mintedKreskoAssets[_account].removeAddress(_repayKreskoAsset, mintedKreskoAssetIndex);\n        }\n\n        emit MinterEvent.InterestLiquidationOccurred(\n            _account,\n            msg.sender,\n            _repayKreskoAsset,\n            kissRepayAmount, // without the liquidation bonus\n            _collateralAssetToSeize,\n            collateralAmountSeized // with the liquidation bonus\n        );\n    }\n\n    /**\n     * @notice Internal function to perform collateral seizing when interest gets liquidated\n     * @dev\n     * @param _account Account being liquidated\n     * @param _collateralAssetToSeize Collateral asset used to liquidate the debt\n     * @param _depositedCollateralAssetIndex Deposit index for the liquidated accounts collateral\n     * @param _kissRepayAmount Accrued KISS interest value being liquidated\n     */\n    function _seizeAndTransferCollateral(\n        address _account,\n        address _collateralAssetToSeize,\n        uint256 _depositedCollateralAssetIndex,\n        uint256 _kissRepayAmount\n    ) internal returns (uint256 seizeAmount) {\n        MinterState storage s = ms();\n\n        seizeAmount = s.collateralAssets[_collateralAssetToSeize].decimals.fromWad(\n            LibCalculation.calculateAmountToSeize(\n                s.collateralAssets[_collateralAssetToSeize].liquidationIncentive,\n                s.collateralAssets[_collateralAssetToSeize].uintPrice(),\n                _kissRepayAmount.fromWadPriceToUint()\n            )\n        );\n\n        // Collateral deposits for the seized asset of the account being liquidated\n        uint256 collateralDeposit = s.getCollateralDeposits(_account, _collateralAssetToSeize);\n\n        // Default case where deposits are greater than the seized amount\n        if (collateralDeposit > seizeAmount) {\n            // Convert the value being seized into non-rebasing value\n            s.collateralDeposits[_account][_collateralAssetToSeize] -= ms()\n                .collateralAssets[_collateralAssetToSeize]\n                .toNonRebasingAmount(seizeAmount);\n        } else {\n            // This clause means user either has collateralDeposits equal or less than the _seizeAmount\n            seizeAmount = collateralDeposit;\n            // So we set the collateralDeposits to 0\n            s.collateralDeposits[_account][_collateralAssetToSeize] = 0;\n            // And remove the asset from the deposits array.\n            s.depositedCollateralAssets[_account].removeAddress(\n                _collateralAssetToSeize,\n                _depositedCollateralAssetIndex\n            );\n        }\n\n        // Send liquidator the seized collateral.\n        IERC20Permit(_collateralAssetToSeize).safeTransfer(msg.sender, seizeAmount);\n    }\n}\n"
    },
    "src/contracts/minter/facets/LiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n// solhint-disable not-rely-on-time\n\nimport {ILiquidationFacet} from \"../interfaces/ILiquidationFacet.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {LibCalculation} from \"../libs/LibCalculation.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {SafeERC20, IERC20Permit} from \"../../shared/SafeERC20.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\n\nimport {Constants, KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title LiquidationFacet\n * @notice Main end-user functionality concerning liquidations within the Kresko protocol\n */\ncontract LiquidationFacet is DiamondModifiers, ILiquidationFacet {\n    using Arrays for address[];\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n    using SafeERC20 for IERC20Permit;\n\n    /// @inheritdoc ILiquidationFacet\n    function liquidate(\n        address _account,\n        address _repayAsset,\n        uint256 _repayAmount,\n        address _seizeAsset,\n        uint256 _repayAssetIndex,\n        uint256 _seizeAssetIndex\n    ) external nonReentrant {\n        MinterState storage s = ms();\n\n        CollateralAsset memory collateral = s.collateralAssets[_seizeAsset];\n        KrAsset memory krAsset = s.kreskoAssets[_repayAsset];\n\n        /* ------------------------------ Sanity checks ----------------------------- */\n        {\n            // No zero repays\n            require(_repayAmount != 0, Error.ZERO_REPAY);\n            // Borrower cannot liquidate themselves\n            require(msg.sender != _account, Error.SELF_LIQUIDATION);\n            // krAsset exists\n            require(krAsset.exists, Error.KRASSET_DOESNT_EXIST);\n            // Collateral exists\n            require(collateral.exists, Error.COLLATERAL_DOESNT_EXIST);\n            // Check that this account is below its minimum collateralization ratio and can be liquidated.\n            require(s.isAccountLiquidatable(_account), Error.NOT_LIQUIDATABLE);\n        }\n\n        /* ------------------------------ Amount checks ----------------------------- */\n        // Repay amount USD = repay amount * KR asset USD exchange rate.\n        uint256 repayAmountUSD = krAsset.uintUSD(_repayAmount);\n\n        // Avoid deep stack\n        {\n            // Get the principal debt amount which is unscaled for interest.\n            uint256 krAssetDebt = s.getKreskoAssetDebtPrincipal(_account, _repayAsset);\n            // Cannot liquidate more than the account's debt\n            require(krAssetDebt >= _repayAmount, Error.KRASSET_BURN_AMOUNT_OVERFLOW);\n\n            // We limit liquidations to exactly Liquidation Threshold here.\n            uint256 maxLiquidableUSD = s.getMaxLiquidation(_account, krAsset, _seizeAsset);\n            require(repayAmountUSD <= maxLiquidableUSD, Error.LIQUIDATION_OVERFLOW);\n        }\n\n        /* ------------------------------- Charge fee ------------------------------- */\n        s.chargeCloseFee(_account, _repayAsset, _repayAmount);\n\n        /* -------------------------------- Liquidate ------------------------------- */\n        uint256 seizedAmount = _liquidateAssets(\n            ExecutionParams(\n                _account,\n                _repayAmount,\n                collateral.decimals.fromWad(\n                    LibCalculation.calculateAmountToSeize(\n                        collateral.liquidationIncentive,\n                        collateral.uintPrice(),\n                        repayAmountUSD\n                    )\n                ),\n                _repayAsset,\n                _repayAssetIndex,\n                _seizeAsset,\n                _seizeAssetIndex\n            )\n        );\n\n        /* ---------------------------- Balance transfer ---------------------------- */\n        // Send liquidator the seized collateral.\n        IERC20Permit(_seizeAsset).safeTransfer(msg.sender, seizedAmount);\n\n        emit MinterEvent.LiquidationOccurred(\n            _account,\n            // solhint-disable-next-line avoid-tx-origin\n            tx.origin,\n            _repayAsset,\n            _repayAmount,\n            _seizeAsset,\n            seizedAmount\n        );\n    }\n\n    /// @notice Execute the liquidation\n    /// @dev Also updates stability rate and debt index\n    function _liquidateAssets(ExecutionParams memory params) internal returns (uint256 seizedAmount) {\n        MinterState storage s = ms();\n\n        /* -------------------------------------------------------------------------- */\n        /*                                 Reduce debt                                */\n        /* -------------------------------------------------------------------------- */\n        {\n            /* ----------------------------- Destroy assets ----------------------------- */\n            uint256 destroyed = IKreskoAssetIssuer(s.kreskoAssets[params.repayAsset].anchor).destroy(\n                params.repayAmount,\n                msg.sender\n            );\n            s.kreskoAssetDebt[params.account][params.repayAsset] -= destroyed;\n\n            /* ------------------------ Debt index + rate updates ----------------------- */\n\n            uint256 newDebtIndex = irs().srAssets[params.repayAsset].updateDebtIndex();\n            uint256 amountScaled = destroyed.wadToRay().rayDiv(newDebtIndex);\n\n            irs().srUserInfo[params.account][params.repayAsset].debtScaled -= uint128(amountScaled);\n            irs().srUserInfo[params.account][params.repayAsset].lastDebtIndex = uint128(newDebtIndex);\n\n            irs().srAssets[params.repayAsset].updateStabilityRate();\n        }\n\n        // If the liquidation repays entire asset debt, remove from minted assets array.\n        if (s.kreskoAssetDebt[params.account][params.repayAsset] == 0) {\n            s.mintedKreskoAssets[params.account].removeAddress(params.repayAsset, params.repayAssetIndex);\n        }\n\n        /* -------------------------------------------------------------------------- */\n        /*                              Reduce collateral                             */\n        /* -------------------------------------------------------------------------- */\n\n        uint256 collateralDeposits = s.getCollateralDeposits(params.account, params.seizedAsset);\n\n        /* ------------------------ Above collateral deposits ----------------------- */\n        if (collateralDeposits > params.seizeAmount) {\n            s.collateralDeposits[params.account][params.seizedAsset] -= ms()\n                .collateralAssets[params.seizedAsset]\n                .toNonRebasingAmount(params.seizeAmount);\n\n            return params.seizeAmount; // Passthrough value as is.\n        }\n\n        /* ------------------- Exact or below collateral deposits ------------------- */\n        // Remove the collateral deposits.\n        s.collateralDeposits[params.account][params.seizedAsset] = 0;\n        // Remove from the deposits array.\n        s.depositedCollateralAssets[params.account].removeAddress(params.seizedAsset, params.seizedAssetIndex);\n        // Seized amount is the collateral deposits.\n        return collateralDeposits;\n    }\n\n    /// @inheritdoc ILiquidationFacet\n    function isAccountLiquidatable(address _account) external view returns (bool) {\n        return ms().isAccountLiquidatable(_account);\n    }\n\n    /// @inheritdoc ILiquidationFacet\n    function getMaxLiquidation(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize\n    ) public view returns (uint256 maxLiquidatableUSD) {\n        return ms().getMaxLiquidation(_account, ms().kreskoAssets[_repayKreskoAsset], _collateralAssetToSeize);\n    }\n}\n"
    },
    "src/contracts/minter/facets/MintFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IMintFacet} from \"../interfaces/IMintFacet.sol\";\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {MinterModifiers} from \"../MinterModifiers.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\nimport {Action, KrAsset} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title MintFacet\n * @notice Main end-user functionality concerning minting kresko assets\n */\ncontract MintFacet is DiamondModifiers, MinterModifiers, IMintFacet {\n    using Arrays for address[];\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  KrAssets                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IMintFacet\n    function mintKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _mintAmount\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        require(_mintAmount > 0, Error.ZERO_MINT);\n\n        MinterState storage s = ms();\n        if (s.safetyStateSet) {\n            super.ensureNotPaused(_kreskoAsset, Action.Borrow);\n        }\n\n        // Enforce krAsset's total supply limit\n        KrAsset memory krAsset = s.kreskoAssets[_kreskoAsset];\n        require(krAsset.marketStatusOracle.latestMarketOpen(), Error.KRASSET_MARKET_CLOSED);\n\n        require(\n            IKreskoAsset(_kreskoAsset).totalSupply() + _mintAmount <= krAsset.supplyLimit,\n            Error.KRASSET_MAX_SUPPLY_REACHED\n        );\n\n        if (krAsset.openFee > 0) {\n            s.chargeOpenFee(_account, _kreskoAsset, _mintAmount);\n        }\n        {\n            // Get the account's current minimum collateral value required to maintain current debts.\n            // Calculate additional collateral amount required to back requested additional mint.\n            // Verify that minter has sufficient collateral to back current debt + new requested debt.\n            require(\n                s.getAccountMinimumCollateralValueAtRatio(_account, s.minimumCollateralizationRatio) +\n                    s.getMinimumCollateralValueAtRatio(_kreskoAsset, _mintAmount, s.minimumCollateralizationRatio) <=\n                    s.getAccountCollateralValue(_account),\n                Error.KRASSET_COLLATERAL_LOW\n            );\n        }\n\n        // The synthetic asset debt position must be greater than the minimum debt position value\n        uint256 existingDebt = s.getKreskoAssetDebtScaled(_account, _kreskoAsset);\n        require(krAsset.uintUSD(existingDebt + _mintAmount) >= s.minimumDebtValue, Error.KRASSET_MINT_AMOUNT_LOW);\n\n        // If the account does not have an existing debt for this Kresko Asset,\n        // push it to the list of the account's minted Kresko Assets.\n        if (existingDebt == 0) {\n            s.mintedKreskoAssets[_account].push(_kreskoAsset);\n        }\n\n        // Record the mint.\n        s.mint(_kreskoAsset, krAsset.anchor, _mintAmount, _account);\n\n        // Emit logs\n        emit MinterEvent.KreskoAssetMinted(_account, _kreskoAsset, _mintAmount);\n    }\n}\n"
    },
    "src/contracts/minter/facets/SafetyCouncilFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {ISafetyCouncilFacet} from \"../interfaces/ISafetyCouncilFacet.sol\";\n\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {Authorization, Role} from \"../../libs/Authorization.sol\";\n\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\nimport {MinterModifiers} from \"../MinterModifiers.sol\";\n\nimport {Action, SafetyState, Pause} from \"../MinterTypes.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @author Kresko\n * @title SafetyCouncilFacet - protocol safety controls\n * @notice `Role.SAFETY_COUNCIL` must be a multisig.\n */\ncontract SafetyCouncilFacet is MinterModifiers, DiamondModifiers, ISafetyCouncilFacet {\n    /// @inheritdoc ISafetyCouncilFacet\n    function toggleAssetsPaused(\n        address[] calldata _assets,\n        Action _action,\n        bool _withDuration,\n        uint256 _duration\n    ) external override onlyRole(Role.SAFETY_COUNCIL) {\n        bool enabled;\n        /// @dev loop through `_assets` - be it krAsset or collateral\n        for (uint256 i; i < _assets.length; i++) {\n            address asset = _assets[i];\n            // Revert if invalid address is supplied\n            require(\n                ms().collateralAssets[asset].exists || ms().kreskoAssets[asset].exists,\n                Error.INVALID_ASSET_SUPPLIED\n            );\n            // Get the safety state\n            SafetyState memory safetyState = ms().safetyState[asset][_action];\n            // Flip the previous value\n            bool willPause = !safetyState.pause.enabled;\n            // Set a global flag in case any asset gets set to true\n            if (willPause) {\n                enabled = true;\n            }\n            // Update the state for this asset\n            ms().safetyState[asset][_action].pause = Pause(\n                willPause,\n                block.timestamp,\n                _withDuration ? block.timestamp + _duration : 0\n            );\n            // Emit the actions taken\n            emit MinterEvent.SafetyStateChange(_action, asset, enabled ? \"paused\" : \"unpaused\");\n        }\n    }\n\n    /// @inheritdoc ISafetyCouncilFacet\n    function safetyStateSet() external view override returns (bool) {\n        return ms().safetyStateSet;\n    }\n\n    /// @inheritdoc ISafetyCouncilFacet\n    function safetyStateFor(address _asset, Action _action) external view override returns (SafetyState memory) {\n        return ms().safetyState[_asset][_action];\n    }\n\n    /// @inheritdoc ISafetyCouncilFacet\n    function assetActionPaused(Action _action, address _asset) external view returns (bool) {\n        return ms().safetyState[_asset][_action].pause.enabled;\n    }\n}\n"
    },
    "src/contracts/minter/facets/StabilityRateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {InterestRateEvent} from \"../../libs/Events.sol\";\nimport {LibStabilityRate} from \"../libs/LibStabilityRate.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {StabilityRateConfig} from \"../InterestRateState.sol\";\nimport {ms} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {IERC20Permit} from \"../../shared/IERC20Permit.sol\";\nimport {IStabilityRateFacet} from \"../interfaces/IStabilityRateFacet.sol\";\nimport {DiamondModifiers, Role} from \"../../diamond/DiamondModifiers.sol\";\nimport {MinterModifiers, Error} from \"../MinterModifiers.sol\";\nimport {SafeERC20, IERC20Permit} from \"../../shared/SafeERC20.sol\";\n\n/* solhint-disable var-name-mixedcase */\n\n// Stability Rate setup params\nstruct StabilityRateParams {\n    uint128 stabilityRateBase;\n    uint128 rateSlope1;\n    uint128 rateSlope2;\n    uint128 optimalPriceRate;\n    uint128 priceRateDelta;\n}\n\n/**\n * @title Stability rate facet\n * @author Kresko\n * @notice Stability rate related views and state operations\n * @dev Uses both MinterState (ms) and InterestRateState (irs)\n */\ncontract StabilityRateFacet is IStabilityRateFacet, MinterModifiers, DiamondModifiers {\n    using Arrays for address[];\n    using SafeERC20 for IERC20Permit;\n    using LibStabilityRate for StabilityRateConfig;\n    using WadRay for uint256;\n    using LibDecimals for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              ASSET STATE WRITES                            */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IStabilityRateFacet\n    function setupStabilityRateParams(address _asset, StabilityRateParams memory _setup) external onlyRole(Role.ADMIN) {\n        require(irs().kiss != address(0), Error.KISS_NOT_SET);\n        require(irs().srAssets[_asset].asset == address(0), Error.STABILITY_RATES_ALREADY_INITIALIZED);\n        require(WadRay.RAY >= _setup.optimalPriceRate, Error.INVALID_OPTIMAL_RATE);\n        require(WadRay.RAY >= _setup.priceRateDelta, Error.INVALID_PRICE_RATE_DELTA);\n\n        irs().srAssets[_asset] = StabilityRateConfig({\n            debtIndex: uint128(WadRay.RAY),\n            stabilityRateBase: _setup.stabilityRateBase,\n            // solhint-disable not-rely-on-time\n            lastUpdateTimestamp: uint40(block.timestamp),\n            asset: _asset,\n            rateSlope1: _setup.rateSlope1,\n            rateSlope2: _setup.rateSlope2,\n            optimalPriceRate: _setup.optimalPriceRate,\n            priceRateDelta: _setup.priceRateDelta,\n            stabilityRate: uint128(WadRay.RAY)\n        });\n\n        emit InterestRateEvent.StabilityRateConfigured(\n            _asset,\n            _setup.stabilityRateBase,\n            _setup.priceRateDelta,\n            _setup.rateSlope1,\n            _setup.rateSlope2\n        );\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function updateStabilityRateParams(\n        address _asset,\n        StabilityRateParams memory _setup\n    ) external onlyRole(Role.ADMIN) {\n        require(irs().srAssets[_asset].asset == _asset, Error.STABILITY_RATES_NOT_INITIALIZED);\n        require(WadRay.RAY >= _setup.optimalPriceRate, Error.INVALID_OPTIMAL_RATE);\n        require(WadRay.RAY >= _setup.priceRateDelta, Error.INVALID_PRICE_RATE_DELTA);\n\n        irs().srAssets[_asset].rateSlope1 = _setup.rateSlope1;\n        irs().srAssets[_asset].rateSlope2 = _setup.rateSlope2;\n        irs().srAssets[_asset].optimalPriceRate = _setup.optimalPriceRate;\n        irs().srAssets[_asset].priceRateDelta = _setup.priceRateDelta;\n        irs().srAssets[_asset].stabilityRateBase = _setup.stabilityRateBase;\n\n        emit InterestRateEvent.StabilityRateConfigured(\n            _asset,\n            _setup.stabilityRateBase,\n            _setup.priceRateDelta,\n            _setup.rateSlope1,\n            _setup.rateSlope2\n        );\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function updateStabilityRateAndIndexForAsset(address _asset) external {\n        irs().srAssets[_asset].updateDebtIndex();\n        irs().srAssets[_asset].updateStabilityRate();\n    }\n\n    function updateKiss(address _kiss) external onlyRole(Role.ADMIN) {\n        irs().kiss = _kiss;\n        emit InterestRateEvent.KISSUpdated(_kiss);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                REPAYMENT                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IStabilityRateFacet\n    function repayStabilityRateInterestPartial(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kissRepayAmount\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) {\n        // Update debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n\n        // Get the accrued interest in repayment token\n        (, uint256 maxKissRepayAmount) = ms().getKreskoAssetDebtInterest(_account, _kreskoAsset);\n        require(_kissRepayAmount < maxKissRepayAmount, Error.INTEREST_REPAY_NOT_PARTIAL);\n\n        // If no interest has accrued or 0 amount was supplied as parameter - no further operations needed\n        // Do not revert because we want the preserve new debt index and stability rate\n        // Also removes the need to check if the kresko asset exists as the maxKissAmount will return 0\n        if (_kissRepayAmount == 0 || maxKissRepayAmount == 0) {\n            // Update stability rate for asset\n            irs().srAssets[_kreskoAsset].updateStabilityRate();\n            return;\n        }\n\n        // Transfer the accrued interest\n        IERC20Permit(irs().kiss).safeTransferFrom(msg.sender, ms().feeRecipient, _kissRepayAmount);\n        uint256 assetAmount = _kissRepayAmount.divByPrice(ms().kreskoAssets[_kreskoAsset].uintPrice());\n        uint256 amountScaled = assetAmount.wadToRay().rayDiv(newDebtIndex);\n        // Update scaled values for the user\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled -= uint128(amountScaled);\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n        // Update stability rate for asset\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n\n        // Emit event with the account, asset and amount repaid\n        emit InterestRateEvent.StabilityRateInterestRepaid(_account, _kreskoAsset, _kissRepayAmount);\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function repayFullStabilityRateInterest(\n        address _account,\n        address _kreskoAsset\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) returns (uint256 kissRepayAmount) {\n        return ms().repayFullStabilityRateInterest(_account, _kreskoAsset);\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function batchRepayFullStabilityRateInterest(\n        address _account\n    ) external nonReentrant returns (uint256 kissRepayAmount) {\n        address[] memory mintedKreskoAssets = ms().getMintedKreskoAssets(_account);\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            kissRepayAmount += ms().repayFullStabilityRateInterest(_account, mintedKreskoAssets[i]);\n        }\n        emit InterestRateEvent.StabilityRateInterestBatchRepaid(_account, kissRepayAmount);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   VIEWS                                    */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IStabilityRateFacet\n    function getStabilityRateForAsset(address _asset) external view returns (uint256 stabilityRate) {\n        return irs().srAssets[_asset].calculateStabilityRate();\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function getPriceRateForAsset(address _asset) external view returns (uint256 priceRate) {\n        return irs().srAssets[_asset].getPriceRate();\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function getDebtIndexForAsset(address _asset) external view returns (uint256 debtIndex) {\n        return irs().srAssets[_asset].getNormalizedDebtIndex();\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function getStabilityRateConfigurationForAsset(address _asset) external view returns (StabilityRateConfig memory) {\n        return irs().srAssets[_asset];\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function kiss() external view returns (address) {\n        return irs().kiss;\n    }\n\n    function getLastDebtIndexForAccount(\n        address _account,\n        address _asset\n    ) external view returns (uint128 lastDebtIndex) {\n        return irs().srUserInfo[_account][_asset].lastDebtIndex;\n    }\n}\n"
    },
    "src/contracts/minter/facets/StateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IStateFacet} from \"../interfaces/IStateFacet.sol\";\n\nimport {MinterParams, KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {MinterState, ms} from \"../MinterStorage.sol\";\n\n/**\n * @author Kresko\n * @title View functions for protocol parameters and asset values\n * @dev As structs do not create views for members, we must expose most of the state values explicitly.\n */\ncontract StateFacet is IStateFacet {\n    /// @inheritdoc IStateFacet\n    function domainSeparator() external view returns (bytes32) {\n        return ms().domainSeparator;\n    }\n\n    /// @inheritdoc IStateFacet\n    function minterInitializations() external view returns (uint256) {\n        return ms().initializations;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Configurables                               */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IStateFacet\n    function feeRecipient() external view returns (address) {\n        return ms().feeRecipient;\n    }\n\n    /// @inheritdoc IStateFacet\n    function ammOracle() external view returns (address) {\n        return ms().ammOracle;\n    }\n\n    /// @inheritdoc IStateFacet\n    function extOracleDecimals() external view returns (uint8) {\n        return ms().extOracleDecimals;\n    }\n\n    /// @inheritdoc IStateFacet\n    function minimumCollateralizationRatio() external view returns (uint256) {\n        return ms().minimumCollateralizationRatio;\n    }\n\n    /// @inheritdoc IStateFacet\n    function liquidationIncentiveMultiplier() external view returns (uint256) {\n        return ms().liquidationIncentiveMultiplier;\n    }\n\n    /// @inheritdoc IStateFacet\n    function minimumDebtValue() external view returns (uint256) {\n        return ms().minimumDebtValue;\n    }\n\n    /// @inheritdoc IStateFacet\n    function liquidationThreshold() external view returns (uint256) {\n        return ms().liquidationThreshold;\n    }\n\n    /// @inheritdoc IStateFacet\n    function maxLiquidationMultiplier() external view returns (uint256) {\n        return ms().maxLiquidationMultiplier;\n    }\n\n    /// @inheritdoc IStateFacet\n    function getAllParams() external view returns (MinterParams memory) {\n        MinterState storage s = ms();\n        return\n            MinterParams(\n                s.minimumCollateralizationRatio,\n                s.minimumDebtValue,\n                s.liquidationThreshold,\n                s.liquidationIncentiveMultiplier,\n                s.feeRecipient,\n                s.extOracleDecimals\n            );\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Assets                                   */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IStateFacet\n    function krAssetExists(address _kreskoAsset) external view returns (bool exists) {\n        return ms().kreskoAssets[_kreskoAsset].exists;\n    }\n\n    /// @inheritdoc IStateFacet\n    function kreskoAsset(address _kreskoAsset) external view returns (KrAsset memory asset) {\n        return ms().kreskoAsset(_kreskoAsset);\n    }\n\n    /// @inheritdoc IStateFacet\n    function collateralExists(address _collateralAsset) external view returns (bool exists) {\n        return ms().collateralAssets[_collateralAsset].exists;\n    }\n\n    /// @inheritdoc IStateFacet\n    function collateralAsset(address _collateralAsset) external view returns (CollateralAsset memory asset) {\n        return ms().collateralAssets[_collateralAsset];\n    }\n\n    /// @inheritdoc IStateFacet\n    function getCollateralValueAndOraclePrice(\n        address _collateralAsset,\n        uint256 _amount,\n        bool _ignoreCollateralFactor\n    ) external view returns (uint256 value, uint256 oraclePrice) {\n        return ms().getCollateralValueAndOraclePrice(_collateralAsset, _amount, _ignoreCollateralFactor);\n    }\n\n    /// @inheritdoc IStateFacet\n    function getKrAssetValue(\n        address _kreskoAsset,\n        uint256 _amount,\n        bool _ignoreKFactor\n    ) external view returns (uint256 value) {\n        return ms().getKrAssetValue(_kreskoAsset, _amount, _ignoreKFactor);\n    }\n}\n"
    },
    "src/contracts/minter/facets/UIDataProviderFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n/* solhint-disable max-line-length */\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable func-name-mixedcase */\n/* solhint-disable contract-name-camelcase */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\nimport {LibUI, IKrStaking, IUniswapV2Pair, IERC20Permit, AggregatorV2V3Interface, ms} from \"../libs/LibUI.sol\";\n\n/**\n * @author Kresko\n * @title UIDataProviderFacet\n * @notice UI data aggregation views\n */\ncontract UIDataProviderFacet {\n    function getAccountData(\n        address _account,\n        address[] memory _tokens,\n        address _staking\n    )\n        external\n        view\n        returns (LibUI.KreskoUser memory user, LibUI.Balance[] memory balances, LibUI.StakingData[] memory stakingData)\n    {\n        user = LibUI.kreskoUser(_account);\n        balances = LibUI.getBalances(_tokens, _account);\n        stakingData = LibUI.getStakingData(_account, _staking);\n    }\n\n    function batchOracleValues(\n        address[] memory _assets,\n        address[] memory _oracles,\n        address[] memory _marketStatusOracles\n    ) public view returns (LibUI.Price[] memory result) {\n        return LibUI.batchOracleValues(_assets, _oracles, _marketStatusOracles);\n    }\n\n    function getTokenData(\n        address[] memory _allTokens,\n        address[] memory _assets,\n        address[] memory _priceFeeds,\n        address[] memory _marketStatusOracles\n    ) external view returns (LibUI.TokenMetadata[] memory metadatas, LibUI.Price[] memory prices) {\n        metadatas = new LibUI.TokenMetadata[](_allTokens.length);\n        for (uint256 i; i < _allTokens.length; i++) {\n            metadatas[i] = LibUI.TokenMetadata({\n                decimals: IERC20Permit(_allTokens[i]).decimals(),\n                name: IERC20Permit(_allTokens[i]).name(),\n                symbol: IERC20Permit(_allTokens[i]).symbol(),\n                totalSupply: IERC20Permit(_allTokens[i]).totalSupply()\n            });\n        }\n        prices = LibUI.batchOracleValues(_assets, _priceFeeds, _marketStatusOracles);\n    }\n}\n"
    },
    "src/contracts/minter/facets/UIDataProviderFacet2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n/* solhint-disable max-line-length */\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable func-name-mixedcase */\n/* solhint-disable contract-name-camelcase */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\nimport {LibUI, IKrStaking, IUniswapV2Pair, IERC20Permit, AggregatorV2V3Interface, ms} from \"../libs/LibUI.sol\";\n\n/**\n * @author Kresko\n * @title UIDataProviderFacet2\n * @notice UI data aggregation views\n */\ncontract UIDataProviderFacet2 {\n    function getGlobalData(\n        address[] memory _collateralAssets,\n        address[] memory _krAssets\n    )\n        external\n        view\n        returns (\n            LibUI.CollateralAssetInfo[] memory collateralAssets,\n            LibUI.krAssetInfo[] memory krAssets,\n            LibUI.ProtocolParams memory protocolParams\n        )\n    {\n        collateralAssets = LibUI.collateralAssetInfos(_collateralAssets);\n        krAssets = LibUI.krAssetInfos(_krAssets);\n        protocolParams = LibUI.ProtocolParams({\n            minCollateralRatio: ms().minimumCollateralizationRatio,\n            minDebtValue: ms().minimumDebtValue,\n            liquidationThreshold: ms().liquidationThreshold\n        });\n    }\n\n    function getPairsData(address[] memory _pairAddresses) external view returns (LibUI.PairData[] memory result) {\n        result = new LibUI.PairData[](_pairAddresses.length);\n        for (uint256 i; i < _pairAddresses.length; i++) {\n            IUniswapV2Pair pair = IUniswapV2Pair(_pairAddresses[i]);\n            (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\n            result[i] = LibUI.PairData({\n                decimals0: IERC20Permit(pair.token0()).decimals(),\n                decimals1: IERC20Permit(pair.token1()).decimals(),\n                totalSupply: pair.totalSupply(),\n                reserve0: reserve0,\n                reserve1: reserve1\n            });\n        }\n    }\n}\n"
    },
    "src/contracts/minter/initializers/FacetUpgrade16052023.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {ms} from \"../MinterStorage.sol\";\nimport {CollateralAsset} from \"../MinterTypes.sol\";\nimport {AggregatorV2V3Interface} from \"../../vendor/flux/FluxPriceFeed.sol\";\n\n/* solhint-disable var-name-mixedcase */\ninterface NewKresko {\n    function collateralAsset(address) external view returns (CollateralAsset memory);\n}\n\ninterface OldKresko {\n    struct CollateralOld {\n        uint256 factor;\n        AggregatorV2V3Interface oracle;\n        AggregatorV2V3Interface marketStatusOracle;\n        address anchor;\n        uint8 decimals;\n        bool exists;\n    }\n\n    function collateralAsset(address) external view returns (CollateralOld memory);\n}\n\ncontract FacetUpgrade16052023 {\n    function initialize() external {\n        ms().initializations += 1;\n        address DAI = 0x7ff84e6d3111327ED63eb97691Bf469C7fcE832F;\n        address WETH = 0x4200000000000000000000000000000000000006;\n        address krBTC = 0xf88721B9C87EBc86E3C91E6C98c0f646a75600f4;\n        address krETH = 0xbb37d6016f97Dd369eCB76e2A5036DacD8770f8b;\n        address krTSLA = 0x3502B0329a45011C8FEE033B8eEe6BDA89c03081;\n        address KISS = 0xC0B5aBa9F46bDf4D1bC52a4C3ab05C857aC4Ee80;\n        address[] memory collateralAssets = new address[](6);\n        collateralAssets[0] = DAI;\n        collateralAssets[1] = WETH;\n        collateralAssets[2] = krBTC;\n        collateralAssets[3] = krETH;\n        collateralAssets[4] = krTSLA;\n        collateralAssets[5] = KISS;\n        for (uint i = 0; i < collateralAssets.length; i++) {\n            address asset = collateralAssets[i];\n            ms().collateralAssets[asset].liquidationIncentive = 1.05 ether;\n        }\n\n        require(ms().collateralAssets[DAI].exists, \"!found\");\n        require(ms().collateralAssets[WETH].liquidationIncentive == 1.05 ether, \"!config\");\n\n        uint256 liqIncentive = NewKresko(0x0921a7234a2762aaB3C43d3b1F51dB5D8094a04b)\n            .collateralAsset(krBTC)\n            .liquidationIncentive;\n        require(liqIncentive == 1.05 ether, \"!found-new\");\n    }\n}\n"
    },
    "src/contracts/minter/InterestRateState.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {LibStabilityRate} from \"./libs/LibStabilityRate.sol\";\n\nusing LibStabilityRate for StabilityRateConfig global;\n\n/* solhint-disable var-name-mixedcase */\n\n// Asset data\nstruct StabilityRateConfig {\n    // Interest index for debt\n    uint128 debtIndex;\n    // Represents the optimal price rate between an oracle report and an AMM twap\n    uint128 optimalPriceRate;\n    // Slope of the variable interest curve when rate > 0 and <= optimalPriceRate.\n    // Expressed in ray\n    uint128 rateSlope1;\n    // Slope of the variable interest curve when rate > optimalPriceRate.\n    // Expressed in ray\n    uint128 rateSlope2;\n    /**\n     * Represents the excess price premium in either direction.\n     * Expressed in ray\n     * Eg. 1/20 ray = 5% price premium in either direction is considered excess\n     */\n    uint128 priceRateDelta;\n    // Current accrual rate for debt\n    uint128 stabilityRate;\n    // Base accrual rate for debt\n    uint128 stabilityRateBase;\n    // Asset to configure\n    address asset;\n    // Last update for the asset\n    uint40 lastUpdateTimestamp;\n}\n\n// User data\nstruct StabilityRateUser {\n    uint128 debtScaled;\n    uint128 lastDebtIndex;\n}\n\n// Storage layout\nstruct InterestRateState {\n    // asset address -> asset data\n    mapping(address => StabilityRateConfig) srAssets;\n    // account address -> asset address -> user data\n    mapping(address => mapping(address => StabilityRateUser)) srUserInfo;\n    // interest repayment token is KISS\n    address kiss;\n}\n\n// Storage position\nbytes32 constant INTEREST_RATE_STORAGE_POSITION = keccak256(\"kresko.interest.rate.storage\");\n\n// solhint-disable func-visibility\nfunction irs() pure returns (InterestRateState storage state) {\n    bytes32 position = INTEREST_RATE_STORAGE_POSITION;\n    assembly {\n        state.slot := position\n    }\n}\n"
    },
    "src/contracts/minter/interfaces/IAccountStateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {Action} from \"../MinterTypes.sol\";\n\ninterface IAccountStateFacet {\n    // ExpectedFeeRuntimeInfo is used for stack size optimization\n    struct ExpectedFeeRuntimeInfo {\n        address[] assets;\n        uint256[] amounts;\n        uint256 collateralTypeCount;\n    }\n\n    /**\n     * @notice Gets an array of Kresko assets the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @return An array of addresses of Kresko assets the account has minted.\n     */\n    function getMintedKreskoAssets(address _account) external view returns (address[] memory);\n\n    /**\n     * @notice Gets an index for the Kresko asset the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @param _kreskoAsset The asset lookup address.\n     * @return index of the minted Kresko asset.\n     */\n    function getMintedKreskoAssetsIndex(address _account, address _kreskoAsset) external view returns (uint256);\n\n    /**\n     * @notice Gets the Kresko asset value in USD of a particular account.\n     * @param _account The account to calculate the Kresko asset value for.\n     * @return The Kresko asset value of a particular account.\n     */\n    function getAccountKrAssetValue(address _account) external view returns (uint256);\n\n    /**\n     * @notice Get `_account` debt amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of debt for `_asset`\n     */\n    function kreskoAssetDebt(address _account, address _asset) external view returns (uint256);\n\n    /**\n     * @notice Get `_account` principal debt amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of principal debt for `_asset`\n     */\n    function kreskoAssetDebtPrincipal(address _account, address _asset) external view returns (uint256);\n\n    /**\n     * @notice Get `_account` interest amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return assetAmount the interest denominated in _asset\n     * @return kissAmount the interest denominated in KISS, ignores K-factor\n     */\n    function kreskoAssetDebtInterest(\n        address _account,\n        address _asset\n    ) external view returns (uint256 assetAmount, uint256 kissAmount);\n\n    /**\n     * @notice Get `_account` interest amount for `_asset`\n     * @param _account The account to query amount for\n     * @return kissAmount the interest denominated in KISS, ignores K-factor\n     */\n    function kreskoAssetDebtInterestTotal(address _account) external view returns (uint256 kissAmount);\n\n    /**\n     * @notice Gets the collateral value of a particular account.\n     * @dev O(# of different deposited collateral assets by account) complexity.\n     * @param _account The account to calculate the collateral value for.\n     * @return The collateral value of a particular account.\n     */\n    function getAccountCollateralValue(address _account) external view returns (uint256);\n\n    /**\n     * @notice Get an account's minimum collateral value required\n     * to back a Kresko asset amount at a given collateralization ratio.\n     * @dev Accounts that have their collateral value under the minimum collateral value are considered unhealthy,\n     *      accounts with their collateral value under the liquidation threshold are considered liquidatable.\n     * @param _account The account to calculate the minimum collateral value for.\n     * @param _ratio The collateralization ratio required: higher ratio = more collateral required\n     * @return The minimum collateral value of a particular account.\n     */\n    function getAccountMinimumCollateralValueAtRatio(address _account, uint256 _ratio) external view returns (uint256);\n\n    /**\n     * @notice Get a list of accounts and their collateral ratios\n     * @return ratio for an `_account`\n     */\n    function getAccountCollateralRatio(address _account) external view returns (uint256 ratio);\n\n    /**\n     * @notice Get a list of accounts and their collateral ratios\n     * @return ratios of the accounts\n     */\n    function getCollateralRatiosFor(address[] memory _accounts) external view returns (uint256[] memory);\n\n    /**\n     * @notice Get the adjusted value of collateral and the real value of collateral\n     * @dev The adjusted value of collateral is the value of collateral after adjusting for the cFactor\n     * @param _account The account to get the collateral values for.\n     * @param _asset The asset to get the collateral values for.\n     * @return adjustedValue The adjusted value of the collateral.\n     * @return realValue The real value of the collateral.\n     */\n    function getCollateralAdjustedAndRealValue(\n        address _account,\n        address _asset\n    ) external view returns (uint256 adjustedValue, uint256 realValue);\n\n    /**\n     * @notice Gets an index for the collateral asset the account has deposited.\n     * @param _account The account to get the index for.\n     * @param _collateralAsset The asset lookup address.\n     * @return i = index of the minted collateral asset.\n     */\n    function getDepositedCollateralAssetIndex(\n        address _account,\n        address _collateralAsset\n    ) external view returns (uint256 i);\n\n    /**\n     * @notice Gets an array of collateral assets the account has deposited.\n     * @param _account The account to get the deposited collateral assets for.\n     * @return An array of addresses of collateral assets the account has deposited.\n     */\n    function getDepositedCollateralAssets(address _account) external view returns (address[] memory);\n\n    /**\n     * @notice Get `_account` collateral deposit amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of collateral deposited for `_asset`\n     */\n    function collateralDeposits(address _account, address _asset) external view returns (uint256);\n\n    /**\n     * @notice Calculates the expected fee to be taken from a user's deposited collateral assets,\n     *         by imitating calcFee without modifying state.\n     * @param _account The account to charge the open fee from.\n     * @param _kreskoAsset The address of the kresko asset being burned.\n     * @param _kreskoAssetAmount The amount of the kresko asset being minted.\n     * @param _feeType The fee type (open, close, etc).\n     * @return assets The collateral types as an array of addresses.\n     * @return amounts The collateral amounts as an array of uint256.\n     */\n    function calcExpectedFee(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kreskoAssetAmount,\n        uint256 _feeType\n    ) external view returns (address[] memory, uint256[] memory);\n}\n"
    },
    "src/contracts/minter/interfaces/IBurnFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface IBurnFacet {\n    /**\n     * @notice Burns existing Kresko assets.\n     * @param _account The address to burn kresko assets for\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _burnAmount The amount of the Kresko asset to be burned.\n     * @param _mintedKreskoAssetIndex The index of the collateral asset in the user's minted assets array.\n     * @notice Only needed if burning all principal debt of a particular collateral asset.\n     */\n    function burnKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _burnAmount,\n        uint256 _mintedKreskoAssetIndex\n    ) external;\n}\n"
    },
    "src/contracts/minter/interfaces/IBurnHelperFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\ninterface IBurnHelperFacet {\n    /**\n     * @notice Attempts to close all debt positions and interest\n     * @notice Account must have enough of krAsset balance to burn and ennough KISS to cover interest\n     * @param _account The address to close the positions for\n     */\n    function batchCloseKrAssetDebtPositions(address _account) external;\n\n    /**\n     * @notice Burns all Kresko asset debt and repays interest.\n     * @notice Account must have enough of krAsset balance to burn and ennough KISS to cover interest\n     * @param _account The address to close the position for\n     * @param _kreskoAsset The address of the Kresko asset.\n     */\n    function closeKrAssetDebtPosition(address _account, address _kreskoAsset) external;\n}\n"
    },
    "src/contracts/minter/interfaces/ICollateralReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface ICollateralReceiver {\n    function onUncheckedCollateralWithdraw(\n        address _account,\n        address _collateralAsset,\n        uint _withdrawalAmount,\n        uint _depositedCollateralAssetIndex,\n        bytes memory _userData\n    ) external returns (bytes memory);\n}\n"
    },
    "src/contracts/minter/interfaces/IConfigurationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {MinterInitArgs, KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\n\ninterface IConfigurationFacet {\n    function initialize(MinterInitArgs calldata args) external;\n\n    /**\n     * @notice Adds a collateral asset to the protocol.\n     * @dev Only callable by the owner and cannot be called more than once for an asset.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _config The configuration for the collateral asset.\n     */\n    function addCollateralAsset(address _collateralAsset, CollateralAsset memory _config) external;\n\n    /**\n     * @notice Adds a KreskoAsset to the protocol.\n     * @dev Only callable by the owner.\n     * @param _krAsset The address of the wrapped KreskoAsset, needs to support IKreskoAsset.\n     * @param _config Configuration for the KreskoAsset.\n     */\n    function addKreskoAsset(address _krAsset, KrAsset memory _config) external;\n\n    /**\n     * @notice Updates a previously added collateral asset.\n     * @dev Only callable by the owner.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _config The configuration for the collateral asset.\n     */\n    function updateCollateralAsset(address _collateralAsset, CollateralAsset memory _config) external;\n\n    /**\n     * @notice Updates the k-factor of a previously added KreskoAsset.\n     * @dev Only callable by the owner.\n     * @param _krAsset The address of the KreskoAsset.\n     * @param _config Configuration for the KreskoAsset.\n     */\n    function updateKreskoAsset(address _krAsset, KrAsset memory _config) external;\n\n    /**\n     * @notice Updates the fee recipient.\n     * @param _feeRecipient The new fee recipient.\n     */\n    function updateFeeRecipient(address _feeRecipient) external;\n\n    /**\n     * @notice  Updates the cFactor of a KreskoAsset.\n     * @param _collateralAsset The collateral asset.\n     * @param _cFactor The new cFactor.\n     */\n    function updateCFactor(address _collateralAsset, uint256 _cFactor) external;\n\n    /**\n     * @notice Updates the kFactor of a KreskoAsset.\n     * @param _kreskoAsset The KreskoAsset.\n     * @param _kFactor The new kFactor.\n     */\n    function updateKFactor(address _kreskoAsset, uint256 _kFactor) external;\n\n    /**\n     * @notice Updates the liquidation incentive multiplier.\n     * @param _collateralAsset The collateral asset to update it for.\n     * @param _liquidationIncentiveMultiplier The new liquidation incentive multiplie.\n     */\n    function updateLiquidationIncentiveMultiplier(\n        address _collateralAsset,\n        uint256 _liquidationIncentiveMultiplier\n    ) external;\n\n    /**\n     * @notice Updates the max liquidation usd overflow multiplier value.\n     * @param _maxLiquidationMultiplier Overflow value in percent, 18 decimals.\n     */\n    function updateMaxLiquidationMultiplier(uint256 _maxLiquidationMultiplier) external;\n\n    /**\n     * @dev Updates the contract's collateralization ratio.\n     * @param _minimumCollateralizationRatio The new minimum collateralization ratio as wad.\n     */\n    function updateMinimumCollateralizationRatio(uint256 _minimumCollateralizationRatio) external;\n\n    /**\n     * @dev Updates the contract's minimum debt value.\n     * @param _minimumDebtValue The new minimum debt value as a wad.\n     */\n    function updateMinimumDebtValue(uint256 _minimumDebtValue) external;\n\n    /**\n     * @dev Updates the contract's liquidation threshold value\n     * @param _liquidationThreshold The new liquidation threshold value\n     */\n    function updateLiquidationThreshold(uint256 _liquidationThreshold) external;\n\n    /**\n     * @notice Sets the protocol AMM oracle address\n     * @param _ammOracle  The address of the oracle\n     */\n    function updateAMMOracle(address _ammOracle) external;\n\n    /**\n     * @notice Sets the decimal precision of external oracle\n     * @param _decimals Amount of decimals\n     */\n    function updateExtOracleDecimals(uint8 _decimals) external;\n}\n"
    },
    "src/contracts/minter/interfaces/IDepositWithdrawFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface IDepositWithdrawFacet {\n    /**\n     * @notice Deposits collateral into the protocol.\n     * @param _account The user to deposit collateral for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _depositAmount The amount of the collateral asset to deposit.\n     */\n    function depositCollateral(address _account, address _collateralAsset, uint256 _depositAmount) external;\n\n    /**\n     * @notice Withdraws sender's collateral from the protocol.\n     * @dev Requires that the post-withdrawal collateral value does not violate minimum collateral requirement.\n     * @param _account The address to withdraw assets for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\n     * @param _depositedCollateralAssetIndex The index of the collateral asset in the sender's deposited collateral\n     * assets array. Only needed if withdrawing the entire deposit of a particular collateral asset.\n     */\n    function withdrawCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _depositedCollateralAssetIndex\n    ) external;\n\n    /**\n     * @notice Withdraws sender's collateral from the protocol before checking minimum collateral ratio.\n     * @dev Executes post-withdraw-callback triggering onUncheckedCollateralWithdraw on the caller\n     * @dev Requires that the post-withdraw-callback collateral value does not violate minimum collateral requirement.\n     * @param _account The address to withdraw assets for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\n     * @param _depositedCollateralAssetIndex The index of the collateral asset in the sender's deposited collateral\n     * assets array. Only needed if withdrawing the entire deposit of a particular collateral asset.\n     */\n    function withdrawCollateralUnchecked(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _depositedCollateralAssetIndex,\n        bytes memory _userData\n    ) external;\n}\n"
    },
    "src/contracts/minter/interfaces/IInterestLiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface IInterestLiquidationFacet {\n    /**\n     * @notice Attempts to batch liquidate all KISS interest accrued for an account in a unhealthy position\n     * @notice Liquidator must have the KISS balance required with the Kresko contract approved\n     * @notice Checks liquidatable status on each iteration liquidating only what is necessary\n     * @param _account The account to attempt to liquidate.\n     * @param _collateralAssetToSeize The address of the collateral asset to be seized.\n     */\n    function batchLiquidateInterest(address _account, address _collateralAssetToSeize) external;\n\n    /**\n     * @notice Attempts to liquidate all KISS interest accrued for an account in a unhealthy position\n     * @notice Liquidator must have the KISS balance required with the Kresko contract approved\n     * @param _account The account to attempt to liquidate.\n     * @param _repayKreskoAsset The address of the Kresko asset to be repaid.\n     * @param _collateralAssetToSeize The address of the collateral asset to be seized.\n     */\n    function liquidateInterest(address _account, address _repayKreskoAsset, address _collateralAssetToSeize) external;\n}\n"
    },
    "src/contracts/minter/interfaces/ILiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface ILiquidationFacet {\n    /**\n     * @notice Attempts to liquidate an account by repaying the portion of the account's Kresko asset\n     *         princpal debt, receiving in return a portion of the account's collateral at a discounted rate.\n     * @param _account The account to attempt to liquidate.\n     * @param _repayAsset The address of the Kresko asset to be repaid.\n     * @param _repayAmount The amount of the Kresko asset to be repaid.\n     * @param _seizeAsset The address of the collateral asset to be seized.\n     * @param _repayAssetIndex The index of the Kresko asset in the account's minted assets array.\n     * @param _seizeAssetIndex Index of the collateral asset in the account's collateral assets array.\n     */\n    function liquidate(\n        address _account,\n        address _repayAsset,\n        uint256 _repayAmount,\n        address _seizeAsset,\n        uint256 _repayAssetIndex,\n        uint256 _seizeAssetIndex\n    ) external;\n\n    /**\n     * @notice used execute _liquidateAssets.\n     * @param account The account to attempt to liquidate.\n     * @param repayAmount The amount of the Kresko asset to be repaid.\n     * @param seizeAmount The calculated amount of collateral assets to be seized.\n     * @param repayAsset The address of the Kresko asset to be repaid.\n     * @param repayIndex The index of the Kresko asset in the user's minted assets array.\n     * @param seizeAsset The address of the collateral asset to be seized.\n     * @param seizeAssetIndex The index of the collateral asset in the account's collateral assets array.\n     * @param collateralDeposits The index of the collateral asset in the account's collateral assets array.\n     */\n    struct ExecutionParams {\n        address account;\n        uint256 repayAmount;\n        uint256 seizeAmount;\n        address repayAsset;\n        uint256 repayAssetIndex;\n        address seizedAsset;\n        uint256 seizedAssetIndex;\n    }\n\n    /**\n     * @dev Calculates the total value that can be liquidated for a liquidation pair\n     * @param _account address to liquidate\n     * @param _repayKreskoAsset address of the kreskoAsset being repaid on behalf of the liquidatee\n     * @return maxLiquidatableUSD USD value that can be liquidated, 0 if the pair has no liquidatable value\n     */\n    function getMaxLiquidation(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize\n    ) external view returns (uint256 maxLiquidatableUSD);\n\n    /**\n     * @notice Calculates if an account's current collateral value is under its minimum collateral value\n     * @dev Returns true if the account's current collateral value is below the minimum collateral value\n     * required to consider the position healthy.\n     * @param _account The account to check.\n     * @return A boolean indicating if the account can be liquidated.\n     */\n    function isAccountLiquidatable(address _account) external view returns (bool);\n}\n"
    },
    "src/contracts/minter/interfaces/IMintFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface IMintFacet {\n    /**\n     * @notice Mints new Kresko assets.\n     * @param _account The address to mint assets for.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _mintAmount The amount of the Kresko asset to be minted.\n     */\n    function mintKreskoAsset(address _account, address _kreskoAsset, uint256 _mintAmount) external;\n}\n"
    },
    "src/contracts/minter/interfaces/ISafetyCouncilFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {Action, SafetyState, Pause} from \"../MinterTypes.sol\";\n\ninterface ISafetyCouncilFacet {\n    /**\n     * @dev Toggle paused-state of assets in a per-action basis\n     *\n     * @notice These functions are only callable by a multisig quorum.\n     * @param _assets list of addresses of krAssets and/or collateral assets\n     * @param _action One of possible user actions:\n     *  Deposit = 0\n     *  Withdraw = 1,\n     *  Repay = 2,\n     *  Borrow = 3,\n     *  Liquidate = 4\n     * @param _withDuration Set a duration for this pause - @todo: implement it if required\n     * @param _duration Duration for the pause if `_withDuration` is true\n     */\n    function toggleAssetsPaused(\n        address[] memory _assets,\n        Action _action,\n        bool _withDuration,\n        uint256 _duration\n    ) external;\n\n    /**\n     * @notice For external checks if a safety state has been set for any asset\n     */\n    function safetyStateSet() external view returns (bool);\n\n    /**\n     * @notice View the state of safety measures for an asset on a per-action basis\n     * @param _asset krAsset / collateral asset\n     * @param _action One of possible user actions:\n     *\n     *  Deposit = 0\n     *  Withdraw = 1,\n     *  Repay = 2,\n     *  Borrow = 3,\n     *  Liquidate = 4\n     */\n    function safetyStateFor(address _asset, Action _action) external view returns (SafetyState memory);\n\n    /**\n     * @notice Check if `_asset` has a pause enabled for `_action`\n     * @param _action enum `Action`\n     *  Deposit = 0\n     *  Withdraw = 1,\n     *  Repay = 2,\n     *  Borrow = 3,\n     *  Liquidate = 4\n     * @return true if `_action` is paused\n     */\n    function assetActionPaused(Action _action, address _asset) external view returns (bool);\n}\n"
    },
    "src/contracts/minter/interfaces/IStabilityRateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {StabilityRateParams} from \"../facets/StabilityRateFacet.sol\";\nimport {StabilityRateConfig} from \"../InterestRateState.sol\";\n\ninterface IStabilityRateFacet {\n    /**\n     * @notice Initialize an asset with stability rate setup values\n     * @param _asset asset to setup\n     * @param _setup setup parameters\n     */\n    function setupStabilityRateParams(address _asset, StabilityRateParams memory _setup) external;\n\n    /**\n     * @notice Configure existing stability rate values\n     * @param _asset asset to configure\n     * @param _setup setup parameters\n     */\n    function updateStabilityRateParams(address _asset, StabilityRateParams memory _setup) external;\n\n    /// @notice Updates the debt index and stability rates for an asset\n    /// @param _asset asset to update rate and index for\n    function updateStabilityRateAndIndexForAsset(address _asset) external;\n\n    /**\n     * @notice Sets the protocol AMM oracle address\n     * @param _kiss  The address of the oracle\n     */\n    function updateKiss(address _kiss) external;\n\n    /**\n     * @notice Repays part of accrued stability rate interest for a single asset\n     * @param _account Account to repay interest for\n     * @param _kreskoAsset Kresko asset to repay interest for\n     * @param _kissRepayAmount USD value to repay (KISS)\n     */\n    function repayStabilityRateInterestPartial(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kissRepayAmount\n    ) external;\n\n    /**\n     * @notice Repays accrued stability rate interest for a single asset\n     * @param _account Account to repay interest for\n     * @param _kreskoAsset Kresko asset to repay interest for\n     * @return kissRepayAmount KISS value repaid\n     */\n    function repayFullStabilityRateInterest(\n        address _account,\n        address _kreskoAsset\n    ) external returns (uint256 kissRepayAmount);\n\n    /**\n     * @notice Repays all accrued stability rate interest for an account\n     * @param _account Account to repay all asset interests for\n     * @return kissRepayAmount KISS value repaid\n     */\n    function batchRepayFullStabilityRateInterest(address _account) external returns (uint256 kissRepayAmount);\n\n    /**\n     * @notice Gets the current stability rate for an asset\n     * @param _asset asset to get the stability rate for\n     * @return stabilityRate the return variables of a contract’s function state variable\n     * @dev expressed in ray\n     */\n    function getStabilityRateForAsset(address _asset) external view returns (uint256 stabilityRate);\n\n    /**\n     * @notice Gets the current price rate (difference between AMM <-> Oracle pricing)\n     * for an asset\n     * @param _asset asset to get the rate for\n     * @return priceRate the current\n     * @dev expressed in ray\n     */\n    function getPriceRateForAsset(address _asset) external view returns (uint256 priceRate);\n\n    /**\n     * @notice Gets the current running debt index\n     * @param _asset asset to get the index for\n     * @return debtIndex current running debt index\n     * @dev expressed in ray\n     */\n    function getDebtIndexForAsset(address _asset) external view returns (uint256 debtIndex);\n\n    /**\n     * @notice View stability rate configuration for an asset\n     * @param _asset asset to view configuration for\n     */\n    function getStabilityRateConfigurationForAsset(address _asset) external view returns (StabilityRateConfig memory);\n\n    /**\n     * @notice The configured address of KISS\n     */\n    function kiss() external view returns (address);\n\n    /**\n     * @notice Get user stability rate data for an asset\n     * @param _account asset to view configuration for\n     * @param _asset asset to view configuration for\n     * @return lastDebtIndex the previous debt index for the user\n     */\n    function getLastDebtIndexForAccount(address _account, address _asset) external view returns (uint128 lastDebtIndex);\n}\n"
    },
    "src/contracts/minter/interfaces/IStateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {CollateralAsset, KrAsset, MinterParams} from \"../MinterTypes.sol\";\n\ninterface IStateFacet {\n    /// @notice The EIP-712 typehash for the contract's domain.\n    function domainSeparator() external view returns (bytes32);\n\n    /// @notice amount of times the minter has been initialized\n    function minterInitializations() external view returns (uint256);\n\n    /// @notice The recipient of protocol fees.\n    function feeRecipient() external view returns (address);\n\n    /// @notice The AMM oracle address.\n    function ammOracle() external view returns (address);\n\n    /// @notice Offchain oracle decimals\n    function extOracleDecimals() external view returns (uint8);\n\n    /// @notice The collateralization ratio at which positions may be liquidated.\n    function liquidationThreshold() external view returns (uint256);\n\n    /// @notice The factor used to calculate the incentive a liquidator receives in the form of seized collateral.\n    function liquidationIncentiveMultiplier() external view returns (uint256);\n\n    /// @notice Multiplies max liquidatable value, allowing liquidations to go over LT.\n    function maxLiquidationMultiplier() external view returns (uint256);\n\n    /// @notice The minimum ratio of collateral to debt that can be taken by direct action.\n    function minimumCollateralizationRatio() external view returns (uint256);\n\n    /// @notice The minimum USD value of an individual synthetic asset debt position.\n    function minimumDebtValue() external view returns (uint256);\n\n    /// @notice simple check if kresko asset exists\n    function krAssetExists(address _krAsset) external view returns (bool);\n\n    /**\n     * @notice Get the state of a specific krAsset\n     * @param _asset Address of the asset.\n     * @return State of assets `KrAsset` struct\n     */\n    function kreskoAsset(address _asset) external view returns (KrAsset memory);\n\n    /// @notice Mapping of collateral asset token address to information on the collateral asset.\n    function collateralAsset(address _asset) external view returns (CollateralAsset memory);\n\n    /// @notice simple check if collateral asset exists\n    function collateralExists(address _collateralAsset) external view returns (bool);\n\n    /// @notice get all meaningful protocol parameters\n    function getAllParams() external view returns (MinterParams memory);\n\n    /**\n     * @notice Gets the USD value for a single collateral asset and amount.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _amount The amount of the collateral asset to calculate the value for.\n     * @param _ignoreCollateralFactor Boolean indicating if the asset's collateral factor should be ignored.\n     */\n    function getCollateralValueAndOraclePrice(\n        address _collateralAsset,\n        uint256 _amount,\n        bool _ignoreCollateralFactor\n    ) external view returns (uint256, uint256);\n\n    /**\n     * @notice Gets the USD value for a single Kresko asset and amount.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _amount The amount of the Kresko asset to calculate the value for.\n     * @param _ignoreKFactor Boolean indicating if the asset's k-factor should be ignored.\n     * @return The value for the provided amount of the Kresko asset.\n     */\n    function getKrAssetValue(\n        address _kreskoAsset,\n        uint256 _amount,\n        bool _ignoreKFactor\n    ) external view returns (uint256);\n}\n"
    },
    "src/contracts/minter/libs/LibAccount.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {MinterState} from \"../MinterState.sol\";\nimport {KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {RebaseMath} from \"../../kreskoasset/Rebase.sol\";\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\n\nlibrary LibAccount {\n    using RebaseMath for uint256;\n    using WadRay for uint256;\n    using LibDecimals for uint256;\n\n    /**\n     * @notice Gets an array of Kresko assets the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @return An array of addresses of Kresko assets the account has minted.\n     */\n    function getMintedKreskoAssets(\n        MinterState storage self,\n        address _account\n    ) internal view returns (address[] memory) {\n        return self.mintedKreskoAssets[_account];\n    }\n\n    /**\n     * @notice Gets an array of collateral assets the account has deposited.\n     * @param _account The account to get the deposited collateral assets for.\n     * @return An array of addresses of collateral assets the account has deposited.\n     */\n    function getDepositedCollateralAssets(\n        MinterState storage self,\n        address _account\n    ) internal view returns (address[] memory) {\n        return self.depositedCollateralAssets[_account];\n    }\n\n    /**\n     * @notice Get deposited collateral asset amount for an account\n     * @notice Performs rebasing conversion for KreskoAssets\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return uint256 amount of collateral for `_asset`\n     */\n    function getCollateralDeposits(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256) {\n        return self.collateralAssets[_asset].toRebasingAmount(self.collateralDeposits[_account][_asset]);\n    }\n\n    /**\n     * @notice Checks if accounts collateral value is less than required.\n     * @param _account The account to check.\n     * @return A boolean indicating if the account can be liquidated.\n     */\n    function isAccountLiquidatable(MinterState storage self, address _account) internal view returns (bool) {\n        return\n            self.getAccountCollateralValue(_account) <\n            (self.getAccountMinimumCollateralValueAtRatio(_account, self.liquidationThreshold));\n    }\n\n    /**\n     * @notice Overload for calculating liquidatable status with a future liquidated collateral value\n     * @param _account The account to check.\n     * @param _valueLiquidated Value liquidated, eg. in a batch liquidation\n     * @return bool indicating if the account can be liquidated.\n     */\n    function isAccountLiquidatable(\n        MinterState storage self,\n        address _account,\n        uint256 _valueLiquidated\n    ) internal view returns (bool) {\n        return\n            self.getAccountCollateralValue(_account) - _valueLiquidated <\n            (self.getAccountMinimumCollateralValueAtRatio(_account, self.liquidationThreshold));\n    }\n\n    /**\n     * @notice Gets the collateral value of a particular account.\n     * @dev O(# of different deposited collateral assets by account) complexity.\n     * @param _account The account to calculate the collateral value for.\n     * @return totalCollateralValue The collateral value of a particular account.\n     */\n    function getAccountCollateralValue(\n        MinterState storage self,\n        address _account\n    ) internal view returns (uint256 totalCollateralValue) {\n        address[] memory assets = self.depositedCollateralAssets[_account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            (uint256 collateralValue, ) = self.getCollateralValueAndOraclePrice(\n                asset,\n                self.getCollateralDeposits(_account, asset),\n                false // Take the collateral factor into consideration.\n            );\n            totalCollateralValue += collateralValue;\n        }\n\n        return totalCollateralValue;\n    }\n\n    /**\n     * @notice Gets the collateral value of a particular account including extra return value for specific collateral.\n     * @dev O(# of different deposited collateral assets by account) complexity.\n     * @param _account The account to calculate the collateral value for.\n     * @param _collateralAsset The collateral asset to get the collateral value.\n     * @return totalCollateralValue The collateral value of a particular account.\n     */\n    function getAccountCollateralValue(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset\n    ) internal view returns (uint256 totalCollateralValue, uint256 specificValue) {\n        address[] memory assets = self.depositedCollateralAssets[_account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            (uint256 collateralValue, ) = self.getCollateralValueAndOraclePrice(\n                asset,\n                self.getCollateralDeposits(_account, asset),\n                false // Take the collateral factor into consideration.\n            );\n            totalCollateralValue += collateralValue;\n            if (asset == _collateralAsset) {\n                specificValue = collateralValue;\n            }\n        }\n    }\n\n    /**\n     * @notice Gets accounts min collateral value required to cover debt at a given collateralization ratio.\n     * @dev 1. Account with min collateral value under MCR will not borrow.\n     *      2. Account with min collateral value under LT can be liquidated.\n     * @param _account The account to calculate the minimum collateral value for.\n     * @param _ratio The collateralization ratio to get min collateral value against.\n     * @return The min collateral value at given collateralization ratio for the account.\n     */\n    function getAccountMinimumCollateralValueAtRatio(\n        MinterState storage self,\n        address _account,\n        uint256 _ratio\n    ) internal view returns (uint256) {\n        return self.getAccountKrAssetValue(_account).wadMul(_ratio);\n    }\n\n    /**\n     * @notice Gets the total KreskoAsset value in USD for an account.\n     * @param _account The account to calculate the KreskoAsset value for.\n     * @return value The KreskoAsset value of the account.\n     */\n    function getAccountKrAssetValue(MinterState storage self, address _account) internal view returns (uint256 value) {\n        address[] memory assets = self.mintedKreskoAssets[_account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            value += self.getKrAssetValue(asset, self.getKreskoAssetDebtScaled(_account, asset), false);\n        }\n        return value;\n    }\n\n    /**\n     * @notice Get accounts interested scaled debt amount for a KreskoAsset.\n     * @param _asset The asset address\n     * @param _account The account to get the amount for\n     * @return Amount of scaled debt.\n     */\n    function getKreskoAssetDebtScaled(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256) {\n        uint256 debt = self.kreskoAssets[_asset].toRebasingAmount(irs().srUserInfo[_account][_asset].debtScaled);\n        if (debt == 0) {\n            return 0;\n        }\n\n        return debt.rayMul(irs().srAssets[_asset].getNormalizedDebtIndex()).rayToWad();\n    }\n\n    /**\n     * @notice Get `_account` principal debt amount for `_asset`\n     * @dev Principal debt is rebase adjusted due to possible stock splits/reverse splits\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of principal debt for `_asset`\n     */\n    function getKreskoAssetDebtPrincipal(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256) {\n        return self.kreskoAssets[_asset].toRebasingAmount(self.kreskoAssetDebt[_account][_asset]);\n    }\n\n    /**\n     * @notice Get the total interest accrued on top of debt: Scaled Debt - Principal Debt\n     * @return assetAmount Interest denominated in _asset\n     * @return kissAmount Interest denominated in KISS. Ignores K-factor: $1 of interest = 1 KISS\n     **/\n    function getKreskoAssetDebtInterest(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256 assetAmount, uint256 kissAmount) {\n        assetAmount =\n            self.getKreskoAssetDebtScaled(_account, _asset) -\n            self.getKreskoAssetDebtPrincipal(_account, _asset);\n        kissAmount = self.getKrAssetValue(_asset, assetAmount, true).oraclePriceToWad();\n    }\n\n    /**\n     * @notice Gets an index for the Kresko asset the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @param _kreskoAsset The asset lookup address.\n     * @return i = index of the minted Kresko asset.\n     */\n    function getMintedKreskoAssetsIndex(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset\n    ) internal view returns (uint256 i) {\n        uint256 length = self.mintedKreskoAssets[_account].length;\n        require(length > 0, Error.NO_KRASSETS_MINTED);\n        for (i; i < length; i++) {\n            if (self.mintedKreskoAssets[_account][i] == _kreskoAsset) {\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Gets an index for the collateral asset the account has deposited.\n     * @param _account The account to get the index for.\n     * @param _collateralAsset The asset lookup address.\n     * @return i = index of the minted collateral asset.\n     */\n    function getDepositedCollateralAssetIndex(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset\n    ) internal view returns (uint256 i) {\n        uint256 length = self.depositedCollateralAssets[_account].length;\n        require(length > 0, Error.NO_COLLATERAL_DEPOSITS);\n        for (i; i < length; i++) {\n            if (self.depositedCollateralAssets[_account][i] == _collateralAsset) {\n                break;\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibAssetUtility.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {CollateralAsset, KrAsset} from \"../MinterTypes.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\n\n/**\n * @title LibAssetUtility\n * @author Kresko\n * @notice Utility functions for KrAsset and CollateralAsset structs\n */\nlibrary LibAssetUtility {\n    using WadRay for uint256;\n    using LibDecimals for int256;\n\n    /**\n     * @notice Amount of non rebasing tokens -> amount of rebasing tokens\n     * @param self the kresko asset struct\n     * @param _nonRebasedAmount the amount to convert\n     */\n    function toRebasingAmount(KrAsset memory self, uint256 _nonRebasedAmount) internal view returns (uint256) {\n        return IKreskoAssetAnchor(self.anchor).convertToAssets(_nonRebasedAmount);\n    }\n\n    /**\n     * @notice Amount of non rebasing tokens -> amount of rebasing tokens\n     * @dev if collateral is not a kresko asset, returns the input\n     * @param self the collateral asset struct\n     * @param _nonRebasedAmount the amount to convert\n     */\n    function toRebasingAmount(CollateralAsset memory self, uint256 _nonRebasedAmount) internal view returns (uint256) {\n        if (self.anchor == address(0)) return _nonRebasedAmount;\n        return IKreskoAssetAnchor(self.anchor).convertToAssets(_nonRebasedAmount);\n    }\n\n    /**\n     * @notice Amount of rebasing tokens -> amount of non rebasing tokens\n     * @param self the kresko asset struct\n     * @param _maybeRebasedAmount the amount to convert\n     */\n    function toNonRebasingAmount(KrAsset memory self, uint256 _maybeRebasedAmount) internal view returns (uint256) {\n        return IKreskoAssetAnchor(self.anchor).convertToShares(_maybeRebasedAmount);\n    }\n\n    /**\n     * @notice Amount of rebasing tokens -> amount of non rebasing tokens\n     * @dev if collateral is not a kresko asset, returns the input\n     * @param self the collateral asset struct\n     * @param _maybeRebasedAmount the amount to convert\n     */\n    function toNonRebasingAmount(\n        CollateralAsset memory self,\n        uint256 _maybeRebasedAmount\n    ) internal view returns (uint256) {\n        if (self.anchor == address(0)) return _maybeRebasedAmount;\n        return IKreskoAssetAnchor(self.anchor).convertToShares(_maybeRebasedAmount);\n    }\n\n    /**\n     * @notice Get the oracle price of a collateral asset in uint256 with extOracleDecimals\n     */\n    function uintPrice(CollateralAsset memory self) internal view returns (uint256) {\n        return uint256(self.oracle.latestAnswer());\n    }\n\n    /**\n     * @notice Get the oracle price of a kresko asset in uint256 with extOracleDecimals\n     */\n    function uintPrice(KrAsset memory self) internal view returns (uint256) {\n        return uint256(self.oracle.latestAnswer());\n    }\n\n    /**\n     * @notice Get the oracle price of a collateral asset in uint256 with 18 decimals\n     */\n    function wadPrice(CollateralAsset memory self) internal view returns (uint256) {\n        return self.oracle.latestAnswer().oraclePriceToWad();\n    }\n\n    /**\n     * @notice Get the oracle price of a kresko asset in uint256 with 18 decimals\n     */\n    function wadPrice(KrAsset memory self) internal view returns (uint256) {\n        return self.oracle.latestAnswer().oraclePriceToWad();\n    }\n\n    /**\n     * @notice Get value for @param _assetAmount of @param self in uint256\n     */\n    function uintUSD(CollateralAsset memory self, uint256 _assetAmount) internal view returns (uint256) {\n        return self.uintPrice().wadMul(_assetAmount);\n    }\n\n    /**\n     * @notice Get value for @param _assetAmount of @param self in uint256\n     */\n    function uintUSD(KrAsset memory self, uint256 _assetAmount) internal view returns (uint256) {\n        return self.uintPrice().wadMul(_assetAmount);\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibBurn.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n// solhint-disable not-rely-on-time\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {MinterEvent, InterestRateEvent} from \"../../libs/Events.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {IERC20Permit} from \"../../shared/IERC20Permit.sol\";\nimport {SafeERC20} from \"../../shared/SafeERC20.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\n\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {LibCalculation} from \"./LibCalculation.sol\";\nimport {KrAsset} from \"../MinterTypes.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {MinterState} from \"../MinterState.sol\";\n\nlibrary LibBurn {\n    using Arrays for address[];\n\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n\n    using SafeERC20 for IERC20Permit;\n    using LibCalculation for MinterState;\n\n    /// @notice Repay user kresko asset debt with stability rate updates.\n    /// @dev Updates the principal in MinterState and stability rate adjusted values in InterestRateState\n    /// @param _kreskoAsset the asset being repaid\n    /// @param _anchor the anchor token of the asset being repaid\n    /// @param _burnAmount the asset amount being burned\n    /// @param _account the account the debt is subtracted from\n    function burn(\n        MinterState storage self,\n        address _kreskoAsset,\n        address _anchor,\n        uint256 _burnAmount,\n        address _account\n    ) internal {\n        // Update global debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n        // Get the possibly rebalanced amount of destroyed tokens\n        uint256 destroyed = IKreskoAssetIssuer(_anchor).destroy(_burnAmount, msg.sender);\n        // Calculate the debt index scaled amount\n        uint256 amountScaled = destroyed.wadToRay().rayDiv(newDebtIndex);\n        require(amountScaled != 0, Error.INVALID_SCALED_AMOUNT);\n\n        // Decrease the principal debt\n        self.kreskoAssetDebt[_account][_kreskoAsset] -= destroyed;\n        // Decrease the scaled debt and set user asset's last debt index\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled -= uint128(amountScaled);\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n        // Update the stability rate for the asset\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n    }\n\n    /// @notice Repay user global asset debt. Updates rates for regular market.\n    /// @param _kreskoAsset the asset being repaid\n    /// @param _burnAmount the asset amount being burned\n    function repaySwap(\n        MinterState storage self,\n        address _kreskoAsset,\n        uint256 _burnAmount,\n        address _from\n    ) internal returns (uint256 destroyed) {\n        // Burn assets from the protocol, as they are sent in. Get the destroyed shares.\n        destroyed = IKreskoAssetIssuer(self.kreskoAssets[_kreskoAsset].anchor).destroy(_burnAmount, _from);\n        require(destroyed != 0, \"repay-destroyed-amount-invalid\");\n    }\n\n    /**\n     * @notice Repays accrued stability rate interest for a single asset\n     * @param _account Account to repay interest for\n     * @param _kreskoAsset Kresko asset to repay interest for\n     * @return kissRepayAmount amount repaid\n     */\n    function repayFullStabilityRateInterest(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset\n    ) internal returns (uint256 kissRepayAmount) {\n        // Update debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n        // Get the accrued interest in repayment token\n        (, kissRepayAmount) = self.getKreskoAssetDebtInterest(_account, _kreskoAsset);\n\n        // If no interest has accrued no further operations needed\n        // Do not revert because we want the preserve new debt index and stability rate\n        if (kissRepayAmount == 0) {\n            // Update stability rate for asset\n            irs().srAssets[_kreskoAsset].updateStabilityRate();\n            return 0;\n        }\n\n        // Transfer the accrued interest\n        IERC20Permit(irs().kiss).safeTransferFrom(msg.sender, self.feeRecipient, kissRepayAmount);\n\n        // Update scaled values for the user\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled = uint128(\n            self.getKreskoAssetDebtPrincipal(_account, _kreskoAsset).wadToRay().rayDiv(newDebtIndex)\n        );\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n\n        // Remove from minted kresko assets if debt is cleared\n        if (self.getKreskoAssetDebtPrincipal(_account, _kreskoAsset) == 0) {\n            self.mintedKreskoAssets[_account].removeAddress(\n                _kreskoAsset,\n                self.getMintedKreskoAssetsIndex(_account, _kreskoAsset)\n            );\n        }\n\n        // Update stability rates\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n        // Emit event with the account, asset and amount repaid\n        emit InterestRateEvent.StabilityRateInterestRepaid(_account, _kreskoAsset, kissRepayAmount);\n    }\n\n    /**\n     * @notice Charges the protocol close fee based off the value of the burned asset.\n     * @dev Takes the fee from the account's collateral assets. Attempts collateral assets\n     *   in reverse order of the account's deposited collateral assets array.\n     * @param _account The account to charge the close fee from.\n     * @param _kreskoAsset The address of the kresko asset being burned.\n     * @param _burnAmount The amount of the kresko asset being burned.\n     */\n    function chargeCloseFee(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset,\n        uint256 _burnAmount\n    ) internal {\n        KrAsset memory krAsset = self.kreskoAssets[_kreskoAsset];\n        // Calculate the value of the fee according to the value of the krAssets being burned.\n        uint256 feeValue = krAsset.uintUSD(_burnAmount).wadMul(krAsset.closeFee);\n\n        // Do nothing if the fee value is 0.\n        if (feeValue == 0) {\n            return;\n        }\n\n        address[] memory accountCollateralAssets = self.depositedCollateralAssets[_account];\n        // Iterate backward through the account's deposited collateral assets to safely\n        // traverse the array while still being able to remove elements if necessary.\n        // This is because removing the last element of the array does not shift around\n        // other elements in the array.\n\n        for (uint256 i = accountCollateralAssets.length - 1; i >= 0; i--) {\n            address collateralAssetAddress = accountCollateralAssets[i];\n\n            (uint256 transferAmount, uint256 feeValuePaid) = self.calcFee(\n                collateralAssetAddress,\n                _account,\n                feeValue,\n                i\n            );\n\n            // Remove the transferAmount from the stored deposit for the account.\n            self.collateralDeposits[_account][collateralAssetAddress] -= self\n                .collateralAssets[collateralAssetAddress]\n                .toNonRebasingAmount(transferAmount);\n\n            // Transfer the fee to the feeRecipient.\n            IERC20Permit(collateralAssetAddress).safeTransfer(self.feeRecipient, transferAmount);\n            emit MinterEvent.CloseFeePaid(_account, collateralAssetAddress, transferAmount, feeValuePaid);\n\n            feeValue = feeValue - feeValuePaid;\n            // If the entire fee has been paid, no more action needed.\n            if (feeValue == 0) {\n                return;\n            }\n        }\n    }\n\n    /**\n     * @notice Check that debt repaid does not leave a dust position, if it does:\n     * return an amount that pays up to minDebtValue\n     * @param _kreskoAsset The address of the kresko asset being burned.\n     * @param _burnAmount The amount being burned\n     * @param _debtAmount The debt amount of `_account`\n     * @return amount == 0 or >= minDebtAmount\n     */\n    function ensureNotDustPosition(\n        MinterState storage self,\n        address _kreskoAsset,\n        uint256 _burnAmount,\n        uint256 _debtAmount\n    ) internal view returns (uint256 amount) {\n        // If the requested burn would put the user's debt position below the minimum\n        // debt value, close up to the minimum debt value instead.\n        uint256 krAssetValue = self.getKrAssetValue(_kreskoAsset, _debtAmount - _burnAmount, true);\n        if (krAssetValue > 0 && krAssetValue < self.minimumDebtValue) {\n            uint256 minDebtValue = self.minimumDebtValue.wadDiv(self.kreskoAssets[_kreskoAsset].uintPrice());\n            amount = _debtAmount - minDebtValue;\n        } else {\n            amount = _burnAmount;\n        }\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibCalculation.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {MinterState} from \"../MinterState.sol\";\nimport {KrAsset, CollateralAsset, Constants} from \"../MinterTypes.sol\";\nimport {cps} from \"../collateral-pool/CollateralPoolState.sol\";\n\n/**\n * @title Calculation library for liquidation & fee values\n * @author Kresko\n */\nlibrary LibCalculation {\n    struct MaxLiquidationVars {\n        CollateralAsset collateral;\n        uint256 accountCollateralValue;\n        uint256 minCollateralValue;\n        uint256 seizeCollateralAccountValue;\n        uint256 maxLiquidationMultiplier;\n        uint256 minimumDebtValue;\n        uint256 liquidationThreshold;\n        uint256 debtFactor;\n    }\n\n    using Arrays for address[];\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n\n    /**\n     * @dev Calculates the total value that can be liquidated for a liquidation pair\n     * @param _account address to liquidate\n     * @param _repayKreskoAsset address of the kreskoAsset being repaid on behalf of the liquidatee\n     * @param _seizedCollateral The collateral asset being seized in the liquidation\n     * @return maxLiquidatableUSD USD value that can be liquidated, 0 if the pair has no liquidatable value\n     */\n    function getMaxLiquidation(\n        MinterState storage self,\n        address _account,\n        KrAsset memory _repayKreskoAsset,\n        address _seizedCollateral\n    ) internal view returns (uint256 maxLiquidatableUSD) {\n        MaxLiquidationVars memory vars = _account != address(0)\n            ? _getMaxLiquidationParams(self, _account, _repayKreskoAsset, _seizedCollateral)\n            : _getMaxLiquidationParamsShared(self, _repayKreskoAsset, _seizedCollateral);\n        // Account is not liquidatable\n        if (vars.accountCollateralValue >= (vars.minCollateralValue)) {\n            return 0;\n        }\n\n        maxLiquidatableUSD = _getMaxLiquidatableUSD(vars, _repayKreskoAsset);\n\n        if (vars.seizeCollateralAccountValue < maxLiquidatableUSD) {\n            return vars.seizeCollateralAccountValue;\n        } else if (maxLiquidatableUSD < vars.minimumDebtValue) {\n            return vars.minimumDebtValue;\n        } else {\n            return maxLiquidatableUSD;\n        }\n    }\n\n    /**\n     * @notice Calculate amount of collateral to seize during the liquidation procesself.\n     * @param _liquidationIncentiveMultiplier The liquidation incentive multiplier.\n     * @param _collateralOraclePriceUSD The address of the collateral asset to be seized.\n     * @param _kreskoAssetRepayAmountUSD Kresko asset amount being repaid in exchange for the seized collateral.\n     */\n    function calculateAmountToSeize(\n        uint256 _liquidationIncentiveMultiplier,\n        uint256 _collateralOraclePriceUSD,\n        uint256 _kreskoAssetRepayAmountUSD\n    ) internal pure returns (uint256) {\n        // Seize amount = (repay amount USD * liquidation incentive / collateral price USD).\n        // Denominate seize amount in collateral type\n        // Apply liquidation incentive multiplier\n        return _kreskoAssetRepayAmountUSD.wadMul(_liquidationIncentiveMultiplier).wadDiv(_collateralOraclePriceUSD);\n    }\n\n    /**\n     * @notice Calculates the fee to be taken from a user's deposited collateral assetself.\n     * @param _collateralAsset The collateral asset from which to take to the fee.\n     * @param _account The owner of the collateral.\n     * @param _feeValue The original value of the fee.\n     * @param _collateralAssetIndex The collateral asset's index in the user's depositedCollateralAssets array.\n     *\n     * @return transferAmount to be received as a uint256\n     * @return feeValuePaid wad representing the fee value paid.\n     */\n    function calcFee(\n        MinterState storage self,\n        address _collateralAsset,\n        address _account,\n        uint256 _feeValue,\n        uint256 _collateralAssetIndex\n    ) internal returns (uint256 transferAmount, uint256 feeValuePaid) {\n        uint256 depositAmount = self.getCollateralDeposits(_account, _collateralAsset);\n\n        // Don't take the collateral asset's collateral factor into consideration.\n        (uint256 depositValue, uint256 oraclePrice) = self.getCollateralValueAndOraclePrice(\n            _collateralAsset,\n            depositAmount,\n            true\n        );\n\n        if (_feeValue < depositValue) {\n            // If feeValue < depositValue, the entire fee can be charged for this collateral asset.\n            transferAmount = self.collateralAssets[_collateralAsset].decimals.fromWad(_feeValue.wadDiv(oraclePrice));\n            feeValuePaid = _feeValue;\n        } else {\n            // If the feeValue >= depositValue, the entire deposit should be taken as the fee.\n            transferAmount = depositAmount;\n            feeValuePaid = depositValue;\n            // Because the entire deposit is taken, remove it from the depositCollateralAssets array.\n            self.depositedCollateralAssets[_account].removeAddress(_collateralAsset, _collateralAssetIndex);\n        }\n\n        return (transferAmount, feeValuePaid);\n    }\n\n    /**\n     * @notice Calculates the maximum USD value of a given kreskoAsset that can be liquidated given a liquidation pair\n     *\n     * 1. Calculates the value gained per USD repaid in liquidation for a given kreskoAsset\n     *\n     * debtFactor = debtFactor = k * LT / cFactor;\n     *\n     * valPerUSD = (DebtFactor - Asset closeFee - liquidationIncentive) / DebtFactor\n     *\n     * 2. Calculates the maximum amount of USD value that can be liquidated given the account's collateral value\n     *\n     * maxLiquidatableUSD = (MCV - ACV) / valPerUSD / debtFactor / cFactor * LOM\n     *\n     * @dev This function is used by getMaxLiquidation and is factored out for readability\n     * @param vars liquidation variables struct\n     * @param _repayKreskoAsset The kreskoAsset being repaid in the liquidation\n     */\n    function _getMaxLiquidatableUSD(\n        MaxLiquidationVars memory vars,\n        KrAsset memory _repayKreskoAsset\n    ) private pure returns (uint256) {\n        uint256 valuePerUSDRepaid = (vars.debtFactor -\n            vars.collateral.liquidationIncentive -\n            _repayKreskoAsset.closeFee).wadDiv(vars.debtFactor);\n        return\n            (vars.minCollateralValue - vars.accountCollateralValue)\n                .wadDiv(valuePerUSDRepaid)\n                .wadDiv(vars.debtFactor)\n                .wadDiv(vars.collateral.factor)\n                .wadMul(vars.maxLiquidationMultiplier);\n    }\n\n    function _getMaxLiquidationParams(\n        MinterState storage state,\n        address _account,\n        KrAsset memory _repayKreskoAsset,\n        address _seizedCollateral\n    ) private view returns (MaxLiquidationVars memory) {\n        uint256 liquidationThreshold = state.liquidationThreshold;\n        uint256 minCollateralValue = state.getAccountMinimumCollateralValueAtRatio(_account, liquidationThreshold);\n\n        (uint256 accountCollateralValue, uint256 seizeCollateralAccountValue) = state.getAccountCollateralValue(\n            _account,\n            _seizedCollateral\n        );\n\n        CollateralAsset memory collateral = state.collateralAssets[_seizedCollateral];\n\n        return\n            MaxLiquidationVars({\n                collateral: collateral,\n                accountCollateralValue: accountCollateralValue,\n                debtFactor: _repayKreskoAsset.kFactor.wadMul(liquidationThreshold).wadDiv(collateral.factor),\n                minCollateralValue: minCollateralValue,\n                minimumDebtValue: state.minimumDebtValue,\n                seizeCollateralAccountValue: seizeCollateralAccountValue,\n                liquidationThreshold: liquidationThreshold,\n                maxLiquidationMultiplier: Constants.MIN_MAX_LIQUIDATION_MULTIPLIER\n            });\n    }\n\n    function _getMaxLiquidationParamsShared(\n        MinterState storage state,\n        KrAsset memory _repayKreskoAsset,\n        address _seizedCollateral\n    ) private view returns (MaxLiquidationVars memory) {\n        uint256 liquidationThreshold = cps().liquidationThreshold;\n        uint256 minCollateralValue = cps().getTotalPoolKrAssetValueAtRatio(liquidationThreshold, false);\n\n        (uint256 totalCollateralValue, uint256 seizeCollateralValue) = cps().getTotalPoolDepositValue(\n            _seizedCollateral,\n            cps().totalDeposits[_seizedCollateral],\n            false\n        );\n\n        CollateralAsset memory collateral = state.collateralAssets[_seizedCollateral];\n\n        return\n            MaxLiquidationVars({\n                collateral: collateral,\n                accountCollateralValue: totalCollateralValue,\n                debtFactor: _repayKreskoAsset.kFactor.wadMul(liquidationThreshold).wadDiv(collateral.factor),\n                minCollateralValue: minCollateralValue,\n                minimumDebtValue: state.minimumDebtValue,\n                seizeCollateralAccountValue: seizeCollateralValue,\n                liquidationThreshold: liquidationThreshold,\n                maxLiquidationMultiplier: Constants.MIN_MAX_LIQUIDATION_MULTIPLIER\n            });\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibCollateral.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {AggregatorV2V3Interface} from \"../../vendor/flux/interfaces/AggregatorV2V3Interface.sol\";\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {CollateralAsset} from \"../MinterTypes.sol\";\nimport {MinterState} from \"../MinterState.sol\";\n\n/**\n * @title Library for collateral related operations\n * @author Kresko\n */\nlibrary LibCollateral {\n    using LibDecimals for uint8;\n    using Arrays for address[];\n    using WadRay for uint256;\n\n    /**\n     * In case a collateral asset is also a kresko asset, convert an amount to anchor shares\n     * @param _amount amount to possibly convert\n     * @param _collateralAsset address of the collateral asset\n     */\n    function normalizeCollateralAmount(\n        MinterState storage self,\n        uint256 _amount,\n        address _collateralAsset\n    ) internal view returns (uint256 amount) {\n        CollateralAsset memory asset = self.collateralAssets[_collateralAsset];\n        if (asset.anchor != address(0)) {\n            return IKreskoAssetAnchor(asset.anchor).convertToShares(_amount);\n        }\n        return _amount;\n    }\n\n    /**\n     * @notice Get the state of a specific collateral asset\n     * @param _asset Address of the asset.\n     * @return State of assets `CollateralAsset` struct\n     */\n    function collateralAsset(MinterState storage self, address _asset) internal view returns (CollateralAsset memory) {\n        return self.collateralAssets[_asset];\n    }\n\n    /**\n     * @notice Gets the collateral value for a single collateral asset and amount.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _amount The amount of the collateral asset to calculate the collateral value for.\n     * @param _ignoreCollateralFactor Boolean indicating if the asset's collateral factor should be ignored.\n     * @return The collateral value for the provided amount of the collateral asset.\n     */\n    function getCollateralValueAndOraclePrice(\n        MinterState storage self,\n        address _collateralAsset,\n        uint256 _amount,\n        bool _ignoreCollateralFactor\n    ) internal view returns (uint256, uint256) {\n        CollateralAsset memory asset = self.collateralAssets[_collateralAsset];\n\n        uint256 oraclePrice = asset.uintPrice();\n        uint256 value = asset.decimals.toWad(_amount).wadMul(oraclePrice);\n\n        if (!_ignoreCollateralFactor) {\n            value = value.wadMul(asset.factor);\n        }\n        return (value, oraclePrice);\n    }\n\n    /**\n     * @notice verifies that the account has sufficient collateral for the requested amount and records the collateral\n     * @param _account The address of the account to verify the collateral for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\n     * @param _collateralDeposits Collateral deposits for the account.\n     * @param _depositedCollateralAssetIndex Index of the collateral asset in the account's deposited collateral assets array.\n     */\n    function verifyAndRecordCollateralWithdrawal(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _collateralDeposits,\n        uint256 _depositedCollateralAssetIndex\n    ) internal {\n        require(_withdrawAmount > 0, Error.ZERO_WITHDRAW);\n        require(\n            _depositedCollateralAssetIndex <= self.depositedCollateralAssets[_account].length - 1,\n            Error.ARRAY_OUT_OF_BOUNDS\n        );\n\n        // Ensure that the operation passes checks MCR checks\n        verifyAccountCollateral(self, _account, _collateralAsset, _withdrawAmount);\n\n        // Record the withdrawal.\n        self.collateralDeposits[_account][_collateralAsset] = self\n            .collateralAssets[_collateralAsset]\n            .toNonRebasingAmount(_collateralDeposits - _withdrawAmount);\n\n        // If the user is withdrawing all of the collateral asset, remove the collateral asset\n        // from the user's deposited collateral assets array.\n        if (_withdrawAmount == _collateralDeposits) {\n            self.depositedCollateralAssets[_account].removeAddress(_collateralAsset, _depositedCollateralAssetIndex);\n        }\n\n        emit MinterEvent.CollateralWithdrawn(_account, _collateralAsset, _withdrawAmount);\n    }\n\n    /**\n     * @notice Records account as having deposited an amount of a collateral asset.\n     * @dev Token transfers are expected to be done by the caller.\n     * @param _account The address of the collateral asset.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _depositAmount The amount of the collateral asset deposited.\n     */\n    function recordCollateralDeposit(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _depositAmount\n    ) internal {\n        // Because the depositedCollateralAssets[_account] is pushed to if the existing\n        // deposit amount is 0, require the amount to be > 0. Otherwise, the depositedCollateralAssets[_account]\n        // could be filled with duplicates, causing collateral to be double-counted in the collateral value.\n        require(_depositAmount > 0, Error.ZERO_DEPOSIT);\n\n        // If the account does not have an existing deposit for this collateral asset,\n        // push it to the list of the account's deposited collateral assets.\n        uint256 existingDepositAmount = self.getCollateralDeposits(_account, _collateralAsset);\n        if (existingDepositAmount == 0) {\n            self.depositedCollateralAssets[_account].push(_collateralAsset);\n        }\n        // Record the deposit.\n        unchecked {\n            self.collateralDeposits[_account][_collateralAsset] = self\n                .collateralAssets[_collateralAsset]\n                .toNonRebasingAmount(existingDepositAmount + _depositAmount);\n        }\n\n        emit MinterEvent.CollateralDeposited(_account, _collateralAsset, _depositAmount);\n    }\n\n    /**\n     * @notice records the collateral withdrawal\n     * @param _account The address of the account to verify the collateral for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\n     * @param _collateralDeposits Collateral deposits for the account.\n     * @param _depositedCollateralAssetIndex Index of the collateral asset in the account's deposited collateral assets array.\n     */\n    function recordCollateralWithdrawal(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _collateralDeposits,\n        uint256 _depositedCollateralAssetIndex\n    ) internal {\n        require(_withdrawAmount > 0, Error.ZERO_WITHDRAW);\n        require(\n            _depositedCollateralAssetIndex <= self.depositedCollateralAssets[_account].length - 1,\n            Error.ARRAY_OUT_OF_BOUNDS\n        );\n        // ensure that the handler does not attempt to withdraw more collateral than the account has\n        require(_collateralDeposits >= _withdrawAmount, Error.COLLATERAL_INSUFFICIENT_AMOUNT);\n\n        // Record the withdrawal.\n        self.collateralDeposits[_account][_collateralAsset] = self\n            .collateralAssets[_collateralAsset]\n            .toNonRebasingAmount(_collateralDeposits - _withdrawAmount);\n\n        // If the user is withdrawing all of the collateral asset, remove the collateral asset\n        // from the user's deposited collateral assets array.\n        if (_withdrawAmount == _collateralDeposits) {\n            self.depositedCollateralAssets[_account].removeAddress(_collateralAsset, _depositedCollateralAssetIndex);\n        }\n\n        emit MinterEvent.UncheckedCollateralWithdrawn(_account, _collateralAsset, _withdrawAmount);\n    }\n\n    /**\n     * @notice verifies that the account collateral\n     * @param _account The address of the account to verify the collateral for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\n     */\n    function verifyAccountCollateral(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount\n    ) internal view {\n        // Ensure the withdrawal does not result in the account having a collateral value\n        // under the minimum collateral amount required to maintain a healthy position.\n        // I.e. the new account's collateral value must still exceed the account's minimum\n        // collateral value.\n        // Get the account's current collateral value.\n        uint256 accountCollateralValue = self.getAccountCollateralValue(_account);\n        // Get the collateral value that the account will lose as a result of this withdrawal.\n        (uint256 withdrawnCollateralValue, ) = self.getCollateralValueAndOraclePrice(\n            _collateralAsset,\n            _withdrawAmount,\n            false // Take the collateral factor into consideration.\n        );\n        // Get the account's minimum collateral value.\n        uint256 accountMinCollateralValue = self.getAccountMinimumCollateralValueAtRatio(\n            _account,\n            self.minimumCollateralizationRatio\n        );\n        // Require accountMinCollateralValue <= accountCollateralValue - withdrawnCollateralValue.\n        require(\n            accountMinCollateralValue <= accountCollateralValue - withdrawnCollateralValue,\n            Error.COLLATERAL_INSUFFICIENT_AMOUNT\n        );\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibDecimals.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {ms} from \"../MinterStorage.sol\";\n\n/**\n * @title Library for Kresko specific decimals\n */\nlibrary LibDecimals {\n    /**\n     * @notice For a given collateral asset and amount, returns a wad represenatation.\n     * @dev If the collateral asset has decimals other than 18, the amount is scaled appropriately.\n     *   If decimals > 18, there may be a loss of precision.\n     * @param _decimals The collateral asset's number of decimals\n     * @param _amount The amount of the collateral asset.\n     * @return A fp of amount scaled according to the collateral asset's decimals.\n     */\n    function toWad(uint256 _decimals, uint256 _amount) internal pure returns (uint256) {\n        // Initially, use the amount as the raw value for the fixed point.\n        // which internally uses 18 decimals.\n        // Most collateral assets will have 18 decimals.\n\n        // Handle cases where the collateral asset's decimal amount is not 18.\n        if (_decimals < 18) {\n            // If the decimals are less than 18, multiply the amount\n            // to get the correct wad value.\n            // E.g. 1 full token of a 17 decimal token will  cause the\n            // initial setting of amount to be 0.1, so we multiply\n            // by 10 ** (18 - 17) = 10 to get it to 0.1 * 10 = 1.\n            return _amount * (10 ** (18 - _decimals));\n        } else if (_decimals > 18) {\n            // If the decimals are greater than 18, divide the amount\n            // to get the correct fixed point value.\n            // Note because wad numbers are 18 decimals, this results\n            // in loss of precision. E.g. if the collateral asset has 19\n            // decimals and the deposit amount is only 1 uint, this will divide\n            // 1 by 10 ** (19 - 18), resulting in 1 / 10 = 0\n            return _amount / (10 ** (_decimals - 18));\n        }\n        return _amount;\n    }\n\n    /**\n     * @notice For a given collateral asset and wad amount, returns the collateral amount.\n     * @dev If the collateral asset has decimals other than 18, the amount is scaled appropriately.\n     *   If decimals < 18, there may be a loss of precision.\n     * @param _decimals The collateral asset's number of decimals\n     * @param _wadAmount The wad amount of the collateral asset.\n     * @return An amount that is compatible with the collateral asset's decimals.\n     */\n    function fromWad(uint256 _decimals, uint256 _wadAmount) internal pure returns (uint256) {\n        // Initially, use the rawValue, which internally uses 18 decimals.\n        // Most collateral assets will have 18 decimals.\n        // Handle cases where the collateral asset's decimal amount is not 18.\n        if (_decimals < 18) {\n            // If the decimals are less than 18, divide the depositAmount\n            // to get the correct collateral amount.\n            // E.g. 1 full token will result in amount being 1e18 at this point,\n            // so if the token has 17 decimals, divide by 10 ** (18 - 17) = 10\n            // to get a value of 1e17.\n            // This may result in a loss of precision.\n            return _wadAmount / (10 ** (18 - _decimals));\n        } else if (_decimals > 18) {\n            // If the decimals are greater than 18, multiply the depositAmount\n            // to get the correct fixed point value.\n            // E.g. 1 full token will result in amount being 1e18 at this point,\n            // so if the token has 19 decimals, multiply by 10 ** (19 - 18) = 10\n            // to get a value of 1e19.\n            return _wadAmount * (10 ** (_decimals - 18));\n        }\n        return _wadAmount;\n    }\n\n    /**\n     * @notice Divides an uint256 @param _value with @param _priceWithOracleDecimals\n     * @param _value Left side value of the division\n     * @param wadValue result with 18 decimals\n     */\n    function divByPrice(uint256 _value, uint256 _priceWithOracleDecimals) internal view returns (uint256 wadValue) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals >= 18) return _priceWithOracleDecimals;\n        return (_value / _priceWithOracleDecimals) * 10 ** (oracleDecimals);\n    }\n\n    /**\n     * @notice Converts an uint256 with extOracleDecimals into a number with 18 decimals\n     * @param _wadPrice value with extOracleDecimals\n     */\n    function fromWadPriceToUint(uint256 _wadPrice) internal view returns (uint256 priceWithOracleDecimals) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals == 18) return _wadPrice;\n        return _wadPrice / 10 ** (18 - oracleDecimals);\n    }\n\n    /**\n     * @notice Converts an uint256 with extOracleDecimals into a number with 18 decimals\n     * @param _priceWithOracleDecimals value with extOracleDecimals\n     * @return wadPrice with 18 decimals\n     */\n    function oraclePriceToWad(uint256 _priceWithOracleDecimals) internal view returns (uint256) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals == 18) {\n            return _priceWithOracleDecimals;\n        }\n        return _priceWithOracleDecimals * 10 ** (18 - oracleDecimals);\n    }\n\n    /**\n     * @notice Converts an int256 with extOracleDecimals into a number with 18 decimals\n     * @param _priceWithOracleDecimals value with extOracleDecimals\n     * @return wadPrice price with 18 decimals\n     */\n    function oraclePriceToWad(int256 _priceWithOracleDecimals) internal view returns (uint256) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals >= 18) return uint256(_priceWithOracleDecimals);\n        return uint256(_priceWithOracleDecimals) * 10 ** (18 - oracleDecimals);\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibKrAsset.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {IUniswapV2OracleCompat} from \"../amm-oracle/IUniswapV2OracleCompat.sol\";\nimport {KrAsset} from \"../MinterTypes.sol\";\nimport {MinterState} from \"../MinterState.sol\";\n\nlibrary LibKrAsset {\n    using WadRay for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Functions                                 */\n    /* -------------------------------------------------------------------------- */\n    /**\n     * @notice Get the state of a specific krAsset\n     * @param _asset Address of the asset.\n     * @return State of assets `KrAsset` struct\n     */\n    function kreskoAsset(MinterState storage self, address _asset) internal view returns (KrAsset memory) {\n        return self.kreskoAssets[_asset];\n    }\n\n    /**\n     * @notice Get possibly rebased amount of kreskoAssets. Use when saving to storage.\n     * @param _asset The asset address\n     * @param _amount The account to query amount for\n     * @return amount Amount of principal debt for `_asset`\n     */\n    function getKreskoAssetAmount(\n        MinterState storage self,\n        address _asset,\n        uint256 _amount\n    ) internal view returns (uint256 amount) {\n        return self.kreskoAssets[_asset].toRebasingAmount(_amount);\n    }\n\n    /**\n     * @notice Gets the USD value for a single Kresko asset and amount.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _amount The amount of the Kresko asset to calculate the value for.\n     * @param _ignoreKFactor Boolean indicating if the asset's k-factor should be ignored.\n     * @return The value for the provided amount of the Kresko asset.\n     */\n    function getKrAssetValue(\n        MinterState storage self,\n        address _kreskoAsset,\n        uint256 _amount,\n        bool _ignoreKFactor\n    ) internal view returns (uint256) {\n        KrAsset memory krAsset = self.kreskoAssets[_kreskoAsset];\n        uint256 value = krAsset.uintUSD(_amount);\n\n        if (!_ignoreKFactor) {\n            value = value.wadMul(krAsset.kFactor);\n        }\n\n        return value;\n    }\n\n    /**\n     * @notice Gets the AMM price for a Kresko asset.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _amount The amount of the Kresko asset to calculate the value for.\n     * @return The value for the provided amount of the Kresko asset.\n     */\n    function getKrAssetAMMPrice(\n        MinterState storage self,\n        address _kreskoAsset,\n        uint256 _amount\n    ) internal view returns (uint256) {\n        if (self.ammOracle == address(0)) {\n            return 0;\n        }\n        return IUniswapV2OracleCompat(self.ammOracle).consultKrAsset(_kreskoAsset, _amount);\n    }\n\n    /**\n     * @notice Get the minimum collateral value required to\n     * back a Kresko asset amount at a given collateralization ratio.\n     * @param _krAsset The address of the Kresko asset.\n     * @param _amount The Kresko Asset debt amount.\n     * @return minCollateralValue is the minimum collateral value required for this Kresko Asset amount.\n     * @param _ratio The collateralization ratio required: higher ratio = more collateral required.\n     */\n    function getMinimumCollateralValueAtRatio(\n        MinterState storage self,\n        address _krAsset,\n        uint256 _amount,\n        uint256 _ratio\n    ) internal view returns (uint256 minCollateralValue) {\n        // Calculate the collateral value required to back this Kresko asset amount at the given ratio\n        return self.getKrAssetValue(_krAsset, _amount, false).wadMul(_ratio);\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibMint.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n// solhint-disable not-rely-on-time\n// solhint-disable-next-line\nimport {SafeERC20, IERC20Permit} from \"../../shared/SafeERC20.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\n\nimport {LibCalculation} from \"./LibCalculation.sol\";\nimport {KrAsset} from \"../MinterTypes.sol\";\nimport {MinterState} from \"../MinterState.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\nlibrary LibMint {\n    using Arrays for address[];\n\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n\n    using SafeERC20 for IERC20Permit;\n    using LibCalculation for MinterState;\n\n    /// @notice Mint kresko assets with stability rate updates.\n    /// @dev Updates the principal in MinterState and stability rate adjusted values in InterestRateState\n    /// @param _kreskoAsset the asset being repaid\n    /// @param _anchor the anchor token of the asset being issued\n    /// @param _amount the asset amount being minted\n    /// @param _account the account to mint the assets to\n    function mint(\n        MinterState storage self,\n        address _kreskoAsset,\n        address _anchor,\n        uint256 _amount,\n        address _account\n    ) internal {\n        // Update global debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n        // Get possibly rebalanced amount of kresko asset\n        uint256 issued = IKreskoAssetIssuer(_anchor).issue(_amount, _account);\n        // Calculate debt index scaled value\n        uint256 amountScaled = issued.wadToRay().rayDiv(newDebtIndex);\n        require(amountScaled != 0, Error.INVALID_SCALED_AMOUNT);\n        // Increase principal debt\n        self.kreskoAssetDebt[_account][_kreskoAsset] += issued;\n        // Update scaled values for the user\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled += uint128(amountScaled);\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n        // Update the global rate for the asset\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n    }\n\n    /// @notice Mint kresko assets for shared debt pool.\n    /// @dev Updates general markets stability rates and debt index.\n    /// @param _kreskoAsset the asset requested\n    /// @param _amount the asset amount requested\n    /// @param _to the account to mint the assets to\n    function mintSwap(\n        MinterState storage self,\n        address _kreskoAsset,\n        uint256 _amount,\n        address _to\n    ) internal returns (uint256 issued) {\n        issued = IKreskoAssetIssuer(self.kreskoAssets[_kreskoAsset].anchor).issue(_amount, _to);\n        require(issued != 0, \"invalid-shared-pool-mint\");\n    }\n\n    /**\n     * @notice Charges the protocol open fee based off the value of the minted asset.\n     * @dev Takes the fee from the account's collateral assets. Attempts collateral assets\n     *   in reverse order of the account's deposited collateral assets array.\n     * @param _account The account to charge the open fee from.\n     * @param _kreskoAsset The address of the kresko asset being burned.\n     * @param _kreskoAssetAmountMinted The amount of the kresko asset being minted.\n     */\n    function chargeOpenFee(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset,\n        uint256 _kreskoAssetAmountMinted\n    ) internal {\n        KrAsset memory krAsset = self.kreskoAssets[_kreskoAsset];\n        // Calculate the value of the fee according to the value of the krAssets being minted.\n        uint256 feeValue = krAsset.uintUSD(_kreskoAssetAmountMinted).wadMul(krAsset.openFee);\n\n        // Do nothing if the fee value is 0.\n        if (feeValue == 0) {\n            return;\n        }\n\n        address[] memory accountCollateralAssets = self.depositedCollateralAssets[_account];\n        // Iterate backward through the account's deposited collateral assets to safely\n        // traverse the array while still being able to remove elements if necessary.\n        // This is because removing the last element of the array does not shift around\n        // other elements in the array.\n        for (uint256 i = accountCollateralAssets.length - 1; i >= 0; i--) {\n            address collateralAssetAddress = accountCollateralAssets[i];\n\n            (uint256 transferAmount, uint256 feeValuePaid) = self.calcFee(\n                collateralAssetAddress,\n                _account,\n                feeValue,\n                i\n            );\n\n            // Remove the transferAmount from the stored deposit for the account.\n            self.collateralDeposits[_account][collateralAssetAddress] -= self\n                .collateralAssets[collateralAssetAddress]\n                .toNonRebasingAmount(transferAmount);\n\n            // Transfer the fee to the feeRecipient.\n            IERC20Permit(collateralAssetAddress).safeTransfer(self.feeRecipient, transferAmount);\n            emit MinterEvent.OpenFeePaid(_account, collateralAssetAddress, transferAmount, feeValuePaid);\n\n            feeValue = feeValue - feeValuePaid;\n            // If the entire fee has been paid, no more action needed.\n            if (feeValue == 0) {\n                return;\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibStabilityRate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\nimport {IERC20Permit} from \"../../shared/IERC20Permit.sol\";\n\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibKrAsset} from \"../libs/LibKrAsset.sol\";\n\nimport {StabilityRateConfig} from \"../InterestRateState.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @author Kresko\n * @title AMM price stability rate library, derived from Aave Protocols VariableDebtToken calculations\n * @notice Library for performing stability rate related operations\n */\nlibrary LibStabilityRate {\n    using WadRay for uint256;\n    using WadRay for uint128;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /**\n     * @notice Cumulates the stability rate from previous update and multiplies the debt index with it.\n     * @dev Updates the updated timestamp\n     * @dev New debt index cannot overflow uint128\n     * @param self configuration for the asset\n     * @return newDebtIndex the updated index\n     */\n    function updateDebtIndex(StabilityRateConfig storage self) internal returns (uint256 newDebtIndex) {\n        if (self.asset == address(0)) return WadRay.RAY;\n\n        newDebtIndex = self.debtIndex;\n        // only cumulating if there is any assets minted and rate is over 0\n        if (IERC20Permit(self.asset).totalSupply() != 0) {\n            uint256 cumulatedStabilityRate = self.calculateCompoundedInterest(block.timestamp);\n            newDebtIndex = cumulatedStabilityRate.rayMul(self.debtIndex);\n            require(newDebtIndex <= type(uint128).max, Error.DEBT_INDEX_OVERFLOW);\n            self.debtIndex = uint128(newDebtIndex);\n        }\n\n        self.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /**\n     * @notice Updates the current stability rate for an asset\n     * @dev New stability rate cannot overflow uint128\n     * @param self rate configuration for the asset\n     */\n    function updateStabilityRate(StabilityRateConfig storage self) internal {\n        if (self.asset == address(0)) return;\n\n        uint256 stabilityRate = calculateStabilityRate(self);\n        require(stabilityRate <= type(uint128).max, Error.STABILITY_RATE_OVERFLOW);\n        self.stabilityRate = uint128(stabilityRate);\n    }\n\n    /**\n     * @notice Get the current price rate between AMM and oracle pricing\n     * @dev Raw return value of ammPrice == 0 when no AMM pair exists OR liquidity of the pair does not qualify\n     * @param self rate configuration for the asset\n     * @return priceRate the current price rate\n     */\n    function getPriceRate(StabilityRateConfig storage self) internal view returns (uint256 priceRate) {\n        uint256 oraclePrice = ms().getKrAssetValue(self.asset, 1 ether, true);\n        uint256 ammPrice = ms().getKrAssetAMMPrice(self.asset, 1 ether);\n        // no pair, no effect\n        if (ammPrice == 0) {\n            return 0;\n        }\n        return ammPrice.wadDiv(oraclePrice) / 10;\n    }\n\n    /**\n     * @notice Calculate new stability rate from the current price rate\n     * @dev Separate calculations exist for following cases:\n     * case 1: AMM premium < optimal\n     * case 2: AMM premium > optimal\n     * @param self rate configuration for the asset\n     * @return stabilityRate the current stability rate\n     */\n    function calculateStabilityRate(StabilityRateConfig storage self) internal view returns (uint256 stabilityRate) {\n        uint256 priceRate = self.getPriceRate(); // 0.95 RAY = -5% PREMIUM, 1.05 RAY = +5% PREMIUM\n        // Return base rate if no AMM price exists\n        if (priceRate == 0) {\n            return self.stabilityRateBase;\n        }\n        bool rateIsGTOptimal = priceRate > self.optimalPriceRate;\n\n        uint256 rateDiff = rateIsGTOptimal ? priceRate - self.optimalPriceRate : self.optimalPriceRate - priceRate;\n        uint256 rateDiffAdjusted = rateDiff.rayMul(self.rateSlope2.rayDiv(self.rateSlope1 + self.priceRateDelta));\n\n        if (!rateIsGTOptimal) {\n            // Case: AMM price is lower than priceRate\n            return self.stabilityRateBase + rateDiffAdjusted;\n        } else {\n            // Case: AMM price is higher than priceRate\n            return self.stabilityRateBase.rayDiv(WadRay.RAY + rateDiffAdjusted);\n        }\n    }\n\n    /**\n     * @dev Function to calculate the interest using a compounded interest rate formula\n     * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\n     *\n     *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n     *\n     * The approximation slightly underpays liquidity providers and undercharges borrowers\n     * with the advantage of great gas cost reductions\n     * The Aave whitepaper contains reference to the approximation\n     * with a table showing the margin of error per different time periods\n     *\n     * @param self rate configuration for the asset\n     * @param _currentTimestamp The timestamp of the last update of the interest\n     * @return The interest rate compounded during the timeDelta, in ray\n     **/\n    function calculateCompoundedInterest(\n        StabilityRateConfig storage self,\n        uint256 _currentTimestamp\n    ) internal view returns (uint256) {\n        //solium-disable-next-line\n        uint256 exp = _currentTimestamp - uint256(self.lastUpdateTimestamp);\n\n        if (exp == 0) {\n            return WadRay.RAY;\n        }\n\n        uint256 expMinusOne;\n        uint256 expMinusTwo;\n        uint256 basePowerTwo;\n        uint256 basePowerThree;\n        unchecked {\n            expMinusOne = exp - 1;\n\n            expMinusTwo = exp > 2 ? exp - 2 : 0;\n\n            basePowerTwo = self.stabilityRate.rayMul(self.stabilityRate) / (SECONDS_PER_YEAR * SECONDS_PER_YEAR);\n            basePowerThree = basePowerTwo.rayMul(self.stabilityRate) / SECONDS_PER_YEAR;\n        }\n\n        uint256 secondTerm = exp * expMinusOne * basePowerTwo;\n        unchecked {\n            secondTerm /= 2;\n        }\n        uint256 thirdTerm = exp * expMinusOne * expMinusTwo * basePowerThree;\n        unchecked {\n            thirdTerm /= 6;\n        }\n\n        return WadRay.RAY + (self.stabilityRate * exp) / SECONDS_PER_YEAR + secondTerm + thirdTerm;\n    }\n\n    /**\n     * @dev Returns the ongoing normalized debt index for the borrowers\n     * A value of 1e27 means there is no interest. As time passes, the interest is accrued\n     * A value of 2*1e27 means that for each unit of debt, one unit worth of interest has been accumulated\n     * @param self rate configuration for the asset\n     * @return The normalized debt index. expressed in ray\n     **/\n    function getNormalizedDebtIndex(StabilityRateConfig storage self) internal view returns (uint256) {\n        if (self.asset == address(0)) return WadRay.RAY;\n        //solium-disable-next-line\n        if (self.lastUpdateTimestamp == uint40(block.timestamp)) {\n            //if the index was updated in the same block, no need to perform any calculation\n            return self.debtIndex;\n        }\n\n        return self.calculateCompoundedInterest(block.timestamp).rayMul(self.debtIndex);\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibUI.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n// solhint-disable-next-line\nimport {IERC20Permit} from \"../../shared/IERC20Permit.sol\";\nimport {AggregatorV2V3Interface} from \"../../vendor/flux/interfaces/AggregatorV2V3Interface.sol\";\nimport {IUniswapV2Pair} from \"../../vendor/uniswap/v2-core/interfaces/IUniswapV2Pair.sol\";\nimport {IKrStaking} from \"../../staking/interfaces/IKrStaking.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {IUniswapV2OracleCompat} from \"../amm-oracle/IUniswapV2OracleCompat.sol\";\nimport {KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {MinterState, ms} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/* solhint-disable contract-name-camelcase */\n/* solhint-disable var-name-mixedcase */\n\n/**\n * @title Library for UI related views\n * @author Kresko\n */\nlibrary LibUI {\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n\n    struct CollateralAssetInfoUser {\n        address assetAddress;\n        address oracleAddress;\n        address anchorAddress;\n        uint256 amount;\n        uint256 amountUSD;\n        uint256 cFactor;\n        uint256 liquidationIncentive;\n        uint8 decimals;\n        uint256 index;\n        uint256 price;\n        string symbol;\n        string name;\n    }\n\n    struct CollateralAssetInfo {\n        address assetAddress;\n        address oracleAddress;\n        address anchorAddress;\n        uint256 price;\n        uint256 value;\n        uint256 liquidationIncentive;\n        uint256 cFactor;\n        uint8 decimals;\n        string symbol;\n        string name;\n        bool marketOpen;\n    }\n\n    struct ProtocolParams {\n        uint256 minDebtValue;\n        uint256 minCollateralRatio;\n        uint256 liquidationThreshold;\n    }\n\n    struct krAssetInfo {\n        address oracleAddress;\n        address assetAddress;\n        address anchorAddress;\n        uint256 price;\n        uint256 ammPrice;\n        uint256 priceRate;\n        uint256 stabilityRate;\n        uint256 value;\n        uint256 openFee;\n        uint256 closeFee;\n        uint256 kFactor;\n        string symbol;\n        string name;\n        bool marketOpen;\n    }\n\n    struct KreskoUser {\n        krAssetInfoUser[] krAssets;\n        CollateralAssetInfoUser[] collateralAssets;\n        uint256 healthFactor;\n        uint256 debtActualUSD;\n        uint256 debtUSD;\n        uint256 collateralActualUSD;\n        uint256 collateralUSD;\n        uint256 minCollateralUSD;\n        uint256 borrowingPowerUSD;\n    }\n\n    struct PairData {\n        uint8 decimals0;\n        uint8 decimals1;\n        uint256 reserve0;\n        uint256 reserve1;\n        uint256 totalSupply;\n    }\n\n    struct GenericInfo {\n        address assetAddress;\n        uint256 kFactor;\n        uint256 cFactor;\n        uint256 price;\n        bool isKrAsset;\n        bool isCollateral;\n        uint256 debtAmount;\n        uint256 depositAmount;\n        uint256 walletBalance;\n    }\n\n    struct Price {\n        uint256 price;\n        uint256 timestamp;\n        address assetAddress;\n        uint80 roundId;\n        bool marketOpen;\n    }\n\n    struct Allowance {\n        address owner;\n        address spender;\n        uint256 allowance;\n    }\n\n    struct Balance {\n        address token;\n        uint256 balance;\n    }\n\n    struct TokenMetadata {\n        uint8 decimals;\n        string symbol;\n        string name;\n        uint256 totalSupply;\n    }\n\n    struct StakingData {\n        uint256 pid;\n        address depositToken;\n        uint256 totalDeposits;\n        uint256 allocPoint;\n        uint256 rewardPerBlocks;\n        uint256 lastRewardBlock;\n        uint256 depositAmount;\n        address[] rewardTokens;\n        uint256[] rewardAmounts;\n    }\n\n    struct krAssetInfoUser {\n        address assetAddress;\n        address oracleAddress;\n        address anchorAddress;\n        uint256 amount;\n        uint256 amountScaled;\n        uint256 priceRate;\n        uint256 stabilityRate;\n        uint256 amountUSD;\n        uint256 index;\n        uint256 kFactor;\n        uint256 price;\n        uint256 ammPrice;\n        string symbol;\n        string name;\n        uint256 openFee;\n        uint256 closeFee;\n    }\n\n    function getBalances(address[] memory _tokens, address account) internal view returns (Balance[] memory balances) {\n        balances = new Balance[](_tokens.length);\n        for (uint256 i; i < _tokens.length; i++) {\n            balances[i] = Balance({token: address(_tokens[i]), balance: IERC20Permit(_tokens[i]).balanceOf(account)});\n        }\n    }\n\n    function getAllowances(\n        address[] memory _tokens,\n        address owner,\n        address spender\n    ) internal view returns (Allowance[] memory allowances) {\n        allowances = new Allowance[](_tokens.length);\n        for (uint256 i; i < _tokens.length; i++) {\n            allowances[i] = Allowance({\n                allowance: IERC20Permit(_tokens[i]).allowance(owner, spender),\n                spender: spender,\n                owner: owner\n            });\n        }\n    }\n\n    function getStakingData(address _account, address _staking) internal view returns (StakingData[] memory result) {\n        IKrStaking staking = IKrStaking(_staking);\n        IKrStaking.Reward[] memory rewards = staking.allPendingRewards(_account);\n        result = new StakingData[](rewards.length);\n\n        for (uint256 i; i < rewards.length; i++) {\n            IKrStaking.PoolInfo memory poolInfo = staking.poolInfo(rewards[i].pid);\n            address depositTokenAddress = address(poolInfo.depositToken);\n            result[i] = StakingData({\n                pid: rewards[i].pid,\n                totalDeposits: poolInfo.depositToken.balanceOf(_staking),\n                allocPoint: poolInfo.allocPoint,\n                depositToken: depositTokenAddress,\n                depositAmount: staking.userInfo(rewards[i].pid, _account).amount,\n                rewardTokens: rewards[i].tokens,\n                rewardAmounts: rewards[i].amounts,\n                rewardPerBlocks: staking.rewardPerBlockFor(depositTokenAddress),\n                lastRewardBlock: poolInfo.lastRewardBlock\n            });\n        }\n    }\n\n    function borrowingPowerUSD(address _account) internal view returns (uint256) {\n        uint256 minCollateral = ms().getAccountMinimumCollateralValueAtRatio(\n            _account,\n            ms().minimumCollateralizationRatio\n        );\n        uint256 collateral = ms().getAccountCollateralValue(_account);\n\n        if (collateral < minCollateral) {\n            return 0;\n        } else {\n            return collateral - minCollateral;\n        }\n    }\n\n    function batchOracleValues(\n        address[] memory _assets,\n        address[] memory _priceFeeds,\n        address[] memory _marketStatusFeeds\n    ) internal view returns (Price[] memory result) {\n        require(_marketStatusFeeds.length == _priceFeeds.length, Error.PRICEFEEDS_MUST_MATCH_STATUS_FEEDS);\n        result = new Price[](_assets.length);\n        for (uint256 i; i < _assets.length; i++) {\n            result[i] = Price({\n                price: uint256(AggregatorV2V3Interface(_priceFeeds[i]).latestAnswer()),\n                timestamp: AggregatorV2V3Interface(_priceFeeds[i]).latestTimestamp(),\n                assetAddress: _assets[i],\n                roundId: uint80(AggregatorV2V3Interface(_priceFeeds[i]).latestRound()),\n                marketOpen: AggregatorV2V3Interface(_marketStatusFeeds[i]).latestMarketOpen()\n            });\n        }\n    }\n\n    function krAssetInfos(address[] memory assetAddresses) internal view returns (krAssetInfo[] memory result) {\n        result = new krAssetInfo[](assetAddresses.length);\n        for (uint256 i; i < assetAddresses.length; i++) {\n            address assetAddress = assetAddresses[i];\n            KrAsset memory krAsset = ms().kreskoAssets[assetAddress];\n            uint256 ammPrice;\n            uint256 stabilityRate;\n            uint256 priceRate;\n            if (irs().srAssets[assetAddress].asset != address(0)) {\n                ammPrice = IUniswapV2OracleCompat(ms().ammOracle).consultKrAsset(assetAddress, 1 ether);\n                stabilityRate = irs().srAssets[assetAddress].calculateStabilityRate();\n                priceRate = irs().srAssets[assetAddress].getPriceRate();\n            }\n            result[i] = krAssetInfo({\n                value: ms().getKrAssetValue(assetAddress, 1 ether, false),\n                oracleAddress: address(krAsset.oracle),\n                anchorAddress: krAsset.anchor,\n                assetAddress: assetAddress,\n                closeFee: krAsset.closeFee,\n                openFee: krAsset.openFee,\n                kFactor: krAsset.kFactor,\n                price: uint256(krAsset.oracle.latestAnswer()),\n                stabilityRate: stabilityRate,\n                priceRate: priceRate,\n                ammPrice: ammPrice,\n                marketOpen: krAsset.marketStatusOracle.latestMarketOpen(),\n                symbol: IERC20Permit(assetAddress).symbol(),\n                name: IERC20Permit(assetAddress).name()\n            });\n        }\n    }\n\n    function collateralAssetInfos(\n        address[] memory assetAddresses\n    ) internal view returns (CollateralAssetInfo[] memory result) {\n        result = new CollateralAssetInfo[](assetAddresses.length);\n        for (uint256 i; i < assetAddresses.length; i++) {\n            address assetAddress = assetAddresses[i];\n            CollateralAsset memory collateralAsset = ms().collateralAssets[assetAddress];\n            uint8 decimals = IERC20Permit(assetAddress).decimals();\n\n            (uint256 value, uint256 price) = ms().getCollateralValueAndOraclePrice(\n                assetAddress,\n                1 * 10 ** decimals,\n                false\n            );\n\n            result[i] = CollateralAssetInfo({\n                value: value,\n                oracleAddress: address(collateralAsset.oracle),\n                anchorAddress: collateralAsset.anchor,\n                assetAddress: assetAddress,\n                liquidationIncentive: collateralAsset.liquidationIncentive,\n                cFactor: collateralAsset.factor,\n                decimals: decimals,\n                price: price,\n                marketOpen: collateralAsset.marketStatusOracle.latestMarketOpen(),\n                symbol: IERC20Permit(assetAddress).symbol(),\n                name: IERC20Permit(assetAddress).name()\n            });\n        }\n    }\n\n    function collateralAssetInfoFor(\n        address _account\n    ) internal view returns (CollateralAssetInfoUser[] memory result, uint256 totalCollateralUSD) {\n        address[] memory collateralAssetAddresses = ms().getDepositedCollateralAssets(_account);\n        if (collateralAssetAddresses.length > 0) {\n            result = new CollateralAssetInfoUser[](collateralAssetAddresses.length);\n            for (uint256 i; i < collateralAssetAddresses.length; i++) {\n                address assetAddress = collateralAssetAddresses[i];\n                uint8 decimals = IERC20Permit(assetAddress).decimals();\n\n                uint256 amount = ms().getCollateralDeposits(_account, assetAddress);\n\n                (uint256 amountUSD, uint256 price) = ms().getCollateralValueAndOraclePrice(assetAddress, amount, true);\n\n                totalCollateralUSD + amountUSD;\n                result[i] = CollateralAssetInfoUser({\n                    amount: amount,\n                    amountUSD: amountUSD,\n                    liquidationIncentive: ms().collateralAssets[assetAddress].liquidationIncentive,\n                    anchorAddress: ms().collateralAssets[assetAddress].anchor,\n                    oracleAddress: address(ms().collateralAssets[assetAddress].oracle),\n                    assetAddress: assetAddress,\n                    cFactor: ms().collateralAssets[assetAddress].factor,\n                    decimals: decimals,\n                    index: i,\n                    price: price,\n                    symbol: IERC20Permit(assetAddress).symbol(),\n                    name: IERC20Permit(assetAddress).name()\n                });\n            }\n        }\n    }\n\n    function krAssetInfoFor(\n        address _account\n    ) internal view returns (krAssetInfoUser[] memory result, uint256 totalDebtUSD) {\n        address[] memory krAssetAddresses = ms().mintedKreskoAssets[_account];\n        if (krAssetAddresses.length > 0) {\n            result = new krAssetInfoUser[](krAssetAddresses.length);\n            for (uint256 i; i < krAssetAddresses.length; i++) {\n                address assetAddress = krAssetAddresses[i];\n                KrAsset memory krAsset = ms().kreskoAssets[assetAddress];\n                uint256 amount = ms().getKreskoAssetDebtPrincipal(_account, assetAddress);\n                uint256 amountScaled = ms().getKreskoAssetDebtScaled(_account, assetAddress);\n\n                uint256 amountUSD = ms().getKrAssetValue(assetAddress, amount, true);\n                uint256 ammPrice;\n                uint256 stabilityRate;\n                uint256 priceRate;\n                if (irs().srAssets[assetAddress].asset != address(0)) {\n                    stabilityRate = irs().srAssets[assetAddress].calculateStabilityRate();\n                    priceRate = irs().srAssets[assetAddress].getPriceRate();\n                    ammPrice = IUniswapV2OracleCompat(ms().ammOracle).consultKrAsset(assetAddress, 1 ether);\n                }\n                totalDebtUSD + amountUSD;\n                result[i] = krAssetInfoUser({\n                    assetAddress: assetAddress,\n                    oracleAddress: address(krAsset.oracle),\n                    anchorAddress: krAsset.anchor,\n                    openFee: krAsset.openFee,\n                    closeFee: krAsset.closeFee,\n                    amount: amount,\n                    amountScaled: amountScaled,\n                    amountUSD: amountUSD,\n                    stabilityRate: stabilityRate,\n                    priceRate: priceRate,\n                    index: i,\n                    kFactor: krAsset.kFactor,\n                    price: uint256(krAsset.oracle.latestAnswer()),\n                    ammPrice: ammPrice,\n                    symbol: IERC20Permit(assetAddress).symbol(),\n                    name: IERC20Permit(assetAddress).name()\n                });\n            }\n        }\n    }\n\n    function healthFactorFor(address _account) internal view returns (uint256) {\n        uint256 userDebt = ms().getAccountKrAssetValue(_account);\n        uint256 userCollateral = ms().getAccountCollateralValue(_account);\n\n        if (userDebt > 0) {\n            return userCollateral.wadDiv(userDebt);\n        } else {\n            return 0;\n        }\n    }\n\n    function kreskoUser(address _account) internal view returns (KreskoUser memory user) {\n        (krAssetInfoUser[] memory krInfos, uint256 totalDebtUSD) = krAssetInfoFor(_account);\n        (CollateralAssetInfoUser[] memory collateralInfos, uint256 totalCollateralUSD) = collateralAssetInfoFor(\n            _account\n        );\n\n        if (krInfos.length > 0 || collateralInfos.length > 0) {\n            user = KreskoUser({\n                collateralAssets: collateralInfos,\n                krAssets: krInfos,\n                borrowingPowerUSD: borrowingPowerUSD(_account),\n                healthFactor: healthFactorFor(_account),\n                debtActualUSD: totalDebtUSD,\n                debtUSD: ms().getAccountKrAssetValue(_account),\n                collateralActualUSD: totalCollateralUSD,\n                collateralUSD: ms().getAccountCollateralValue(_account),\n                minCollateralUSD: ms().getAccountMinimumCollateralValueAtRatio(\n                    _account,\n                    ms().minimumCollateralizationRatio\n                )\n            });\n        }\n    }\n}\n"
    },
    "src/contracts/minter/MinterModifiers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {ms} from \"./MinterStorage.sol\";\nimport {Action} from \"./MinterTypes.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\nabstract contract MinterModifiers {\n    /**\n     * @notice Reverts if a collateral asset does not exist within the protocol.\n     * @param _collateralAsset The address of the collateral asset.\n     */\n    modifier collateralAssetExists(address _collateralAsset) {\n        require(ms().collateralAssets[_collateralAsset].exists, Error.COLLATERAL_DOESNT_EXIST);\n        _;\n    }\n\n    /**\n     * @notice Reverts if a collateral asset already exists within the protocol.\n     * @param _collateralAsset The address of the collateral asset.\n     */\n    modifier collateralAssetDoesNotExist(address _collateralAsset) {\n        require(!ms().collateralAssets[_collateralAsset].exists, Error.COLLATERAL_EXISTS);\n        _;\n    }\n\n    /**\n     * @notice Reverts if a Kresko asset does not exist within the protocol. Does not revert if\n     * the Kresko asset is not mintable.\n     * @param _kreskoAsset The address of the Kresko asset.\n     */\n    modifier kreskoAssetExists(address _kreskoAsset) {\n        require(ms().kreskoAssets[_kreskoAsset].exists, Error.KRASSET_DOESNT_EXIST);\n        _;\n    }\n\n    /**\n     * @notice Reverts if the symbol of a Kresko asset already exists within the protocol.\n     * @param _kreskoAsset The address of the Kresko asset.\n     */\n    modifier kreskoAssetDoesNotExist(address _kreskoAsset) {\n        require(!ms().kreskoAssets[_kreskoAsset].exists, Error.KRASSET_EXISTS);\n        _;\n    }\n\n    /// @dev Simple check for the enabled flag\n    function ensureNotPaused(address _asset, Action _action) internal view virtual {\n        require(!ms().safetyState[_asset][_action].pause.enabled, Error.ACTION_PAUSED_FOR_ASSET);\n    }\n}\n"
    },
    "src/contracts/minter/MinterState.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {LibKrAsset} from \"./libs/LibKrAsset.sol\";\nimport {LibAccount} from \"./libs/LibAccount.sol\";\nimport {LibCollateral} from \"./libs/LibCollateral.sol\";\nimport {LibCalculation} from \"./libs/LibCalculation.sol\";\nimport {LibBurn} from \"./libs/LibBurn.sol\";\nimport {LibMint} from \"./libs/LibMint.sol\";\nimport {Action, SafetyState, CollateralAsset, KrAsset} from \"./MinterTypes.sol\";\n\n/* solhint-disable state-visibility */\nusing LibCalculation for MinterState global;\nusing LibKrAsset for MinterState global;\nusing LibCollateral for MinterState global;\nusing LibAccount for MinterState global;\nusing LibBurn for MinterState global;\nusing LibMint for MinterState global;\n\n/**\n * @title Storage layout for the minter state\n * @author Kresko\n */\nstruct MinterState {\n    /* -------------------------------------------------------------------------- */\n    /*                               Initialization                               */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Initialization version\n    uint256 initializations;\n    bytes32 domainSeparator;\n    /* -------------------------------------------------------------------------- */\n    /*                           Configurable Parameters                          */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice The recipient of protocol fees.\n    address feeRecipient;\n    /// @notice The factor used to calculate the incentive a liquidator receives in the form of seized collateral.\n    uint256 liquidationIncentiveMultiplier;\n    /// @notice The minimum ratio of collateral to debt that can be taken by direct action.\n    uint256 minimumCollateralizationRatio;\n    /// @notice The minimum USD value of an individual synthetic asset debt position.\n    uint256 minimumDebtValue;\n    /// @notice The collateralization ratio at which positions may be liquidated.\n    uint256 liquidationThreshold;\n    /// @notice Flag tells if there is a need to perform safety checks on user actions\n    bool safetyStateSet;\n    /// @notice asset -> action -> state\n    mapping(address => mapping(Action => SafetyState)) safetyState;\n    /* -------------------------------------------------------------------------- */\n    /*                              Collateral Assets                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Mapping of collateral asset token address to information on the collateral asset.\n    mapping(address => CollateralAsset) collateralAssets;\n    /**\n     * @notice Mapping of account -> asset -> deposit amount\n     */\n    mapping(address => mapping(address => uint256)) collateralDeposits;\n    /// @notice Mapping of account -> collateral asset addresses deposited\n    mapping(address => address[]) depositedCollateralAssets;\n    /* -------------------------------------------------------------------------- */\n    /*                                Kresko Assets                               */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Mapping of kresko asset token address to information on the Kresko asset.\n    mapping(address => KrAsset) kreskoAssets;\n    /// @notice Mapping of account -> krAsset -> debt amount owed to the protocol\n    mapping(address => mapping(address => uint256)) kreskoAssetDebt;\n    /// @notice Mapping of account -> addresses of borrowed krAssets\n    mapping(address => address[]) mintedKreskoAssets;\n    /// @notice The AMM oracle address.\n    address ammOracle;\n    /// @notice Offchain oracle decimals\n    uint8 extOracleDecimals;\n    /// @notice Liquidation Overflow Multiplier, multiplies max liquidatable value.\n    uint256 maxLiquidationMultiplier;\n}\n"
    },
    "src/contracts/minter/MinterStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\npragma solidity >=0.8.19;\n\nimport {MinterState} from \"./MinterState.sol\";\n\n// Storage position\nbytes32 constant MINTER_STORAGE_POSITION = keccak256(\"kresko.minter.storage\");\n\nfunction ms() pure returns (MinterState storage state) {\n    bytes32 position = MINTER_STORAGE_POSITION;\n    assembly {\n        state.slot := position\n    }\n}\n"
    },
    "src/contracts/minter/MinterTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {AggregatorV2V3Interface} from \"../vendor/flux/interfaces/AggregatorV2V3Interface.sol\";\nimport {IKreskoAssetAnchor} from \"../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {LibAssetUtility} from \"./libs/LibAssetUtility.sol\";\n\n/* solhint-disable state-visibility */\n\n/* -------------------------------------------------------------------------- */\n/*                                  CONSTANTS                                 */\n/* -------------------------------------------------------------------------- */\n\nlibrary Constants {\n    uint256 constant FP_DECIMALS = 18;\n\n    uint256 constant FP_SCALING_FACTOR = 10 ** FP_DECIMALS;\n\n    uint256 constant ONE_HUNDRED_PERCENT = 1 ether;\n\n    uint256 constant BASIS_POINT = 1e14;\n\n    /// @dev The maximum configurable close fee.\n    uint256 constant MAX_CLOSE_FEE = 0.1 ether; // 10%\n\n    /// @dev The maximum configurable open fee.\n    uint256 constant MAX_OPEN_FEE = 0.1 ether; // 10%\n\n    /// @dev The maximum configurable protocol fee per asset for collateral pool swaps.\n    uint256 constant MAX_COLLATERAL_POOL_PROTOCOL_FEE = 0.5 ether; // 50%\n\n    /// @dev Overflow over maximum liquidatable value to allow leeway for users after one happens.\n    uint256 constant MIN_MAX_LIQUIDATION_MULTIPLIER = ONE_HUNDRED_PERCENT + BASIS_POINT; // 100.01% or .01% over\n\n    /// @dev The minimum configurable minimum collateralization ratio.\n    uint256 constant MIN_COLLATERALIZATION_RATIO = ONE_HUNDRED_PERCENT;\n\n    /// @dev The minimum configurable liquidation incentive multiplier.\n    /// This means liquidator only receives equal amount of collateral to debt repaid.\n    uint256 constant MIN_LIQUIDATION_INCENTIVE_MULTIPLIER = ONE_HUNDRED_PERCENT;\n\n    /// @dev The maximum configurable liquidation incentive multiplier.\n    /// This means liquidator receives 25% bonus collateral compared to the debt repaid.\n    uint256 constant MAX_LIQUIDATION_INCENTIVE_MULTIPLIER = 1.25 ether; // 125%\n\n    /// @dev The maximum configurable minimum debt USD value. 8 decimals.\n    uint256 constant MAX_MIN_DEBT_VALUE = 1000 gwei; // $1,000\n}\n\n/* -------------------------------------------------------------------------- */\n/*                                    ENUM                                    */\n/* -------------------------------------------------------------------------- */\n\n/**\n * @dev Protocol user facing actions\n *\n * Deposit = 0\n * Withdraw = 1,\n * Repay = 2,\n * Borrow = 3,\n * Liquidate = 4\n */\nenum Action {\n    Deposit,\n    Withdraw,\n    Repay,\n    Borrow,\n    Liquidation\n}\n/**\n * @dev Fee types\n *\n * Open = 0\n * Close = 1\n */\nenum Fee {\n    Open,\n    Close\n}\n\n/* ========================================================================== */\n/*                                   STRUCTS                                  */\n/* ========================================================================== */\n\n/**\n * @notice Initialization arguments for the protocol\n */\nstruct MinterInitArgs {\n    address admin;\n    address council;\n    address treasury;\n    uint8 extOracleDecimals;\n    uint256 minimumCollateralizationRatio;\n    uint256 minimumDebtValue;\n    uint256 liquidationThreshold;\n}\n\n/**\n * @notice Configurable parameters within the protocol\n */\n\nstruct MinterParams {\n    uint256 minimumCollateralizationRatio;\n    uint256 minimumDebtValue;\n    uint256 liquidationThreshold;\n    uint256 liquidationOverflowPercentage;\n    address feeRecipient;\n    uint8 extOracleDecimals;\n}\n\n/**\n * @notice Information on a token that is a KreskoAsset.\n * @dev Each KreskoAsset has 18 decimals.\n * @param kFactor The k-factor used for calculating the required collateral value for KreskoAsset debt.\n * @param oracle The oracle that provides the USD price of one KreskoAsset.\n * @param supplyLimit The total supply limit of the KreskoAsset.\n * @param anchor The anchor address\n * @param closeFee The percentage paid in fees when closing a debt position of this type.\n * @param openFee The percentage paid in fees when opening a debt position of this type.\n * @param exists Whether the KreskoAsset exists within the protocol.\n */\nstruct KrAsset {\n    uint256 kFactor;\n    AggregatorV2V3Interface oracle;\n    AggregatorV2V3Interface marketStatusOracle;\n    uint256 supplyLimit;\n    address anchor;\n    uint256 closeFee;\n    uint256 openFee;\n    bool exists;\n}\nusing LibAssetUtility for KrAsset global;\n/**\n * @notice Information on a token that can be used as collateral.\n * @dev Setting the factor to zero effectively makes the asset useless as collateral while still allowing\n * it to be deposited and withdrawn.\n * @param factor The collateral factor used for calculating the value of the collateral.\n * @param oracle The oracle that provides the USD price of one collateral asset.\n * @param anchor If the collateral is a KreskoAsset, the anchor address\n * @param decimals The decimals for the token, stored here to avoid repetitive external calls.\n * @param exists Whether the collateral asset exists within the protocol.\n * @param liquidationIncentive The liquidation incentive for the asset\n */\nstruct CollateralAsset {\n    uint256 factor;\n    AggregatorV2V3Interface oracle;\n    AggregatorV2V3Interface marketStatusOracle;\n    address anchor;\n    uint8 decimals;\n    bool exists;\n    uint256 liquidationIncentive;\n}\nusing LibAssetUtility for CollateralAsset global;\n\n/// @notice Configuration for pausing `Action`\nstruct Pause {\n    bool enabled;\n    uint256 timestamp0;\n    uint256 timestamp1;\n}\n\n/// @notice Safety configuration for assets\nstruct SafetyState {\n    Pause pause;\n}\n"
    },
    "src/contracts/shared/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.19;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\n\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable not-rely-on-time */\n/* solhint-disable func-name-mixedcase */\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @author Kresko: modified to an upgradeable\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\n\ncontract ERC20Upgradeable is Initializable, IERC20Permit {\n    /* -------------------------------------------------------------------------- */\n    /*                                   Events                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /* -------------------------------------------------------------------------- */\n    /*                                ERC20 Storage                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  EIP-2612                                  */\n    /* -------------------------------------------------------------------------- */\n\n    mapping(address => uint256) public nonces;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Immutables                                 */\n    /* -------------------------------------------------------------------------- */\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    constructor() payable initializer {\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20Upgradeable_init(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) internal onlyInitializing {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    READ                                    */\n    /* -------------------------------------------------------------------------- */\n\n    function balanceOf(address _account) public view virtual returns (uint256) {\n        return _balances[_account];\n    }\n\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    function allowance(address _owner, address _spender) public view virtual returns (uint256) {\n        return _allowances[_owner][_spender];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 ERC20 Logic                                */\n    /* -------------------------------------------------------------------------- */\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _balances[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balances[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        uint256 allowed = _allowances[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) _allowances[from][msg.sender] = allowed - amount;\n\n        _balances[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               EIP-2612 Logic                               */\n    /* -------------------------------------------------------------------------- */\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            _allowances[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Internals                                 */\n    /* -------------------------------------------------------------------------- */\n\n    function _mint(address to, uint256 amount) internal virtual {\n        _totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balances[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        _balances[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {\n        // Silence state mutability warning without generating bytecode.\n    }\n}\n"
    },
    "src/contracts/shared/IERC165.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.19;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/contracts/shared/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.19;\n\n/* solhint-disable func-name-mixedcase */\n\ninterface IERC20Permit {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function allowance(address, address) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function name() external view returns (string memory);\n\n    function nonces(address) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "src/contracts/shared/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(IERC20Permit token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20Permit token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Permit token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20Permit token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20Permit token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Permit token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "src/contracts/staking/interfaces/IKrStaking.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IKrStaking {\n    struct UserInfo {\n        uint256 amount;\n        uint256[] rewardDebts;\n    }\n\n    struct PoolInfo {\n        IERC20 depositToken; // Address of LP token contract.\n        uint128 allocPoint; // How many allocation points assigned to this pool.\n        uint128 lastRewardBlock; // Last block number that rewards distribution occurs.\n        uint256[] accRewardPerShares; // Accumulated rewards per share, times 1e12.\n        address[] rewardTokens; // Reward tokens for this pool.\n    }\n\n    struct Reward {\n        uint256 pid;\n        address[] tokens;\n        uint256[] amounts;\n    }\n\n    /**\n     * @notice Get id for a token\n     * @notice Useful for external contracts\n     * @param _depositToken depositToken in `_poolInfo`\n     * @return pid of pool with `_depositToken`\n     * @return found ensure 0 index\n     */\n    function getPidFor(address _depositToken) external view returns (uint256 pid, bool found);\n\n    /**\n     * @notice Amount of pools\n     */\n    function poolLength() external view returns (uint256);\n\n    /**\n     * @notice Deposits tokens for @param _to\n     * @param _to address that msg.sender deposits tokens for\n     * @param _pid in `_poolInfo`\n     * @param _amount amount of tokens to deposit\n     */\n    function deposit(address _to, uint256 _pid, uint256 _amount) external payable;\n\n    /**\n     * @notice Trusted helper contract can withdraw rewards and deposits on behalf of an account\n     * @notice For eg. withdraw + remove liquidity\n     * @param _for account to withdraw from\n     * @param _pid id in `_poolInfo`\n     * @param _amount amount to withdraw\n     * @param _rewardRecipient reward recipient\n     */\n    function withdrawFor(address _for, uint256 _pid, uint256 _amount, address _rewardRecipient) external payable;\n\n    /**\n     * @notice Trusted helper contract can claim rewards on behalf of an account\n     * @param _for account to claim for\n     * @param _pid id in `_poolInfo`\n     * @param _rewardRecipient address that receives rewards\n     */\n    function claimFor(address _for, uint256 _pid, address _rewardRecipient) external payable;\n\n    /**\n     * @notice Get all pending rewards for an account\n     * @param _account to get rewards for\n     * @return all pending rewards\n     */\n    function allPendingRewards(address _account) external view returns (Reward[] memory);\n\n    /**\n     * @notice Get account information on a pool\n     * @param _pid in `_poolInfo`\n     * @param _account to get information for\n     * @return information on the account\n     */\n    function userInfo(uint256 _pid, address _account) external view returns (UserInfo memory);\n\n    /**\n     * @notice Get pool information\n     * @param _pid in `_poolInfo`\n     * @return pool information\n     */\n    function poolInfo(uint256 _pid) external view returns (PoolInfo memory);\n\n    function rewardPerBlockFor(address depositTokenAddress) external view returns (uint256 rewardPerBlocks);\n\n    /**\n     * @notice A rescue function for missent msg.value\n     * @notice Since we are using payable functions to save gas on calls\n     */\n    function rescueNative() external payable;\n\n    /**\n     * @notice A rescue function for missent tokens / airdrops\n     * @notice This cannot withdraw any deposits due `ensurePoolDoesNotExist` modifier.\n     */\n    function rescueNonPoolToken(IERC20 _tokenToRescue, uint256 _amount) external payable;\n\n    /**\n     * @notice Set new allocations for a pool\n     * @notice Set `_newAllocPoint` to 0 to retire a pool\n     * @param _pid pool to modify\n     * @param _newAllocPoint new allocation (weight) for rewards\n     */\n    function setPool(uint256 _pid, uint128 _newAllocPoint) external payable;\n\n    /**\n     * @notice Adds a new reward pool\n     * @notice Updates reward token count in case of adding extra tokens\n     * @param _rewardTokens tokens to reward from this pool\n     * @param _depositToken token to deposit for rewards\n     * @param _allocPoint weight of rewards this pool receives\n     * @param _startBlock block when rewards start\n     */\n    function addPool(\n        address[] calldata _rewardTokens,\n        IERC20 _depositToken,\n        uint128 _allocPoint,\n        uint128 _startBlock\n    ) external payable;\n\n    /**\n     * @notice Adjust/Set reward per block for a particular reward token\n     * @param _rewardToken token to adjust the drip for\n     * @param _rewardPerBlock tokens to drip per block\n     */\n    function setRewardPerBlockFor(address _rewardToken, uint256 _rewardPerBlock) external payable;\n\n    /**\n     * @notice Emergency function, withdraws deposits from a pool\n     * @notice This will forfeit your rewards.\n     * @param _pid pool id to withdraw tokens from\n     */\n    function emergencyWithdraw(uint256 _pid) external payable;\n\n    /**\n     * @notice Claim rewards only\n     * @param _pid id in `_poolInfo`\n     * @param _rewardRecipient address to send rewards to\n     */\n    function claim(uint256 _pid, address _rewardRecipient) external payable;\n\n    /**\n     * @notice Withdraw deposited tokens and rewards.\n     * @param _pid id in `_poolInfo`\n     * @param _amount amount to withdraw\n     * @param _rewardRecipient address to send rewards to\n     */\n    function withdraw(uint256 _pid, uint256 _amount, address _rewardRecipient) external payable;\n\n    /**\n     * @notice Updates all pools to be up-to date\n     */\n    function massUpdatePools() external payable;\n\n    /**\n     * @notice Updates a pools reward variables to be up-to date\n     * @param _pid pool to update\n     */\n    function updatePool(uint256 _pid) external payable returns (PoolInfo memory pool);\n\n    /**\n     * @notice Get pending rewards from a certain pool\n     * @param _pid id in `_poolInfo`\n     * @param _user id in `_userInfo[_pid]`\n     * @return rewards pending rewards\n     */\n    function pendingRewards(uint256 _pid, address _user) external view returns (Reward memory rewards);\n}\n"
    },
    "src/contracts/staking/KrStaking.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IKrStaking} from \"./interfaces/IKrStaking.sol\";\n\ncontract KrStaking is AccessControlUpgradeable, ReentrancyGuardUpgradeable, IKrStaking {\n    using SafeERC20 for IERC20;\n\n    // keccak256(\"kresko.operator.role\")\n    bytes32 public constant OPERATOR_ROLE = 0x8952ae23cc3fea91b9dba0cefa16d18a26ca2bf124b54f42b5d04bce3aacecd2;\n\n    /**\n     * ==================================================\n     * =============== Storage ==========================\n     * ==================================================\n     */\n\n    // Info of each staked user.\n    mapping(uint256 => mapping(address => UserInfo)) private _userInfo;\n\n    // Reward token drip per block\n    mapping(address => uint256) public rewardPerBlockFor;\n\n    // Info of each pool.\n    PoolInfo[] private _poolInfo;\n\n    // Total allocation points.\n    uint128 public totalAllocPoint;\n\n    /**\n     * ==================================================\n     * ============== Events ============================\n     * ==================================================\n     */\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event ClaimRewards(address indexed user, address indexed rewardToken, uint256 indexed amount);\n\n    /**\n     * ==================================================\n     * ============== Initializer =======================\n     * ==================================================\n     */\n\n    /**\n     * @notice Initialize the contract with a single pool\n     * @notice Sets initial reward token and rates\n     * @notice Sets the caller as DEFAULT_ADMIN\n     */\n    function initialize(\n        address[] calldata _rewardTokens,\n        uint256[] calldata _rewardPerBlocks,\n        IERC20 _depositToken,\n        uint128 _allocPoint,\n        uint128 _startBlock,\n        address _admin,\n        address _operator\n    ) external initializer {\n        require(_rewardPerBlocks.length == _rewardTokens.length, \"Reward tokens must have a rewardPerBlock value\");\n\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n        _setupRole(OPERATOR_ROLE, _operator);\n        _setupRole(OPERATOR_ROLE, msg.sender);\n\n        // Set initial reward tokens and allocations\n        for (uint256 i; i < _rewardTokens.length; i++) {\n            rewardPerBlockFor[_rewardTokens[i]] = _rewardPerBlocks[i];\n        }\n\n        // Push the initial pool in.\n        _poolInfo.push(\n            PoolInfo({\n                depositToken: _depositToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: _startBlock,\n                accRewardPerShares: new uint256[](_rewardTokens.length),\n                rewardTokens: _rewardTokens\n            })\n        );\n\n        totalAllocPoint += _allocPoint;\n    }\n\n    /**\n     * ==================================================\n     * =============== Modifiers ========================\n     * ==================================================\n     */\n\n    /**\n     * @notice Ensures no pool exists with this depositToken\n     * @param _depositToken to check\n     */\n    modifier ensurePoolDoesNotExist(IERC20 _depositToken) {\n        for (uint256 i; i < _poolInfo.length; i++) {\n            require(address(_poolInfo[i].depositToken) != address(_depositToken), \"KR: poolExists\");\n        }\n        _;\n    }\n\n    /**\n     * @notice Ensures this pool exists\n     * @param _pid to check\n     */\n    modifier ensurePoolExists(uint256 _pid) {\n        require(address(_poolInfo[_pid].depositToken) != address(0), \"KR: !poolExists\");\n        _;\n    }\n\n    /**\n     * ==================================================\n     * ================== Views =========================\n     * ==================================================\n     */\n\n    /// @inheritdoc IKrStaking\n    function pendingRewards(uint256 _pid, address _user) public view returns (Reward memory rewards) {\n        PoolInfo memory pool = _poolInfo[_pid];\n        UserInfo memory user = _userInfo[_pid][_user];\n        uint256 depositTokenSupply = pool.depositToken.balanceOf(address(this));\n        uint256 rewardTokensLength = pool.rewardTokens.length;\n\n        rewards = Reward({pid: _pid, tokens: pool.rewardTokens, amounts: new uint256[](rewardTokensLength)});\n\n        if (depositTokenSupply != 0 && user.amount > 0) {\n            for (uint256 rewardIndex; rewardIndex < rewardTokensLength; rewardIndex++) {\n                uint256 accRewardPerShare = pool.accRewardPerShares[rewardIndex];\n\n                uint256 rewardPerBlock = rewardPerBlockFor[pool.rewardTokens[rewardIndex]];\n                uint256 blocks = block.number - pool.lastRewardBlock;\n                uint256 reward = (rewardPerBlock * blocks * pool.allocPoint) / totalAllocPoint;\n\n                accRewardPerShare += (reward * 1e12) / depositTokenSupply;\n\n                rewards.amounts[rewardIndex] = (user.amount * accRewardPerShare) / 1e12 - user.rewardDebts[rewardIndex];\n                rewards.tokens[rewardIndex] = pool.rewardTokens[rewardIndex];\n            }\n        }\n    }\n\n    /// @inheritdoc IKrStaking\n    function allPendingRewards(address _account) external view returns (Reward[] memory allRewards) {\n        allRewards = new Reward[](_poolInfo.length);\n        for (uint256 pid; pid < _poolInfo.length; pid++) {\n            Reward memory poolReward = pendingRewards(pid, _account);\n            allRewards[pid] = poolReward;\n        }\n    }\n\n    /// @inheritdoc IKrStaking\n    function poolLength() external view returns (uint256) {\n        return _poolInfo.length;\n    }\n\n    /// @inheritdoc IKrStaking\n    function poolInfo(uint256 _pid) external view returns (PoolInfo memory) {\n        return _poolInfo[_pid];\n    }\n\n    /// @inheritdoc IKrStaking\n    function getPidFor(address _depositToken) external view returns (uint256 pid, bool found) {\n        for (pid; pid < _poolInfo.length; pid++) {\n            if (address(_poolInfo[pid].depositToken) == _depositToken) {\n                found = true;\n                break;\n            }\n        }\n    }\n\n    /// @inheritdoc IKrStaking\n    function userInfo(uint256 _pid, address _account) external view returns (UserInfo memory) {\n        return _userInfo[_pid][_account];\n    }\n\n    /**\n     * ==================================================\n     * =========== Core public functions ================\n     * ==================================================\n     */\n\n    /// @inheritdoc IKrStaking\n    function massUpdatePools() public payable {\n        for (uint256 pid; pid < _poolInfo.length; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n    /// @inheritdoc IKrStaking\n    function updatePool(uint256 _pid) public payable returns (PoolInfo memory pool) {\n        pool = _poolInfo[_pid];\n        // Updates once per block\n        if (block.number > pool.lastRewardBlock) {\n            uint256 deposits = pool.depositToken.balanceOf(address(this));\n            // No rewards for 0 deposits\n            if (deposits > 0) {\n                for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n                    // Reward per block for a particular reward token\n                    uint256 rewardPerBlock = rewardPerBlockFor[pool.rewardTokens[rewardIndex]];\n                    // Blocks advanced since last update\n                    uint256 blocks = block.number - pool.lastRewardBlock;\n                    // Allocation for this particular pool\n                    uint256 reward = (rewardPerBlock * blocks * pool.allocPoint) / totalAllocPoint;\n                    // Increment accumulated rewards for new block height\n                    pool.accRewardPerShares[rewardIndex] += (reward * 1e12) / deposits;\n                }\n            }\n            // No further updates within same block height\n            pool.lastRewardBlock = uint128(block.number);\n            // storage\n            _poolInfo[_pid] = pool;\n        }\n    }\n\n    /// @inheritdoc IKrStaking\n    function deposit(address _to, uint256 _pid, uint256 _amount) external payable nonReentrant ensurePoolExists(_pid) {\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][_to];\n\n        // Initialize rewardDebts\n        if (user.rewardDebts.length == 0) {\n            user.rewardDebts = new uint256[](pool.rewardTokens.length);\n        }\n\n        pool.depositToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n        user.amount += _amount;\n\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] += (_amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n        }\n\n        emit Deposit(_to, _pid, _amount);\n    }\n\n    /// @inheritdoc IKrStaking\n    function withdraw(uint256 _pid, uint256 _amount, address _rewardRecipient) external payable nonReentrant {\n        require(_amount > 0, \"KR: 0-withdraw\");\n        require(_rewardRecipient != address(0), \"KR: !rewardRecipient\");\n\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][msg.sender];\n\n        sendRewards(pool, user, _rewardRecipient);\n\n        // Send whole balance in case of amount exceeds deposits\n        if (_amount > user.amount) {\n            _amount = user.amount;\n            user.amount = 0;\n        } else {\n            user.amount -= _amount;\n        }\n\n        pool.depositToken.safeTransfer(address(msg.sender), _amount);\n\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n        }\n\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n\n    /// @inheritdoc IKrStaking\n    function claim(uint256 _pid, address _rewardRecipient) external payable nonReentrant {\n        require(_rewardRecipient != address(0), \"KR: !rewardRecipient\");\n\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][msg.sender];\n\n        if (user.amount > 0) {\n            sendRewards(pool, user, _rewardRecipient);\n\n            for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n                user.rewardDebts[rewardIndex] = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n            }\n        }\n    }\n\n    /// @inheritdoc IKrStaking\n    function emergencyWithdraw(uint256 _pid) external payable nonReentrant {\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][msg.sender];\n        pool.depositToken.safeTransfer(address(msg.sender), user.amount);\n        user.amount = 0;\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] = 0;\n        }\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n    }\n\n    /**\n     * ==================================================\n     * ============= Admin functions ====================\n     * ==================================================\n     */\n\n    /// @inheritdoc IKrStaking\n    function setRewardPerBlockFor(\n        address _rewardToken,\n        uint256 _rewardPerBlock\n    ) external payable onlyRole(OPERATOR_ROLE) {\n        rewardPerBlockFor[_rewardToken] = _rewardPerBlock;\n    }\n\n    /// @inheritdoc IKrStaking\n    function addPool(\n        address[] calldata _rewardTokens,\n        IERC20 _depositToken,\n        uint128 _allocPoint,\n        uint128 _startBlock\n    ) external payable onlyRole(OPERATOR_ROLE) ensurePoolDoesNotExist(_depositToken) {\n        require(_rewardTokens.length > 0, \"KR: !rewardTokens\");\n\n        totalAllocPoint += _allocPoint;\n\n        _poolInfo.push(\n            PoolInfo({\n                depositToken: _depositToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: _startBlock != 0 ? _startBlock : uint128(block.number),\n                accRewardPerShares: new uint256[](_rewardTokens.length),\n                rewardTokens: _rewardTokens\n            })\n        );\n    }\n\n    /// @inheritdoc IKrStaking\n    function setPool(\n        uint256 _pid,\n        uint128 _newAllocPoint\n    ) external payable onlyRole(OPERATOR_ROLE) ensurePoolExists(_pid) {\n        totalAllocPoint -= _poolInfo[_pid].allocPoint + _newAllocPoint;\n        _poolInfo[_pid].allocPoint = _newAllocPoint;\n    }\n\n    /**\n     * ==================================================\n     * ============ Protected functions =================\n     * ==================================================\n     */\n\n    /// @inheritdoc IKrStaking\n    function withdrawFor(\n        address _for,\n        uint256 _pid,\n        uint256 _amount,\n        address _rewardRecipient\n    ) external payable nonReentrant onlyRole(OPERATOR_ROLE) {\n        require(_amount > 0, \"KR: 0-withdraw\");\n        require(_rewardRecipient != address(0), \"KR: !rewardRecipient\");\n\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][_for];\n\n        sendRewards(pool, user, _rewardRecipient);\n\n        // Send whole balance in case of amount exceeds deposits\n        if (_amount > user.amount) {\n            _amount = user.amount;\n            user.amount = 0;\n        } else {\n            user.amount -= _amount;\n        }\n\n        pool.depositToken.safeTransfer(address(msg.sender), _amount);\n\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n        }\n\n        emit Withdraw(_for, _pid, _amount);\n    }\n\n    /// @inheritdoc IKrStaking\n    function claimFor(\n        address _for,\n        uint256 _pid,\n        address _rewardRecipient\n    ) external payable nonReentrant onlyRole(OPERATOR_ROLE) {\n        require(_rewardRecipient != address(0), \"KR: !rewardRecipient\");\n\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][_for];\n\n        if (user.amount > 0) {\n            sendRewards(pool, user, _rewardRecipient);\n\n            for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n                user.rewardDebts[rewardIndex] = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n            }\n        }\n    }\n\n    /// @inheritdoc IKrStaking\n    function rescueNative() external payable onlyRole(OPERATOR_ROLE) {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    /// @inheritdoc IKrStaking\n    function rescueNonPoolToken(\n        IERC20 _tokenToRescue,\n        uint256 _amount\n    ) external payable onlyRole(OPERATOR_ROLE) ensurePoolDoesNotExist(_tokenToRescue) {\n        _tokenToRescue.safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * ==================================================\n     * ============= Internal functions =================\n     * ==================================================\n     */\n\n    /**\n     * @notice Loops over pools reward tokens and sends them to the user\n     * @param pool pool to send rewards from in `_poolInfo`\n     * @param user users info in the @param pool\n     * @param recipient user to send rewards to\n     */\n    function sendRewards(PoolInfo memory pool, UserInfo memory user, address recipient) internal {\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            uint256 rewardDebt = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n            uint256 pending = rewardDebt - user.rewardDebts[rewardIndex];\n\n            if (pending > 0) {\n                IERC20(pool.rewardTokens[rewardIndex]).safeTransfer(recipient, pending);\n                emit ClaimRewards(recipient, pool.rewardTokens[rewardIndex], pending);\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/staking/KrStakingHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IUniswapV2Factory} from \"../vendor/uniswap/v2-core/interfaces/IUniswapV2Factory.sol\";\nimport {IUniswapV2Router02} from \"../vendor/uniswap/v2-periphery/interfaces/IUniswapV2Router02.sol\";\nimport {IKrStaking, IERC20} from \"./interfaces/IKrStaking.sol\";\n\ncontract KrStakingHelper {\n    using SafeERC20 for IERC20;\n\n    IUniswapV2Router02 public immutable router;\n    IUniswapV2Factory public immutable factory;\n    IKrStaking public immutable staking;\n\n    constructor(IUniswapV2Router02 _router, IUniswapV2Factory _factory, IKrStaking _staking) {\n        router = _router;\n        factory = _factory;\n        staking = _staking;\n    }\n\n    /**\n     * ==================================================\n     * ============ Events ==============================\n     * ==================================================\n     */\n\n    event LiquidityAndStakeAdded(address indexed to, uint256 indexed amount, uint256 indexed pid);\n    event LiquidityAndStakeRemoved(address indexed to, uint256 indexed amount, uint256 indexed pid);\n    event ClaimRewardsMulti(address indexed to);\n\n    /**\n     * ==================================================\n     * ============ Public functions ====================\n     * ==================================================\n     */\n\n    /**\n     * @notice Add liquidity to a pair, deposit liquidity tokens to staking\n     * @param tokenA address of tokenA\n     * @param tokenB address of tokenB\n     * @param amountADesired optimal amount of token A\n     * @param amountBDesired optimal amount of token B\n     * @param amountAMin min amountA (slippage)\n     * @param amountBMin min amountB (slippage)\n     * @param to address to deposit for\n     * @param deadline transaction deadline (used by router)\n     */\n    function addLiquidityAndStake(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256) {\n        require(to != address(0), \"KR: !address\");\n        address pair = factory.getPair(tokenA, tokenB);\n        (uint256 pid, bool found) = staking.getPidFor(pair);\n\n        require(found, \"KR: !poolExists\");\n\n        IERC20(tokenA).safeTransferFrom(msg.sender, address(this), amountADesired);\n        IERC20(tokenB).safeTransferFrom(msg.sender, address(this), amountBDesired);\n\n        IERC20(tokenA).approve(address(router), amountADesired);\n        IERC20(tokenB).approve(address(router), amountBDesired);\n\n        (, , uint256 liquidity) = router.addLiquidity(\n            tokenA,\n            tokenB,\n            amountADesired,\n            amountBDesired,\n            amountAMin,\n            amountBMin,\n            address(this),\n            deadline\n        );\n\n        IERC20(pair).approve(address(staking), liquidity);\n        staking.deposit(to, pid, liquidity);\n\n        emit LiquidityAndStakeAdded(to, liquidity, pid);\n        return liquidity;\n    }\n\n    /**\n     * @notice Withdraw liquidity tokens from staking, remove the underlying\n     * @param tokenA address of tokenA\n     * @param tokenB address of tokenB\n     * @param liquidity liquidity token amount to remove\n     * @param amountAMin min amountA to receive (slippage)\n     * @param amountBMin min amountB to receive (slippage)\n     * @param to address that receives the underlying\n     * @param deadline transaction deadline (used by router)\n     */\n    function withdrawAndRemoveLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external {\n        require(to != address(0), \"KR: !address\");\n        address pair = factory.getPair(tokenA, tokenB);\n        (uint256 pid, bool found) = staking.getPidFor(pair);\n\n        require(found, \"KR: !poolExists\");\n\n        staking.withdrawFor(msg.sender, pid, liquidity, to);\n\n        IERC20(pair).approve(address(router), liquidity);\n        router.removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n\n        emit LiquidityAndStakeRemoved(to, liquidity, pid);\n    }\n\n    /**\n     * @notice Claim rewards from each pool\n     * @param to address that receives the rewards\n     */\n    function claimRewardsMulti(address to) external {\n        require(to != address(0), \"KR: !address\");\n\n        uint256 length = staking.poolLength();\n\n        for (uint256 i; i < length; i++) {\n            staking.claimFor(msg.sender, i, to);\n        }\n\n        emit ClaimRewardsMulti(to);\n    }\n}\n"
    },
    "src/contracts/test/Funder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IERC20Permit} from \"../shared/IERC20Permit.sol\";\nimport {WETH} from \"./WETH.sol\";\nimport {IAccountStateFacet} from \"../minter/interfaces/IAccountStateFacet.sol\";\n\n/* solhint-disable no-empty-blocks */\n\nstruct Token {\n    uint256 amount;\n    address token;\n}\n\ncontract Funder {\n    mapping(address => bool) public owners;\n    mapping(address => bool) public funded;\n    IAccountStateFacet public kresko;\n\n    event Funded(address indexed account);\n\n    constructor(address _kresko) {\n        owners[msg.sender] = true;\n        kresko = IAccountStateFacet(_kresko);\n    }\n\n    function toggleOwners(address[] calldata accounts) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < accounts.length; i++) {\n            owners[accounts[i]] = !owners[accounts[i]];\n        }\n    }\n\n    function isEligible(address account) public view returns (bool) {\n        return account.balance < 0.001 ether && kresko.getAccountKrAssetValue(account) > 0 && !funded[account];\n    }\n\n    function distribute(address[] calldata accounts, uint256 ethAmount) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < accounts.length; i++) {\n            if (!isEligible(accounts[i])) continue;\n\n            funded[accounts[i]] = true;\n            payable(accounts[i]).transfer(ethAmount);\n            emit Funded(accounts[i]);\n        }\n    }\n\n    function drain() external {\n        require(owners[msg.sender], \"!o\");\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}\n"
    },
    "src/contracts/test/FunderTestnetExtended.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {MockERC20} from \"./MockERC20.sol\";\nimport {WETH} from \"./WETH.sol\";\nimport {IAccountStateFacet} from \"../minter/interfaces/IAccountStateFacet.sol\";\n\n/* solhint-disable no-empty-blocks */\n\nstruct Token {\n    uint256 amount;\n    address token;\n}\n\ncontract FunderTestnetExtended {\n    mapping(address => bool) public owners;\n    mapping(address => bool) public funded;\n    IAccountStateFacet public kresko;\n    MockERC20 public tokenToFund;\n    uint256 public fundAmount = 10000 ether;\n    event Funded(address indexed account);\n\n    constructor(address _kresko, address _tokenToFund) {\n        owners[msg.sender] = true;\n        kresko = IAccountStateFacet(_kresko);\n        tokenToFund = MockERC20(_tokenToFund);\n    }\n\n    function toggleOwners(address[] calldata accounts) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < accounts.length; i++) {\n            owners[accounts[i]] = !owners[accounts[i]];\n        }\n    }\n\n    function isEligible(address account) public view returns (bool) {\n        return !funded[account];\n    }\n\n    function setFundAmount(uint256 amount) external {\n        require(owners[msg.sender], \"!o\");\n        fundAmount = amount;\n    }\n\n    function distribute() external {\n        if (!isEligible(msg.sender)) return;\n        tokenToFund.mint(msg.sender, fundAmount);\n        funded[msg.sender] = true;\n        emit Funded(msg.sender);\n    }\n\n    function drain() external {\n        require(owners[msg.sender], \"!o\");\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}\n"
    },
    "src/contracts/test/interfaces/ISmockFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\ninterface ISmockFacet {\n    event NewMessage(address indexed caller, string message);\n\n    function activate() external;\n\n    function disable() external;\n\n    function setMessage(string memory message) external;\n}\n"
    },
    "src/contracts/test/markets/UniswapMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.6.6;\n\nimport {IUniswapV2Router02} from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport {TransferHelper} from \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport {UniswapV2LiquidityMathLibrary, SafeMath, Babylonian, UniswapV2Library} from \"./UniswapV2LiquidityMathLibrary.sol\";\n\ncontract UniswapMath {\n    using SafeMath for uint256;\n    IUniswapV2Router02 public immutable router;\n    address public immutable factory;\n\n    constructor(address factory_, IUniswapV2Router02 router_) {\n        factory = factory_;\n        router = router_;\n    }\n\n    // computes the direction and magnitude of the profit-maximizing trade\n    function computeProfitMaximizingTrade(\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 reserveA,\n        uint256 reserveB\n    ) public pure returns (bool aToB, uint256 amountIn) {\n        aToB = reserveA.mul(truePriceTokenB) / reserveB < truePriceTokenA;\n\n        uint256 invariant = reserveA.mul(reserveB);\n\n        uint256 leftSide = Babylonian.sqrt(\n            invariant.mul(aToB ? truePriceTokenA : truePriceTokenB).mul(1000) /\n                uint256(aToB ? truePriceTokenB : truePriceTokenA).mul(997)\n        );\n        uint256 rightSide = (aToB ? reserveA.mul(1000) : reserveB.mul(1000)) / 997;\n\n        // compute the amount that must be sent to move the price to the profit-maximizing price\n        amountIn = leftSide.sub(rightSide);\n    }\n\n    // swaps an amount of either token such that the trade is profit-maximizing, given an external true price\n    // true price is expressed in the ratio of token A to token B\n    // caller must approve this contract to spend whichever token is intended to be swapped\n    function swapToPrice(\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 maxSpendTokenA,\n        uint256 maxSpendTokenB,\n        address to,\n        uint256 deadline\n    ) public {\n        // true price is expressed as a ratio, so both values must be non-zero\n        require(truePriceTokenA != 0 && truePriceTokenB != 0, \"ExampleSwapToPrice: ZERO_PRICE\");\n        // caller can specify 0 for either if they wish to swap in only one direction, but not both\n        require(maxSpendTokenA != 0 || maxSpendTokenB != 0, \"ExampleSwapToPrice: ZERO_SPEND\");\n\n        bool aToB;\n        uint256 amountIn;\n        {\n            (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n            (aToB, amountIn) = computeProfitMaximizingTrade(truePriceTokenA, truePriceTokenB, reserveA, reserveB);\n        }\n\n        // spend up to the allowance of the token in\n        uint256 maxSpend = aToB ? maxSpendTokenA : maxSpendTokenB;\n        if (amountIn > maxSpend) {\n            amountIn = maxSpend;\n        }\n\n        address tokenIn = aToB ? tokenA : tokenB;\n        address tokenOut = aToB ? tokenB : tokenA;\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, address(this), amountIn);\n        TransferHelper.safeApprove(tokenIn, address(router), amountIn);\n\n        address[] memory path = new address[](2);\n        path[0] = tokenIn;\n        path[1] = tokenOut;\n\n        router.swapExactTokensForTokens(\n            amountIn,\n            0, // amountOutMin: we can skip computing this number because the math is tested\n            path,\n            to,\n            deadline\n        );\n    }\n\n    function profitMaximizingTrade(\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB\n    ) external view returns (uint256 amountIn, bool aToB) {\n        (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n        (aToB, amountIn) = computeProfitMaximizingTrade(truePriceTokenA, truePriceTokenB, reserveA, reserveB);\n    }\n\n    function getReservesAfterArbitrage(\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB\n    ) external view returns (uint256 reserveA, uint256 reserveB) {\n        return\n            UniswapV2LiquidityMathLibrary.getReservesAfterArbitrage(\n                factory,\n                tokenA,\n                tokenB,\n                truePriceTokenA,\n                truePriceTokenB\n            );\n    }\n\n    function getLiquidityValue(\n        address tokenA,\n        address tokenB,\n        uint256 liquidityAmount\n    ) external view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n        return UniswapV2LiquidityMathLibrary.getLiquidityValue(factory, tokenA, tokenB, liquidityAmount);\n    }\n\n    function getLiquidityValueAfterArbitrageToPrice(\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 liquidityAmount\n    ) external view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n        return\n            UniswapV2LiquidityMathLibrary.getLiquidityValueAfterArbitrageToPrice(\n                factory,\n                tokenA,\n                tokenB,\n                truePriceTokenA,\n                truePriceTokenB,\n                liquidityAmount\n            );\n    }\n\n    function getGasCostOfGetLiquidityValueAfterArbitrageToPrice(\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 liquidityAmount\n    ) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        UniswapV2LiquidityMathLibrary.getLiquidityValueAfterArbitrageToPrice(\n            factory,\n            tokenA,\n            tokenB,\n            truePriceTokenA,\n            truePriceTokenB,\n            liquidityAmount\n        );\n        uint256 gasAfter = gasleft();\n        return gasBefore - gasAfter;\n    }\n}\n"
    },
    "src/contracts/test/markets/UniswapV2LiquidityMathLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nimport {Babylonian} from \"@uniswap/lib/contracts/libraries/Babylonian.sol\";\nimport {UniswapV2Library, SafeMath, IUniswapV2Pair, IUniswapV2Factory} from \"../../vendor/uniswap/v2-periphery/libraries/UniswapV2Library.sol\";\n\n// library containing some math for dealing with the liquidity shares of a pair, e.g. computing their exact value\n// in terms of the underlying tokens\nlibrary UniswapV2LiquidityMathLibrary {\n    using SafeMath for uint256;\n\n    // computes the direction and magnitude of the profit-maximizing trade\n    function computeProfitMaximizingTrade(\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 reserveA,\n        uint256 reserveB\n    ) public pure returns (bool aToB, uint256 amountIn) {\n        aToB = reserveA.mul(truePriceTokenB) / reserveB < truePriceTokenA;\n\n        uint256 invariant = reserveA.mul(reserveB);\n\n        uint256 leftSide = Babylonian.sqrt(\n            invariant.mul(aToB ? truePriceTokenA : truePriceTokenB).mul(1000) /\n                uint256(aToB ? truePriceTokenB : truePriceTokenA).mul(997)\n        );\n        uint256 rightSide = (aToB ? reserveA.mul(1000) : reserveB.mul(1000)) / 997;\n\n        // compute the amount that must be sent to move the price to the profit-maximizing price\n        amountIn = leftSide.sub(rightSide);\n    }\n\n    // gets the reserves after an arbitrage moves the price to\n    // the profit-maximizing ratio given an externally observed true price\n    function getReservesAfterArbitrage(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        // first get reserves before the swap\n        (reserveA, reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n\n        require(reserveA > 0 && reserveB > 0, \"UniswapV2ArbitrageLibrary: ZERO_PAIR_RESERVES\");\n\n        // then compute how much to swap to arb to the true price\n        (bool aToB, uint256 amountIn) = computeProfitMaximizingTrade(\n            truePriceTokenA,\n            truePriceTokenB,\n            reserveA,\n            reserveB\n        );\n\n        if (amountIn == 0) {\n            return (reserveA, reserveB);\n        }\n\n        // now affect the trade to the reserves\n        if (aToB) {\n            uint256 amountOut = UniswapV2Library.getAmountOut(amountIn, reserveA, reserveB);\n            reserveA += amountIn;\n            reserveB -= amountOut;\n        } else {\n            uint256 amountOut = UniswapV2Library.getAmountOut(amountIn, reserveB, reserveA);\n            reserveB += amountIn;\n            reserveA -= amountOut;\n        }\n    }\n\n    // computes liquidity value given all the parameters of the pair\n    function computeLiquidityValue(\n        uint256 reservesA,\n        uint256 reservesB,\n        uint256 totalSupply,\n        uint256 liquidityAmount,\n        bool feeOn,\n        uint256 kLast\n    ) internal pure returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n        if (feeOn && kLast > 0) {\n            uint256 rootK = Babylonian.sqrt(reservesA.mul(reservesB));\n            uint256 rootKLast = Babylonian.sqrt(kLast);\n            if (rootK > rootKLast) {\n                uint256 numerator1 = totalSupply;\n                uint256 numerator2 = rootK.sub(rootKLast);\n                uint256 denominator = rootK.mul(5).add(rootKLast);\n                uint256 feeLiquidity = numerator1.mul(numerator2) / denominator;\n                totalSupply = totalSupply.add(feeLiquidity);\n            }\n        }\n        return (reservesA.mul(liquidityAmount) / totalSupply, reservesB.mul(liquidityAmount) / totalSupply);\n    }\n\n    // get all current parameters from the pair and compute value of a liquidity amount\n    // **note this is subject to manipulation, e.g. sandwich attacks**. prefer passing a manipulation resistant price to\n    // #getLiquidityValueAfterArbitrageToPrice\n    function getLiquidityValue(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint256 liquidityAmount\n    ) internal view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n        (uint256 reservesA, uint256 reservesB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n        IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, tokenA, tokenB));\n        bool feeOn = IUniswapV2Factory(factory).feeTo() != address(0);\n        uint256 kLast = feeOn ? pair.kLast() : 0;\n        uint256 totalSupply = pair.totalSupply();\n        return computeLiquidityValue(reservesA, reservesB, totalSupply, liquidityAmount, feeOn, kLast);\n    }\n\n    // Given two tokens, tokenA and tokenB, and their \"true price\",\n    // i.e. the observed ratio of value of token A to token B,\n    // and a liquidity amount, returns the value of the liquidity in terms of tokenA and tokenB\n    function getLiquidityValueAfterArbitrageToPrice(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 liquidityAmount\n    ) internal view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n        bool feeOn = IUniswapV2Factory(factory).feeTo() != address(0);\n        IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, tokenA, tokenB));\n        uint256 kLast = feeOn ? pair.kLast() : 0;\n        uint256 totalSupply = pair.totalSupply();\n\n        // this also checks that totalSupply > 0\n        require(totalSupply >= liquidityAmount && liquidityAmount > 0, \"ComputeLiquidityValue: LIQUIDITY_AMOUNT\");\n\n        (uint256 reservesA, uint256 reservesB) = getReservesAfterArbitrage(\n            factory,\n            tokenA,\n            tokenB,\n            truePriceTokenA,\n            truePriceTokenB\n        );\n\n        return computeLiquidityValue(reservesA, reservesB, totalSupply, liquidityAmount, feeOn, kLast);\n    }\n}\n"
    },
    "src/contracts/test/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.19;\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    mapping(address => bool) public minters;\n    address public owner;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _initialSupply\n    ) ERC20(_name, _symbol, _decimals) {\n        _mint(msg.sender, _initialSupply);\n        minters[msg.sender] = true;\n    }\n\n    function reinitializeERC20(string memory _name, string memory _symbol) external {\n        require(msg.sender == owner, \"!owner\");\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function toggleMinters(address[] calldata _minters) external {\n        require(minters[msg.sender], \"!minter\");\n        for (uint256 i; i < _minters.length; i++) {\n            minters[_minters[i]] = !minters[_minters[i]];\n        }\n    }\n\n    function mint(address to, uint256 value) public virtual {\n        require(minters[msg.sender], \"!minter\");\n        _mint(to, value);\n    }\n\n    function burn(address from, uint256 value) public virtual {\n        require(minters[msg.sender], \"!minter\");\n        _burn(from, value);\n    }\n}\n"
    },
    "src/contracts/test/Multisender.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {MockERC20} from \"./MockERC20.sol\";\nimport {WETH} from \"./WETH.sol\";\n\n/* solhint-disable no-empty-blocks */\n\nstruct Token {\n    uint256 amount;\n    address token;\n}\n\ncontract Multisender {\n    mapping(address => bool) public owners;\n    mapping(address => bool) public funded;\n\n    Token[] internal tokens;\n    WETH internal weth;\n    address internal kiss;\n\n    event Funded(address indexed account);\n\n    constructor(Token[] memory _tokens, address _weth, address _kiss) {\n        owners[msg.sender] = true;\n\n        for (uint256 i; i < _tokens.length; i++) {\n            tokens.push(_tokens[i]);\n        }\n        weth = WETH(_weth);\n        kiss = _kiss;\n    }\n\n    function addToken(Token memory _token) external {\n        require(owners[msg.sender], \"!o\");\n        tokens.push(_token);\n    }\n\n    function setTokens(Token[] memory _tokens) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < _tokens.length; i++) {\n            tokens[i].amount = _tokens[i].amount;\n            tokens[i].token = _tokens[i].token;\n        }\n    }\n\n    function toggleOwners(address[] calldata accounts) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < accounts.length; i++) {\n            owners[accounts[i]] = !owners[accounts[i]];\n        }\n    }\n\n    function distribute(\n        address[] calldata accounts,\n        uint256 wethAmount,\n        uint256 ethAmount,\n        uint256 kissAmount\n    ) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < accounts.length; i++) {\n            if (funded[accounts[i]]) continue;\n\n            funded[accounts[i]] = true;\n            for (uint256 j; j < tokens.length; j++) {\n                MockERC20(tokens[j].token).mint(accounts[i], tokens[j].amount);\n            }\n\n            weth.deposit(wethAmount);\n            weth.transfer(accounts[i], wethAmount);\n            MockERC20(kiss).transfer(accounts[i], kissAmount);\n\n            payable(accounts[i]).transfer(ethAmount);\n\n            emit Funded(accounts[i]);\n        }\n    }\n\n    function drain() external {\n        require(owners[msg.sender], \"!o\");\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function drainERC20() external {\n        require(owners[msg.sender], \"!o\");\n        MockERC20(kiss).transfer(msg.sender, MockERC20(kiss).balanceOf(address(this)));\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}\n"
    },
    "src/contracts/test/SmockCollateralReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\nimport {IDepositWithdrawFacet} from \"../minter/interfaces/IDepositWithdrawFacet.sol\";\nimport {ICollateralReceiver} from \"../minter/interfaces/ICollateralReceiver.sol\";\nimport {IERC20Permit} from \"../shared/IERC20Permit.sol\";\n\ncontract SmockCollateralReceiver is ICollateralReceiver {\n    IDepositWithdrawFacet public kresko;\n    function(address, address, uint256, bytes memory) internal callbackLogic;\n\n    address public account;\n    address public collateralAsset;\n    uint256 public withdrawalAmountRequested;\n    uint256 public withdrawalAmountReceived;\n    Params public userData;\n\n    struct Params {\n        uint256 val;\n        uint256 val1;\n        address addr;\n    }\n\n    constructor(address _kresko) {\n        kresko = IDepositWithdrawFacet(_kresko);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Callback                                  */\n    /* -------------------------------------------------------------------------- */\n\n    function onUncheckedCollateralWithdraw(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawalAmount,\n        uint256 _depositedCollateralAssetIndex,\n        bytes memory _userData\n    ) external returns (bytes memory) {\n        _depositedCollateralAssetIndex;\n        callbackLogic(_account, _collateralAsset, _withdrawalAmount, _userData);\n        return \"\";\n    }\n\n    function execute(\n        address _collateralAsset,\n        uint256 _amount,\n        function(address, address, uint256, bytes memory) internal logic\n    ) internal {\n        bytes memory data = abi.encode(_amount, 0, address(0));\n        execute(_collateralAsset, _amount, data, logic);\n    }\n\n    function execute(\n        address _collateralAsset,\n        uint256 _amount,\n        bytes memory data,\n        function(address, address, uint256, bytes memory) internal logic\n    ) internal {\n        callbackLogic = logic;\n        withdrawalAmountRequested = _amount;\n        kresko.withdrawCollateralUnchecked(msg.sender, _collateralAsset, _amount, 0, data);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               Test functions                               */\n    /* -------------------------------------------------------------------------- */\n\n    // should send correct values to the callback\n    function test(address _collateralAsset, uint256 _amount) external {\n        execute(_collateralAsset, _amount, logicBase);\n    }\n\n    function testWithdrawalAmount(address _collateralAsset, uint256 _amount) external {\n        execute(_collateralAsset, _amount, logicTestWithdrawalAmount);\n    }\n\n    // should be able to redeposit\n    function testRedeposit(address _collateralAsset, uint256 _amount) external {\n        execute(_collateralAsset, _amount, logicRedeposit);\n    }\n\n    // should be able to redeposit\n    function testInsufficientRedeposit(address _collateralAsset, uint256 _amount) external {\n        execute(_collateralAsset, _amount, logicInsufficientRedeposit);\n    }\n\n    function testDepositAlternate(address _collateralWithdraw, uint _amount, address _collateralDeposit) external {\n        bytes memory data = abi.encode(_amount, 0, _collateralDeposit);\n        execute(_collateralWithdraw, _amount, data, logicDepositAlternate);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             Callback Execution                             */\n    /* -------------------------------------------------------------------------- */\n\n    function logicDepositAlternate(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawalAmount,\n        bytes memory _userData\n    ) internal {\n        _collateralAsset;\n        userData = abi.decode(_userData, (Params));\n        withdrawalAmountReceived = _withdrawalAmount;\n        IERC20Permit(userData.addr).transferFrom(_account, address(this), userData.val);\n        IERC20Permit(userData.addr).approve(address(kresko), userData.val);\n        // redeposit all\n        kresko.depositCollateral(_account, userData.addr, userData.val);\n    }\n\n    function logicBase(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawalAmount,\n        bytes memory _userData\n    ) internal {\n        // just set data\n        account = _account;\n        collateralAsset = _collateralAsset;\n        withdrawalAmountReceived = _withdrawalAmount;\n        userData = abi.decode(_userData, (Params));\n    }\n\n    function logicTestWithdrawalAmount(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawalAmount,\n        bytes memory _userData\n    ) internal {\n        _userData;\n        account = _account;\n        require(IERC20Permit(_collateralAsset).balanceOf(address(this)) == _withdrawalAmount, \"wrong amount received\");\n    }\n\n    function logicRedeposit(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawalAmount,\n        bytes memory _userData\n    ) internal {\n        _userData;\n        withdrawalAmountReceived = _withdrawalAmount;\n        IERC20Permit(_collateralAsset).approve(address(kresko), _withdrawalAmount);\n        // redeposit all\n        kresko.depositCollateral(_account, _collateralAsset, _withdrawalAmount);\n    }\n\n    function logicInsufficientRedeposit(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawalAmount,\n        bytes memory _userData\n    ) internal {\n        _userData;\n        withdrawalAmountReceived = _withdrawalAmount;\n        IERC20Permit(_collateralAsset).approve(address(kresko), 1);\n        // bare minimum redeposit\n        kresko.depositCollateral(_account, _collateralAsset, 1);\n    }\n}\n"
    },
    "src/contracts/test/SmockFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {ISmockFacet} from \"./interfaces/ISmockFacet.sol\";\nimport {DiamondModifiers} from \"../diamond/DiamondModifiers.sol\";\nimport {SmockStorage, Errors} from \"./SmockStorage.sol\";\n\nbytes32 constant TEST_OPERATOR_ROLE = keccak256(\"kresko.test.operator\");\n\n/**\n * @dev Use for Smock fakes / mocks.\n */\ncontract SmockFacet is DiamondModifiers, ISmockFacet {\n    uint256 public constant MESSAGE_THROTTLE = 2;\n\n    function operator() external view returns (address) {\n        return SmockStorage.state().operator;\n    }\n\n    function activate() external override onlyRole(TEST_OPERATOR_ROLE) onlyDisabled {\n        SmockStorage.activate();\n    }\n\n    function disable() external override onlyRole(TEST_OPERATOR_ROLE) onlyActive {\n        SmockStorage.disable();\n    }\n\n    function smockInitialized() external view returns (bool) {\n        return SmockStorage.state().initialized;\n    }\n\n    function setMessage(string memory message) external override onlyActive {\n        require(block.number >= SmockStorage.state().lastMessageBlock + MESSAGE_THROTTLE, \"Cant set message yet\");\n\n        SmockStorage.state().message = message;\n        SmockStorage.state().callers[msg.sender] = true;\n\n        emit SmockStorage.Call(msg.sender);\n        emit NewMessage(msg.sender, message);\n    }\n\n    modifier onlyActive() {\n        require(SmockStorage.state().isActive, Errors.ACTIVE);\n        _;\n    }\n    modifier onlyDisabled() {\n        require(!SmockStorage.state().isActive, Errors.NOT_ACTIVE);\n        _;\n    }\n}\n"
    },
    "src/contracts/test/SmockFacet2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {GeneralEvent} from \"../libs/Events.sol\";\nimport {ISmockFacet} from \"./interfaces/ISmockFacet.sol\";\nimport {TEST_OPERATOR_ROLE} from \"./SmockFacet.sol\";\nimport {SmockStorage} from \"./SmockStorage.sol\";\n\ncontract SmockFacet2 {\n    function initialize() external {\n        SmockStorage.stateExtended().extended = true;\n    }\n\n    function getOldStructValueFromExtended() external view returns (bool) {\n        return SmockStorage.stateExtended().initialized;\n    }\n\n    function getNewStructValueFromExtended() external view returns (bool) {\n        return SmockStorage.stateExtended().extended;\n    }\n}\n"
    },
    "src/contracts/test/SmockInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {GeneralEvent} from \"../libs/Events.sol\";\nimport {Authorization, ds, Role, DiamondModifiers} from \"../diamond/DiamondModifiers.sol\";\n\nimport {ISmockFacet} from \"./interfaces/ISmockFacet.sol\";\nimport {TEST_OPERATOR_ROLE} from \"./SmockFacet.sol\";\nimport {SmockStorage} from \"./SmockStorage.sol\";\n\ncontract SmockInit is DiamondModifiers {\n    function initialize(address _operator) external onlyOwner onlyRole(Role.ADMIN) {\n        require(msg.sender == ds().contractOwner, \"WithStorage: Not owner\");\n        SmockStorage.initialize(_operator);\n\n        Authorization.grantRole(TEST_OPERATOR_ROLE, _operator);\n\n        ds().supportedInterfaces[type(ISmockFacet).interfaceId] = true;\n        emit GeneralEvent.Initialized(msg.sender, 1);\n    }\n\n    function getNumber() public pure returns (uint8) {\n        return 1;\n    }\n\n    function getBool() public pure returns (bool) {\n        return false;\n    }\n\n    function upgradeState() external {\n        ds().initialized = getBool();\n    }\n}\n"
    },
    "src/contracts/test/SmockStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nlibrary Errors {\n    string public constant INITIALIZED = \"Already initialized\";\n    string public constant NOT_ACTIVE = \"SmockFacet: Not active\";\n    string public constant ACTIVE = \"SmockFacet: Active\";\n}\n\nstruct SmockState {\n    bool initialized;\n    bool isActive;\n    address operator;\n    mapping(address => bool) callers;\n    string message;\n    uint256 lastMessageBlock;\n}\n// This is not how it has to be done in reality\n// We can just extend the original\nstruct SmockState2 {\n    bool initialized;\n    bool isActive;\n    address operator;\n    mapping(address => bool) callers;\n    string message;\n    uint256 lastMessageBlock;\n    bool extended;\n}\n\nlibrary SmockStorage {\n    event Call(address indexed caller);\n\n    bytes32 public constant SMOCK_STORAGE_POSITION = keccak256(\"kresko.smock.storage\");\n\n    function initialize(address _operator) internal {\n        SmockState storage ss = state();\n        require(!ss.initialized, Errors.INITIALIZED);\n        ss.initialized = true;\n        ss.operator = _operator;\n        emit Call(msg.sender);\n    }\n\n    function state() internal pure returns (SmockState storage ss) {\n        bytes32 position = SMOCK_STORAGE_POSITION;\n        assembly {\n            ss.slot := position\n        }\n    }\n\n    // This is not how it has to be done in reality\n    function stateExtended() internal pure returns (SmockState2 storage ss) {\n        bytes32 position = SMOCK_STORAGE_POSITION;\n        assembly {\n            ss.slot := position\n        }\n    }\n\n    function activate() internal {\n        state().isActive = true;\n        state().callers[msg.sender] = true;\n        emit Call(msg.sender);\n    }\n\n    function disable() internal {\n        state().isActive = false;\n        state().callers[msg.sender] = true;\n        emit Call(msg.sender);\n    }\n}\n"
    },
    "src/contracts/test/WBTC.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {WETH9} from \"../vendor/WETH9.sol\";\n\ncontract WBTC is WETH9 {\n    mapping(address => bool) public minters;\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\n        minters[msg.sender] = true;\n        symbol = _symbol;\n        name = _name;\n        decimals = _decimals;\n    }\n\n    function toggleMinter(address minter) public {\n        require(minters[msg.sender], \"Not a minter\");\n        minters[minter] = !minters[minter];\n    }\n\n    function deposit() public payable override {\n        revert(\"Use deposit(uint256 amount) instead\");\n    }\n\n    function deposit(uint256 amount) public {\n        require(minters[msg.sender], \"Not a minter\");\n        balanceOf[msg.sender] += amount;\n        emit Deposit(msg.sender, amount);\n    }\n}\n"
    },
    "src/contracts/test/WETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {WETH9} from \"../vendor/WETH9.sol\";\n\ncontract WETH is WETH9 {\n    mapping(address => bool) public minters;\n\n    constructor() {\n        minters[msg.sender] = true;\n    }\n\n    function deposit(uint256 amount) public {\n        require(minters[msg.sender], \"Not a minter\");\n        balanceOf[msg.sender] += amount;\n        emit Deposit(msg.sender, amount);\n    }\n}\n"
    },
    "src/contracts/vendor/flux/FluxPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./interfaces/AggregatorV2V3Interface.sol\";\n\n/** solhint-disable var-name-mixedcase */\n/**\n * @notice Simple data posting on chain of a scalar value, compatible with Chainlink V2 and V3 aggregator interface\n */\ncontract FluxPriceFeed is AccessControl, AggregatorV2V3Interface {\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant VALIDATOR_ROLE = keccak256(\"VALIDATOR_ROLE\");\n    uint32 public latestAggregatorRoundId;\n\n    // Transmission records the answer from the transmit transaction at\n    // time timestamp\n    struct Transmission {\n        int192 answer; // 192 bits ought to be enough for anyone\n        uint64 timestamp;\n        bool marketOpen;\n    }\n    mapping(uint32 => Transmission) internal s_transmissions; /* aggregator round ID */\n       \n\n    /**\n     * @param _validator the initial validator that can post data to this contract\n     * @param _decimals answers are stored in fixed-point format, with this many digits of precision\n     * @param _description short human-readable description of observable this contract's answers pertain to\n     */\n    constructor(\n        address _validator,\n        uint8 _decimals,\n        string memory _description\n    ) {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setupRole(VALIDATOR_ROLE, _validator);\n        decimals = _decimals;\n        s_description = _description;\n    }\n\n    /*\n     * Versioning\n     */\n    function typeAndVersion() external pure virtual returns (string memory) {\n        return \"FluxPriceFeed 1.0.0\";\n    }\n\n    /*\n     * Transmission logic\n     */\n\n    /**\n     * @notice indicates that a new report was transmitted\n     * @param aggregatorRoundId the round to which this report was assigned\n     * @param answer value posted by validator\n     * @param marketOpen bool indicating if the market is open\n     * @param transmitter address from which the report was transmitted\n     */\n    event NewTransmission(uint32 indexed aggregatorRoundId, int192 answer, bool marketOpen, address transmitter);\n        \n    /**\n     * @notice details about the most recent report\n     * @return _latestAnswer value from latest report\n     * @return _latestTimestamp when the latest report was transmitted\n     * @return _marketOpen value from latest report\n     */\n    function latestTransmissionDetails() external view returns (int192 _latestAnswer, uint64 _latestTimestamp, bool _marketOpen) {\n        // solhint-disable-next-line avoid-tx-origin\n        require(msg.sender == tx.origin, \"Only callable by EOA\");\n        return (\n            s_transmissions[latestAggregatorRoundId].answer,\n            s_transmissions[latestAggregatorRoundId].timestamp,\n            s_transmissions[latestAggregatorRoundId].marketOpen\n        );\n    }\n\n    /**\n     * @notice transmit is called to post a new report to the contract\n     * @param _answer latest answer\n     */\n    function transmit(int192 _answer, bool _marketOpen) external {\n        require(hasRole(VALIDATOR_ROLE, msg.sender), \"Caller is not a validator\");\n\n        // Check the report contents, and record the result\n        latestAggregatorRoundId++;\n        // solhint-disable-next-line not-rely-on-time\n        s_transmissions[latestAggregatorRoundId] = Transmission(_answer, uint64(block.timestamp), _marketOpen);\n\n        emit NewTransmission(latestAggregatorRoundId, _answer, _marketOpen, msg.sender);\n    }\n\n    /*\n     * v2 Aggregator interface\n     */\n\n    /**\n     * @notice answer from the most recent report\n     */\n    function latestAnswer() public view virtual override returns (int256) {\n        return s_transmissions[latestAggregatorRoundId].answer;\n    }\n\n    /**\n     * @notice timestamp of block in which last report was transmitted\n     */\n    function latestTimestamp() public view virtual override returns (uint256) {\n        return s_transmissions[latestAggregatorRoundId].timestamp;\n    }\n\n     /**\n     * @notice market open indicator from the most recent report\n     */\n    function latestMarketOpen() public view virtual override returns (bool) {\n        return s_transmissions[latestAggregatorRoundId].marketOpen;\n    }\n\n    /**\n     * @notice Aggregator round in which last report was transmitted\n     */\n    function latestRound() public view virtual override returns (uint256) {\n        return latestAggregatorRoundId;\n    }\n\n    /**\n     * @notice answer of report from given aggregator round\n     * @param _roundId the aggregator round of the target report\n     */\n    function getAnswer(uint256 _roundId) public view virtual override returns (int256) {\n        if (_roundId > 0xFFFFFFFF) {\n            return 0;\n        }\n        return s_transmissions[uint32(_roundId)].answer;\n    }\n\n    /**\n     * @notice timestamp of block in which report from given aggregator round was transmitted\n     * @param _roundId aggregator round of target report\n     */\n    function getTimestamp(uint256 _roundId) public view virtual override returns (uint256) {\n        if (_roundId > 0xFFFFFFFF) {\n            return 0;\n        }\n        return s_transmissions[uint32(_roundId)].timestamp;\n    }\n\n    /**\n     * @notice market open of report from given aggregator round\n     * @param _roundId the aggregator round of the target report\n     */\n    function getMarketOpen(uint256 _roundId) public view virtual override returns (bool) {\n        require(_roundId <= 0xFFFFFFFF, \"FluxPriceFeed: round ID\");\n        return s_transmissions[uint32(_roundId)].marketOpen;\n    }\n\n    /*\n     * v3 Aggregator interface\n     */\n\n    string private constant V3_NO_DATA_ERROR = \"No data present\";\n\n    /**\n     * @return answers are stored in fixed-point format, with this many digits of precision\n     */\n    uint8 public immutable override decimals;\n\n    /**\n     * @notice aggregator contract version\n     */\n    uint256 public constant override version = 1;\n\n    string internal s_description;\n\n    /**\n     * @notice human-readable description of observable this contract is reporting on\n     */\n    function description() public view virtual override returns (string memory) {\n        return s_description;\n    }\n\n    /**\n     * @notice details for the given aggregator round\n     * @param _roundId target aggregator round. Must fit in uint32\n     * @return roundId _roundId\n     * @return answer answer of report from given _roundId\n     * @return marketOpen of report from given _roundId\n     * @return startedAt timestamp of block in which report from given _roundId was transmitted\n     * @return updatedAt timestamp of block in which report from given _roundId was transmitted\n     * @return answeredInRound _roundId\n     */\n    function getRoundData(uint80 _roundId)\n        public\n        view\n        virtual\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            bool marketOpen,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        require(_roundId <= 0xFFFFFFFF, V3_NO_DATA_ERROR);\n        Transmission memory transmission = s_transmissions[uint32(_roundId)];\n        return (_roundId, transmission.answer, transmission.marketOpen, transmission.timestamp, transmission.timestamp, _roundId);\n    }\n\n    /**\n     * @notice aggregator details for the most recently transmitted report\n     * @return roundId aggregator round of latest report\n     * @return answer answer of latest report\n     * @return marketOpen of latest report\n     * @return startedAt timestamp of block containing latest report\n     * @return updatedAt timestamp of block containing latest report\n     * @return answeredInRound aggregator round of latest report\n     */\n    function latestRoundData()\n        public\n        view\n        virtual\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            bool marketOpen,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        roundId = latestAggregatorRoundId;\n\n        // Skipped for compatability with existing FluxAggregator in which latestRoundData never reverts.\n        // require(roundId != 0, V3_NO_DATA_ERROR);\n\n        Transmission memory transmission = s_transmissions[uint32(roundId)];\n        return (roundId, transmission.answer, transmission.marketOpen, transmission.timestamp, transmission.timestamp, roundId);\n    }\n}\n"
    },
    "src/contracts/vendor/flux/FluxPriceFeedFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"./FluxPriceFeed.sol\";\n\n/**\n * @title Flux first-party price feed factory\n * @author fluxprotocol.org\n */\ncontract FluxPriceFeedFactory {\n    address public owner;\n    // roles\n    bytes32 public constant VALIDATOR_ROLE = keccak256(\"VALIDATOR_ROLE\");\n\n    // mapping of id to FluxPriceFeed\n    mapping(bytes32 => FluxPriceFeed) public fluxPriceFeeds;\n\n    /**\n     * @notice indicates that a new oracle was created\n     * @param id hash of the price pair of the deployed oracle\n     * @param oracle address of the deployed oracle\n     */\n    event FluxPriceFeedCreated(bytes32 indexed id, address indexed oracle);\n\n    /**\n     * @notice to log error messages\n     * @param message the logged message\n     */\n    event Log(string message);\n\n    constructor () {\n        owner = msg.sender;\n    }\n\n    function transferOwnership(address newOwner) external {\n        require(msg.sender == owner, \"!owner\");\n        owner = newOwner;\n    }\n\n    /**\n     * @notice transmit submits an answer to a price feed or creates a new one if it does not exist\n     * @param _pricePairs array of price pairs strings (e.g. ETH/USD)\n     * @param _decimals array of decimals for associated price pairs (e.g. 3)\n     * @param _answers array of prices for associated price pairs\n     * @param _marketStatusAnswers array of market open/closed statuses\n     * @param _provider optional address of the provider, if different from msg.sender\n     */\n    function transmit(\n        string[] calldata _pricePairs,\n        uint8[] calldata _decimals,\n        int192[] calldata _answers,\n        bool[] calldata _marketStatusAnswers,\n        address _provider\n    ) external {\n        require(\n            (_pricePairs.length == _decimals.length) && (_pricePairs.length == _answers.length) && (_pricePairs.length == _marketStatusAnswers.length),\n            \"Transmitted arrays must be equal\"\n        );\n        // if no provider is provided, use the msg.sender\n        address provider = (_provider == address(0)) ? msg.sender : _provider;\n\n        // Iterate through each transmitted price pair\n        for (uint256 i = 0; i < _pricePairs.length; i++) {\n            string memory str = string(\n                abi.encodePacked(\"Price-\", _pricePairs[i], \"-\", Strings.toString(_decimals[i]), \"-\", provider)\n            );\n            bytes32 id = keccak256(bytes(str));\n\n            // deploy a new oracle if there's none previously deployed and this is the original provider\n            if (address(fluxPriceFeeds[id]) == address(0x0)) { \n                _deployOracle(id, _pricePairs[i], _decimals[i], _provider);\n            }\n\n            require(address(fluxPriceFeeds[id]) != address(0x0), \"Provider doesn't exist\");\n\n            require(fluxPriceFeeds[id].hasRole(VALIDATOR_ROLE, msg.sender), \"Only validators can transmit\");\n\n            // try transmitting values to the oracle\n            /* solhint-disable-next-line no-empty-blocks */\n            try fluxPriceFeeds[id].transmit(_answers[i], _marketStatusAnswers[i]) {\n                // transmission is successful, nothing to do\n            } catch Error(string memory reason) {\n                // catch failing revert() and require()\n                emit Log(reason);\n            }\n        }\n    }\n\n    /**\n     * @notice internal function to create a new FluxPriceFeed\n     * @dev only a validator should be able to call this function\n     */\n    function _deployOracle(\n        bytes32 _id,\n        string calldata _pricePair,\n        uint8 _decimals,\n        address _provider\n    ) internal {\n        require(msg.sender == owner, \"!owner\");\n        // deploy the new contract and store it in the mapping\n        FluxPriceFeed newPriceFeed = new FluxPriceFeed(address(this), _decimals, _pricePair);\n\n        fluxPriceFeeds[_id] = newPriceFeed;\n\n        // grant the provider DEFAULT_ADMIN_ROLE and VALIDATOR_ROLE on the new FluxPriceFeed\n        newPriceFeed.grantRole(0x00, msg.sender);\n        newPriceFeed.grantRole(VALIDATOR_ROLE, msg.sender);\n        newPriceFeed.grantRole(VALIDATOR_ROLE, _provider);\n\n        emit FluxPriceFeedCreated(_id, address(newPriceFeed));\n    }\n\n    /**\n     * @notice answer from the most recent report of a certain price pair from factory\n     * @param _id hash of the price pair string to query\n     */\n    function valueFor(bytes32 _id)\n        external\n        view\n        returns (\n            int256,\n            bool,\n            uint256,\n            uint256\n        )\n    {\n        // if oracle exists then fetch values\n        if (address(fluxPriceFeeds[_id]) != address(0x0)) {\n            // fetch the price feed contract and read its latest answer and timestamp\n            try fluxPriceFeeds[_id].latestRoundData() returns (\n                uint80,\n                int256 answer,\n                bool marketOpen,\n                uint256,\n                uint256 updatedAt,\n                uint80\n            ) {\n                return (answer,marketOpen, updatedAt, 200);\n            } catch {\n                // catch failing revert() and require()\n                return (0, false, 0, 404);\n            }\n\n            // else return not found\n        } else {\n            return (0, false, 0, 404);\n        }\n    }\n\n    /**\n     * @notice returns address of a price feed id\n     * @param _id hash of the price pair string to query\n     */\n    function addressOfPricePairId(bytes32 _id) external view returns (address) {\n        return address(fluxPriceFeeds[_id]);\n    }\n\n    /**\n     * @notice returns the hash of a price pair\n     * @param _pricePair ETH/USD\n     * @param _decimals decimal of the price pair\n     * @param _provider original provider of the price pair\n     */\n    function getId(\n        string calldata _pricePair,\n        uint8 _decimals,\n        address _provider\n    ) external pure returns (bytes32) {\n        string memory str = string(\n            abi.encodePacked(\"Price-\", _pricePair, \"-\", Strings.toString(_decimals), \"-\", _provider)\n        );\n        bytes32 id = keccak256(bytes(str));\n        return id;\n    }\n\n    /**\n     * @notice returns address of a price feed id\n     * @param _pricePair ETH/USD\n     * @param _decimals decimal of the price pair\n     * @param _provider original provider of the price pair\n     */\n    function addressOfPricePair(\n        string calldata _pricePair,\n        uint8 _decimals,\n        address _provider\n    ) external view returns (address) {\n        bytes32 id = this.getId(_pricePair, _decimals, _provider);\n        return address(fluxPriceFeeds[id]);\n    }\n\n    /**\n     * @notice returns factory's type and version\n     */\n    function typeAndVersion() external pure virtual returns (string memory) {\n        return \"FluxPriceFeedFactory 2.0.0\";\n    }\n}"
    },
    "src/contracts/vendor/flux/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\ninterface AggregatorInterface {\n    function latestAnswer() external view returns (int256);\n\n    function latestTimestamp() external view returns (uint256);\n\n    function latestMarketOpen() external view returns (bool);\n\n    function latestRound() external view returns (uint256);\n\n    function getAnswer(uint256 roundId) external view returns (int256);\n\n    function getTimestamp(uint256 roundId) external view returns (uint256);\n\n    function getMarketOpen(uint256 roundId) external view returns (bool);\n\n    event AnswerUpdated(int256 indexed current, bool marketOpen, uint256 indexed roundId, uint256 updatedAt);\n    event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "src/contracts/vendor/flux/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n/* solhint-disable no-global-import */\n/* solhint-disable no-empty-blocks */\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "src/contracts/vendor/flux/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n    \n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            bool marketOpen,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            bool marketOpen,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "src/contracts/vendor/flux/interfaces/IERC2362.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n/**\n * @dev EIP2362 Interface for pull oracles\n * https://github.com/tellor-io/EIP-2362\n */\ninterface IERC2362 {\n    /**\n     * @dev Exposed function pertaining to EIP standards\n     * @param _id bytes32 ID of the query\n     * @return int,uint,uint returns the value, timestamp, and status code of query\n     */\n    function valueFor(bytes32 _id)\n        external\n        view\n        returns (\n            int256,\n            uint256,\n            uint256\n        );\n}"
    },
    "src/contracts/vendor/gnosis/GnosisSafe.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity <=0.8.19;\n\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/base/ModuleManager.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/base/OwnerManager.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/base/FallbackManager.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/base/GuardManager.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/common/EtherPaymentFallback.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/common/Singleton.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/common/SignatureDecoder.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/common/SecuredTokenTransfer.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/common/StorageAccessible.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/interfaces/ISignatureValidator.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/external/GnosisSafeMath.sol\";\n\n/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract GnosisSafe is\n    EtherPaymentFallback,\n    Singleton,\n    ModuleManager,\n    OwnerManager,\n    SignatureDecoder,\n    SecuredTokenTransfer,\n    ISignatureValidatorConstants,\n    FallbackManager,\n    StorageAccessible,\n    GuardManager\n{\n    using GnosisSafeMath for uint256;\n\n    string public constant VERSION = \"1.3.0\";\n\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n        0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // keccak256(\n    //     \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    event SafeSetup(\n        address indexed initiator,\n        address[] owners,\n        uint256 threshold,\n        address initializer,\n        address fallbackHandler\n    );\n    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);\n    event SignMsg(bytes32 indexed msgHash);\n    event ExecutionFailure(bytes32 txHash, uint256 payment);\n    event ExecutionSuccess(bytes32 txHash, uint256 payment);\n\n    uint256 public nonce;\n    bytes32 private _deprecatedDomainSeparator;\n    // Mapping to keep track of all message hashes that have been approved by ALL REQUIRED owners\n    mapping(bytes32 => uint256) public signedMessages;\n    // Mapping to keep track of all hashes (message or transaction) that have been approved by ANY owners\n    mapping(address => mapping(bytes32 => uint256)) public approvedHashes;\n\n    // This constructor ensures that this contract can only be used as a master copy for Proxy contracts\n    constructor() {\n        // By setting the threshold it is not possible to call setup anymore,\n        // so we create a Safe with 0 owners and threshold 1.\n        // This is an unusable Safe, perfect for the singleton\n        threshold = 1;\n    }\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    /// @param to Contract address for optional delegate call.\n    /// @param data Data payload for optional delegate call.\n    /// @param fallbackHandler Handler for fallback calls to this contract\n    /// @param paymentToken Token that should be used for the payment (0 is ETH)\n    /// @param payment Value that should be paid\n    /// @param paymentReceiver Address that should receive the payment (or 0 if tx.origin)\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external {\n        // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n        emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);\n    }\n\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    ///      Note: The fees are always transferred, even if the user transaction fails.\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\n    /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Gas price that should be used for the payment calculation.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable virtual returns (bool success) {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData = encodeTransactionData(\n                // Transaction info\n                to,\n                value,\n                data,\n                operation,\n                safeTxGas,\n                // Payment info\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                // Signature info\n                nonce\n            );\n            // Increase nonce and execute transaction.\n            nonce++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n        address guard = getGuard();\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkTransaction(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    signatures,\n                    msg.sender\n                );\n            }\n        }\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500, \"GS010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas\n            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || safeTxGas != 0 || gasPrice != 0, \"GS013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkAfterExecution(txHash, success);\n            }\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    ) private returns (uint256 payment) {\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            require(receiver.send(payment), \"GS011\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            require(transferToken(gasToken, receiver, payment), \"GS012\");\n        }\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) public view {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        require(_threshold > 0, \"GS001\");\n        checkNSignatures(dataHash, data, signatures, _threshold);\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     * @param requiredSignatures Amount of required valid signatures.\n     */\n    function checkNSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures,\n        uint256 requiredSignatures\n    ) public view {\n        // Check that the provided signature data is not too short\n        require(signatures.length >= requiredSignatures.mul(65), \"GS020\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < requiredSignatures; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= requiredSignatures.mul(65), \"GS021\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s).add(32) <= signatures.length, \"GS022\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"GS023\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(\n                    ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE,\n                    \"GS024\"\n                );\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"GS025\");\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(\n                    keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)),\n                    v - 4,\n                    r,\n                    s\n                );\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n            require(\n                currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS,\n                \"GS026\"\n            );\n            lastOwner = currentOwner;\n        }\n    }\n\n    /// @dev Allows to estimate a Safe transaction.\n    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    /// @notice Deprecated in favor of common/StorageAccessible.sol and will be removed in next version.\n    function requiredTxGas(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (uint256) {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n     * @dev Marks a hash as approved. This can be used to validate a hash that is used by a signature.\n     * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.\n     */\n    function approveHash(bytes32 hashToApprove) external {\n        require(owners[msg.sender] != address(0), \"GS030\");\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(hashToApprove, msg.sender);\n    }\n\n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Gas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash = keccak256(\n            abi.encode(\n                SAFE_TX_TYPEHASH,\n                to,\n                value,\n                keccak256(data),\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                _nonce\n            )\n        );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    /// @dev Returns hash to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        return\n            keccak256(\n                encodeTransactionData(\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    _nonce\n                )\n            );\n    }\n}\n"
    },
    "src/contracts/vendor/gnosis/GnosisSafeL2.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./GnosisSafe.sol\";\n\n/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract GnosisSafeL2 is GnosisSafe {\n    event SafeMultiSigTransaction(\n        address to,\n        uint256 value,\n        bytes data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes signatures,\n        // We combine nonce, sender and threshold into one to avoid stack too deep\n        // Dev note: additionalInfo should not contain `bytes`, as this complicates decoding\n        bytes additionalInfo\n    );\n\n    event SafeModuleTransaction(address module, address to, uint256 value, bytes data, Enum.Operation operation);\n\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    ///      Note: The fees are always transferred, even if the user transaction fails.\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\n    /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Gas price that should be used for the payment calculation.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable override returns (bool) {\n        bytes memory additionalInfo;\n        {\n            additionalInfo = abi.encode(nonce, msg.sender, threshold);\n        }\n        emit SafeMultiSigTransaction(\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver,\n            signatures,\n            additionalInfo\n        );\n        return\n            super.execTransaction(\n                to,\n                value,\n                data,\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                signatures\n            );\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public override returns (bool success) {\n        emit SafeModuleTransaction(msg.sender, to, value, data, operation);\n        success = super.execTransactionFromModule(to, value, data, operation);\n    }\n}\n"
    },
    "src/contracts/vendor/gnosis/GnosisSafeProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/proxies/IProxyCreationCallback.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/proxies/GnosisSafeProxy.sol\";\n\n/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n/// @author Stefan George - <stefan@gnosis.pm>\ncontract GnosisSafeProxyFactory {\n    event ProxyCreation(GnosisSafeProxy proxy, address singleton);\n\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n    /// @param singleton Address of singleton contract.\n    /// @param data Payload for message call sent to new proxy contract.\n    function createProxy(address singleton, bytes memory data) public returns (GnosisSafeProxy proxy) {\n        proxy = new GnosisSafeProxy(singleton);\n        if (data.length > 0)\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                if eq(call(gas(), proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) {\n                    revert(0, 0)\n                }\n            }\n        emit ProxyCreation(proxy, singleton);\n    }\n\n    /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\n    function proxyRuntimeCode() public pure returns (bytes memory) {\n        return type(GnosisSafeProxy).runtimeCode;\n    }\n\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\n    function proxyCreationCode() public pure returns (bytes memory) {\n        return type(GnosisSafeProxy).creationCode;\n    }\n\n    /// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\n    ///      This method is only meant as an utility to be called from other methods\n    /// @param _singleton Address of singleton contract.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function deployProxyWithNonce(\n        address _singleton,\n        bytes memory initializer,\n        uint256 saltNonce\n    ) internal returns (GnosisSafeProxy proxy) {\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\n        bytes memory deploymentData = abi.encodePacked(\n            type(GnosisSafeProxy).creationCode,\n            uint256(uint160(_singleton))\n        );\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        require(address(proxy) != address(0), \"Create2 call failed\");\n    }\n\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n    /// @param _singleton Address of singleton contract.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function createProxyWithNonce(\n        address _singleton,\n        bytes memory initializer,\n        uint256 saltNonce\n    ) public returns (GnosisSafeProxy proxy) {\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\n        if (initializer.length > 0)\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) {\n                    revert(0, 0)\n                }\n            }\n        emit ProxyCreation(proxy, _singleton);\n    }\n\n    /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction\n    /// @param _singleton Address of singleton contract.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    /// @param callback Callback that will be invoked after the new proxy contract has been successfully deployed and initialized.\n    function createProxyWithCallback(\n        address _singleton,\n        bytes memory initializer,\n        uint256 saltNonce,\n        IProxyCreationCallback callback\n    ) public returns (GnosisSafeProxy proxy) {\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\n        proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback);\n        if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce);\n    }\n\n    /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce`\n    ///      This method is only meant for address calculation purpose when you use an initializer that would revert,\n    ///      therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory.\n    /// @param _singleton Address of singleton contract.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function calculateCreateProxyWithNonceAddress(\n        address _singleton,\n        bytes calldata initializer,\n        uint256 saltNonce\n    ) external returns (GnosisSafeProxy proxy) {\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\n        revert(string(abi.encodePacked(proxy)));\n    }\n}\n"
    },
    "src/contracts/vendor/gnosis/IGnosisSafeL2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\ninterface IGnosisSafeL2 {\n    function isOwner(address owner) external view returns (bool);\n\n    function getOwners() external view returns (address[] memory);\n}\n"
    },
    "src/contracts/vendor/Multicall3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n/// @title Multicall3\n/// @notice Aggregate results from multiple function calls\n/// @dev Multicall & Multicall2 backwards-compatible\n/// @dev Aggregate methods are marked `payable` to save 24 gas per call\n/// @author Michael Elliot <mike@makerdao.com>\n/// @author Joshua Levine <joshua@makerdao.com>\n/// @author Nick Johnson <arachnid@notdot.net>\n/// @author Andreas Bigger <andreas@nascent.xyz>\n/// @author Matt Solomon <matt@mattsolomon.dev>\ncontract Multicall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    /// @notice Backwards-compatible call aggregation with Multicall\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return returnData An array of bytes containing the responses\n    function aggregate(Call[] calldata calls) public payable returns (uint256 blockNumber, bytes[] memory returnData) {\n        blockNumber = block.number;\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n        Call calldata call;\n        for (uint256 i = 0; i < length;) {\n            bool success;\n            call = calls[i];\n            (success, returnData[i]) = call.target.call(call.callData);\n            require(success, \"Multicall3: call failed\");\n            unchecked { ++i; }\n        }\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls without requiring success\n    /// @param requireSuccess If true, require all calls to succeed\n    /// @param calls An array of Call structs\n    /// @return returnData An array of Result structs\n    function tryAggregate(bool requireSuccess, Call[] calldata calls) public payable returns (Result[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call calldata call;\n        for (uint256 i = 0; i < length;) {\n            Result memory result = returnData[i];\n            call = calls[i];\n            (result.success, result.returnData) = call.target.call(call.callData);\n            if (requireSuccess) require(result.success, \"Multicall3: call failed\");\n            unchecked { ++i; }\n        }\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls and allow failures using tryAggregate\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return blockHash The hash of the block where the calls were executed\n    /// @return returnData An array of Result structs\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls) public payable returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {\n        blockNumber = block.number;\n        blockHash = blockhash(block.number);\n        returnData = tryAggregate(requireSuccess, calls);\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls and allow failures using tryAggregate\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return blockHash The hash of the block where the calls were executed\n    /// @return returnData An array of Result structs\n    function blockAndAggregate(Call[] calldata calls) public payable returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {\n        (blockNumber, blockHash, returnData) = tryBlockAndAggregate(true, calls);\n    }\n\n    /// @notice Aggregate calls, ensuring each returns success if required\n    /// @param calls An array of Call3 structs\n    /// @return returnData An array of Result structs\n    function aggregate3(Call3[] calldata calls) public payable returns (Result[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call3 calldata calli;\n        for (uint256 i = 0; i < length;) {\n            Result memory result = returnData[i];\n            calli = calls[i];\n            (result.success, result.returnData) = calli.target.call(calli.callData);\n            assembly {\n                // Revert if the call fails and failure is not allowed\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                    // set data offset\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n                    // set length of revert string\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\n                    revert(0x00, 0x64)\n                }\n            }\n            unchecked { ++i; }\n        }\n    }\n\n    /// @notice Aggregate calls with a msg value\n    /// @notice Reverts if msg.value is less than the sum of the call values\n    /// @param calls An array of Call3Value structs\n    /// @return returnData An array of Result structs\n    function aggregate3Value(Call3Value[] calldata calls) public payable returns (Result[] memory returnData) {\n        uint256 valAccumulator;\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call3Value calldata calli;\n        for (uint256 i = 0; i < length;) {\n            Result memory result = returnData[i];\n            calli = calls[i];\n            uint256 val = calli.value;\n            // Humanity will be a Type V Kardashev Civilization before this overflows - andreas\n            // ~ 10^25 Wei in existence << ~ 10^76 size uint fits in a uint256\n            unchecked { valAccumulator += val; }\n            (result.success, result.returnData) = calli.target.call{value: val}(calli.callData);\n            assembly {\n                // Revert if the call fails and failure is not allowed\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                    // set data offset\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n                    // set length of revert string\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\n                    revert(0x00, 0x84)\n                }\n            }\n            unchecked { ++i; }\n        }\n        // Finally, make sure the msg.value = SUM(call[0...i].value)\n        require(msg.value == valAccumulator, \"Multicall3: value mismatch\");\n    }\n\n    /// @notice Returns the block hash for the given block number\n    /// @param blockNumber The block number\n    function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\n        blockHash = blockhash(blockNumber);\n    }\n\n    /// @notice Returns the block number\n    function getBlockNumber() public view returns (uint256 blockNumber) {\n        blockNumber = block.number;\n    }\n\n    /// @notice Returns the block coinbase\n    function getCurrentBlockCoinbase() public view returns (address coinbase) {\n        coinbase = block.coinbase;\n    }\n\n    /// @notice Returns the block difficulty\n    function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\n        difficulty = block.difficulty;\n    }\n\n    /// @notice Returns the block gas limit\n    function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n        gaslimit = block.gaslimit;\n    }\n\n    /// @notice Returns the block timestamp\n    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\n        timestamp = block.timestamp;\n    }\n\n    /// @notice Returns the (ETH) balance of a given address\n    function getEthBalance(address addr) public view returns (uint256 balance) {\n        balance = addr.balance;\n    }\n\n    /// @notice Returns the block hash of the last block\n    function getLastBlockHash() public view returns (bytes32 blockHash) {\n        unchecked {\n            blockHash = blockhash(block.number - 1);\n        }\n    }\n\n    /// @notice Gets the base fee of the given block\n    /// @notice Can revert if the BASEFEE opcode is not implemented by the given chain\n    function getBasefee() public view returns (uint256 basefee) {\n        basefee = block.basefee;\n    }\n\n    /// @notice Returns the chain id\n    function getChainId() public view returns (uint256 chainid) {\n        chainid = block.chainid;\n    }\n\n     function multiSend(bytes memory transactions) public payable {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let length := mload(transactions)\n            let i := 0x20\n            for {\n                // Pre block is not used in \"while mode\"\n            } lt(i, length) {\n                // Post block is not used in \"while mode\"\n            } {\n                // First byte of the data is the operation.\n                // We shift by 248 bits (256 - 8 [operation byte]) it right since mload will always load 32 bytes (a word).\n                // This will also zero out unused data.\n                let operation := shr(0xf8, mload(add(transactions, i)))\n                // We offset the load address by 1 byte (operation byte)\n                // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.\n                let to := shr(0x60, mload(add(transactions, add(i, 0x01))))\n                // We offset the load address by 21 byte (operation byte + 20 address bytes)\n                let value := mload(add(transactions, add(i, 0x15)))\n                // We offset the load address by 53 byte (operation byte + 20 address bytes + 32 value bytes)\n                let dataLength := mload(add(transactions, add(i, 0x35)))\n                // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\n                let data := add(transactions, add(i, 0x55))\n                let success := 0\n                switch operation\n                    case 0 {\n                        success := call(gas(), to, value, data, dataLength, 0, 0)\n                    }\n                    // This version does not allow delegatecalls\n                    case 1 {\n                        revert(0, 0)\n                    }\n                if eq(success, 0) {\n                    revert(0, 0)\n                }\n                // Next entry starts at 85 byte + data length\n                i := add(i, add(0x55, dataLength))\n            }\n        }\n        }\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-core/interfaces/IERC20Minimal.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IERC20Minimal {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-core/interfaces/IUniswapV2Callee.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-core/interfaces/IUniswapV2ERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2ERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-core/interfaces/IUniswapV2Factory.sol": {
      "content": "// // SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-core/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.16;\n\n/** solhint-disable func-name-mixedcase */\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/interfaces/IUniswapV2Migrator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Migrator {\n    function migrate(\n        address token,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/interfaces/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.6.2;\n/** solhint-disable no-global-import */\nimport \"./IUniswapV2Router01.sol\";\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}"
    },
    "src/contracts/vendor/uniswap/v2-periphery/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.6.6;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/libraries/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: APGL-3.0\npragma solidity >=0.5.0;\n\nimport \"../../v2-core/interfaces/IUniswapV2Pair.sol\";\nimport \"../../v2-core/interfaces/IUniswapV2Factory.sol\";\n\nimport \"./SafeMath.sol\";\n\nlibrary UniswapV2Library {\n    using SafeMath for uint256;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (address pair) {\n        pair = IUniswapV2Factory(factory).getPair(tokenA, tokenB);\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n        require(reserveA > 0 && reserveB > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        uint256 amountOut,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "src/contracts/vendor/WETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.19;\n\ncontract WETH9 {\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    function deposit() public payable virtual {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public virtual {\n        require(balanceOf[msg.sender] >= wad, \"WETH9: Error\");\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public virtual returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public virtual returns (bool) {\n        require(balanceOf[src] >= wad, \"WETH9: Error\");\n\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\n            require(allowance[src][msg.sender] >= wad, \"WETH9: Error\");\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "constantOptimizer": false,
        "deduplicate": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "metadata",
          "abi",
          "storageLayout",
          "evm.methodIdentifiers",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "evm.byteCode",
          "evm.bytecode",
          "evm.deployedBytecode"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}