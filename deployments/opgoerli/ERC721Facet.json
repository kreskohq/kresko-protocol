{
  "address": "0xCc0498199e461c6e2dcFe4e21c380F0981Fc77aF",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "approved",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "DOMAIN_SEPARATOR",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PERMIT_TYPEHASH",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_approved",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        }
      ],
      "name": "getApproved",
      "outputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCurrentId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_operator",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        }
      ],
      "name": "ownerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "v",
          "type": "uint8"
        },
        {
          "internalType": "bytes32",
          "name": "r",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "s",
          "type": "bytes32"
        }
      ],
      "name": "permit",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "_approved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x7382ca85a991033c731f1ca0ac4eae665cf1dfe1e3d1ecb371d3a41f3bf7a73d",
  "receipt": {
    "to": null,
    "from": "0xB48bB6b68Ab4D366B4f9A30eE6f7Ee55125c2D9d",
    "contractAddress": "0xCc0498199e461c6e2dcFe4e21c380F0981Fc77aF",
    "transactionIndex": 5,
    "gasUsed": "1336899",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x3b4a93c1ebdd90ebb43fa75d00c5fa2dce0827b8b14d84b7ce922ac8e811828e",
    "transactionHash": "0x7382ca85a991033c731f1ca0ac4eae665cf1dfe1e3d1ecb371d3a41f3bf7a73d",
    "logs": [],
    "blockNumber": 9755711,
    "cumulativeGasUsed": "3640912",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "6631d94f6b53ea8c7f04af64e7cd9d11",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"Approval(address,address,uint256)\":{\"details\":\"Emitted when `owner` enables `approved` to manage the `tokenId` token.\"},\"ApprovalForAll(address,address,bool)\":{\"details\":\"Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\"},\"Transfer(address,address,uint256)\":{\"details\":\"Emitted when `tokenId` token is transferred from `from` to `to`.\"}},\"kind\":\"dev\",\"methods\":{\"DOMAIN_SEPARATOR()\":{\"returns\":{\"_0\":\"The domain seperator used in encoding of permit signature\"}},\"permit(address,uint256,uint256,uint8,bytes32,bytes32)\":{\"params\":{\"deadline\":\"The deadline timestamp by which the call must be mined for the approve to work\",\"r\":\"Must produce valid secp256k1 signature from the holder along with `v` and `s`\",\"s\":\"Must produce valid secp256k1 signature from the holder along with `r` and `v`\",\"spender\":\"The account that is being approved\",\"tokenId\":\"The ID of the token that is being approved for spending\",\"v\":\"Must produce valid secp256k1 signature from the holder along with `r` and `s`\"}}},\"stateVariables\":{\"PERMIT_TYPEHASH\":{\"details\":\"Value is equal to keccak256(\\\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\\\");\",\"return\":\"The typehash for the permit\",\"returns\":{\"_0\":\"The typehash for the permit\"}},\"nameHash\":{\"details\":\"The hash of the name used in the permit signature verification\"},\"versionHash\":{\"details\":\"The hash of the version string used in the permit signature verification\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"DOMAIN_SEPARATOR()\":{\"notice\":\"The domain separator used in the permit signature\"},\"PERMIT_TYPEHASH()\":{\"notice\":\"The permit typehash used in the permit signature\"},\"permit(address,uint256,uint256,uint8,bytes32,bytes32)\":{\"notice\":\"Approve of a specific token ID for spending by spender via signature\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/contracts/minter/collateral-pool/position/facets/ERC721Facet.sol\":\"ERC721Facet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"details\":{\"constantOptimizer\":false,\"cse\":true,\"deduplicate\":true,\"inliner\":true,\"jumpdestRemover\":true,\"orderLiterals\":true,\"peephole\":true,\"yul\":true,\"yulDetails\":{\"optimizerSteps\":\"dhfoDgvulfnTUtnIf[xa[r]EscLMcCTUtTOntnfDIulLculVcul [j]Tpeulxa[rul]xa[r]cLgvifCTUca[r]LSsTFOtfDnca[r]Iulc]jmul[jul] VcTOcul jmul:fDnTOc\",\"stackAllocation\":true}},\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xbb2ed8106d94aeae6858e2551a1e7174df73994b77b13ebd120ccaaef80155f5\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2edcb41c121abc510932e8d83ff8b82cf9cdde35e7c297622f5c29ef0af25183\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/MathUpgradeable.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = MathUpgradeable.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0x6b9a5d35b744b25529a2856a8093e7c03fb35a34b1c4fb5499e560f8ade140da\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc1bd5b53319c68f84e3becd75694d941e8f4be94049903232cd8bc7c535aaa5a\",\"license\":\"MIT\"},\"src/contracts/libs/Meta.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/* solhint-disable no-inline-assembly */\\n\\npragma solidity >=0.8.19;\\n\\nlibrary Meta {\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\\n        keccak256(bytes(\\\"EIP712Domain(string name,string version,uint256 salt,address verifyingContract)\\\"));\\n\\n    function domainSeparator(\\n        string memory name,\\n        string memory version\\n    ) internal view returns (bytes32 domainSeparator_) {\\n        domainSeparator_ = keccak256(\\n            abi.encode(\\n                EIP712_DOMAIN_TYPEHASH,\\n                keccak256(bytes(name)),\\n                keccak256(bytes(version)),\\n                getChainID(),\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function getChainID() internal view returns (uint256 id) {\\n        assembly {\\n            id := chainid()\\n        }\\n    }\\n\\n    function msgSender() internal view returns (address sender_) {\\n        if (msg.sender == address(this)) {\\n            bytes memory array = msg.data;\\n            uint256 index = msg.data.length;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\n                sender_ := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\\n            }\\n        } else {\\n            sender_ = msg.sender;\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0xab3a89ab4294d6b84baa5f2449987b09b8a841c3ae3440fb78353903e4d159d4\",\"license\":\"MIT\"},\"src/contracts/libs/WadRay.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.10;\\n\\n/**\\n * @title WadRayMath library\\n * @author Aave\\n * @notice Provides functions to perform calculations with Wad and Ray units\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\\n * with 27 digits of precision)\\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\\n **/\\nlibrary WadRay {\\n    // HALF_WAD and HALF_RAY expressed with extended notation\\n    // as constant with operations are not supported in Yul assembly\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant HALF_WAD = 0.5e18;\\n\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant HALF_RAY = 0.5e27;\\n\\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n    /**\\n     * @dev Multiplies two wad, rounding half up to the nearest wad\\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Wad\\n     * @param b Wad\\n     * @return c = a*b, in wad\\n     **/\\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\\n        assembly {\\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, b), HALF_WAD), WAD)\\n        }\\n    }\\n\\n    /**\\n     * @dev Divides two wad, rounding half up to the nearest wad\\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Wad\\n     * @param b Wad\\n     * @return c = a/b, in wad\\n     **/\\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\\n        assembly {\\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, WAD), div(b, 2)), b)\\n        }\\n    }\\n\\n    /**\\n     * @notice Multiplies two ray, rounding half up to the nearest ray\\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Ray\\n     * @param b Ray\\n     * @return c = a raymul b\\n     **/\\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\\n        assembly {\\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, b), HALF_RAY), RAY)\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides two ray, rounding half up to the nearest ray\\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Ray\\n     * @param b Ray\\n     * @return c = a raydiv b\\n     **/\\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\\n        assembly {\\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, RAY), div(b, 2)), b)\\n        }\\n    }\\n\\n    /**\\n     * @dev Casts ray down to wad\\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Ray\\n     * @return b = a converted to wad, rounded half up to the nearest wad\\n     **/\\n    function rayToWad(uint256 a) internal pure returns (uint256 b) {\\n        assembly {\\n            b := div(a, WAD_RAY_RATIO)\\n            let remainder := mod(a, WAD_RAY_RATIO)\\n            if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\\n                b := add(b, 1)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts wad up to ray\\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Wad\\n     * @return b = a converted in ray\\n     **/\\n    function wadToRay(uint256 a) internal pure returns (uint256 b) {\\n        // to avoid overflow, b/WAD_RAY_RATIO == a\\n        assembly {\\n            b := mul(a, WAD_RAY_RATIO)\\n\\n            if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xccf0652e967667a457836300e6fd1ef4e790e7db3f2cb183a74ba9b79337e2c9\",\"license\":\"MIT\"},\"src/contracts/minter/collateral-pool/interfaces/ICollateralPoolSwapFacet.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\nimport {Position, NewPosition} from \\\"../position/state/PositionsStorage.sol\\\";\\n\\ninterface ICollateralPoolSwapFacet {\\n    event Swap(\\n        address indexed who,\\n        address indexed assetIn,\\n        address indexed assetOut,\\n        uint256 amountIn,\\n        uint256 amountOut\\n    );\\n    event SwapFee(address indexed assetIn, uint256 feeAmount, uint256 protocolFeeAmount);\\n\\n    event Income(address asset, uint256 amount);\\n\\n    /// @notice Get a price for an asset. It is `extOracleDecimals()` of precision.\\n    function getPrice(address _asset) external view returns (uint256 price);\\n\\n    /**\\n     * @notice Preview the amount out received.\\n     * @param _assetIn The asset to pay with.\\n     * @param _assetOut The asset to receive.\\n     * @param _amountIn The amount of _assetIn to pay.\\n     * @param _leverage The leverage to use. 1e18 = 1x, 2e18 = 2x, etc.\\n     * @return amountOut The amount of `_assetOut` to receive according to `_amountIn`.\\n     */\\n    function previewSwap(\\n        address _assetIn,\\n        address _assetOut,\\n        uint256 _amountIn,\\n        uint256 _leverage\\n    ) external view returns (uint256 amountOut, uint256 feeAmount, uint256 protocolFee);\\n\\n    /**\\n     * @notice Swap kresko assets with KISS using the shared collateral pool.\\n     * Uses oracle pricing of _amountIn to determine how much _assetOut to send.\\n     * @param _account The receiver of amount out.\\n     * @param _assetIn The asset to pay with.\\n     * @param _assetOut The asset to receive.\\n     * @param _amountIn The amount of _assetIn to pay.\\n     * @param _amountOutMin The minimum amount of _assetOut to receive, this is due to possible oracle price change.\\n     */\\n    function swap(\\n        address _account,\\n        address _assetIn,\\n        address _assetOut,\\n        uint256 _amountIn,\\n        uint256 _amountOutMin\\n    ) external;\\n\\n    /// @notice deposit collateral into a position\\n    function positionDepositA(address _to, uint256 _amountA, Position memory _pos) external;\\n\\n    /// @notice withdraw collateral from a position\\n    function positionWithdrawA(address _from, uint256 _amountA, Position memory _pos) external;\\n\\n    /**\\n     * @notice Swap in to leverage. This is only callable by the positions NFT.\\n     * @param _sender The account that funds the position.\\n     * @param _pos The position to swap into.\\n     * @return amountAInAfterFee Amount in after fees are paid.\\n     * @return amountBOut Amount of `_assetOut` received.\\n     */\\n    function swapIntoLeverage(\\n        address _sender,\\n        NewPosition memory _pos\\n    ) external returns (uint256 amountAInAfterFee, uint256 amountBOut);\\n\\n    /**\\n     * @notice Swaps out of leverage. This is only callable by the positions NFT.\\n     * @notice Called by the position contract.\\n     * @param _pos The position to swap out of.\\n     * @param _liquidator The incentive receiver if position is liquidated or closed by external caller.\\n     * @return amountAOut The amount of `_assetOut` to receive.\\n     */\\n    function swapOutOfLeverage(Position memory _pos, address _liquidator) external returns (uint256 amountAOut);\\n\\n    /**\\n     * @notice Accumulates fees to deposits as a fixed, instantaneous income.\\n     * @param _incomeAsset the income asset\\n     * @param _amount amount to accumulate\\n     */\\n    function cumulateIncome(address _incomeAsset, uint256 _amount) external;\\n}\\n\",\"keccak256\":\"0x4b3374025742235349fabc6d24ce735212d4c460008c5e2d1d9a8b144a0de766\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/collateral-pool/position/facets/ERC721Facet.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity <=0.8.19;\\n\\nimport {ERC721} from \\\"../state/ERC721Storage.sol\\\";\\nimport {IERC721Permit} from \\\"../interfaces/IERC721Permit.sol\\\";\\nimport {IERC1271} from \\\"../interfaces/IERC1271.sol\\\";\\nimport {pos} from \\\"../state/PositionsStorage.sol\\\";\\nimport {AddressUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\n\\ncontract ERC721Facet is IERC721Permit {\\n    using AddressUpgradeable for address;\\n    /// @dev The hash of the name used in the permit signature verification\\n    bytes32 private immutable nameHash;\\n\\n    /// @dev The hash of the version string used in the permit signature verification\\n    bytes32 private immutable versionHash;\\n\\n    constructor() {\\n        nameHash = keccak256(\\\"Kresko Positions\\\");\\n        versionHash = keccak256(\\\"1\\\");\\n    }\\n\\n    /// @inheritdoc IERC721Permit\\n    /// @dev Value is equal to keccak256(\\\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant override PERMIT_TYPEHASH =\\n        0x49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad;\\n\\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\\n                    0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\\n                    nameHash,\\n                    versionHash,\\n                    getChainId(),\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    function permit(\\n        address spender,\\n        uint256 tokenId,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable override {\\n        require(_blockTimestamp() <= deadline, \\\"Permit expired\\\");\\n\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR(),\\n                keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, pos().getAndIncrementNonce(tokenId), deadline))\\n            )\\n        );\\n        address owner = ERC721().ownerOf(tokenId);\\n        require(spender != owner, \\\"ERC721Permit: approval to current owner\\\");\\n\\n        if (AddressUpgradeable.isContract(owner)) {\\n            require(IERC1271(owner).isValidSignature(digest, abi.encodePacked(r, s, v)) == 0x1626ba7e, \\\"Unauthorized\\\");\\n        } else {\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n            require(recoveredAddress != address(0), \\\"Invalid signature\\\");\\n            require(recoveredAddress == owner, \\\"Unauthorized\\\");\\n        }\\n\\n        ERC721().approve(spender, tokenId);\\n    }\\n\\n    function getCurrentId() external view returns (uint256) {\\n        return ERC721().currentId;\\n    }\\n\\n    function name() external view returns (string memory) {\\n        return ERC721().name;\\n    }\\n\\n    function symbol() external view returns (string memory) {\\n        return ERC721().symbol;\\n    }\\n\\n    function balanceOf(address _owner) external view returns (uint256) {\\n        return ERC721().balances[_owner];\\n    }\\n\\n    function ownerOf(uint256 _tokenId) external view returns (address) {\\n        return ERC721().owners[_tokenId];\\n    }\\n\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\\n        ERC721().safeTransferFrom(_from, _to, _tokenId);\\n    }\\n\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external {\\n        //solhint-disable-next-line max-line-length\\n        require(ERC721().isApprovedOrOwner(msg.sender, _tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n\\n        ERC721().transfer(_from, _to, _tokenId);\\n    }\\n\\n    function approve(address _approved, uint256 _tokenId) public {\\n        ERC721().approve(_approved, _tokenId);\\n    }\\n\\n    function getApproved(uint256 _tokenId) external view returns (address operator) {\\n        return ERC721().getApproved(_tokenId);\\n    }\\n\\n    function setApprovalForAll(address _operator, bool _approved) external {\\n        ERC721().setApprovalForAll(_operator, _approved);\\n    }\\n\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\\n        return ERC721().isApprovedForAll(_owner, _operator);\\n    }\\n\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) external {\\n        ERC721().safeTransferFrom(_from, _to, _tokenId, _data);\\n    }\\n\\n    function _blockTimestamp() internal view virtual returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    function getChainId() internal view returns (uint256 chainId) {\\n        assembly {\\n            chainId := chainid()\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xeb41dc7304c748fe72455cf13c1f2618096937ba5052063334ee9ab8d2aa28b3\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/collateral-pool/position/interfaces/IERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Interface for verifying contract-based account signatures\\n/// @notice Interface that verifies provided signature for the data\\n/// @dev Interface defined by EIP-1271\\ninterface IERC1271 {\\n    /// @notice Returns whether the provided signature is valid for the provided data\\n    /// @dev MUST return the bytes4 magic value 0x1626ba7e when function passes.\\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5).\\n    /// MUST allow external calls.\\n    /// @param hash Hash of the data to be signed\\n    /// @param signature Signature byte array associated with _data\\n    /// @return magicValue The bytes4 magic value 0x1626ba7e\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\",\"keccak256\":\"0xfafb0a232f7410fa2fbcae4627e357dfa8f43a58dea6ba796d8bf5523c5c7b89\",\"license\":\"GPL-2.0-or-later\"},\"src/contracts/minter/collateral-pool/position/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xed9a88103742da6bf24b9a981539e54de3ad33bd1509beb46335fa1d5053c7d6\",\"license\":\"MIT\"},\"src/contracts/minter/collateral-pool/position/interfaces/IERC721Permit.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity <=0.8.19;\\n\\nimport {IERC721} from \\\"./IERC721.sol\\\";\\n\\n/// @title ERC721 with permit\\n/// @notice Extension to ERC721 that includes a permit function for signature based approvals\\ninterface IERC721Permit is IERC721 {\\n    /// @notice The permit typehash used in the permit signature\\n    /// @return The typehash for the permit\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    /// @notice The domain separator used in the permit signature\\n    /// @return The domain seperator used in encoding of permit signature\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    /// @notice Approve of a specific token ID for spending by spender via signature\\n    /// @param spender The account that is being approved\\n    /// @param tokenId The ID of the token that is being approved for spending\\n    /// @param deadline The deadline timestamp by which the call must be mined for the approve to work\\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n    function permit(address spender, uint256 tokenId, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external payable;\\n}\\n\",\"keccak256\":\"0x5e0b6bde7dce3ace49991f7c23c0f7f0051e1b9eca0d351af4106c91e6be870a\",\"license\":\"GPL-2.0-or-later\"},\"src/contracts/minter/collateral-pool/position/interfaces/ILayerZeroEndpointUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"./ILayerZeroUserApplicationConfigUpgradeable.sol\\\";\\n\\ninterface ILayerZeroEndpointUpgradeable is ILayerZeroUserApplicationConfigUpgradeable {\\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\\n    // @param _payload - a custom bytes payload to send to the destination contract\\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\\n    function send(\\n        uint16 _dstChainId,\\n        bytes calldata _destination,\\n        bytes calldata _payload,\\n        address payable _refundAddress,\\n        address _zroPaymentAddress,\\n        bytes calldata _adapterParams\\n    ) external payable;\\n\\n    // @notice used by the messaging library to publish verified payload\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source contract (as bytes) at the source chain\\n    // @param _dstAddress - the address on destination chain\\n    // @param _nonce - the unbound message ordering nonce\\n    // @param _gasLimit - the gas limit for external contract execution\\n    // @param _payload - verified payload to send to the destination contract\\n    function receivePayload(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress,\\n        address _dstAddress,\\n        uint64 _nonce,\\n        uint _gasLimit,\\n        bytes calldata _payload\\n    ) external;\\n\\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\\n\\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\\n    // @param _srcAddress - the source chain contract address\\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\\n\\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _userApplication - the user app address on this EVM chain\\n    // @param _payload - the custom message to send over LayerZero\\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\\n    function estimateFees(\\n        uint16 _dstChainId,\\n        address _userApplication,\\n        bytes calldata _payload,\\n        bool _payInZRO,\\n        bytes calldata _adapterParam\\n    ) external view returns (uint nativeFee, uint zroFee);\\n\\n    // @notice get this Endpoint's immutable source identifier\\n    function getChainId() external view returns (uint16);\\n\\n    // @notice the interface to retry failed message on this Endpoint destination\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    // @param _payload - the payload to be retried\\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\\n\\n    // @notice query if any STORED payload (message blocking) at the endpoint.\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\\n\\n    // @notice query if the _libraryAddress is valid for sending msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\\n\\n    // @notice query if the _libraryAddress is valid for receiving msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\\n\\n    // @notice query if the non-reentrancy guard for send() is on\\n    // @return true if the guard is on. false otherwise\\n    function isSendingPayload() external view returns (bool);\\n\\n    // @notice query if the non-reentrancy guard for receive() is on\\n    // @return true if the guard is on. false otherwise\\n    function isReceivingPayload() external view returns (bool);\\n\\n    // @notice get the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _userApplication - the contract address of the user application\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    function getConfig(\\n        uint16 _version,\\n        uint16 _chainId,\\n        address _userApplication,\\n        uint _configType\\n    ) external view returns (bytes memory);\\n\\n    // @notice get the send() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getSendVersion(address _userApplication) external view returns (uint16);\\n\\n    // @notice get the lzReceive() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\\n}\\n\",\"keccak256\":\"0x94df152b24e7395f52570c656e5f1e016bfa8b5c3623ff2fc2ced1c14ecd7c79\",\"license\":\"MIT\"},\"src/contracts/minter/collateral-pool/position/interfaces/ILayerZeroUserApplicationConfigUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.2;\\n\\ninterface ILayerZeroUserApplicationConfigUpgradeable {\\n    // @notice set the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    // @param _config - configuration in the bytes. can encode arbitrary content.\\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\\n\\n    // @notice set the send() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setSendVersion(uint16 _version) external;\\n\\n    // @notice set the lzReceive() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setReceiveVersion(uint16 _version) external;\\n\\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\\n    // @param _srcChainId - the chainId of the source chain\\n    // @param _srcAddress - the contract address of the source contract at the source chain\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\\n}\\n\",\"keccak256\":\"0xa808baa32db12c453b982320e0c9a8c07aec8c0f3bb36ac2ed26f3ad47476879\",\"license\":\"MIT\"},\"src/contracts/minter/collateral-pool/position/libs/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\nlibrary BytesLib {\\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(\\n                0x40,\\n                and(\\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n                    not(31) // Round down to the nearest 32 bytes.\\n                )\\n            )\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1, \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                    // the next line is the loop condition:\\n                    // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {\\n\\n                        } eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0xaa1c57864bd8483bb17f2fa96a0cbebb39006ca7aab1a28ff85e52e487437c4c\",\"license\":\"Unlicense\"},\"src/contracts/minter/collateral-pool/position/libs/LibERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport {AddressUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport {StringsUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\\\";\\nimport {IERC721ReceiverUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\\\";\\nimport {ERC721, ERC721Storage} from \\\"../state/ERC721Storage.sol\\\";\\nimport {LibLZ} from \\\"./LibLZ.sol\\\";\\nimport {Meta} from \\\"../../../../libs/Meta.sol\\\";\\n\\nlibrary LibERC721 {\\n    using AddressUpgradeable for address;\\n    using StringsUpgradeable for uint256;\\n    using LibERC721 for ERC721Storage;\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(\\n        ERC721Storage storage self,\\n        address owner,\\n        address operator\\n    ) internal view returns (bool) {\\n        return self.operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(ERC721Storage storage self, address operator, bool approved) internal {\\n        require(msg.sender != operator, \\\"ERC721: approve to caller\\\");\\n        self.operatorApprovals[msg.sender][operator] = approved;\\n    }\\n\\n    function isApprovedOrOwner(\\n        ERC721Storage storage self,\\n        address spender,\\n        uint256 tokenId\\n    ) internal view returns (bool) {\\n        address owner = self.ownerOf(tokenId);\\n        return (spender == owner || self.isApprovedForAll(owner, spender) || self.getApproved(tokenId) == spender);\\n    }\\n\\n    function debitFrom(ERC721Storage storage self, address _from, uint16, bytes memory, uint _tokenId) internal {\\n        require(self.isApprovedOrOwner(Meta.msgSender(), _tokenId), LibLZ.INVALID_CALLER);\\n        require(self.ownerOf(_tokenId) == _from, LibLZ.INVALID_TOKEN_OWNER);\\n        self.transfer(_from, address(this), _tokenId);\\n    }\\n\\n    function creditTo(ERC721Storage storage self, uint16, address _toAddress, uint _tokenId) internal {\\n        bool tokenExists = self.exists(_tokenId);\\n        require(!tokenExists || (tokenExists && self.ownerOf(_tokenId) == address(this)));\\n        if (!tokenExists) {\\n            self.safeMint(_toAddress, _tokenId, \\\"\\\");\\n        } else {\\n            self.transfer(address(this), _toAddress, _tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(ERC721Storage storage self, uint256 tokenId) internal view returns (address) {\\n        self.requireMinted(tokenId);\\n\\n        return self.tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function safeMint(ERC721Storage storage self, address to, uint256 tokenId, bytes memory data) internal {\\n        _mint(self, to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    function _mint(ERC721Storage storage self, address to, uint256 tokenId) private {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!self.exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        self.beforeTokenTransfer(address(0), to, tokenId, 1);\\n\\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\\n        require(!self.exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        unchecked {\\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\\n            // Given that tokens are minted one by one, it is impossible in practice that\\n            // this ever happens. Might change if we allow batch minting.\\n            // The ERC fails to describe this case.\\n            self.balances[to] += 1;\\n        }\\n\\n        self.owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        self.afterTokenTransfer(address(0), to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function burn(ERC721Storage storage self, uint256 tokenId) internal {\\n        address owner = self.ownerOf(tokenId);\\n\\n        self.beforeTokenTransfer(owner, address(0), tokenId, 1);\\n\\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\\n        owner = self.ownerOf(tokenId);\\n\\n        // Clear approvals\\n        delete self.tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // Cannot overflow, as that would require more tokens to be burned/transferred\\n            // out than the owner initially received through minting and transferring in.\\n            self.balances[owner] -= 1;\\n        }\\n        delete self.owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        self.afterTokenTransfer(owner, address(0), tokenId, 1);\\n    }\\n\\n    function ownerOf(ERC721Storage storage self, uint256 tokenId) internal view returns (address) {\\n        address owner = self.owners[tokenId];\\n        require(owner != address(0), \\\"ERC721 :address zero is not a valid owner\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function requireMinted(ERC721Storage storage self, uint256 tokenId) internal view {\\n        require(self.exists(tokenId), \\\"ERC721: invalid token ID\\\");\\n    }\\n\\n    /** @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721ReceiverUpgradeable(to).onERC721Received(msg.sender, from, tokenId, data) returns (\\n                bytes4 retval\\n            ) {\\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(ERC721Storage storage self, address to, uint256 tokenId) internal {\\n        self.tokenApprovals[tokenId] = to;\\n        emit Approval(self.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(ERC721Storage storage self, address owner, address operator, bool approved) internal {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        self.operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    function safeTransferFrom(ERC721Storage storage self, address from, address to, uint256 tokenId) internal {\\n        self.safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        ERC721Storage storage self,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal {\\n        require(self.isApprovedOrOwner(msg.sender, tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n        _safeTransfer(self, from, to, tokenId, data);\\n    }\\n\\n    function _safeTransfer(\\n        ERC721Storage storage self,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private {\\n        transfer(self, from, to, tokenId);\\n        _checkOnERC721Received(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(ERC721Storage storage self, address from, address to, uint256 tokenId) internal {\\n        require(self.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        self.beforeTokenTransfer(from, to, tokenId, 1);\\n\\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\\n        require(self.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n\\n        // Clear approvals from the previous owner\\n        delete self.tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\\n            // `from`'s balance is the number of token held, which is at least one before the current\\n            // transfer.\\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\\n            // all 2**256 token ids to be minted, which in practice is impossible.\\n            self.balances[from] -= 1;\\n            self.balances[to] += 1;\\n        }\\n        self.owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        self.afterTokenTransfer(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function exists(ERC721Storage storage self, uint256 tokenId) internal view returns (bool) {\\n        return self.owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\\n     * - When `from` is zero, the tokens will be minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function beforeTokenTransfer(\\n        ERC721Storage storage self,\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize\\n    ) internal {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\\n     * - When `from` is zero, the tokens were minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens were burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function afterTokenTransfer(\\n        ERC721Storage storage self,\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize\\n    ) internal {}\\n\\n    /**\\n     * @dev Unsafe write access to the balances, used by extensions that \\\"mint\\\" tokens using an {ownerOf} override.\\n     *\\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\\n     * that `ownerOf(tokenId)` is `a`.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\\n        ERC721().balances[account] += amount;\\n    }\\n}\\n\",\"keccak256\":\"0xbcd36d49c727c356b63f0c17c356c572a80ed72f2713caaedbb5abbbd8e82234\",\"license\":\"MIT\"},\"src/contracts/minter/collateral-pool/position/libs/LibLZ.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity <=0.8.19;\\nimport {BytesLib} from \\\"../libs/BytesLib.sol\\\";\\nimport {Meta} from \\\"../../../../libs/Meta.sol\\\";\\nimport {ERC721} from \\\"../state/ERC721Storage.sol\\\";\\nimport {lz, LZStorage, StoredCredit, AirdropParams, CallParams} from \\\"../state/LZStorage.sol\\\";\\n\\nlibrary LibLZ {\\n    using BytesLib for bytes;\\n    ///@dev Emitted when `_payload` was received from lz, but not enough gas to deliver all tokenIds\\n    event CreditStored(bytes32 _hashedPayload, bytes _payload);\\n\\n    /// @dev Emitted when `_hashedPayload` has been completely delivered\\n    event CreditCleared(bytes32 _hashedPayload);\\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\\n\\n    /// @dev Emitted when `_tokenIds[]` are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\\n    /// `_nonce` is the outbound nonce from\\n    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes indexed _toAddress, uint[] _tokenIds);\\n    event ReceiveFromChain(\\n        uint16 indexed _srcChainId,\\n        bytes indexed _srcAddress,\\n        address indexed _toAddress,\\n        uint[] _tokenIds\\n    );\\n\\n    event SetPrecrime(address precrime);\\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\\n\\n    uint16 internal constant FUNCTION_TYPE_SEND = 1;\\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\\n    uint256 internal constant DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\\n\\n    string internal constant MINGASZERO = \\\"2\\\"; // ONFT721: minGasToTransferAndStore must be > 0\\\"\\n    string internal constant TOKENIDS_EMPTY = \\\"1\\\"; // LzApp: tokenIds[] is empty\\n    string internal constant BATCH_LIMIT_EXCEEDED = \\\"3\\\"; // \\\"ONFT721: batch size exceeds dst batch limit\\\"\\n    string internal constant NO_CREDITS_STORED = \\\"4\\\"; // \\\"ONFT721: no credits stored\\\"\\n    string internal constant NO_GAS_REMAINING = \\\"5\\\"; // \\\"ONFT721: not enough gas to process credit transfer\\\"\\n    string internal constant MIN_GAS_NOT_ZERO = \\\"6\\\"; // \\\"ONFT721: minGasToTransferAndStore must be > 0\\\"\\n    string internal constant INVALID_CALLER = \\\"7\\\"; // \\\"ONFT721: send caller is not owner nor approved\\\"\\n    string internal constant INVALID_TOKEN_OWNER = \\\"8\\\"; // \\\"ONFT721: send from incorrect owner\\\"\\n    string internal constant INVALID_ENDPOINT = \\\"9\\\"; // Endpoint cannot be 0\\n\\n    function estimateFees(\\n        LZStorage storage self,\\n        uint16 _dstChainId,\\n        bytes memory _toAddress,\\n        uint[] memory _tokenIds,\\n        bool _useZro,\\n        bytes memory _adapterParams\\n    ) internal view returns (uint256, uint256) {\\n        bytes memory payload = abi.encode(_toAddress, _tokenIds);\\n        return self.lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\\n    }\\n\\n    function send(\\n        LZStorage storage self,\\n        address _from,\\n        uint16 _dstChainId,\\n        bytes memory _toAddress,\\n        uint[] memory _tokenIds,\\n        address payable _refundAddress,\\n        address _zroPaymentAddress,\\n        bytes memory _adapterParams\\n    ) internal {\\n        // allow 1 by default\\n        require(_tokenIds.length > 0, \\\"tokenIds[] is empty\\\");\\n        require(\\n            _tokenIds.length == 1 || _tokenIds.length <= self.dstChainIdToBatchLimit[_dstChainId],\\n            \\\"batch size exceeds dst batch limit\\\"\\n        );\\n\\n        for (uint i = 0; i < _tokenIds.length; i++) {\\n            ERC721().debitFrom(_from, _dstChainId, _toAddress, _tokenIds[i]);\\n        }\\n\\n        bytes memory payload = abi.encode(_toAddress, _tokenIds);\\n\\n        checkGasLimit(\\n            self,\\n            _dstChainId,\\n            FUNCTION_TYPE_SEND,\\n            _adapterParams,\\n            self.dstChainIdToTransferGas[_dstChainId] * _tokenIds.length\\n        );\\n        _lzSend(self, _dstChainId, payload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\\n        emit SendToChain(_dstChainId, _from, _toAddress, _tokenIds);\\n    }\\n\\n    function _lzSend(\\n        LZStorage storage self,\\n        uint16 _dstChainId,\\n        bytes memory _payload,\\n        address payable _refundAddress,\\n        address _zroPaymentAddress,\\n        bytes memory _adapterParams,\\n        uint _nativeFee\\n    ) internal {\\n        bytes memory trustedRemote = self.trustedRemoteLookup[_dstChainId];\\n        require(trustedRemote.length != 0, \\\"LzApp: destination chain is not a trusted source\\\");\\n        self.checkPayloadSize(_dstChainId, _payload.length);\\n        self.lzEndpoint.send{value: _nativeFee}(\\n            _dstChainId,\\n            trustedRemote,\\n            _payload,\\n            _refundAddress,\\n            _zroPaymentAddress,\\n            _adapterParams\\n        );\\n    }\\n\\n    function nonblockingLzReceive(\\n        LZStorage storage self,\\n        uint16 _srcChainId,\\n        bytes memory _srcAddress,\\n        uint64 /*_nonce*/,\\n        bytes memory _payload\\n    ) internal {\\n        // decode and load the toAddress\\n        (bytes memory toAddressBytes, uint[] memory tokenIds) = abi.decode(_payload, (bytes, uint[]));\\n\\n        address toAddress;\\n        assembly {\\n            toAddress := mload(add(toAddressBytes, 20))\\n        }\\n\\n        uint nextIndex = self.creditTill(_srcChainId, toAddress, 0, tokenIds);\\n        if (nextIndex < tokenIds.length) {\\n            // not enough gas to complete transfers, store to be cleared in another tx\\n            bytes32 hashedPayload = keccak256(_payload);\\n            self.storedCredits[hashedPayload] = StoredCredit(_srcChainId, toAddress, nextIndex, true);\\n            emit CreditStored(hashedPayload, _payload);\\n        }\\n\\n        emit ReceiveFromChain(_srcChainId, _srcAddress, toAddress, tokenIds);\\n    }\\n\\n    // When a srcChain has the ability to transfer more chainIds in a single tx than the dst can do.\\n    // Needs the ability to iterate and stop if the minGasToTransferAndStore is not met\\n    function creditTill(\\n        LZStorage storage self,\\n        uint16 _srcChainId,\\n        address _toAddress,\\n        uint _startIndex,\\n        uint[] memory _tokenIds\\n    ) internal returns (uint256) {\\n        uint i = _startIndex;\\n        while (i < _tokenIds.length) {\\n            // if not enough gas to process, store this index for next loop\\n            if (gasleft() < self.minGasToTransferAndStore) break;\\n\\n            ERC721().creditTo(_srcChainId, _toAddress, _tokenIds[i]);\\n            i++;\\n        }\\n\\n        // indicates the next index to send of tokenIds,\\n        // if i == tokenIds.length, we are finished\\n        return i;\\n    }\\n\\n    function checkGasLimit(\\n        LZStorage storage self,\\n        uint16 _dstChainId,\\n        uint16 _type,\\n        bytes memory _adapterParams,\\n        uint _extraGas\\n    ) internal view {\\n        uint providedGasLimit = getGasLimit(_adapterParams);\\n        uint minGasLimit = self.minDstGasLookup[_dstChainId][_type] + _extraGas;\\n        require(minGasLimit > 0, \\\"LzApp: minGasLimit not set\\\");\\n        require(providedGasLimit >= minGasLimit, \\\"LzApp: gas limit is too low\\\");\\n    }\\n\\n    function getGasLimit(bytes memory _adapterParams) internal pure returns (uint gasLimit) {\\n        require(_adapterParams.length >= 34, \\\"LzApp: invalid adapterParams\\\");\\n        assembly {\\n            gasLimit := mload(add(_adapterParams, 34))\\n        }\\n    }\\n\\n    function checkPayloadSize(LZStorage storage self, uint16 _dstChainId, uint _payloadSize) internal view {\\n        uint payloadSizeLimit = self.payloadSizeLimitLookup[_dstChainId];\\n        if (payloadSizeLimit == 0) {\\n            // use default if not set\\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\\n        }\\n        require(_payloadSize <= payloadSizeLimit, \\\"LzApp: payload size is too large\\\");\\n    }\\n\\n    function buildAdapterParams(\\n        AirdropParams memory _airdropParams,\\n        uint _uaGasLimit\\n    ) internal pure returns (bytes memory adapterParams) {\\n        if (_airdropParams.airdropAmount == 0 && _airdropParams.airdropAddress == bytes32(0x0)) {\\n            adapterParams = buildDefaultAdapterParams(_uaGasLimit);\\n        } else {\\n            adapterParams = buildAirdropAdapterParams(_uaGasLimit, _airdropParams);\\n        }\\n    }\\n\\n    // Build Adapter Params\\n    function buildDefaultAdapterParams(uint _uaGas) internal pure returns (bytes memory) {\\n        // txType 1\\n        // bytes  [2       32      ]\\n        // fields [txType  extraGas]\\n        return abi.encodePacked(uint16(1), _uaGas);\\n    }\\n\\n    function buildAirdropAdapterParams(uint _uaGas, AirdropParams memory _params) internal pure returns (bytes memory) {\\n        require(_params.airdropAmount > 0, \\\"Airdrop amount must be greater than 0\\\");\\n        require(_params.airdropAddress != bytes32(0x0), \\\"Airdrop address must be set\\\");\\n\\n        // txType 2\\n        // bytes  [2       32        32            bytes[]         ]\\n        // fields [txType  extraGas  dstNativeAmt  dstNativeAddress]\\n        return abi.encodePacked(uint16(2), _uaGas, _params.airdropAmount, _params.airdropAddress);\\n    }\\n\\n    // Decode Adapter Params\\n    function decodeAdapterParams(\\n        bytes memory _adapterParams\\n    ) internal pure returns (uint16 txType, uint uaGas, uint airdropAmount, address payable airdropAddress) {\\n        require(_adapterParams.length == 34 || _adapterParams.length > 66, \\\"Invalid adapterParams\\\");\\n        assembly {\\n            txType := mload(add(_adapterParams, 2))\\n            uaGas := mload(add(_adapterParams, 34))\\n        }\\n        require(txType == 1 || txType == 2, \\\"Unsupported txType\\\");\\n        require(uaGas > 0, \\\"Gas too low\\\");\\n\\n        if (txType == 2) {\\n            assembly {\\n                airdropAmount := mload(add(_adapterParams, 66))\\n                airdropAddress := mload(add(_adapterParams, 86))\\n            }\\n        }\\n    }\\n\\n    //---------------------------------------------------------------------------\\n    // Address type handling\\n    function bytes32ToAddress(bytes32 _bytes32Address) internal pure returns (address _address) {\\n        return address(uint160(uint(_bytes32Address)));\\n    }\\n\\n    function addressToBytes32(address _address) internal pure returns (bytes32 _bytes32Address) {\\n        return bytes32(uint(uint160(_address)));\\n    }\\n}\\n\",\"keccak256\":\"0x99d171bc1a15ec71836a1c7980dfd6e25682f78a5e4bef9eb219e2aa1b81707a\",\"license\":\"MIT\"},\"src/contracts/minter/collateral-pool/position/libs/LibPositions.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity <=0.8.19;\\nimport {WadRay} from \\\"../../../../libs/WadRay.sol\\\";\\nimport {pos, PositionStorage, Position} from \\\"../state/PositionsStorage.sol\\\";\\n\\nlibrary LibPositions {\\n    using WadRay for uint256;\\n    using LibPositions for PositionStorage;\\n\\n    string internal constant INVALID_LT = \\\"PC0\\\";\\n    string internal constant INVALID_MAX_LEVERAGE = \\\"PC1\\\";\\n    string internal constant INVALID_KRESKO = \\\"PC2\\\";\\n    string internal constant ERROR_NOT_OWNER = \\\"PC3\\\";\\n    string internal constant ERROR_POSITION_NOT_OWNED_BY_CALLER = \\\"PC4\\\";\\n    string internal constant ERROR_POSITION_NOT_FOUND = \\\"PC5\\\";\\n    string internal constant INVALID_NAME = \\\"PC6\\\";\\n    string internal constant LEVERAGE_TOO_HIGH = \\\"PC7\\\";\\n    string internal constant LEVERAGE_TOO_LOW = \\\"PC8\\\";\\n\\n    function getPosition(PositionStorage storage self, uint256 _id) internal view returns (Position memory) {\\n        return self.positions[_id];\\n    }\\n\\n    function getLeverage(PositionStorage storage self, uint256 _id) internal view returns (uint256 leverage) {\\n        Position memory position = self.positions[_id];\\n        uint256 priceA = self.kresko.getPrice(position.assetA);\\n        uint256 priceB = self.kresko.getPrice(position.assetB);\\n\\n        if (priceA == 0 || priceB == 0 || position.amountA == 0) return 0;\\n\\n        return position.amountB.wadMul(priceB).wadDiv(position.amountA.wadMul(priceA));\\n    }\\n\\n    function getRatio(PositionStorage storage self, uint256 _id) internal view returns (int256 ratio) {\\n        return int256(self.getLeverage(_id)) - int256(self.positions[_id].leverage);\\n    }\\n\\n    function isLiquidatable(PositionStorage storage self, uint256 _id) internal view returns (bool) {\\n        return self.getRatio(_id) <= self.liquidationThreshold;\\n    }\\n\\n    function isCloseable(PositionStorage storage self, uint256 _id) internal view returns (bool) {\\n        return self.getRatio(_id) >= self.closeThreshold;\\n    }\\n\\n    function getAndIncrementNonce(PositionStorage storage self, uint256 id) internal returns (uint256) {\\n        return uint256(self.positions[id].nonce++);\\n    }\\n}\\n\",\"keccak256\":\"0x3737f34cb726aa4e620e68620f34a31257645e8a402657d285d421b3a8d5a84c\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/collateral-pool/position/state/ERC721Storage.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {LibERC721} from \\\"../libs/LibERC721.sol\\\";\\n\\nstruct ERC721Storage {\\n    uint256 currentId;\\n    // Token name\\n    string name;\\n    // Token symbol\\n    string symbol;\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) owners;\\n    // Mapping owner address to token count\\n    mapping(address => uint256) balances;\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) tokenApprovals;\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) operatorApprovals;\\n    string baseURI;\\n}\\n\\n// Storage position\\nbytes32 constant ERC721_STORAGE_POSITION = keccak256(\\\"kresko.positions.erc721.storage\\\");\\n\\nfunction ERC721() pure returns (ERC721Storage storage state) {\\n    bytes32 position = ERC721_STORAGE_POSITION;\\n    assembly {\\n        state.slot := position\\n    }\\n}\\n\\nusing LibERC721 for ERC721Storage global;\\n\",\"keccak256\":\"0xc0c135c35619ada024ab9f683185278ead6208726df1189798462c04501f006a\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/collateral-pool/position/state/LZStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\nimport {ILayerZeroEndpointUpgradeable} from \\\"../interfaces/ILayerZeroEndpointUpgradeable.sol\\\";\\nimport {ILayerZeroUserApplicationConfigUpgradeable} from \\\"../interfaces/ILayerZeroUserApplicationConfigUpgradeable.sol\\\";\\nimport {LibLZ} from \\\"../libs/LibLZ.sol\\\";\\n\\nusing LibLZ for LZStorage global;\\n\\nstruct StoredCredit {\\n    uint16 srcChainId;\\n    address toAddress;\\n    uint256 index; // which index of the tokenIds remain\\n    bool creditsRemain;\\n}\\n\\nstruct CallParams {\\n    address payable refundAddress;\\n    address zroPaymentAddress;\\n}\\n\\nstruct AirdropParams {\\n    uint airdropAmount;\\n    bytes32 airdropAddress;\\n}\\n\\nstruct LZStorage {\\n    uint256 minGasToTransferAndStore; // min amount of gas required to transfer, and also store the payload\\n    mapping(uint16 => uint256) dstChainIdToBatchLimit;\\n    mapping(uint16 => uint256) dstChainIdToTransferGas; // per transfer amount of gas required to mint/transfer on the dst\\n    mapping(bytes32 => StoredCredit) storedCredits;\\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) failedMessages;\\n    ILayerZeroEndpointUpgradeable lzEndpoint;\\n    mapping(uint16 => bytes) trustedRemoteLookup;\\n    mapping(uint16 => mapping(uint16 => uint)) minDstGasLookup;\\n    mapping(uint16 => uint) payloadSizeLimitLookup;\\n    address precrime;\\n}\\n\\nbytes32 constant LZ_STORAGE_POSITION = keccak256(\\\"kresko.positions.lz.storage\\\");\\n\\nfunction lz() pure returns (LZStorage storage state) {\\n    bytes32 position = LZ_STORAGE_POSITION;\\n    assembly {\\n        state.slot := position\\n    }\\n}\\n\",\"keccak256\":\"0xe515f19edbe39be8bc1fa1708326c16b2c1403265e28b474612b99407bcb7ad5\",\"license\":\"MIT\"},\"src/contracts/minter/collateral-pool/position/state/PositionsStorage.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {LibPositions} from \\\"../libs/LibPositions.sol\\\";\\nimport {ICollateralPoolSwapFacet} from \\\"../../interfaces/ICollateralPoolSwapFacet.sol\\\";\\n\\nstruct NewPosition {\\n    address account;\\n    address assetA;\\n    address assetB;\\n    uint256 amountA;\\n    uint256 amountBMin;\\n    uint256 leverage;\\n}\\n\\nstruct Position {\\n    address account;\\n    address assetA;\\n    address assetB;\\n    uint256 amountA;\\n    uint256 amountB;\\n    uint256 valueBCache;\\n    uint256 leverage;\\n    uint256 liquidationIncentive;\\n    uint256 closeIncentive;\\n    uint256 creationTimestamp;\\n    uint256 lastUpdateTimestamp;\\n    uint256 nonce;\\n}\\n\\nstruct PositionsInitializer {\\n    ICollateralPoolSwapFacet kresko;\\n    string name;\\n    string symbol;\\n    int128 liquidationThreshold;\\n    int128 closeThreshold;\\n    uint256 maxLeverage;\\n    uint256 minLeverage;\\n}\\n\\nstruct PositionStorage {\\n    ICollateralPoolSwapFacet kresko;\\n    uint256 minLeverage;\\n    uint256 maxLeverage;\\n    int128 liquidationThreshold;\\n    int128 closeThreshold;\\n    mapping(uint256 => Position) positions;\\n}\\n\\nusing LibPositions for PositionStorage global;\\n\\n// Storage position\\nbytes32 constant POSITIONS_STORAGE = keccak256(\\\"kresko.positions.positions.storage\\\");\\n\\nfunction pos() pure returns (PositionStorage storage state) {\\n    bytes32 position = POSITIONS_STORAGE;\\n    assembly {\\n        state.slot := position\\n    }\\n}\\n\",\"keccak256\":\"0x26f410dd92b57a1278fc85dd8615c827d1d1b837193ab126a45816e74f6e3359\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x60c08060405234610070577f11c46bd0bd3e1ce4ade04ba3c5a440057b3c2a5618fe8e7fd1cf6c90c9960bb96080527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660a05261175a9081610076823960805181610f70015260a05181610f960152f35b600080fdfe608080604052600436101561001357600080fd5b600090813560e01c90816306fdde0314610cea57508063081812fc14610bd8578063095ea7b314610b9457806323b872dd14610b6f57806330adf81f14610b345780633644e51514610b1157806342842e0e14610a9e5780636352211e14610a2e5780636c143862146109f157806370a082311461096e5780637ac2ff7b146104ae57806395d89b4114610360578063a22cb46514610252578063b88d4fde146101835763e985e9c5146100c657600080fd5b34610180576040367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101805760ff6040602092610104610e0c565b61015761010f610e34565b73ffffffffffffffffffffffffffffffffffffffff90921660009081527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d96020526040902090565b73ffffffffffffffffffffffffffffffffffffffff909116825284522054604051911615158152f35b80fd5b5034610180576080367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0112610180576101bb610e0c565b6101c3610e34565b6044356064359167ffffffffffffffff831161024e573660238401121561024e57826004013593856101f486610f09565b946102026040519687610ee7565b868652366024888301011161024a57866102469760246020930183890137860101526102366102318433611103565b611077565b610241838383611571565b61136a565b5080f35b5080fd5b8480fd5b5034610180576040367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101805761028a610e0c565b6024359081151580920361035c5773ffffffffffffffffffffffffffffffffffffffff163381146102fd573360009081527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d960205260409020908352602052604082209060ff8019835416911617905580f35b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f4552433732313a20617070726f766520746f2063616c6c6572000000000000006044820152606490fd5b8280fd5b5034610180578060031936011261018057604051817fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d592835491600183811c928185169687156104a4575b602095868610891461047757868899878a98999a5291826000146104535750506001146103fa575b5050506103e292500383610ee7565b6103f6604051928284938452830190610dcc565b0390f35b8152859250907f21b933b14ffe6ab58fd7c3aee75f3ce284841da094d61160b28f611141e42d075b85831061043b5750506103e293508201013880806103d3565b80548389018501528794508693909201918101610422565b9350945050506103e294915060ff191682840152151560051b8201013880806103d3565b7f4e487b710000000000000000000000000000000000000000000000000000000083526022600452602483fd5b93607f16936103ab565b5060c0367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0112610180576104e1610e0c565b906064359160ff83169283810361035c576044359384421161090f57610505610f43565b90602495863586527f7fa3672f0a15500ff7afa2c728d0e7f7814ec4292bd398cee8caf1d13a0c6767602052600b60408720019283549360001985146108e35760018501905560405160208101907f49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad825260018060a01b0393848916968760408401528b356060840152608083015260a082015260a081526105a681610e99565b51902060405190602082019261190160f01b845260228301526042820152604281526105d181610ecb565b51902091873587527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d66020528160408820541693841561085f5784146107db57833b156107235750509160209161067b959693604051926084358585015260a435604085015260ff60f81b9060f81b1660608401526041835261065383610ecb565b604051809781948293630b135d3f60e11b845260048401526040888401526044830190610dcc565b03915afa928315610718576106e6936106df9186916106e9575b507fffffffff00000000000000000000000000000000000000000000000000000000167f1626ba7e0000000000000000000000000000000000000000000000000000000014610fd9565b35906112c9565b80f35b61070b915060203d602011610711575b6107038183610ee7565b81019061103f565b38610695565b503d6106f9565b6040513d86823e3d90fd5b869193945060209260809160405191825284820152608435604082015260a435606082015282805260015afa156107d0578351168015610772576106e693949161076d9114610fd9565b6106df565b6040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526011818701527f496e76616c6964207369676e61747572650000000000000000000000000000006044820152606490fd5b6040513d85823e3d90fd5b6040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526027818a01527f4552433732315065726d69743a20617070726f76616c20746f2063757272656e60448201527f74206f776e6572000000000000000000000000000000000000000000000000006064820152608490fd5b6040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526029818b01527f455243373231203a61646472657373207a65726f206973206e6f74206120766160448201527f6c6964206f776e657200000000000000000000000000000000000000000000006064820152608490fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000885260116004528888fd5b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f5065726d697420657870697265640000000000000000000000000000000000006044820152606490fd5b5034610180576020367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101805760209060409073ffffffffffffffffffffffffffffffffffffffff6109c1610e0c565b1681527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d783522054604051908152f35b503461018057806003193601126101805760207fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d354604051908152f35b5034610180576020367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101805760209060043581527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d68252604060018060a01b0391205416604051908152f35b503461018057610aad36610e57565b60409392935191602083019483861067ffffffffffffffff871117610ae45761024694956040528584526102366102318433611103565b7f4e487b710000000000000000000000000000000000000000000000000000000085526041600452602485fd5b50346101805780600319360112610180576020610b2c610f43565b604051908152f35b503461018057806003193601126101805760206040517f49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad8152f35b5034610180576106e6610b8136610e57565b91610b8f6102318433611103565b611571565b5034610180576040367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0112610180576106e6610bcf610e0c565b602435906112c9565b5034610180576020367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0112610180576004358082527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d6602052604082205473ffffffffffffffffffffffffffffffffffffffff9190821615610c8b5782604091602094527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d88452205416604051908152f35b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f4552433732313a20696e76616c696420746f6b656e20494400000000000000006044820152606490fd5b90503461024a578160031936011261024a57817fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d492835491600183811c92818516968715610dc2575b602095868610891461047757868899878a98999a529182600014610453575050600114610d69575050506103e292500383610ee7565b8152859250907f71378b296151749ed178607cf606725b947f386eb9d5e3ed6a8549172e117d4e5b858310610daa5750506103e293508201013880806103d3565b80548389018501528794508693909201918101610d91565b93607f1693610d33565b919082519283825260005b848110610df8575050826000602080949584010152601f8019910116010190565b602081830181015184830182015201610dd7565b6004359073ffffffffffffffffffffffffffffffffffffffff82168203610e2f57565b600080fd5b6024359073ffffffffffffffffffffffffffffffffffffffff82168203610e2f57565b6060906003190112610e2f5773ffffffffffffffffffffffffffffffffffffffff906004358281168103610e2f57916024359081168103610e2f579060443590565b60c0810190811067ffffffffffffffff821117610eb557604052565b634e487b7160e01b600052604160045260246000fd5b6080810190811067ffffffffffffffff821117610eb557604052565b90601f8019910116810190811067ffffffffffffffff821117610eb557604052565b67ffffffffffffffff8111610eb557601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b60405160208101907f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f82527f000000000000000000000000000000000000000000000000000000000000000060408201527f000000000000000000000000000000000000000000000000000000000000000060608201524660808201523060a082015260a08152610fd381610e99565b51902090565b15610fe057565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f556e617574686f72697a656400000000000000000000000000000000000000006044820152606490fd5b90816020910312610e2f57517fffffffff0000000000000000000000000000000000000000000000000000000081168103610e2f5790565b1561107e57565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f4552433732313a2063616c6c6572206973206e6f7420746f6b656e206f776e6560448201527f72206f7220617070726f766564000000000000000000000000000000000000006064820152608490fd5b9073ffffffffffffffffffffffffffffffffffffffff8080611124846111f7565b169316918383149384156111b1575b508315611141575b50505090565b80919293506000527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d6602052816040600020541615610c8b576000527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d8602052604060002054161438808061113b565b9093506000527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d960205260406000208260005260205260ff604060002054169238611133565b60009081527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d6602052604090205473ffffffffffffffffffffffffffffffffffffffff1680156112445790565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f455243373231203a61646472657373207a65726f206973206e6f74206120766160448201527f6c6964206f776e657200000000000000000000000000000000000000000000006064820152608490fd5b60008281527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d86020526040902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92831690811790915590611342836111f7565b167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925600080a4565b92939290803b156114dc57936000916113c19560405180948193630a85bd0160e11b9788845233600485015260018060a01b0380921660248501526044840152608060648401528260209a8b976084830190610dcc565b0393165af1600091816114bd575b5061149657833d1561148e573d906113e682610f09565b916113f46040519384610ee7565b82523d60008284013e5b8151918261148b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260048101839052603260248201527f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560448201527f63656976657220696d706c656d656e74657200000000000000000000000000006064820152608490fd5b01fd5b6060906113fe565b7fffffffff0000000000000000000000000000000000000000000000000000000016149150565b6114d5919250853d8711610711576107038183610ee7565b90386113cf565b50600193505050565b156114ec57565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f4552433732313a207472616e736665722066726f6d20696e636f72726563742060448201527f6f776e65720000000000000000000000000000000000000000000000000000006064820152608490fd5b906115a69161157f846111f7565b73ffffffffffffffffffffffffffffffffffffffff939184169284929091831684146114e5565b169182156116a057816115c3916115bc866111f7565b16146114e5565b7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60008481527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d8602052604081206bffffffffffffffffffffffff60a01b908181541690558382527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d760205260408220600019815401905584825260408220600181540190558582527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d660205284604083209182541617905580a4565b6040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f4552433732313a207472616e7366657220746f20746865207a65726f2061646460448201527f72657373000000000000000000000000000000000000000000000000000000006064820152608490fdfea2646970667358221220093cac5b9441c92feeb816a2d33279d2abf527bc96cb5a49a6750bc5b004fdd664736f6c63430008130033",
  "deployedBytecode": "0x608080604052600436101561001357600080fd5b600090813560e01c90816306fdde0314610cea57508063081812fc14610bd8578063095ea7b314610b9457806323b872dd14610b6f57806330adf81f14610b345780633644e51514610b1157806342842e0e14610a9e5780636352211e14610a2e5780636c143862146109f157806370a082311461096e5780637ac2ff7b146104ae57806395d89b4114610360578063a22cb46514610252578063b88d4fde146101835763e985e9c5146100c657600080fd5b34610180576040367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101805760ff6040602092610104610e0c565b61015761010f610e34565b73ffffffffffffffffffffffffffffffffffffffff90921660009081527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d96020526040902090565b73ffffffffffffffffffffffffffffffffffffffff909116825284522054604051911615158152f35b80fd5b5034610180576080367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0112610180576101bb610e0c565b6101c3610e34565b6044356064359167ffffffffffffffff831161024e573660238401121561024e57826004013593856101f486610f09565b946102026040519687610ee7565b868652366024888301011161024a57866102469760246020930183890137860101526102366102318433611103565b611077565b610241838383611571565b61136a565b5080f35b5080fd5b8480fd5b5034610180576040367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101805761028a610e0c565b6024359081151580920361035c5773ffffffffffffffffffffffffffffffffffffffff163381146102fd573360009081527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d960205260409020908352602052604082209060ff8019835416911617905580f35b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f4552433732313a20617070726f766520746f2063616c6c6572000000000000006044820152606490fd5b8280fd5b5034610180578060031936011261018057604051817fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d592835491600183811c928185169687156104a4575b602095868610891461047757868899878a98999a5291826000146104535750506001146103fa575b5050506103e292500383610ee7565b6103f6604051928284938452830190610dcc565b0390f35b8152859250907f21b933b14ffe6ab58fd7c3aee75f3ce284841da094d61160b28f611141e42d075b85831061043b5750506103e293508201013880806103d3565b80548389018501528794508693909201918101610422565b9350945050506103e294915060ff191682840152151560051b8201013880806103d3565b7f4e487b710000000000000000000000000000000000000000000000000000000083526022600452602483fd5b93607f16936103ab565b5060c0367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0112610180576104e1610e0c565b906064359160ff83169283810361035c576044359384421161090f57610505610f43565b90602495863586527f7fa3672f0a15500ff7afa2c728d0e7f7814ec4292bd398cee8caf1d13a0c6767602052600b60408720019283549360001985146108e35760018501905560405160208101907f49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad825260018060a01b0393848916968760408401528b356060840152608083015260a082015260a081526105a681610e99565b51902060405190602082019261190160f01b845260228301526042820152604281526105d181610ecb565b51902091873587527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d66020528160408820541693841561085f5784146107db57833b156107235750509160209161067b959693604051926084358585015260a435604085015260ff60f81b9060f81b1660608401526041835261065383610ecb565b604051809781948293630b135d3f60e11b845260048401526040888401526044830190610dcc565b03915afa928315610718576106e6936106df9186916106e9575b507fffffffff00000000000000000000000000000000000000000000000000000000167f1626ba7e0000000000000000000000000000000000000000000000000000000014610fd9565b35906112c9565b80f35b61070b915060203d602011610711575b6107038183610ee7565b81019061103f565b38610695565b503d6106f9565b6040513d86823e3d90fd5b869193945060209260809160405191825284820152608435604082015260a435606082015282805260015afa156107d0578351168015610772576106e693949161076d9114610fd9565b6106df565b6040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526011818701527f496e76616c6964207369676e61747572650000000000000000000000000000006044820152606490fd5b6040513d85823e3d90fd5b6040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526027818a01527f4552433732315065726d69743a20617070726f76616c20746f2063757272656e60448201527f74206f776e6572000000000000000000000000000000000000000000000000006064820152608490fd5b6040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526029818b01527f455243373231203a61646472657373207a65726f206973206e6f74206120766160448201527f6c6964206f776e657200000000000000000000000000000000000000000000006064820152608490fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000885260116004528888fd5b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f5065726d697420657870697265640000000000000000000000000000000000006044820152606490fd5b5034610180576020367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101805760209060409073ffffffffffffffffffffffffffffffffffffffff6109c1610e0c565b1681527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d783522054604051908152f35b503461018057806003193601126101805760207fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d354604051908152f35b5034610180576020367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101805760209060043581527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d68252604060018060a01b0391205416604051908152f35b503461018057610aad36610e57565b60409392935191602083019483861067ffffffffffffffff871117610ae45761024694956040528584526102366102318433611103565b7f4e487b710000000000000000000000000000000000000000000000000000000085526041600452602485fd5b50346101805780600319360112610180576020610b2c610f43565b604051908152f35b503461018057806003193601126101805760206040517f49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad8152f35b5034610180576106e6610b8136610e57565b91610b8f6102318433611103565b611571565b5034610180576040367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0112610180576106e6610bcf610e0c565b602435906112c9565b5034610180576020367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0112610180576004358082527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d6602052604082205473ffffffffffffffffffffffffffffffffffffffff9190821615610c8b5782604091602094527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d88452205416604051908152f35b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f4552433732313a20696e76616c696420746f6b656e20494400000000000000006044820152606490fd5b90503461024a578160031936011261024a57817fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d492835491600183811c92818516968715610dc2575b602095868610891461047757868899878a98999a529182600014610453575050600114610d69575050506103e292500383610ee7565b8152859250907f71378b296151749ed178607cf606725b947f386eb9d5e3ed6a8549172e117d4e5b858310610daa5750506103e293508201013880806103d3565b80548389018501528794508693909201918101610d91565b93607f1693610d33565b919082519283825260005b848110610df8575050826000602080949584010152601f8019910116010190565b602081830181015184830182015201610dd7565b6004359073ffffffffffffffffffffffffffffffffffffffff82168203610e2f57565b600080fd5b6024359073ffffffffffffffffffffffffffffffffffffffff82168203610e2f57565b6060906003190112610e2f5773ffffffffffffffffffffffffffffffffffffffff906004358281168103610e2f57916024359081168103610e2f579060443590565b60c0810190811067ffffffffffffffff821117610eb557604052565b634e487b7160e01b600052604160045260246000fd5b6080810190811067ffffffffffffffff821117610eb557604052565b90601f8019910116810190811067ffffffffffffffff821117610eb557604052565b67ffffffffffffffff8111610eb557601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b60405160208101907f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f82527f000000000000000000000000000000000000000000000000000000000000000060408201527f000000000000000000000000000000000000000000000000000000000000000060608201524660808201523060a082015260a08152610fd381610e99565b51902090565b15610fe057565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f556e617574686f72697a656400000000000000000000000000000000000000006044820152606490fd5b90816020910312610e2f57517fffffffff0000000000000000000000000000000000000000000000000000000081168103610e2f5790565b1561107e57565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f4552433732313a2063616c6c6572206973206e6f7420746f6b656e206f776e6560448201527f72206f7220617070726f766564000000000000000000000000000000000000006064820152608490fd5b9073ffffffffffffffffffffffffffffffffffffffff8080611124846111f7565b169316918383149384156111b1575b508315611141575b50505090565b80919293506000527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d6602052816040600020541615610c8b576000527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d8602052604060002054161438808061113b565b9093506000527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d960205260406000208260005260205260ff604060002054169238611133565b60009081527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d6602052604090205473ffffffffffffffffffffffffffffffffffffffff1680156112445790565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f455243373231203a61646472657373207a65726f206973206e6f74206120766160448201527f6c6964206f776e657200000000000000000000000000000000000000000000006064820152608490fd5b60008281527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d86020526040902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92831690811790915590611342836111f7565b167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925600080a4565b92939290803b156114dc57936000916113c19560405180948193630a85bd0160e11b9788845233600485015260018060a01b0380921660248501526044840152608060648401528260209a8b976084830190610dcc565b0393165af1600091816114bd575b5061149657833d1561148e573d906113e682610f09565b916113f46040519384610ee7565b82523d60008284013e5b8151918261148b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260048101839052603260248201527f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560448201527f63656976657220696d706c656d656e74657200000000000000000000000000006064820152608490fd5b01fd5b6060906113fe565b7fffffffff0000000000000000000000000000000000000000000000000000000016149150565b6114d5919250853d8711610711576107038183610ee7565b90386113cf565b50600193505050565b156114ec57565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f4552433732313a207472616e736665722066726f6d20696e636f72726563742060448201527f6f776e65720000000000000000000000000000000000000000000000000000006064820152608490fd5b906115a69161157f846111f7565b73ffffffffffffffffffffffffffffffffffffffff939184169284929091831684146114e5565b169182156116a057816115c3916115bc866111f7565b16146114e5565b7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60008481527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d8602052604081206bffffffffffffffffffffffff60a01b908181541690558382527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d760205260408220600019815401905584825260408220600181540190558582527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d660205284604083209182541617905580a4565b6040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f4552433732313a207472616e7366657220746f20746865207a65726f2061646460448201527f72657373000000000000000000000000000000000000000000000000000000006064820152608490fdfea2646970667358221220093cac5b9441c92feeb816a2d33279d2abf527bc96cb5a49a6750bc5b004fdd664736f6c63430008130033",
  "devdoc": {
    "events": {
      "Approval(address,address,uint256)": {
        "details": "Emitted when `owner` enables `approved` to manage the `tokenId` token."
      },
      "ApprovalForAll(address,address,bool)": {
        "details": "Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets."
      },
      "Transfer(address,address,uint256)": {
        "details": "Emitted when `tokenId` token is transferred from `from` to `to`."
      }
    },
    "kind": "dev",
    "methods": {
      "DOMAIN_SEPARATOR()": {
        "returns": {
          "_0": "The domain seperator used in encoding of permit signature"
        }
      },
      "permit(address,uint256,uint256,uint8,bytes32,bytes32)": {
        "params": {
          "deadline": "The deadline timestamp by which the call must be mined for the approve to work",
          "r": "Must produce valid secp256k1 signature from the holder along with `v` and `s`",
          "s": "Must produce valid secp256k1 signature from the holder along with `r` and `v`",
          "spender": "The account that is being approved",
          "tokenId": "The ID of the token that is being approved for spending",
          "v": "Must produce valid secp256k1 signature from the holder along with `r` and `s`"
        }
      }
    },
    "stateVariables": {
      "PERMIT_TYPEHASH": {
        "details": "Value is equal to keccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");",
        "return": "The typehash for the permit",
        "returns": {
          "_0": "The typehash for the permit"
        }
      },
      "nameHash": {
        "details": "The hash of the name used in the permit signature verification"
      },
      "versionHash": {
        "details": "The hash of the version string used in the permit signature verification"
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "DOMAIN_SEPARATOR()": {
        "notice": "The domain separator used in the permit signature"
      },
      "PERMIT_TYPEHASH()": {
        "notice": "The permit typehash used in the permit signature"
      },
      "permit(address,uint256,uint256,uint8,bytes32,bytes32)": {
        "notice": "Approve of a specific token ID for spending by spender via signature"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}