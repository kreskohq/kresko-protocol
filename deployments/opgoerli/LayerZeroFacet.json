{
  "address": "0x47DE2c2371806f6Ca46De1758817C73a25D1EDAb",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "_hashedPayload",
          "type": "bytes32"
        }
      ],
      "name": "CreditCleared",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "_hashedPayload",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "_payload",
          "type": "bytes"
        }
      ],
      "name": "CreditStored",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint16",
          "name": "_srcChainId",
          "type": "uint16"
        },
        {
          "indexed": true,
          "internalType": "bytes",
          "name": "_srcAddress",
          "type": "bytes"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "_toAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "_tokenIds",
          "type": "uint256[]"
        }
      ],
      "name": "ReceiveFromChain",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint16",
          "name": "_dstChainId",
          "type": "uint16"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "_from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "bytes",
          "name": "_toAddress",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "_tokenIds",
          "type": "uint256[]"
        }
      ],
      "name": "SendToChain",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_payload",
          "type": "bytes"
        }
      ],
      "name": "clearCredits",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "_dstChainId",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "_toAddress",
          "type": "bytes"
        },
        {
          "internalType": "uint256[]",
          "name": "_tokenIds",
          "type": "uint256[]"
        },
        {
          "internalType": "bool",
          "name": "_useZro",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "_adapterParams",
          "type": "bytes"
        }
      ],
      "name": "estimateSendBatchFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "nativeFee",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "zroFee",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "_dstChainId",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "_toAddress",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "_useZro",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "_adapterParams",
          "type": "bytes"
        }
      ],
      "name": "estimateSendFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "nativeFee",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "zroFee",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "_srcChainId",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "_srcAddress",
          "type": "bytes"
        }
      ],
      "name": "forceResumeReceive",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "_version",
          "type": "uint16"
        },
        {
          "internalType": "uint16",
          "name": "_chainId",
          "type": "uint16"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_configType",
          "type": "uint256"
        }
      ],
      "name": "getConfig",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "_remoteChainId",
          "type": "uint16"
        }
      ],
      "name": "getTrustedRemoteAddress",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "_srcChainId",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "_srcAddress",
          "type": "bytes"
        }
      ],
      "name": "isTrustedRemote",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "_srcChainId",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "_srcAddress",
          "type": "bytes"
        },
        {
          "internalType": "uint64",
          "name": "_nonce",
          "type": "uint64"
        },
        {
          "internalType": "bytes",
          "name": "_payload",
          "type": "bytes"
        }
      ],
      "name": "lzReceive",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "_srcChainId",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "_srcAddress",
          "type": "bytes"
        },
        {
          "internalType": "uint64",
          "name": "_nonce",
          "type": "uint64"
        },
        {
          "internalType": "bytes",
          "name": "_payload",
          "type": "bytes"
        }
      ],
      "name": "nonblockingLzReceive",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "_srcChainId",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "_srcAddress",
          "type": "bytes"
        },
        {
          "internalType": "uint64",
          "name": "_nonce",
          "type": "uint64"
        },
        {
          "internalType": "bytes",
          "name": "_payload",
          "type": "bytes"
        }
      ],
      "name": "retryMessage",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_from",
          "type": "address"
        },
        {
          "internalType": "uint16",
          "name": "_dstChainId",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "_toAddress",
          "type": "bytes"
        },
        {
          "internalType": "uint256[]",
          "name": "_tokenIds",
          "type": "uint256[]"
        },
        {
          "internalType": "address payable",
          "name": "_refundAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_zroPaymentAddress",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_adapterParams",
          "type": "bytes"
        }
      ],
      "name": "sendBatchFrom",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_from",
          "type": "address"
        },
        {
          "internalType": "uint16",
          "name": "_dstChainId",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "_toAddress",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        },
        {
          "internalType": "address payable",
          "name": "_refundAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_zroPaymentAddress",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_adapterParams",
          "type": "bytes"
        }
      ],
      "name": "sendFrom",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "_version",
          "type": "uint16"
        },
        {
          "internalType": "uint16",
          "name": "_chainId",
          "type": "uint16"
        },
        {
          "internalType": "uint256",
          "name": "_configType",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_config",
          "type": "bytes"
        }
      ],
      "name": "setConfig",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "_dstChainId",
          "type": "uint16"
        },
        {
          "internalType": "uint256",
          "name": "_dstChainIdToBatchLimit",
          "type": "uint256"
        }
      ],
      "name": "setDstChainIdToBatchLimit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "_dstChainId",
          "type": "uint16"
        },
        {
          "internalType": "uint256",
          "name": "_dstChainIdToTransferGas",
          "type": "uint256"
        }
      ],
      "name": "setDstChainIdToTransferGas",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4[]",
          "name": "interfaceIds",
          "type": "bytes4[]"
        },
        {
          "internalType": "bytes4[]",
          "name": "interfaceIdsToRemove",
          "type": "bytes4[]"
        }
      ],
      "name": "setERC165",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "_dstChainId",
          "type": "uint16"
        },
        {
          "internalType": "uint16",
          "name": "_packetType",
          "type": "uint16"
        },
        {
          "internalType": "uint256",
          "name": "_minGas",
          "type": "uint256"
        }
      ],
      "name": "setMinDstGas",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_minGasToTransferAndStore",
          "type": "uint256"
        }
      ],
      "name": "setMinGasToTransferAndStore",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "_dstChainId",
          "type": "uint16"
        },
        {
          "internalType": "uint256",
          "name": "_size",
          "type": "uint256"
        }
      ],
      "name": "setPayloadSizeLimit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_precrime",
          "type": "address"
        }
      ],
      "name": "setPrecrime",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "_version",
          "type": "uint16"
        }
      ],
      "name": "setReceiveVersion",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "_version",
          "type": "uint16"
        }
      ],
      "name": "setSendVersion",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "_srcChainId",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "_path",
          "type": "bytes"
        }
      ],
      "name": "setTrustedRemote",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "_remoteChainId",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "_remoteAddress",
          "type": "bytes"
        }
      ],
      "name": "setTrustedRemoteAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_minGasToTransfer",
          "type": "uint256"
        },
        {
          "internalType": "contract ILayerZeroEndpointUpgradeable",
          "name": "_lzEndpoint",
          "type": "address"
        }
      ],
      "name": "setupLayerZero",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x42d557f3613a7dea8a54c1c4b24d42b44d47500c723ef18aeee0bccfaeaf0c06",
  "receipt": {
    "to": null,
    "from": "0xB48bB6b68Ab4D366B4f9A30eE6f7Ee55125c2D9d",
    "contractAddress": "0x47DE2c2371806f6Ca46De1758817C73a25D1EDAb",
    "transactionIndex": 7,
    "gasUsed": "3861737",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xb80984b06ac3202745447202f49d6ff03b30bde3a62e7b82adff72de948ebcef",
    "transactionHash": "0x42d557f3613a7dea8a54c1c4b24d42b44d47500c723ef18aeee0bccfaeaf0c06",
    "logs": [],
    "blockNumber": 9748859,
    "cumulativeGasUsed": "6774473",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "da64b2514f06331329702e90140ebd5b",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_hashedPayload\",\"type\":\"bytes32\"}],\"name\":\"CreditCleared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_hashedPayload\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"CreditStored\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"ReceiveFromChain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"_toAddress\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"SendToChain\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"clearCredits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_toAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"_useZro\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_adapterParams\",\"type\":\"bytes\"}],\"name\":\"estimateSendBatchFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zroFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_toAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_useZro\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_adapterParams\",\"type\":\"bytes\"}],\"name\":\"estimateSendFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zroFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"name\":\"forceResumeReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_chainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_configType\",\"type\":\"uint256\"}],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_remoteChainId\",\"type\":\"uint16\"}],\"name\":\"getTrustedRemoteAddress\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"name\":\"isTrustedRemote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"lzReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"nonblockingLzReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"retryMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_toAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address payable\",\"name\":\"_refundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_zroPaymentAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_adapterParams\",\"type\":\"bytes\"}],\"name\":\"sendBatchFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_toAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_refundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_zroPaymentAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_adapterParams\",\"type\":\"bytes\"}],\"name\":\"sendFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_chainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_configType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_config\",\"type\":\"bytes\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_dstChainIdToBatchLimit\",\"type\":\"uint256\"}],\"name\":\"setDstChainIdToBatchLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_dstChainIdToTransferGas\",\"type\":\"uint256\"}],\"name\":\"setDstChainIdToTransferGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"interfaceIds\",\"type\":\"bytes4[]\"},{\"internalType\":\"bytes4[]\",\"name\":\"interfaceIdsToRemove\",\"type\":\"bytes4[]\"}],\"name\":\"setERC165\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_packetType\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_minGas\",\"type\":\"uint256\"}],\"name\":\"setMinDstGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minGasToTransferAndStore\",\"type\":\"uint256\"}],\"name\":\"setMinGasToTransferAndStore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_size\",\"type\":\"uint256\"}],\"name\":\"setPayloadSizeLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_precrime\",\"type\":\"address\"}],\"name\":\"setPrecrime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"}],\"name\":\"setReceiveVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"}],\"name\":\"setSendVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_path\",\"type\":\"bytes\"}],\"name\":\"setTrustedRemote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_remoteChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_remoteAddress\",\"type\":\"bytes\"}],\"name\":\"setTrustedRemoteAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minGasToTransfer\",\"type\":\"uint256\"},{\"internalType\":\"contract ILayerZeroEndpointUpgradeable\",\"name\":\"_lzEndpoint\",\"type\":\"address\"}],\"name\":\"setupLayerZero\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"CreditCleared(bytes32)\":{\"details\":\"Emitted when `_hashedPayload` has been completely delivered\"},\"CreditStored(bytes32,bytes)\":{\"details\":\"Emitted when `_payload` was received from lz, but not enough gas to deliver all tokenIds\"},\"SendToChain(uint16,address,bytes,uint256[])\":{\"details\":\"Emitted when `_tokenIds[]` are moved from the `_sender` to (`_dstChainId`, `_toAddress`) `_nonce` is the outbound nonce from\"}},\"kind\":\"dev\",\"methods\":{\"estimateSendBatchFee(uint16,bytes,uint256[],bool,bytes)\":{\"details\":\"estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`) _dstChainId - L0 defined chain id to send tokens too _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain _tokenIds[] - token Ids to transfer _useZro - indicates to use zro to pay L0 fees _adapterParams - flexible bytes array to indicate messaging adapter services in L0\"},\"estimateSendFee(uint16,bytes,uint256,bool,bytes)\":{\"details\":\"estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`) _dstChainId - L0 defined chain id to send tokens too _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain _tokenId - token Id to transfer _useZro - indicates to use zro to pay L0 fees _adapterParams - flexible bytes array to indicate messaging adapter services in L0\"},\"sendBatchFrom(address,uint16,bytes,uint256[],address,address,bytes)\":{\"details\":\"send tokens `_tokenIds[]` to (`_dstChainId`, `_toAddress`) from `_from` `_toAddress` can be any size depending on the `dstChainId`. `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token) `_adapterParams` is a flexible bytes array to indicate messaging adapter services\"},\"sendFrom(address,uint16,bytes,uint256,address,address,bytes)\":{\"details\":\"send token `_tokenId` to (`_dstChainId`, `_toAddress`) from `_from` `_toAddress` can be any size depending on the `dstChainId`. `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token) `_adapterParams` is a flexible bytes array to indicate messaging adapter services\"},\"setERC165(bytes4[],bytes4[])\":{\"params\":{\"interfaceIds\":\"list of interface id to set as supported\",\"interfaceIdsToRemove\":\"list of interface id to unset as supported. Technically, you can remove support of ERC165 by having the IERC165 id itself being part of that array.\"}},\"supportsInterface(bytes4)\":{\"details\":\"Interface identification is specified in ERC-165. This function  uses less than 30,000 gas.\",\"params\":{\"interfaceId\":\"The interface identifier, as specified in ERC-165\"},\"returns\":{\"_0\":\"`true` if the contract implements `interfaceID` and  `interfaceID` is not 0xffffffff, `false` otherwise\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"setERC165(bytes4[],bytes4[])\":{\"notice\":\"set or unset ERC165 using DiamondStorage.supportedInterfaces\"},\"supportsInterface(bytes4)\":{\"notice\":\"Query if a contract implements an interface\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/contracts/minter/collateral-pool/position/facets/LayerZeroFacet.sol\":\"LayerZeroFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"details\":{\"constantOptimizer\":false,\"cse\":true,\"deduplicate\":true,\"inliner\":true,\"jumpdestRemover\":true,\"orderLiterals\":true,\"peephole\":true,\"yul\":true,\"yulDetails\":{\"optimizerSteps\":\"dhfoDgvulfnTUtnIf[xa[r]EscLMcCTUtTOntnfDIulLculVcul [j]Tpeulxa[rul]xa[r]cLgvifCTUca[r]LSsTFOtfDnca[r]Iulc]jmul[jul] VcTOcul jmul:fDnTOc\",\"stackAllocation\":true}},\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlUpgradeable.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\\n */\\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x7acbc538aad6eb4614e26612a8c5c0149bb8808db95e2638d245a8365f63e572\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\",\"keccak256\":\"0xb8f5302f12138c5561362e88a78d061573e6298b7a1a5afe84a1e2c8d4d5aeaa\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x037c334add4b033ad3493038c25be1682d78c00992e1acb0e2795caff3925271\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xbb2ed8106d94aeae6858e2551a1e7174df73994b77b13ebd120ccaaef80155f5\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x2c0b89cef83f353c6f9488c013d8a5968587ffdd6dfc26aad53774214b97e229\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x95a471796eb5f030fdc438660bebec121ad5d063763e64d92376ffb4b5ce8b70\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2edcb41c121abc510932e8d83ff8b82cf9cdde35e7c297622f5c29ef0af25183\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/MathUpgradeable.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = MathUpgradeable.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0x6b9a5d35b744b25529a2856a8093e7c03fb35a34b1c4fb5499e560f8ade140da\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x9a3b990bd56d139df3e454a9edf1c64668530b5a77fc32eb063bc206f958274a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xc6cef87559d0aeffdf0a99803de655938a7779ec0a3cd5d4383483ad85565a09\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc1bd5b53319c68f84e3becd75694d941e8f4be94049903232cd8bc7c535aaa5a\",\"license\":\"MIT\"},\"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            // Start off with z at 1.\\n            z := 1\\n\\n            // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n            // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z) // Like multiplying by 2 ** 64.\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z) // Like multiplying by 2 ** 32.\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z) // Like multiplying by 2 ** 16.\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z) // Like multiplying by 2 ** 8.\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z) // Like multiplying by 2 ** 4.\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z) // Like multiplying by 2 ** 2.\\n            }\\n            if iszero(lt(y, 0x8)) {\\n                // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n            // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x96ab2a92fbac88a704270b039691afb363c5a1ef1170fb0c955043e4da84b987\",\"license\":\"AGPL-3.0-only\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x60b0215121bf25612a6739fb2f1ec35f31ee82e4a8216c032c8243d904ab3aa9\",\"license\":\"MIT\"},\"src/contracts/diamond/DiamondModifiers.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {Authorization, Role} from \\\"../libs/Authorization.sol\\\";\\nimport {Meta} from \\\"../libs/Meta.sol\\\";\\nimport {Error} from \\\"../libs/Errors.sol\\\";\\n\\nimport {Action} from \\\"../minter/MinterTypes.sol\\\";\\nimport {ms} from \\\"../minter/MinterStorage.sol\\\";\\n\\nimport {ENTERED, NOT_ENTERED} from \\\"../diamond/DiamondTypes.sol\\\";\\nimport {ds} from \\\"../diamond/DiamondStorage.sol\\\";\\n\\nabstract contract DiamondModifiers {\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^Authorization: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        Authorization.checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @notice Ensure only trusted contracts can act on behalf of `_account`\\n     * @param _accountIsNotMsgSender The address of the collateral asset.\\n     */\\n    modifier onlyRoleIf(bool _accountIsNotMsgSender, bytes32 role) {\\n        if (_accountIsNotMsgSender) {\\n            Authorization.checkRole(role);\\n        }\\n        _;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(Meta.msgSender() == ds().contractOwner, Error.DIAMOND_INVALID_OWNER);\\n        _;\\n    }\\n\\n    modifier onlyPendingOwner() {\\n        require(Meta.msgSender() == ds().pendingOwner, Error.DIAMOND_INVALID_PENDING_OWNER);\\n        _;\\n    }\\n\\n    modifier nonReentrant() {\\n        require(ds().entered == NOT_ENTERED, Error.RE_ENTRANCY);\\n        ds().entered = ENTERED;\\n        _;\\n        ds().entered = NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0xe9e63cdb6f1b6430066e8f761294217a6e02d1f6b5cd2d2bebf86070eb6d0d99\",\"license\":\"BUSL-1.1\"},\"src/contracts/diamond/DiamondState.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {EnumerableSet} from \\\"../libs/EnumerableSet.sol\\\";\\nimport {FacetAddressAndPosition, FacetFunctionSelectors, RoleData, ENTERED, NOT_ENTERED} from \\\"./DiamondTypes.sol\\\";\\n\\nimport {LibDiamondCut} from \\\"./libs/LibDiamondCut.sol\\\";\\nimport {LibOwnership} from \\\"./libs/LibOwnership.sol\\\";\\n\\nusing LibDiamondCut for DiamondState global;\\nusing LibOwnership for DiamondState global;\\n\\n/* -------------------------------------------------------------------------- */\\n/*                                 Main Layout                                */\\n/* -------------------------------------------------------------------------- */\\n\\nstruct DiamondState {\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   Proxy                                    */\\n    /* -------------------------------------------------------------------------- */\\n    /// @notice Maps function selector to the facet address and\\n    /// the position of the selector in the facetFunctionSelectors.selectors array\\n    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n    /// @notice Maps facet addresses to function selectors\\n    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n    /// @notice Facet addresses\\n    address[] facetAddresses;\\n    /// @notice ERC165 query implementation\\n    mapping(bytes4 => bool) supportedInterfaces;\\n    /* -------------------------------------------------------------------------- */\\n    /*                               Initialization                               */\\n    /* -------------------------------------------------------------------------- */\\n    /// @notice Initialization status\\n    bool initialized;\\n    /// @notice Domain field separator\\n    bytes32 domainSeparator;\\n    /* -------------------------------------------------------------------------- */\\n    /*                                  Ownership                                 */\\n    /* -------------------------------------------------------------------------- */\\n    /// @notice Current owner of the diamond\\n    address contractOwner;\\n    /// @notice Pending new diamond owner\\n    address pendingOwner;\\n    /// @notice Storage version\\n    uint8 storageVersion;\\n    /// @notice address(this) replacement for FF\\n    address self;\\n    /* -------------------------------------------------------------------------- */\\n    /*                               Access Control                               */\\n    /* -------------------------------------------------------------------------- */\\n    mapping(bytes32 => RoleData) _roles;\\n    mapping(bytes32 => EnumerableSet.AddressSet) _roleMembers;\\n    /* -------------------------------------------------------------------------- */\\n    /*                                 Reentrancy                                 */\\n    /* -------------------------------------------------------------------------- */\\n    uint256 entered;\\n}\\n\",\"keccak256\":\"0x8a9c805aab7a471834ccd992881a32976b5e2a03de8fd8f50dd8d2d1f56db8b1\",\"license\":\"BUSL-1.1\"},\"src/contracts/diamond/DiamondStorage.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n/* solhint-disable no-inline-assembly */\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable func-visibility */\\n\\npragma solidity >=0.8.19;\\n\\nimport {DiamondState} from \\\"./DiamondState.sol\\\";\\n\\n// Storage position\\nbytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"kresko.diamond.storage\\\");\\n\\nfunction ds() pure returns (DiamondState storage state) {\\n    bytes32 position = DIAMOND_STORAGE_POSITION;\\n    assembly {\\n        state.slot := position\\n    }\\n}\\n\",\"keccak256\":\"0xe614f2b675f68dd7a27e301941000a0a9820ab80cc7e2b262917e5a42d30251a\",\"license\":\"BUSL-1.1\"},\"src/contracts/diamond/DiamondTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n/// @dev set the initial value to 1 as we do not\\n/// wanna hinder possible gas refunds by setting it to 0 on exit.\\n\\n/* -------------------------------------------------------------------------- */\\n/*                                 Reentrancy                                 */\\n/* -------------------------------------------------------------------------- */\\nuint256 constant NOT_ENTERED = 1;\\nuint256 constant ENTERED = 2;\\n\\n/* ========================================================================== */\\n/*                                   STRUCTS                                  */\\n/* ========================================================================== */\\n\\nstruct FacetAddressAndPosition {\\n    address facetAddress;\\n    // position in facetFunctionSelectors.functionSelectors array\\n    uint96 functionSelectorPosition;\\n}\\n\\nstruct FacetFunctionSelectors {\\n    bytes4[] functionSelectors;\\n    // position of facetAddress in facetAddresses array\\n    uint256 facetAddressPosition;\\n}\\n\\nstruct RoleData {\\n    mapping(address => bool) members;\\n    bytes32 adminRole;\\n}\\n\",\"keccak256\":\"0x3ab1de13ae0bc6504ead22cbfba14484a2fce79bdd0a2494b00b594615b944a5\",\"license\":\"BUSL-1.1\"},\"src/contracts/diamond/interfaces/IAuthorizationFacet.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\ninterface IAuthorizationFacet {\\n    /**\\n     * @dev OpenZeppelin\\n     * Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * @notice WARNING:\\n     * When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block.\\n     *\\n     * See the following forum post for more information:\\n     * - https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296\\n     *\\n     * @dev Kresko\\n     *\\n     * TL;DR above:\\n     *\\n     * - If you iterate the EnumSet outside a single block scope you might get different results.\\n     * - Since when EnumSet member is deleted it is replaced with the highest index.\\n     * @return address with the `role`\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     * @notice See warning in {getRoleMember} if combining these two\\n     */\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * @notice To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Returns true if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * @notice Requirements\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * @notice Requirements\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n}\\n\",\"keccak256\":\"0x42e06a216165d7c4e017cf802487116edf3f70f2f7dd20c62587a33519936f64\",\"license\":\"BUSL-1.1\"},\"src/contracts/diamond/interfaces/IDiamondCutFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\nimport {DiamondEvent} from \\\"../../libs/Events.sol\\\";\\n\\ninterface IDiamondCutFacet {\\n    /// @dev  Add=0, Replace=1, Remove=2\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /**\\n     *@notice Add/replace/remove any number of functions, optionally execute a function with delegatecall\\n     * @param _diamondCut Contains the facet addresses and function selectors\\n     * @param _init The address of the contract or facet to execute _calldata\\n     * @param _calldata A function call, including function selector and arguments\\n     *                  _calldata is executed with delegatecall on _init\\n     */\\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\\n\\n    /**\\n     * @notice Use an initializer contract without doing modifications\\n     * @param _init The address of the contract or facet to execute _calldata\\n     * @param _calldata A function call, including function selector and arguments\\n     * - _calldata is executed with delegatecall on _init\\n     */\\n    function upgradeState(address _init, bytes calldata _calldata) external;\\n}\\n\",\"keccak256\":\"0x4a1102f4dc50aecbf6d5c20d685466e44df60150bb6b91a3650bfe0fe1863193\",\"license\":\"MIT\"},\"src/contracts/diamond/interfaces/IDiamondLoupeFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupeFacet {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\",\"keccak256\":\"0x88d99e8bb186ba6bceb110ab7e6a639a8dc9066385aa7fe2a8fe963ac2ca1394\",\"license\":\"MIT\"},\"src/contracts/diamond/interfaces/IDiamondOwnershipFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\n/// @title Contract Ownership\\ninterface IDiamondOwnershipFacet {\\n    /**\\n     * @notice Get the address of the owner\\n     * @return owner_ The address of the owner.\\n     */\\n    function owner() external view returns (address owner_);\\n\\n    /**\\n     * @notice Get the address of pending owner\\n     * @return pendingOwner_ The address of the pending owner.\\n     **/\\n    function pendingOwner() external view returns (address pendingOwner_);\\n\\n    /**\\n     * @notice Initiate ownership transfer to a new address\\n     * @notice caller must be the current contract owner\\n     * @notice the new owner cannot be address(0)\\n     * @notice emits a {AuthEvent.PendingOwnershipTransfer} event\\n     * @param _newOwner address that is set as the pending new owner\\n     */\\n    function transferOwnership(address _newOwner) external;\\n\\n    /**\\n     * @notice Transfer the ownership to the new pending owner\\n     * @notice caller must be the pending owner\\n     * @notice emits a {AuthEvent.OwnershipTransferred} event\\n     */\\n    function acceptOwnership() external;\\n\\n    /**\\n     * @notice Check if the contract is initialized\\n     * @return initialized_ bool True if the contract is initialized, false otherwise.\\n     */\\n    function initialized() external view returns (bool initialized_);\\n}\\n\",\"keccak256\":\"0xf456be7eb02028cd24ca4253ae4fc77743037bda1d98f35e0d861294e1c25420\",\"license\":\"MIT\"},\"src/contracts/diamond/interfaces/IERC165Facet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\nimport {DiamondEvent} from \\\"../../libs/Events.sol\\\";\\n\\ninterface IERC165Facet {\\n    /**\\n     * @notice Query if a contract implements an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @dev Interface identification is specified in ERC-165. This function\\n     *  uses less than 30,000 gas.\\n     * @return `true` if the contract implements `interfaceID` and\\n     *  `interfaceID` is not 0xffffffff, `false` otherwise\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    /**\\n     * @notice set or unset ERC165 using DiamondStorage.supportedInterfaces\\n     * @param interfaceIds list of interface id to set as supported\\n     * @param interfaceIdsToRemove list of interface id to unset as supported.\\n     * Technically, you can remove support of ERC165 by having the IERC165 id itself being part of that array.\\n     */\\n    function setERC165(bytes4[] calldata interfaceIds, bytes4[] calldata interfaceIdsToRemove) external;\\n}\\n\",\"keccak256\":\"0xbf9b349df8db7e0ed3cfdfdad7106b72f865d3942f2e030bfa0179766e9a7f5c\",\"license\":\"MIT\"},\"src/contracts/diamond/libs/LibDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\nimport {IDiamondCutFacet} from \\\"../interfaces/IDiamondCutFacet.sol\\\";\\n\\nimport {Meta} from \\\"../../libs/Meta.sol\\\";\\nimport {DiamondEvent} from \\\"../../libs/Events.sol\\\";\\nimport {DiamondState} from \\\"../DiamondState.sol\\\";\\n\\n// solhint-disable-next-line func-visibility\\nfunction initializeDiamondCut(address _init, bytes memory _calldata) {\\n    if (_init == address(0)) {\\n        require(_calldata.length == 0, \\\"DiamondCut: _init is address(0) but_calldata is not empty\\\");\\n    } else {\\n        require(_calldata.length > 0, \\\"DiamondCut: _calldata is empty but _init is not address(0)\\\");\\n        Meta.enforceHasContractCode(_init, \\\"DiamondCut: _init address has no code\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n        if (!success) {\\n            if (error.length > 0) {\\n                // bubble up the error\\n                revert(string(error));\\n            } else {\\n                revert(\\\"DiamondCut: _init function reverted\\\");\\n            }\\n        }\\n    }\\n}\\n\\nlibrary LibDiamondCut {\\n    /* -------------------------------------------------------------------------- */\\n    /*                              Diamond Functions                             */\\n    /* -------------------------------------------------------------------------- */\\n\\n    function diamondCut(\\n        DiamondState storage self,\\n        IDiamondCutFacet.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCutFacet.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCutFacet.FacetCutAction.Add) {\\n                self.addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCutFacet.FacetCutAction.Replace) {\\n                self.replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCutFacet.FacetCutAction.Remove) {\\n                self.removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"DiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondEvent.DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(\\n        DiamondState storage self,\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        require(_functionSelectors.length > 0, \\\"DiamondCut: No selectors in facet to cut\\\");\\n        require(_facetAddress != address(0), \\\"DiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(self.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            self.addFacet(_facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = self.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"DiamondCut: Can't add function that already exists\\\");\\n            self.addFunction(selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(\\n        DiamondState storage self,\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        require(_functionSelectors.length > 0, \\\"DiamondCut: No selectors in facet to cut\\\");\\n        require(_facetAddress != address(0), \\\"DiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(self.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            self.addFacet(_facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = self.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"DiamondCut: Can't replace function with same function\\\");\\n            self.removeFunction(oldFacetAddress, selector);\\n            self.addFunction(selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(\\n        DiamondState storage self,\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        require(_functionSelectors.length > 0, \\\"DiamondCut: No selectors in facet to cut\\\");\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"DiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = self.selectorToFacetAndPosition[selector].facetAddress;\\n            self.removeFunction(oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondState storage self, address _facetAddress) internal {\\n        Meta.enforceHasContractCode(_facetAddress, \\\"DiamondCut: New facet has no code\\\");\\n        self.facetFunctionSelectors[_facetAddress].facetAddressPosition = self.facetAddresses.length;\\n        self.facetAddresses.push(_facetAddress);\\n    }\\n\\n    function addFunction(\\n        DiamondState storage self,\\n        bytes4 _selector,\\n        uint96 _selectorPosition,\\n        address _facetAddress\\n    ) internal {\\n        self.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        self.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        self.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondState storage self, address _facetAddress, bytes4 _selector) internal {\\n        require(_facetAddress != address(0), \\\"DiamondCut: Can't remove function that doesn't exist\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = self.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = self.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = self.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            self.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            self.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        self.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete self.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = self.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = self.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = self.facetAddresses[lastFacetAddressPosition];\\n                self.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                self.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            self.facetAddresses.pop();\\n            delete self.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8897fe35db2485e9f7551798c8c354b038e53bd30f8e30429c584097f3772735\",\"license\":\"MIT\"},\"src/contracts/diamond/libs/LibOwnership.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport {IERC165} from \\\"../../shared/IERC165.sol\\\";\\nimport {IDiamondCutFacet} from \\\"../interfaces/IDiamondCutFacet.sol\\\";\\nimport {IDiamondLoupeFacet} from \\\"../interfaces/IDiamondLoupeFacet.sol\\\";\\nimport {IDiamondOwnershipFacet} from \\\"../interfaces/IDiamondOwnershipFacet.sol\\\";\\nimport {IAuthorizationFacet} from \\\"../interfaces/IAuthorizationFacet.sol\\\";\\n\\nimport {GeneralEvent, AuthEvent} from \\\"../../libs/Events.sol\\\";\\nimport {Error} from \\\"../../libs/Errors.sol\\\";\\nimport {Meta} from \\\"../../libs/Meta.sol\\\";\\n\\nimport {NOT_ENTERED} from \\\"../DiamondTypes.sol\\\";\\nimport {DiamondState} from \\\"../DiamondState.sol\\\";\\n\\nlibrary LibOwnership {\\n    /* -------------------------------------------------------------------------- */\\n    /*                         Initialization & Ownership                         */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @notice Ownership initializer\\n    /// @notice Only called on the first deployment\\n    function initialize(DiamondState storage self, address _owner) internal {\\n        require(!self.initialized, Error.ALREADY_INITIALIZED);\\n        self.entered = NOT_ENTERED;\\n        self.initialized = true;\\n        self.storageVersion++;\\n        self.contractOwner = _owner;\\n\\n        self.supportedInterfaces[type(IDiamondLoupeFacet).interfaceId] = true;\\n        self.supportedInterfaces[type(IERC165).interfaceId] = true;\\n        self.supportedInterfaces[type(IDiamondCutFacet).interfaceId] = true;\\n        self.supportedInterfaces[type(IDiamondOwnershipFacet).interfaceId] = true;\\n        self.supportedInterfaces[type(IAuthorizationFacet).interfaceId] = true;\\n\\n        emit GeneralEvent.Deployed(_owner, self.storageVersion);\\n        emit AuthEvent.OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Initiate ownership transfer to a new address\\n     * @param _newOwner address that is set as the pending new owner\\n     * @notice caller must be the current contract owner\\n     */\\n    function initiateOwnershipTransfer(DiamondState storage self, address _newOwner) internal {\\n        require(Meta.msgSender() == self.contractOwner, Error.DIAMOND_INVALID_OWNER);\\n        require(_newOwner != address(0), \\\"DS: Owner cannot be 0-address\\\");\\n\\n        self.pendingOwner = _newOwner;\\n\\n        emit AuthEvent.PendingOwnershipTransfer(self.contractOwner, _newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfer the ownership to the new pending owner\\n     * @notice caller must be the pending owner\\n     */\\n    function finalizeOwnershipTransfer(DiamondState storage self) internal {\\n        address sender = Meta.msgSender();\\n        require(sender == self.pendingOwner, Error.DIAMOND_INVALID_PENDING_OWNER);\\n        self.contractOwner = self.pendingOwner;\\n        self.pendingOwner = address(0);\\n\\n        emit AuthEvent.OwnershipTransferred(self.contractOwner, sender);\\n    }\\n}\\n\",\"keccak256\":\"0x7ef862d36f9bdf2a3f3f379f40f2c6db76e17caa5e3d11aa4209162e56a93c17\",\"license\":\"MIT\"},\"src/contracts/kreskoasset/IERC4626Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.19;\\n\\nimport {IKreskoAsset} from \\\"./IKreskoAsset.sol\\\";\\n\\ninterface IERC4626Upgradeable {\\n    /**\\n     * @notice The underlying Kresko Asset\\n     */\\n    function asset() external view returns (IKreskoAsset);\\n\\n    /**\\n     * @notice Deposit KreskoAssets for equivalent amount of anchor tokens\\n     * @param assets Amount of KreskoAssets to deposit\\n     * @param receiver Address to send shares to\\n     * @return shares Amount of shares minted\\n     */\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n\\n    /**\\n     * @notice Withdraw KreskoAssets for equivalent amount of anchor tokens\\n     * @param assets Amount of KreskoAssets to withdraw\\n     * @param receiver Address to send KreskoAssets to\\n     * @param owner Address to burn shares from\\n     * @return shares Amount of shares burned\\n     * @dev shares are burned from owner, not msg.sender\\n     */\\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\\n\\n    function maxDeposit(address) external view returns (uint256);\\n\\n    function maxMint(address) external view returns (uint256 assets);\\n\\n    function maxRedeem(address owner) external view returns (uint256 assets);\\n\\n    function maxWithdraw(address owner) external view returns (uint256 assets);\\n\\n    /**\\n     * @notice Mint shares of anchor tokens for equivalent amount of KreskoAssets\\n     * @param shares Amount of shares to mint\\n     * @param receiver Address to send shares to\\n     * @return assets Amount of KreskoAssets redeemed\\n     */\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\\n\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @notice Track the underlying amount\\n     * @return Total supply for the underlying\\n     */\\n    function totalAssets() external view returns (uint256);\\n\\n    /**\\n     * @notice Redeem shares of anchor for KreskoAssets\\n     * @param shares Amount of shares to redeem\\n     * @param receiver Address to send KreskoAssets to\\n     * @param owner Address to burn shares from\\n     * @return assets Amount of KreskoAssets redeemed\\n     */\\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\\n}\\n\",\"keccak256\":\"0xdf7c2b3274b00db9981933ce1a47fba69de716bcee67d92bb72e9dae0ec3dadc\",\"license\":\"AGPL-3.0-only\"},\"src/contracts/kreskoasset/IKreskoAsset.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {IAccessControlEnumerableUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\\\";\\nimport {IERC20Permit} from \\\"../shared/IERC20Permit.sol\\\";\\nimport {IERC165} from \\\"../shared/IERC165.sol\\\";\\n\\ninterface IKreskoAsset is IERC20Permit, IAccessControlEnumerableUpgradeable, IERC165 {\\n    /**\\n     * @notice Rebase information\\n     * @param positive supply increasing/reducing rebase\\n     * @param denominator the denumerator for the operator, 1 ether = 1\\n     */\\n    struct Rebase {\\n        bool positive;\\n        uint256 denominator;\\n    }\\n\\n    /**\\n     * @notice Initializes a KreskoAsset ERC20 token.\\n     * @dev Intended to be operated by the Kresko smart contract.\\n     * @param _name The name of the KreskoAsset.\\n     * @param _symbol The symbol of the KreskoAsset.\\n     * @param _decimals Decimals for the asset.\\n     * @param _admin The adminstrator of this contract.\\n     * @param _kresko The protocol, can perform mint and burn.\\n     */\\n    function initialize(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals,\\n        address _admin,\\n        address _kresko\\n    ) external;\\n\\n    function kresko() external view returns (address);\\n\\n    function rebaseInfo() external view returns (Rebase memory);\\n\\n    function isRebased() external view returns (bool);\\n\\n    /**\\n     * @notice Perform a rebase, changing the denumerator and its operator\\n     * @param _denominator the denumerator for the operator, 1 ether = 1\\n     * @param _positive supply increasing/reducing rebase\\n     * @param _pools UniswapV2Pair address to sync so we wont get rekt by skim() calls.\\n     * @dev denumerator values 0 and 1 ether will disable the rebase\\n     */\\n    function rebase(uint256 _denominator, bool _positive, address[] calldata _pools) external;\\n\\n    /**\\n     * @notice Updates ERC20 metadata for the token in case eg. a ticker change\\n     * @param _name new name for the asset\\n     * @param _symbol new symbol for the asset\\n     * @param _version number that must be greater than latest emitted `Initialized` version\\n     */\\n    function reinitializeERC20(string memory _name, string memory _symbol, uint8 _version) external;\\n\\n    /**\\n     * @notice Returns the total supply of the token.\\n     * @notice This amount is adjusted by rebases.\\n     * @inheritdoc IERC20Permit\\n     */\\n    function totalSupply() external view override(IERC20Permit) returns (uint256);\\n\\n    /**\\n     * @notice Returns the balance of @param _account\\n     * @notice This amount is adjusted by rebases.\\n     * @inheritdoc IERC20Permit\\n     */\\n    function balanceOf(address _account) external view override(IERC20Permit) returns (uint256);\\n\\n    /// @inheritdoc IERC20Permit\\n    function allowance(address _owner, address _account) external view override(IERC20Permit) returns (uint256);\\n\\n    /// @inheritdoc IERC20Permit\\n    function approve(address spender, uint256 amount) external override returns (bool);\\n\\n    /// @inheritdoc IERC20Permit\\n    function transfer(address _to, uint256 _amount) external override(IERC20Permit) returns (bool);\\n\\n    /// @inheritdoc IERC20Permit\\n    function transferFrom(address _from, address _to, uint256 _amount) external override(IERC20Permit) returns (bool);\\n\\n    /**\\n     * @notice Mints tokens to an address.\\n     * @dev Only callable by operator.\\n     * @dev Internal balances are always unrebased, events emitted are not.\\n     * @param _to The address to mint tokens to.\\n     * @param _amount The amount of tokens to mint.\\n     */\\n    function mint(address _to, uint256 _amount) external;\\n\\n    /**\\n     * @notice Burns tokens from an address.\\n     * @dev Only callable by operator.\\n     * @dev Internal balances are always unrebased, events emitted are not.\\n     * @param _from The address to burn tokens from.\\n     * @param _amount The amount of tokens to burn.\\n     */\\n    function burn(address _from, uint256 _amount) external;\\n}\\n\",\"keccak256\":\"0x67a5d95257fe396a6b60412f395b0abfc150c14c7f86e96289b830cc2fd597fe\",\"license\":\"BUSL-1.1\"},\"src/contracts/kreskoasset/IKreskoAssetAnchor.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {IAccessControlEnumerableUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\\\";\\nimport {IERC165} from \\\"../shared/IERC165.sol\\\";\\nimport {IERC20Permit} from \\\"../shared/IERC20Permit.sol\\\";\\nimport {IKreskoAssetIssuer} from \\\"./IKreskoAssetIssuer.sol\\\";\\nimport {IKreskoAsset} from \\\"./IKreskoAsset.sol\\\";\\nimport {IERC4626Upgradeable} from \\\"./IERC4626Upgradeable.sol\\\";\\n\\ninterface IKreskoAssetAnchor is\\n    IKreskoAssetIssuer,\\n    IERC4626Upgradeable,\\n    IERC20Permit,\\n    IAccessControlEnumerableUpgradeable,\\n    IERC165\\n{\\n    function totalAssets() external view override(IERC4626Upgradeable) returns (uint256);\\n\\n    /**\\n     * @notice Initializes the Kresko Asset Anchor.\\n     *\\n     * @param _asset The underlying (Kresko) Asset\\n     * @param _name Name of the anchor token\\n     * @param _symbol Symbol of the anchor token\\n     * @param _admin The adminstrator of this contract.\\n     * @dev Decimals are not supplied as they are read from the underlying Kresko Asset\\n     */\\n    function initialize(IKreskoAsset _asset, string memory _name, string memory _symbol, address _admin) external;\\n\\n    /**\\n     * @notice Updates ERC20 metadata for the token in case eg. a ticker change\\n     * @param _name new name for the asset\\n     * @param _symbol new symbol for the asset\\n     * @param _version number that must be greater than latest emitted `Initialized` version\\n     */\\n    function reinitializeERC20(string memory _name, string memory _symbol, uint8 _version) external;\\n}\\n\",\"keccak256\":\"0x73d8fcfc54759a7e8c1eed4e00e22760f2c04757a33f12339232afb8e747a8a1\",\"license\":\"BUSL-1.1\"},\"src/contracts/kreskoasset/IKreskoAssetIssuer.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n/// @title KreskoAsset issuer interface\\n/// @author Kresko\\n/// @notice Contract that can issue/destroy Kresko Assets through Kresko\\n/// @dev This interface is used by KISS & KreskoAssetAnchor\\ninterface IKreskoAssetIssuer {\\n    /**\\n     * @notice Mints @param _assets of krAssets for @param _to,\\n     * @notice Mints relative @return _shares of wkrAssets\\n     */\\n    function issue(uint256 _assets, address _to) external returns (uint256 shares);\\n\\n    /**\\n     * @notice Burns @param _assets of krAssets from @param _from,\\n     * @notice Burns relative @return _shares of wkrAssets\\n     */\\n    function destroy(uint256 _assets, address _from) external returns (uint256 shares);\\n\\n    /**\\n     * @notice Returns the total amount of anchor tokens out\\n     */\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @notice Returns the total amount of krAssets out\\n     */\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n}\\n\",\"keccak256\":\"0x623d38271ac967e40374d7fb7f0bafe887a6b80ec65a5a02150675c1fc85d18c\",\"license\":\"BUSL-1.1\"},\"src/contracts/kreskoasset/Rebase.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\nimport {FixedPointMathLib} from \\\"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {IKreskoAsset} from \\\"../kreskoasset/IKreskoAsset.sol\\\";\\n\\nlibrary RebaseMath {\\n    using FixedPointMathLib for uint256;\\n\\n    /**\\n     * @notice Unrebase a value by a given rebase struct.\\n     * @param self The value to unrebase.\\n     * @param _rebase The rebase struct.\\n     * @return The unrebased value.\\n     */\\n    function unrebase(uint256 self, IKreskoAsset.Rebase memory _rebase) internal pure returns (uint256) {\\n        if (_rebase.denominator == 0) return self;\\n        return _rebase.positive ? self.divWadDown(_rebase.denominator) : self.mulWadDown(_rebase.denominator);\\n    }\\n\\n    /**\\n     * @notice Rebase a value by a given rebase struct.\\n     * @param self The value to rebase.\\n     * @param _rebase The rebase struct.\\n     * @return The rebased value.\\n     */\\n    function rebase(uint256 self, IKreskoAsset.Rebase memory _rebase) internal pure returns (uint256) {\\n        if (_rebase.denominator == 0) return self;\\n        return _rebase.positive ? self.mulWadDown(_rebase.denominator) : self.divWadDown(_rebase.denominator);\\n    }\\n}\\n\",\"keccak256\":\"0xf981ad23fd87634a6da3089d58cee01cd81da20aceee12963daab307a28a1ad1\",\"license\":\"BUSL-1.1\"},\"src/contracts/libs/Arrays.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.19;\\n\\nimport {Error} from \\\"./Errors.sol\\\";\\n\\n/**\\n * @title Library for operations on arrays\\n */\\nlibrary Arrays {\\n    /**\\n     * @dev Removes an element by copying the last element to the element to remove's place and removing\\n     * the last element.\\n     * @param _addresses The address array containing the item to be removed.\\n     * @param _elementToRemove The element to be removed.\\n     * @param _elementIndex The index of the element to be removed.\\n     */\\n    function removeAddress(address[] storage _addresses, address _elementToRemove, uint256 _elementIndex) internal {\\n        require(_addresses[_elementIndex] == _elementToRemove, Error.ARRAY_OUT_OF_BOUNDS);\\n\\n        uint256 lastIndex = _addresses.length - 1;\\n        // If the index to remove is not the last one, overwrite the element at the index\\n        // with the last element.\\n        if (_elementIndex != lastIndex) {\\n            _addresses[_elementIndex] = _addresses[lastIndex];\\n        }\\n        // Remove the last element.\\n        _addresses.pop();\\n    }\\n}\\n\",\"keccak256\":\"0xeefdf188ef12b77fe9c53cc86d064937aa643e90563daaf475a30ae1c80f2afd\",\"license\":\"AGPL-3.0-only\"},\"src/contracts/libs/Authorization.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.19;\\n\\nimport {IGnosisSafeL2} from \\\"../vendor/gnosis/IGnosisSafeL2.sol\\\";\\nimport {Strings} from \\\"./Strings.sol\\\";\\nimport {AuthEvent} from \\\"./Events.sol\\\";\\nimport {EnumerableSet} from \\\"./EnumerableSet.sol\\\";\\nimport {Error} from \\\"./Errors.sol\\\";\\nimport {Meta} from \\\"./Meta.sol\\\";\\nimport {ds} from \\\"../diamond/DiamondStorage.sol\\\";\\n\\n/* solhint-disable state-visibility */\\n\\n/**\\n * @title Shared library for access control\\n * @author Kresko\\n */\\n\\n/* -------------------------------------------------------------------------- */\\n/*                                    Roles                                   */\\n/* -------------------------------------------------------------------------- */\\n\\nlibrary Role {\\n    /// @dev role that grants other roles\\n    bytes32 constant DEFAULT_ADMIN = 0x00;\\n    /// @dev  keccak256(\\\"kresko.roles.minter.admin\\\")\\n    bytes32 constant ADMIN = 0xb9dacdf02281f2e98ddbadaaf44db270b3d5a916342df47c59f77937a6bcd5d8;\\n    /// @dev keccak256(\\\"kresko.roles.minter.operator\\\")\\n    bytes32 constant OPERATOR = 0x112e48a576fb3a75acc75d9fcf6e0bc670b27b1dbcd2463502e10e68cf57d6fd;\\n    /// @dev keccak256(\\\"kresko.roles.minter.manager\\\")\\n    bytes32 constant MANAGER = 0x46925e0f0cc76e485772167edccb8dc449d43b23b55fc4e756b063f49099e6a0;\\n    /// @dev keccak256(\\\"kresko.roles.minter.safety.council\\\")\\n    bytes32 constant SAFETY_COUNCIL = 0x9c387ecf1663f9144595993e2c602b45de94bf8ba3a110cb30e3652d79b581c0;\\n}\\n\\nlibrary Authorization {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    function hasRole(bytes32 role, address account) internal view returns (bool) {\\n        return ds()._roles[role].members[account];\\n    }\\n\\n    function getRoleMemberCount(bytes32 role) internal view returns (uint256) {\\n        return ds()._roleMembers[role].length();\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `Meta.msgSender` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function checkRole(bytes32 role) internal view {\\n        _checkRole(role, Meta.msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) internal view returns (bytes32) {\\n        return ds()._roles[role].adminRole;\\n    }\\n\\n    function getRoleMember(bytes32 role, uint256 index) internal view returns (address) {\\n        return ds()._roleMembers[role].at(index);\\n    }\\n\\n    /**\\n     * @notice Checks if the target contract implements the ERC165 interfaceId for the multisig.\\n     *\\n     */\\n    function setupSecurityCouncil(address _councilAddress) internal {\\n        require(getRoleMemberCount(Role.SAFETY_COUNCIL) == 0, Error.SAFETY_COUNCIL_EXISTS);\\n        require(IGnosisSafeL2(_councilAddress).isOwner(msg.sender), Error.ADDRESS_INVALID_SAFETY_COUNCIL);\\n\\n        ds()._roles[Role.SAFETY_COUNCIL].members[_councilAddress] = true;\\n        ds()._roleMembers[Role.SAFETY_COUNCIL].add(_councilAddress);\\n\\n        emit AuthEvent.RoleGranted(Role.SAFETY_COUNCIL, _councilAddress, Meta.msgSender());\\n    }\\n\\n    function transferSecurityCouncil(address _newCouncil) internal {\\n        hasRole(Role.SAFETY_COUNCIL, msg.sender);\\n        require(IGnosisSafeL2(_newCouncil).getOwners().length >= 5, Error.MULTISIG_NOT_ENOUGH_OWNERS);\\n\\n        // As this is called by the multisig - just check that it's not an EOA\\n        ds()._roles[Role.SAFETY_COUNCIL].members[msg.sender] = false;\\n        ds()._roleMembers[Role.SAFETY_COUNCIL].remove(msg.sender);\\n\\n        ds()._roles[Role.SAFETY_COUNCIL].members[_newCouncil] = true;\\n        ds()._roleMembers[Role.SAFETY_COUNCIL].add(_newCouncil);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) internal {\\n        checkRole(getRoleAdmin(role));\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) internal {\\n        checkRole(getRoleAdmin(role));\\n        _revokeRole(role, account);\\n        ds()._roleMembers[role].remove(account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function _renounceRole(bytes32 role, address account) internal {\\n        require(account == Meta.msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        ds()._roles[role].adminRole = adminRole;\\n        emit AuthEvent.RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * @notice Cannot grant the role `SAFETY_COUNCIL` - must be done via explicit function.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _grantRole(bytes32 role, address account) internal ensureNotSafetyCouncil(role) {\\n        if (!hasRole(role, account)) {\\n            ds()._roles[role].members[account] = true;\\n            ds()._roleMembers[role].add(account);\\n            emit AuthEvent.RoleGranted(role, account, Meta.msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal {\\n        if (hasRole(role, account)) {\\n            ds()._roles[role].members[account] = false;\\n            ds()._roleMembers[role].remove(account);\\n            emit AuthEvent.RoleRevoked(role, account, Meta.msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Ensure we use the explicit `grantSafetyCouncilRole` function.\\n     */\\n    modifier ensureNotSafetyCouncil(bytes32 role) {\\n        require(role != Role.SAFETY_COUNCIL, Error.ADDRESS_INVALID_SAFETY_COUNCIL);\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x75f5fefcc0600c8d7eff402a31d75ffedb3055fbf685d571444b73c38386755d\",\"license\":\"AGPL-3.0-only\"},\"src/contracts/libs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\\n\\npragma solidity >=0.8.19;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0xfdef0c587bb7f19214c3469cb3bd16a8e4671b24d75acf6e85ea808f054bcb87\",\"license\":\"MIT\"},\"src/contracts/libs/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity <0.9.0;\\n\\n/* solhint-disable max-line-length */\\n\\n/**\\n * @author Kresko\\n * @title Error codes\\n * @notice Kresko-specific revert return values and their explanation\\n * @dev First number indicates the domain for the error\\n */\\nlibrary Error {\\n    /* -------------------------------------------------------------------------- */\\n    /*                                    Diamond                                 */\\n    /* -------------------------------------------------------------------------- */\\n\\n    // Preserve readability for the diamond proxy\\n    string public constant DIAMOND_INVALID_FUNCTION_SIGNATURE = \\\"krDiamond: function does not exist\\\";\\n    string public constant DIAMOND_INVALID_PENDING_OWNER = \\\"krDiamond: Must be pending contract owner\\\";\\n    string public constant DIAMOND_INVALID_OWNER = \\\"krDiamond: Must be diamond owner\\\";\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   1. General                               */\\n    /* -------------------------------------------------------------------------- */\\n\\n    string public constant NOT_OWNER = \\\"100\\\"; // The sender must be owner\\n    string public constant NOT_OPERATOR = \\\"101\\\"; // The sender must be operator\\n    string public constant ZERO_WITHDRAW = \\\"102\\\"; // Withdraw must be greater than 0\\n    string public constant ZERO_DEPOSIT = \\\"103\\\"; // Deposit must be greater than 0\\n    string public constant ZERO_ADDRESS = \\\"104\\\"; // Address provided cannot be address(0)\\n    string public constant ALREADY_INITIALIZED = \\\"105\\\"; // Contract has already been initialized\\n    string public constant RE_ENTRANCY = \\\"106\\\"; // Function does not allow re-entrant calls\\n    string public constant NOT_ENOUGH_BALANCE = \\\"107\\\"; // Transfer of rebasing token exceeds value\\n    string public constant NOT_ENOUGH_ALLOWANCE = \\\"108\\\"; // TransferFrom of rebasing token exceeds allowance\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   2. Minter                                 */\\n    /* -------------------------------------------------------------------------- */\\n\\n    string public constant NOT_LIQUIDATABLE = \\\"200\\\"; // Account has collateral deposits exceeding minCollateralValue\\n    string public constant ZERO_MINT = \\\"201\\\"; // Mint amount must be greater than 0\\n    string public constant ZERO_BURN = \\\"202\\\"; // Burn amount must be greater than 0\\n    string public constant ADDRESS_INVALID_ORACLE = \\\"203\\\"; // Oracle address cant be set to address(0)\\n    string public constant ADDRESS_INVALID_NRWT = \\\"204\\\"; // Underlying rebasing token address cant be set to address(0)\\n    string public constant ADDRESS_INVALID_FEERECIPIENT = \\\"205\\\"; // Fee recipient address cant be set to address(0)\\n    string public constant ADDRESS_INVALID_COLLATERAL = \\\"206\\\"; // Collateral address cant be set to address(0)\\n    string public constant COLLATERAL_EXISTS = \\\"207\\\"; // Collateral has already been added into the protocol\\n    string public constant COLLATERAL_INVALID_FACTOR = \\\"208\\\"; // cFactor must be greater than 1FP\\n    string public constant COLLATERAL_WITHDRAW_OVERFLOW = \\\"209\\\"; // Withdraw amount cannot reduce accounts collateral value under minCollateralValue\\n    string public constant KRASSET_INVALID_FACTOR = \\\"210\\\"; // kFactor must be greater than 1FP\\n    string public constant KRASSET_BURN_AMOUNT_OVERFLOW = \\\"211\\\"; // Repaying more than account has debt\\n    string public constant KRASSET_EXISTS = \\\"212\\\"; // KrAsset is already added\\n    string public constant PARAM_CLOSE_FEE_TOO_HIGH = \\\"213\\\"; // \\\"Close fee exceeds MAX_CLOSE_FEE\\\"\\n    string public constant PARAM_LIQUIDATION_INCENTIVE_LOW = \\\"214\\\"; // \\\"Liquidation incentive less than MIN_LIQUIDATION_INCENTIVE_MULTIPLIER\\\"\\n    string public constant PARAM_LIQUIDATION_INCENTIVE_HIGH = \\\"215\\\"; // \\\"Liquidation incentive greater than MAX_LIQUIDATION_INCENTIVE_MULTIPLIER\\\"\\n    string public constant PARAM_MIN_COLLATERAL_RATIO_LOW = \\\"216\\\"; // Minimum collateral ratio less than MIN_COLLATERALIZATION_RATIO\\n    string public constant PARAM_MIN_DEBT_AMOUNT_HIGH = \\\"217\\\"; // Minimum debt param argument exceeds MAX_MIN_DEBT_VALUE\\n    string public constant COLLATERAL_DOESNT_EXIST = \\\"218\\\"; // Collateral does not exist within the protocol\\n    string public constant KRASSET_DOESNT_EXIST = \\\"219\\\"; // KrAsset does not exist within the protocol\\n    string public constant KRASSET_NOT_MINTABLE = \\\"220\\\"; // KrAsset is not mintable\\n    string public constant KRASSET_SYMBOL_EXISTS = \\\"221\\\"; // KrAsset with this symbol is already within the protocl\\n    string public constant KRASSET_COLLATERAL_LOW = \\\"222\\\"; // Collateral deposits do not cover the amount being minted\\n    string public constant KRASSET_MINT_AMOUNT_LOW = \\\"223\\\"; // Debt position must be greater than the minimum debt position value\\n    string public constant KRASSET_MAX_SUPPLY_REACHED = \\\"224\\\"; // KrAsset being minted has reached its current supply limit\\n    string public constant SELF_LIQUIDATION = \\\"225\\\"; // Account cannot liquidate itself\\n    string public constant ZERO_REPAY = \\\"226\\\"; // Cannot liquidate zero value\\n    string public constant STALE_PRICE = \\\"227\\\"; // Price for the asset is stale\\n    string public constant LIQUIDATION_OVERFLOW = \\\"228\\\"; // Repaying more USD value than allowed\\n    string public constant ADDRESS_INVALID_SAFETY_COUNCIL = \\\"229\\\"; // Account responsible for the safety council role must be a multisig\\n    string public constant SAFETY_COUNCIL_EXISTS = \\\"230\\\"; // Only one council role can exist\\n    string public constant NOT_SAFETY_COUNCIL = \\\"231\\\"; // Sender must have the role `Role.SAFETY_COUNCIL`\\n    string public constant ACTION_PAUSED_FOR_ASSET = \\\"232\\\"; // This action is currently paused for this asset\\n    string public constant INVALID_ASSET_SUPPLIED = \\\"233\\\"; // Asset supplied is not a collateral nor a krAsset\\n    string public constant KRASSET_NOT_ANCHOR = \\\"234\\\"; // Address is not the anchor for the krAsset\\n    string public constant INVALID_LT = \\\"235\\\"; // Liquidation threshold is greater than minimum collateralization ratio\\n    string public constant COLLATERAL_INSUFFICIENT_AMOUNT = \\\"236\\\"; // Insufficient amount of collateral to complete the operation\\n    string public constant MULTISIG_NOT_ENOUGH_OWNERS = \\\"237\\\"; // Multisig has invalid amount of owners\\n    string public constant PARAM_OPEN_FEE_TOO_HIGH = \\\"238\\\"; // \\\"Close fee exceeds MAX_OPEN_FEE\\\"\\n    string public constant INVALID_FEE_TYPE = \\\"239\\\"; // \\\"Invalid fee type\\n    string public constant KRASSET_INVALID_ANCHOR = \\\"240\\\"; // krAsset anchor does not support the correct interfaceId\\n    string public constant KRASSET_INVALID_CONTRACT = \\\"241\\\"; // krAsset does not support the correct interfaceId\\n    string public constant KRASSET_MARKET_CLOSED = \\\"242\\\"; // KrAsset's market is currently closed\\n    string public constant NO_KRASSETS_MINTED = \\\"243\\\"; // Account has no active KreskoAsset positions\\n    string public constant NO_COLLATERAL_DEPOSITS = \\\"244\\\"; // Account has no active Collateral deposits\\n    string public constant INVALID_ORACLE_DECIMALS = \\\"245\\\"; // Oracle decimals do not match extOracleDecimals\\n    string public constant PARAM_LIQUIDATION_OVERFLOW_LOW = \\\"246\\\"; // Liquidation overflow is less than MIN_LIQUIDATION_OVERFLOW\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   3. Staking                               */\\n    /* -------------------------------------------------------------------------- */\\n\\n    string public constant REWARD_PER_BLOCK_MISSING = \\\"300\\\"; // Each reward token must have a reward per block value\\n    string public constant REWARD_TOKENS_MISSING = \\\"301\\\"; // Pool must include an array of reward token addresses\\n    string public constant POOL_EXISTS = \\\"302\\\"; // Pool with this deposit token already exists\\n    string public constant POOL_DOESNT_EXIST = \\\"303\\\"; // Pool with this deposit token does not exist\\n    string public constant ADDRESS_INVALID_REWARD_RECIPIENT = \\\"304\\\"; // Reward recipient cant be address(0)\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   4. Libraries                             */\\n    /* -------------------------------------------------------------------------- */\\n\\n    string public constant ARRAY_OUT_OF_BOUNDS = \\\"400\\\"; // Array out of bounds error\\n    string public constant PRICEFEEDS_MUST_MATCH_STATUS_FEEDS = \\\"401\\\"; // Supplied price feeds must match status feeds in length\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   5. KrAsset                               */\\n    /* -------------------------------------------------------------------------- */\\n\\n    string public constant REBASING_DENOMINATOR_LOW = \\\"500\\\"; // denominator of rebases must be >= 1\\n    string public constant ISSUER_NOT_KRESKO = \\\"501\\\"; // issue must be done by kresko\\n    string public constant REDEEMER_NOT_KRESKO = \\\"502\\\"; // redeem must be done by kresko\\n    string public constant DESTROY_OVERFLOW = \\\"503\\\"; // trying to destroy more than allowed\\n    string public constant ISSUE_OVERFLOW = \\\"504\\\"; // trying to destroy more than allowed\\n    string public constant MINT_OVERFLOW = \\\"505\\\"; // trying to destroy more than allowed\\n    string public constant DEPOSIT_OVERFLOW = \\\"506\\\"; // trying to destroy more than allowed\\n    string public constant REDEEM_OVERFLOW = \\\"507\\\"; // trying to destroy more than allowed\\n    string public constant WITHDRAW_OVERFLOW = \\\"508\\\"; // trying to destroy more than allowed\\n    string public constant ZERO_SHARES = \\\"509\\\"; // amount of shares must be greater than 0\\n    string public constant ZERO_ASSETS = \\\"510\\\"; // amount of assets must be greater than 0\\n    string public constant INVALID_SCALED_AMOUNT = \\\"511\\\"; // amount of debt scaled must be greater than 0\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                              6. STABILITY RATES                            */\\n    /* -------------------------------------------------------------------------- */\\n\\n    string public constant STABILITY_RATES_ALREADY_INITIALIZED = \\\"601\\\"; // stability rates for the asset are already initialized\\n    string public constant INVALID_OPTIMAL_RATE = \\\"602\\\"; // the optimal price rate configured is less than 1e27 for the asset\\n    string public constant INVALID_PRICE_RATE_DELTA = \\\"603\\\"; // the price rate delta configured is less than 1e27 for the asset\\n    string public constant STABILITY_RATES_NOT_INITIALIZED = \\\"604\\\"; // the stability rates for the asset are not initialized\\n    string public constant STABILITY_RATE_OVERFLOW = \\\"605\\\"; // the stability rates is > max uint128\\n    string public constant DEBT_INDEX_OVERFLOW = \\\"606\\\"; // the debt index is > max uint128\\n    string public constant KISS_NOT_SET = \\\"607\\\"; // the debt index is > max uint128\\n    string public constant STABILITY_RATE_REPAYMENT_AMOUNT_ZERO = \\\"608\\\"; // interest being repaid cannot be 0\\n    string public constant STABILITY_RATE_INTEREST_IS_ZERO = \\\"609\\\"; // account must have accrued interest to repay it\\n    string public constant INTEREST_REPAY_NOT_PARTIAL = \\\"610\\\"; // account must have accrued interest to repay it\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                              7. AMM ORACLE                                 */\\n    /* -------------------------------------------------------------------------- */\\n\\n    string public constant PAIR_ADDRESS_IS_ZERO = \\\"701\\\"; // Pair address to configure cannot be zero\\n    string public constant INVALID_UPDATE_PERIOD = \\\"702\\\"; // Update period must be greater than the minimum\\n    string public constant PAIR_ALREADY_EXISTS = \\\"703\\\"; // Pair with the address is already initialized\\n    string public constant PAIR_DOES_NOT_EXIST = \\\"704\\\"; // Pair supplied does not exist\\n    string public constant INVALID_LIQUIDITY = \\\"706\\\"; // Pair initializaition requires that the pair has liquidity\\n    string public constant UPDATE_PERIOD_NOT_FINISHED = \\\"707\\\"; // Update can only be called once per update period\\n    string public constant INVALID_PAIR = \\\"708\\\"; // Pair being consulted does not have the token that the price was requested for\\n    string public constant CALLER_NOT_ADMIN = \\\"709\\\"; // Caller must be the admin\\n    string public constant CONSTRUCTOR_INVALID_ADMIN = \\\"710\\\"; // Admin cannot be zero address in the constructor\\n    string public constant CONSTRUCTOR_INVALID_FACTORY = \\\"711\\\"; // Factory cannot be the zero address\\n    string public constant NO_INCENTIVES_LEFT = \\\"712\\\"; // No incentives left for updating the price\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                              8. KISS                                 */\\n    /* -------------------------------------------------------------------------- */\\n\\n    string public constant OPERATOR_WAIT_PERIOD_NOT_OVER = \\\"800\\\"; // Operator role has a cooldown period which has not passed\\n    string public constant OPERATOR_LIMIT_REACHED = \\\"801\\\"; // More minters cannot be assigned before existing one is removed\\n    string public constant CALLER_NOT_CONTRACT = \\\"802\\\"; // Caller of the function must be a contract\\n    string public constant OPERATOR_NOT_CONTRACT = \\\"803\\\"; // Operator role can only be granted to a contract\\n    string public constant KRESKO_NOT_CONTRACT = \\\"804\\\"; // Operator role can only be granted to a contract\\n    string public constant ADMIN_NOT_A_CONTRACT = \\\"805\\\"; // Operator role can only be granted to a contract\\n    string public constant OPERATOR_WAIT_PERIOD_TOO_SHORT = \\\"806\\\"; // Operator assignment cooldown period must be greater than 15 minutes\\n}\\n\",\"keccak256\":\"0x1bdc58128ed5c5ad443d039b89cc3abf6545c4cb5578135fb949065667b42f42\",\"license\":\"BUSL-1.1\"},\"src/contracts/libs/Events.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {IDiamondCutFacet} from \\\"../diamond/interfaces/IDiamondCutFacet.sol\\\";\\nimport {Action} from \\\"../minter/MinterTypes.sol\\\";\\n\\n/* solhint-disable var-name-mixedcase */\\n\\n/**\\n * @author Kresko\\n * @title Events\\n * @notice Event definitions\\n */\\n\\nlibrary GeneralEvent {\\n    /**\\n     * @dev Triggered when the contract has been deployed\\n     */\\n    event Deployed(address indexed owner, uint8 version);\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(address indexed operator, uint8 version);\\n}\\n\\nlibrary DiamondEvent {\\n    event DiamondCut(IDiamondCutFacet.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\\nlibrary MinterEvent {\\n    /* -------------------------------------------------------------------------- */\\n    /*                                 Collateral                                 */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /**\\n     * @notice Emitted when a collateral asset is added to the protocol.\\n     * @dev Can only be emitted once for a given collateral asset.\\n     * @param collateralAsset The address of the collateral asset.\\n     * @param factor The collateral factor.\\n     * @param oracle The address of the oracle.\\n     * @param marketStatusOracle The address of the market status oracle.\\n     * @param liquidationIncentive The liquidation incentive\\n     */\\n    event CollateralAssetAdded(\\n        address indexed collateralAsset,\\n        uint256 factor,\\n        address indexed oracle,\\n        address indexed marketStatusOracle,\\n        address anchor,\\n        uint256 liquidationIncentive\\n    );\\n\\n    /**\\n     * @notice Emitted when a collateral asset is updated.\\n     * @param collateralAsset The address of the collateral asset.\\n     * @param factor The collateral factor.\\n     * @param oracle The oracle address.\\n     * @param marketStatusOracle The address of the market status oracle.\\n     * @param liquidationIncentive The liquidation incentive\\n     */\\n    event CollateralAssetUpdated(\\n        address indexed collateralAsset,\\n        uint256 factor,\\n        address indexed oracle,\\n        address indexed marketStatusOracle,\\n        address anchor,\\n        uint256 liquidationIncentive\\n    );\\n\\n    /**\\n     * @notice Emitted when an account deposits collateral.\\n     * @param account The address of the account depositing collateral.\\n     * @param collateralAsset The address of the collateral asset.\\n     * @param amount The amount of the collateral asset that was deposited.\\n     */\\n    event CollateralDeposited(address indexed account, address indexed collateralAsset, uint256 amount);\\n\\n    /**\\n     * @notice Emitted when an account withdraws collateral.\\n     * @param account The address of the account withdrawing collateral.\\n     * @param collateralAsset The address of the collateral asset.\\n     * @param amount The amount of the collateral asset that was withdrawn.\\n     */\\n    event CollateralWithdrawn(address indexed account, address indexed collateralAsset, uint256 amount);\\n\\n    /**\\n     * @notice Emitted when AMM helper withdraws account collateral without MCR checks.\\n     * @param account The address of the account withdrawing collateral.\\n     * @param collateralAsset The address of the collateral asset.\\n     * @param amount The amount of the collateral asset that was withdrawn.\\n     */\\n    event UncheckedCollateralWithdrawn(address indexed account, address indexed collateralAsset, uint256 amount);\\n\\n    /**\\n     * @notice Emitted when AMM oracle is set.\\n     * @param ammOracle The address of the AMM oracle.\\n     */\\n    event AMMOracleUpdated(address indexed ammOracle);\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                Kresko Assets                               */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /**\\n     * @notice Emitted when a KreskoAsset is added to the protocol.\\n     * @dev Can only be emitted once for a given Kresko asset.\\n     * @param kreskoAsset The address of the Kresko asset.\\n     * @param anchor anchor token\\n     * @param kFactor The k-factor.\\n     * @param oracle The address of the oracle.\\n     * @param marketStatusOracle The address of the market status oracle.\\n     * @param supplyLimit The total supply limit.\\n     * @param closeFee The close fee percentage.\\n     * @param openFee The open fee percentage.\\n     */\\n    event KreskoAssetAdded(\\n        address indexed kreskoAsset,\\n        address anchor,\\n        address indexed oracle,\\n        address indexed marketStatusOracle,\\n        uint256 kFactor,\\n        uint256 supplyLimit,\\n        uint256 closeFee,\\n        uint256 openFee\\n    );\\n\\n    /**\\n     * @notice Emitted when a Kresko asset's oracle is updated.\\n     * @param kreskoAsset The address of the Kresko asset.\\n     * @param kFactor The k-factor.\\n     * @param oracle The address of the oracle.\\n     * @param marketStatusOracle The address of the market status oracle.\\n     * @param supplyLimit The total supply limit.\\n     * @param closeFee The close fee percentage.\\n     * @param openFee The open fee percentage.\\n     */\\n    event KreskoAssetUpdated(\\n        address indexed kreskoAsset,\\n        address anchor,\\n        address indexed oracle,\\n        address indexed marketStatusOracle,\\n        uint256 kFactor,\\n        uint256 supplyLimit,\\n        uint256 closeFee,\\n        uint256 openFee\\n    );\\n\\n    /**\\n     * @notice Emitted when an account mints a Kresko asset.\\n     * @param account The address of the account minting the Kresko asset.\\n     * @param kreskoAsset The address of the Kresko asset.\\n     * @param amount The amount of the KreskoAsset that was minted.\\n     */\\n    event KreskoAssetMinted(address indexed account, address indexed kreskoAsset, uint256 amount);\\n\\n    /**\\n     * @notice Emitted when an account burns a Kresko asset.\\n     * @param account The address of the account burning the Kresko asset.\\n     * @param kreskoAsset The address of the Kresko asset.\\n     * @param amount The amount of the KreskoAsset that was burned.\\n     */\\n    event KreskoAssetBurned(address indexed account, address indexed kreskoAsset, uint256 amount);\\n\\n    /**\\n     * @notice Emitted when an account burns a Kresko asset.\\n     * @param account The address of the account burning the Kresko asset.\\n     * @param kreskoAsset The address of the Kresko asset.\\n     * @param amount The amount of the KreskoAsset that was burned.\\n     * @param interestRepaid The amount of the KISS repaid due to interest accrual\\n     */\\n    event DebtPositionClosed(\\n        address indexed account,\\n        address indexed kreskoAsset,\\n        uint256 amount,\\n        uint256 interestRepaid\\n    );\\n\\n    /**\\n     * @notice Emitted when cFactor is updated for a collateral asset.\\n     * @param collateralAsset The address of the collateral asset.\\n     * @param cFactor The new cFactor\\n     */\\n    event CFactorUpdated(address indexed collateralAsset, uint256 cFactor);\\n    /**\\n     * @notice Emitted when kFactor is updated for a KreskoAsset.\\n     * @param kreskoAsset The address of the KreskoAsset.\\n     * @param kFactor The new kFactor\\n     */\\n    event KFactorUpdated(address indexed kreskoAsset, uint256 kFactor);\\n\\n    /**\\n     * @notice Emitted when an account pays a close fee with a collateral asset upon burning a KreskoAsset.\\n     * @dev This can be emitted multiple times for a single KreskoAsset burn.\\n     * @param account The address of the account burning the KreskoAsset.\\n     * @param paymentCollateralAsset The address of the collateral asset used to pay the close fee.\\n     * @param paymentAmount The amount of the payment collateral asset that was paid.\\n     * @param paymentValue The USD value of the payment.\\n     */\\n    event CloseFeePaid(\\n        address indexed account,\\n        address indexed paymentCollateralAsset,\\n        uint256 paymentAmount,\\n        uint256 paymentValue\\n    );\\n\\n    /**\\n     * @notice Emitted when an account pays an open fee with a collateral asset upon minting a KreskoAsset.\\n     * @dev This can be emitted multiple times for a single KreskoAsset mint.\\n     * @param account The address of the account minting the KreskoAsset.\\n     * @param paymentCollateralAsset The address of the collateral asset used to pay the open fee.\\n     * @param paymentAmount The amount of the payment collateral asset that was paid.\\n     * @param paymentValue The USD value of the payment.\\n     */\\n    event OpenFeePaid(\\n        address indexed account,\\n        address indexed paymentCollateralAsset,\\n        uint256 paymentAmount,\\n        uint256 paymentValue\\n    );\\n\\n    /**\\n     * @notice Emitted when a liquidation occurs.\\n     * @param account The address of the account being liquidated.\\n     * @param liquidator The account performing the liquidation.\\n     * @param repayKreskoAsset The address of the KreskoAsset being paid back to the protocol by the liquidator.\\n     * @param repayAmount The amount of the repay KreskoAsset being paid back to the protocol by the liquidator.\\n     * @param seizedCollateralAsset The address of the collateral asset being seized from the account by the liquidator.\\n     * @param collateralSent The amount of the seized collateral asset being seized from the account by the liquidator.\\n     */\\n    event LiquidationOccurred(\\n        address indexed account,\\n        address indexed liquidator,\\n        address indexed repayKreskoAsset,\\n        uint256 repayAmount,\\n        address seizedCollateralAsset,\\n        uint256 collateralSent\\n    );\\n\\n    /**\\n     * @notice Emitted when a liquidation of interest occurs.\\n     * @param account The address of the account being liquidated.\\n     * @param liquidator The account performing the liquidation.\\n     * @param repayKreskoAsset The address of the KreskoAsset being paid back to the protocol by the liquidator.\\n     * @param repayUSD The value of the repay KreskoAsset being paid back to the protocol by the liquidator.\\n     * @param seizedCollateralAsset The address of the collateral asset being seized from the account by the liquidator.\\n     * @param collateralSent The amount of the seized collateral asset being seized from the account by the liquidator.\\n     */\\n    event InterestLiquidationOccurred(\\n        address indexed account,\\n        address indexed liquidator,\\n        address indexed repayKreskoAsset,\\n        uint256 repayUSD,\\n        address seizedCollateralAsset,\\n        uint256 collateralSent\\n    );\\n    /**\\n     * @notice Emitted when a batch liquidation of interest occurs.\\n     * @param account The address of the account being liquidated.\\n     * @param liquidator The account performing the liquidation.\\n     * @param seizedCollateralAsset The address of the collateral asset being seized from the account by the liquidator.\\n     * @param repayUSD The value of the repay KreskoAsset being paid back to the protocol by the liquidator.\\n     * @param collateralSent The amount of the seized collateral asset being seized from the account by the liquidator.\\n     */\\n    event BatchInterestLiquidationOccurred(\\n        address indexed account,\\n        address indexed liquidator,\\n        address indexed seizedCollateralAsset,\\n        uint256 repayUSD,\\n        uint256 collateralSent\\n    );\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                Parameters                                  */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /**\\n     * @notice Emitted when a safety state is triggered for an asset\\n     * @param action Target action\\n     * @param asset Asset affected\\n     * @param description change description\\n     */\\n    event SafetyStateChange(Action indexed action, address indexed asset, string indexed description);\\n\\n    /**\\n     * @notice Emitted when the fee recipient is updated.\\n     * @param feeRecipient The new fee recipient.\\n     */\\n    event FeeRecipientUpdated(address indexed feeRecipient);\\n\\n    /**\\n     * @notice Emitted when the liquidation incentive multiplier is updated.\\n     * @param asset The collateral asset being updated.\\n     * @param liquidationIncentiveMultiplier The new liquidation incentive multiplier raw value.\\n     */\\n    event LiquidationIncentiveMultiplierUpdated(address indexed asset, uint256 liquidationIncentiveMultiplier);\\n\\n    /**\\n     * @notice Emitted when the liquidation overflow multiplier is updated.\\n     * @param maxLiquidationMultiplier The new liquidation overflow multiplier value.\\n     */\\n    event maxLiquidationMultiplierUpdated(uint256 maxLiquidationMultiplier);\\n\\n    /**\\n     * @notice Emitted when the minimum collateralization ratio is updated.\\n     * @param minimumCollateralizationRatio The new minimum collateralization ratio raw value.\\n     */\\n    event MinimumCollateralizationRatioUpdated(uint256 minimumCollateralizationRatio);\\n\\n    /**\\n     * @notice Emitted when the minimum debt value updated.\\n     * @param minimumDebtValue The new minimum debt value.\\n     */\\n    event MinimumDebtValueUpdated(uint256 minimumDebtValue);\\n\\n    /**\\n     * @notice Emitted when the liquidation threshold value is updated\\n     * @param liquidationThreshold The new liquidation threshold value.\\n     */\\n    event LiquidationThresholdUpdated(uint256 liquidationThreshold);\\n}\\n\\nlibrary StakingEvent {\\n    event LiquidityAndStakeAdded(address indexed to, uint256 indexed amount, uint256 indexed pid);\\n    event LiquidityAndStakeRemoved(address indexed to, uint256 indexed amount, uint256 indexed pid);\\n    event Deposit(address indexed user, uint256 indexed pid, uint256 indexed amount);\\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\\n    event ClaimRewards(address indexed user, address indexed rewardToken, uint256 indexed amount);\\n    event ClaimRewardsMulti(address indexed to);\\n}\\n\\nlibrary AuthEvent {\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    event PendingOwnershipTransfer(address indexed previousOwner, address indexed newOwner);\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n}\\n\\nlibrary InterestRateEvent {\\n    /**\\n     * @dev Emitted when @param account repaid their @param asset interest @param value\\n     */\\n    event StabilityRateConfigured(\\n        address indexed asset,\\n        uint256 stabilityRateBase,\\n        uint256 priceRateDelta,\\n        uint256 rateSlope1,\\n        uint256 rateSlope2\\n    );\\n    /**\\n     * @dev Emitted when @param account repaid their @param asset interest @param value\\n     */\\n    event StabilityRateInterestRepaid(address indexed account, address indexed asset, uint256 value);\\n    /**\\n     * @dev Emitted when @param account repaid all interest @param value\\n     */\\n    event StabilityRateInterestBatchRepaid(address indexed account, uint256 value);\\n\\n    /**\\n     * @notice Emitted when KISS address is set.\\n     * @param KISS The address of KISS.\\n     */\\n    event KISSUpdated(address indexed KISS);\\n}\\n\",\"keccak256\":\"0x9ab0bf466d22bbb6c9fc7242de94b5c5e76df3c7a02c18a27e680eb3e9cbf1de\",\"license\":\"BUSL-1.1\"},\"src/contracts/libs/Meta.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/* solhint-disable no-inline-assembly */\\n\\npragma solidity >=0.8.19;\\n\\nlibrary Meta {\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\\n        keccak256(bytes(\\\"EIP712Domain(string name,string version,uint256 salt,address verifyingContract)\\\"));\\n\\n    function domainSeparator(\\n        string memory name,\\n        string memory version\\n    ) internal view returns (bytes32 domainSeparator_) {\\n        domainSeparator_ = keccak256(\\n            abi.encode(\\n                EIP712_DOMAIN_TYPEHASH,\\n                keccak256(bytes(name)),\\n                keccak256(bytes(version)),\\n                getChainID(),\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function getChainID() internal view returns (uint256 id) {\\n        assembly {\\n            id := chainid()\\n        }\\n    }\\n\\n    function msgSender() internal view returns (address sender_) {\\n        if (msg.sender == address(this)) {\\n            bytes memory array = msg.data;\\n            uint256 index = msg.data.length;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\n                sender_ := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\\n            }\\n        } else {\\n            sender_ = msg.sender;\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0xab3a89ab4294d6b84baa5f2449987b09b8a841c3ae3440fb78353903e4d159d4\",\"license\":\"MIT\"},\"src/contracts/libs/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity >=0.8.19;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x22d448aa5242a8d7e469bca40a6df1409527444397c83b8ab38fff9011b5cc1a\",\"license\":\"MIT\"},\"src/contracts/libs/WadRay.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.10;\\n\\n/**\\n * @title WadRayMath library\\n * @author Aave\\n * @notice Provides functions to perform calculations with Wad and Ray units\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\\n * with 27 digits of precision)\\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\\n **/\\nlibrary WadRay {\\n    // HALF_WAD and HALF_RAY expressed with extended notation\\n    // as constant with operations are not supported in Yul assembly\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant HALF_WAD = 0.5e18;\\n\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant HALF_RAY = 0.5e27;\\n\\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n    /**\\n     * @dev Multiplies two wad, rounding half up to the nearest wad\\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Wad\\n     * @param b Wad\\n     * @return c = a*b, in wad\\n     **/\\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\\n        assembly {\\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, b), HALF_WAD), WAD)\\n        }\\n    }\\n\\n    /**\\n     * @dev Divides two wad, rounding half up to the nearest wad\\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Wad\\n     * @param b Wad\\n     * @return c = a/b, in wad\\n     **/\\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\\n        assembly {\\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, WAD), div(b, 2)), b)\\n        }\\n    }\\n\\n    /**\\n     * @notice Multiplies two ray, rounding half up to the nearest ray\\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Ray\\n     * @param b Ray\\n     * @return c = a raymul b\\n     **/\\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\\n        assembly {\\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, b), HALF_RAY), RAY)\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides two ray, rounding half up to the nearest ray\\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Ray\\n     * @param b Ray\\n     * @return c = a raydiv b\\n     **/\\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\\n        assembly {\\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, RAY), div(b, 2)), b)\\n        }\\n    }\\n\\n    /**\\n     * @dev Casts ray down to wad\\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Ray\\n     * @return b = a converted to wad, rounded half up to the nearest wad\\n     **/\\n    function rayToWad(uint256 a) internal pure returns (uint256 b) {\\n        assembly {\\n            b := div(a, WAD_RAY_RATIO)\\n            let remainder := mod(a, WAD_RAY_RATIO)\\n            if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\\n                b := add(b, 1)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts wad up to ray\\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Wad\\n     * @return b = a converted in ray\\n     **/\\n    function wadToRay(uint256 a) internal pure returns (uint256 b) {\\n        // to avoid overflow, b/WAD_RAY_RATIO == a\\n        assembly {\\n            b := mul(a, WAD_RAY_RATIO)\\n\\n            if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xccf0652e967667a457836300e6fd1ef4e790e7db3f2cb183a74ba9b79337e2c9\",\"license\":\"MIT\"},\"src/contracts/minter/InterestRateState.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {LibStabilityRate} from \\\"./libs/LibStabilityRate.sol\\\";\\n\\nusing LibStabilityRate for StabilityRateConfig global;\\n\\n/* solhint-disable var-name-mixedcase */\\n\\n// Asset data\\nstruct StabilityRateConfig {\\n    // Interest index for debt\\n    uint128 debtIndex;\\n    // Represents the optimal price rate between an oracle report and an AMM twap\\n    uint128 optimalPriceRate;\\n    // Slope of the variable interest curve when rate > 0 and <= optimalPriceRate.\\n    // Expressed in ray\\n    uint128 rateSlope1;\\n    // Slope of the variable interest curve when rate > optimalPriceRate.\\n    // Expressed in ray\\n    uint128 rateSlope2;\\n    /**\\n     * Represents the excess price premium in either direction.\\n     * Expressed in ray\\n     * Eg. 1/20 ray = 5% price premium in either direction is considered excess\\n     */\\n    uint128 priceRateDelta;\\n    // Current accrual rate for debt\\n    uint128 stabilityRate;\\n    // Base accrual rate for debt\\n    uint128 stabilityRateBase;\\n    // Asset to configure\\n    address asset;\\n    // Last update for the asset\\n    uint40 lastUpdateTimestamp;\\n}\\n\\n// User data\\nstruct StabilityRateUser {\\n    uint128 debtScaled;\\n    uint128 lastDebtIndex;\\n}\\n\\n// Storage layout\\nstruct InterestRateState {\\n    // asset address -> asset data\\n    mapping(address => StabilityRateConfig) srAssets;\\n    // account address -> asset address -> user data\\n    mapping(address => mapping(address => StabilityRateUser)) srUserInfo;\\n    // interest repayment token is KISS\\n    address kiss;\\n}\\n\\n// Storage position\\nbytes32 constant INTEREST_RATE_STORAGE_POSITION = keccak256(\\\"kresko.interest.rate.storage\\\");\\n\\n// solhint-disable func-visibility\\nfunction irs() pure returns (InterestRateState storage state) {\\n    bytes32 position = INTEREST_RATE_STORAGE_POSITION;\\n    assembly {\\n        state.slot := position\\n    }\\n}\\n\",\"keccak256\":\"0x83295d5e5eceaed370af95d39b179ac0c38c5fd44e3278770083c33cdb4493e5\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/MinterState.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {LibKrAsset} from \\\"./libs/LibKrAsset.sol\\\";\\nimport {LibAccount} from \\\"./libs/LibAccount.sol\\\";\\nimport {LibCollateral} from \\\"./libs/LibCollateral.sol\\\";\\nimport {LibCalculation} from \\\"./libs/LibCalculation.sol\\\";\\nimport {LibBurn} from \\\"./libs/LibBurn.sol\\\";\\nimport {LibMint} from \\\"./libs/LibMint.sol\\\";\\nimport {Action, SafetyState, CollateralAsset, KrAsset} from \\\"./MinterTypes.sol\\\";\\n\\n/* solhint-disable state-visibility */\\nusing LibCalculation for MinterState global;\\nusing LibKrAsset for MinterState global;\\nusing LibCollateral for MinterState global;\\nusing LibAccount for MinterState global;\\nusing LibBurn for MinterState global;\\nusing LibMint for MinterState global;\\n\\n/**\\n * @title Storage layout for the minter state\\n * @author Kresko\\n */\\nstruct MinterState {\\n    /* -------------------------------------------------------------------------- */\\n    /*                               Initialization                               */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @notice Initialization version\\n    uint256 initializations;\\n    bytes32 domainSeparator;\\n    /* -------------------------------------------------------------------------- */\\n    /*                           Configurable Parameters                          */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @notice The recipient of protocol fees.\\n    address feeRecipient;\\n    /// @notice The factor used to calculate the incentive a liquidator receives in the form of seized collateral.\\n    uint256 liquidationIncentiveMultiplier;\\n    /// @notice The minimum ratio of collateral to debt that can be taken by direct action.\\n    uint256 minimumCollateralizationRatio;\\n    /// @notice The minimum USD value of an individual synthetic asset debt position.\\n    uint256 minimumDebtValue;\\n    /// @notice The collateralization ratio at which positions may be liquidated.\\n    uint256 liquidationThreshold;\\n    /// @notice Flag tells if there is a need to perform safety checks on user actions\\n    bool safetyStateSet;\\n    /// @notice asset -> action -> state\\n    mapping(address => mapping(Action => SafetyState)) safetyState;\\n    /* -------------------------------------------------------------------------- */\\n    /*                              Collateral Assets                             */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @notice Mapping of collateral asset token address to information on the collateral asset.\\n    mapping(address => CollateralAsset) collateralAssets;\\n    /**\\n     * @notice Mapping of account -> asset -> deposit amount\\n     */\\n    mapping(address => mapping(address => uint256)) collateralDeposits;\\n    /// @notice Mapping of account -> collateral asset addresses deposited\\n    mapping(address => address[]) depositedCollateralAssets;\\n    /* -------------------------------------------------------------------------- */\\n    /*                                Kresko Assets                               */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @notice Mapping of kresko asset token address to information on the Kresko asset.\\n    mapping(address => KrAsset) kreskoAssets;\\n    /// @notice Mapping of account -> krAsset -> debt amount owed to the protocol\\n    mapping(address => mapping(address => uint256)) kreskoAssetDebt;\\n    /// @notice Mapping of account -> addresses of borrowed krAssets\\n    mapping(address => address[]) mintedKreskoAssets;\\n    /// @notice The AMM oracle address.\\n    address ammOracle;\\n    /// @notice Offchain oracle decimals\\n    uint8 extOracleDecimals;\\n    /// @notice Liquidation Overflow Multiplier, multiplies max liquidatable value.\\n    uint256 maxLiquidationMultiplier;\\n}\\n\",\"keccak256\":\"0x7179d8fb7de920499cb81aeecbbd8782b838f305be1d24d3a57e2b0c6702e7e2\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/MinterStorage.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n/* solhint-disable no-inline-assembly */\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable func-visibility */\\n\\npragma solidity >=0.8.19;\\n\\nimport {MinterState} from \\\"./MinterState.sol\\\";\\n\\n// Storage position\\nbytes32 constant MINTER_STORAGE_POSITION = keccak256(\\\"kresko.minter.storage\\\");\\n\\nfunction ms() pure returns (MinterState storage state) {\\n    bytes32 position = MINTER_STORAGE_POSITION;\\n    assembly {\\n        state.slot := position\\n    }\\n}\\n\",\"keccak256\":\"0x960701164cf10f551b8e7c4b3d8d29cf6b0a45fa4212b329c6f28b36e7ee7b4a\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/MinterTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {AggregatorV2V3Interface} from \\\"../vendor/flux/interfaces/AggregatorV2V3Interface.sol\\\";\\nimport {IKreskoAssetAnchor} from \\\"../kreskoasset/IKreskoAssetAnchor.sol\\\";\\nimport {LibAssetUtility} from \\\"./libs/LibAssetUtility.sol\\\";\\n\\n/* solhint-disable state-visibility */\\n\\n/* -------------------------------------------------------------------------- */\\n/*                                  CONSTANTS                                 */\\n/* -------------------------------------------------------------------------- */\\n\\nlibrary Constants {\\n    uint256 constant FP_DECIMALS = 18;\\n\\n    uint256 constant FP_SCALING_FACTOR = 10 ** FP_DECIMALS;\\n\\n    uint256 constant ONE_HUNDRED_PERCENT = 1 ether;\\n\\n    uint256 constant BASIS_POINT = 1e14;\\n\\n    /// @dev The maximum configurable close fee.\\n    uint256 constant MAX_CLOSE_FEE = 0.1 ether; // 10%\\n\\n    /// @dev The maximum configurable open fee.\\n    uint256 constant MAX_OPEN_FEE = 0.1 ether; // 10%\\n\\n    /// @dev The maximum configurable protocol fee per asset for collateral pool swaps.\\n    uint256 constant MAX_COLLATERAL_POOL_PROTOCOL_FEE = 0.5 ether; // 50%\\n\\n    /// @dev Overflow over maximum liquidatable value to allow leeway for users after one happens.\\n    uint256 constant MIN_MAX_LIQUIDATION_MULTIPLIER = ONE_HUNDRED_PERCENT + BASIS_POINT; // 100.01% or .01% over\\n\\n    /// @dev The minimum configurable minimum collateralization ratio.\\n    uint256 constant MIN_COLLATERALIZATION_RATIO = ONE_HUNDRED_PERCENT;\\n\\n    /// @dev The minimum configurable liquidation incentive multiplier.\\n    /// This means liquidator only receives equal amount of collateral to debt repaid.\\n    uint256 constant MIN_LIQUIDATION_INCENTIVE_MULTIPLIER = ONE_HUNDRED_PERCENT;\\n\\n    /// @dev The maximum configurable liquidation incentive multiplier.\\n    /// This means liquidator receives 25% bonus collateral compared to the debt repaid.\\n    uint256 constant MAX_LIQUIDATION_INCENTIVE_MULTIPLIER = 1.25 ether; // 125%\\n\\n    /// @dev The maximum configurable minimum debt USD value. 8 decimals.\\n    uint256 constant MAX_MIN_DEBT_VALUE = 1000 gwei; // $1,000\\n}\\n\\n/* -------------------------------------------------------------------------- */\\n/*                                    ENUM                                    */\\n/* -------------------------------------------------------------------------- */\\n\\n/**\\n * @dev Protocol user facing actions\\n *\\n * Deposit = 0\\n * Withdraw = 1,\\n * Repay = 2,\\n * Borrow = 3,\\n * Liquidate = 4\\n */\\nenum Action {\\n    Deposit,\\n    Withdraw,\\n    Repay,\\n    Borrow,\\n    Liquidation\\n}\\n/**\\n * @dev Fee types\\n *\\n * Open = 0\\n * Close = 1\\n */\\nenum Fee {\\n    Open,\\n    Close\\n}\\n\\n/* ========================================================================== */\\n/*                                   STRUCTS                                  */\\n/* ========================================================================== */\\n\\n/**\\n * @notice Initialization arguments for the protocol\\n */\\nstruct MinterInitArgs {\\n    address admin;\\n    address council;\\n    address treasury;\\n    uint8 extOracleDecimals;\\n    uint256 minimumCollateralizationRatio;\\n    uint256 minimumDebtValue;\\n    uint256 liquidationThreshold;\\n}\\n\\n/**\\n * @notice Configurable parameters within the protocol\\n */\\n\\nstruct MinterParams {\\n    uint256 minimumCollateralizationRatio;\\n    uint256 minimumDebtValue;\\n    uint256 liquidationThreshold;\\n    uint256 liquidationOverflowPercentage;\\n    address feeRecipient;\\n    uint8 extOracleDecimals;\\n}\\n\\n/**\\n * @notice Information on a token that is a KreskoAsset.\\n * @dev Each KreskoAsset has 18 decimals.\\n * @param kFactor The k-factor used for calculating the required collateral value for KreskoAsset debt.\\n * @param oracle The oracle that provides the USD price of one KreskoAsset.\\n * @param supplyLimit The total supply limit of the KreskoAsset.\\n * @param anchor The anchor address\\n * @param closeFee The percentage paid in fees when closing a debt position of this type.\\n * @param openFee The percentage paid in fees when opening a debt position of this type.\\n * @param exists Whether the KreskoAsset exists within the protocol.\\n */\\nstruct KrAsset {\\n    uint256 kFactor;\\n    AggregatorV2V3Interface oracle;\\n    AggregatorV2V3Interface marketStatusOracle;\\n    uint256 supplyLimit;\\n    address anchor;\\n    uint256 closeFee;\\n    uint256 openFee;\\n    bool exists;\\n}\\nusing LibAssetUtility for KrAsset global;\\n/**\\n * @notice Information on a token that can be used as collateral.\\n * @dev Setting the factor to zero effectively makes the asset useless as collateral while still allowing\\n * it to be deposited and withdrawn.\\n * @param factor The collateral factor used for calculating the value of the collateral.\\n * @param oracle The oracle that provides the USD price of one collateral asset.\\n * @param anchor If the collateral is a KreskoAsset, the anchor address\\n * @param decimals The decimals for the token, stored here to avoid repetitive external calls.\\n * @param exists Whether the collateral asset exists within the protocol.\\n * @param liquidationIncentive The liquidation incentive for the asset\\n */\\nstruct CollateralAsset {\\n    uint256 factor;\\n    AggregatorV2V3Interface oracle;\\n    AggregatorV2V3Interface marketStatusOracle;\\n    address anchor;\\n    uint8 decimals;\\n    bool exists;\\n    uint256 liquidationIncentive;\\n}\\nusing LibAssetUtility for CollateralAsset global;\\n\\n/// @notice Configuration for pausing `Action`\\nstruct Pause {\\n    bool enabled;\\n    uint256 timestamp0;\\n    uint256 timestamp1;\\n}\\n\\n/// @notice Safety configuration for assets\\nstruct SafetyState {\\n    Pause pause;\\n}\\n\",\"keccak256\":\"0xafb73561008616d6d2e73a67ffb6da4a52c304aaf80766f00a981088c98cdfb7\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/amm-oracle/IUniswapV2OracleCompat.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\nimport {IERC20Minimal} from \\\"../../vendor/uniswap/v2-core/interfaces/IERC20Minimal.sol\\\";\\nimport {IUniswapV2Factory} from \\\"../../vendor/uniswap/v2-periphery/libraries/UniswapV2Library.sol\\\";\\n\\n/// @notice without UQ values\\ninterface IUniswapV2OracleCompat {\\n    event NewAdmin(address indexed newAdmin);\\n    event NewMinUpdatePeriod(uint256 newMinUpdatePeriod);\\n    event NewPair(address indexed pair, address indexed token0, address indexed token1, uint256 updatePeriod);\\n    event PairUpdated(address indexed pair, address indexed token0, address indexed token1, uint256 updatePeriod);\\n\\n    event NewKrAssetPair(address indexed krAsset, address indexed pairAddress);\\n\\n    /// @notice returns the connected univ2 factory\\n    function factory() external view returns (IUniswapV2Factory);\\n\\n    /// @notice returns the incentive token for the incentivized update\\n    function incentiveToken() external view returns (IERC20Minimal);\\n\\n    /// @notice returns the amount of incentive tokens sent using the incentivized update\\n    function incentiveAmount() external view returns (uint256);\\n\\n    /// @notice returns the current admin of the oracle\\n    function admin() external view returns (address);\\n\\n    /// @notice returns the TWAP time period in seconds\\n    function minUpdatePeriod() external view returns (uint256);\\n\\n    /// @notice returns the pair address for a given krAsset\\n    function krAssets(address) external returns (address);\\n\\n    /**\\n     *\\n     * @param _newIncentiveToken new incentive token for updater\\n     * @param amount amount of incentive tokens\\n     */\\n    function setIncentiveToken(address _newIncentiveToken, uint256 amount) external;\\n\\n    /**\\n     * @notice Configures existing values of an AMM pair\\n     * @param _pairAddress Pair address\\n     * @param _updatePeriod Update period (TWAP)\\n     */\\n    function configurePair(address _pairAddress, uint256 _updatePeriod) external;\\n\\n    /**\\n     * @notice Get the AMM price for an amount of krAsset\\n     * @param _kreskoAsset Kresko asset address\\n     * @param _amountIn Amount of Kresko Asset to get value for\\n     */\\n    function consultKrAsset(address _kreskoAsset, uint256 _amountIn) external view returns (uint256 amountOut);\\n\\n    /**\\n     * @notice General consult function, gets a value for `_amountIn` of `_token` in terms of `_tokenOut`\\n     * @param _pairAddress Address of the pair that contains the token\\n     * @param _token Address of the token to get value for\\n     * @param _amountIn Amount of token to get value for\\n     * @return amountOut Amount of tokenOut that `_amountIn` of `_token` is worth\\n     */\\n    function consult(address _pairAddress, address _token, uint256 _amountIn) external view returns (uint256 amountOut);\\n\\n    /**\\n     * @notice Initializes an Uniswap V2 pair to be tracked by this oracle.\\n     *\\n     * The criteria for a pair to be tracked:\\n     * The pair must not already be tracked by this oracle.\\n     * The pair must exist.\\n     * The pair must have reserves.\\n     * The update period must be greater than the minimum update period.\\n     * @param _pairAddress Liquidity token address for the pair\\n     * @param _krAsset Kresko Asset in the pair we want to add helper functionality for\\n     * @param _updatePeriod The update period (TWAP) for this AMM pair\\n     *\\n     */\\n    function initPair(address _pairAddress, address _krAsset, uint256 _updatePeriod) external;\\n\\n    /**\\n     * @notice Updates the oracle values for a pair\\n     * @param _pairAddress Pair address\\n     */\\n    function update(address _pairAddress) external;\\n\\n    /**\\n     * @notice Sets a new admin\\n     * @param _newAdmin New admin address\\n     */\\n    function setAdmin(address _newAdmin) external;\\n\\n    /**\\n     * @notice Set a new min update period\\n     * @param _minUpdatePeriod The new minimum period that can be set for a pair\\n     */\\n    function setMinUpdatePeriod(uint256 _minUpdatePeriod) external;\\n\\n    /**\\n     * @notice Move any missent tokens\\n     * @param _erc20 drain any sent tokens\\n     * @param _to drain any sent tokens\\n     */\\n    function drainERC20(address _erc20, address _to) external;\\n\\n    /**\\n     * Update pair data with incentives sent\\n     * @param _kreskoAsset Kresko Asset in the pair we want to update pair data for\\n     */\\n    function updateWithIncentive(address _kreskoAsset) external;\\n}\\n\",\"keccak256\":\"0x1e4c82cdbda55571ce72e1ce3386afdd7326d020c6009590193b985d460789ef\",\"license\":\"MIT\"},\"src/contracts/minter/collateral-pool/CollateralPoolState.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\nimport {LibCollateralPool} from \\\"./libs/LibCollateralPool.sol\\\";\\nimport {LibSwap} from \\\"./libs/LibSwap.sol\\\";\\nimport {LibAmounts} from \\\"./libs/LibAmounts.sol\\\";\\nimport {IPositionsFacet} from \\\"./position/interfaces/IPositionsFacet.sol\\\";\\n\\n/* solhint-disable var-name-mixedcase */\\n\\nusing LibCollateralPool for CollateralPoolState global;\\nusing LibAmounts for CollateralPoolState global;\\nusing LibSwap for CollateralPoolState global;\\n\\nstruct PoolCollateral {\\n    uint256 liquidationIncentive;\\n    uint128 liquidityIndex;\\n    uint8 decimals;\\n}\\n\\nstruct PoolKrAsset {\\n    uint256 protocolFee; // Taken from the open/close fee. Goes to protocol.\\n    uint256 openFee;\\n    uint256 closeFee;\\n    uint256 supplyLimit;\\n}\\n\\n// Storage layout\\nstruct CollateralPoolState {\\n    /// @notice The minimum ratio of collateral to debt that can be taken by direct action.\\n    uint256 minimumCollateralizationRatio;\\n    /// @notice The collateralization ratio at which positions may be liquidated.\\n    uint256 liquidationThreshold;\\n    /// @notice Mapping of krAsset -> pooled debt\\n    mapping(address => uint256) debt;\\n    /// @notice Mapping of collateral -> pooled deposits\\n    mapping(address => uint256) totalDeposits;\\n    /// @notice Mapping of asset -> swap owned collateral deposits\\n    mapping(address => uint256) swapDeposits;\\n    /// @notice Mapping of account -> collateral -> collateral deposits.\\n    mapping(address => mapping(address => uint256)) deposits;\\n    /// @notice Mapping of account -> collateral -> principal collateral deposits.\\n    mapping(address => mapping(address => uint256)) depositsPrincipal;\\n    /// @notice Mapping of collateral -> PoolCollateral\\n    mapping(address => PoolCollateral) poolCollateral;\\n    /// @notice Mapping of krAsset -> PoolKreskoAsset\\n    mapping(address => PoolKrAsset) poolKrAsset;\\n    /// @notice Mapping of asset -> asset -> swap enabled\\n    mapping(address => mapping(address => bool)) isSwapEnabled;\\n    /// @notice Mapping of asset -> enabled\\n    mapping(address => bool) isEnabled;\\n    /// @notice Array of collateral assets that can be deposited\\n    address[] collaterals;\\n    /// @notice Array of kresko assets that can be minted and swapped.\\n    address[] krAssets;\\n    /// @notice User swap fee receiver\\n    address swapFeeRecipient;\\n    /// @notice Positions NFT\\n    IPositionsFacet positions;\\n}\\n\\n// Storage position\\nbytes32 constant COLLATEREAL_POOL_STORAGE_POSITION = keccak256(\\\"kresko.collateral.pool.storage\\\");\\n\\n// solhint-disable func-visibility\\nfunction cps() pure returns (CollateralPoolState storage state) {\\n    bytes32 position = COLLATEREAL_POOL_STORAGE_POSITION;\\n    assembly {\\n        state.slot := position\\n    }\\n}\\n\",\"keccak256\":\"0x1b26920398d20320ef417ebee5d02a30104ad127a137cb5d8f91c73a85b1da32\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/collateral-pool/interfaces/ICollateralPoolSwapFacet.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\nimport {Position, NewPosition} from \\\"../position/state/PositionsStorage.sol\\\";\\n\\ninterface ICollateralPoolSwapFacet {\\n    event Swap(\\n        address indexed who,\\n        address indexed assetIn,\\n        address indexed assetOut,\\n        uint256 amountIn,\\n        uint256 amountOut\\n    );\\n    event SwapFee(address indexed assetIn, uint256 feeAmount, uint256 protocolFeeAmount);\\n\\n    event Income(address asset, uint256 amount);\\n\\n    /// @notice Get a price for an asset. It is `extOracleDecimals()` of precision.\\n    function getPrice(address _asset) external view returns (uint256 price);\\n\\n    /**\\n     * @notice Preview the amount out received.\\n     * @param _assetIn The asset to pay with.\\n     * @param _assetOut The asset to receive.\\n     * @param _amountIn The amount of _assetIn to pay.\\n     * @param _leverage The leverage to use. 1e18 = 1x, 2e18 = 2x, etc.\\n     * @return amountOut The amount of `_assetOut` to receive according to `_amountIn`.\\n     */\\n    function previewSwap(\\n        address _assetIn,\\n        address _assetOut,\\n        uint256 _amountIn,\\n        uint256 _leverage\\n    ) external view returns (uint256 amountOut, uint256 feeAmount, uint256 protocolFee);\\n\\n    /**\\n     * @notice Swap kresko assets with KISS using the shared collateral pool.\\n     * Uses oracle pricing of _amountIn to determine how much _assetOut to send.\\n     * @param _account The receiver of amount out.\\n     * @param _assetIn The asset to pay with.\\n     * @param _assetOut The asset to receive.\\n     * @param _amountIn The amount of _assetIn to pay.\\n     * @param _amountOutMin The minimum amount of _assetOut to receive, this is due to possible oracle price change.\\n     */\\n    function swap(\\n        address _account,\\n        address _assetIn,\\n        address _assetOut,\\n        uint256 _amountIn,\\n        uint256 _amountOutMin\\n    ) external;\\n\\n    /// @notice deposit collateral into a position\\n    function positionDepositA(address _to, uint256 _amountA, Position memory _pos) external;\\n\\n    /// @notice withdraw collateral from a position\\n    function positionWithdrawA(address _from, uint256 _amountA, Position memory _pos) external;\\n\\n    /**\\n     * @notice Swap in to leverage. This is only callable by the positions NFT.\\n     * @param _sender The account that funds the position.\\n     * @param _pos The position to swap into.\\n     * @return amountAInAfterFee Amount in after fees are paid.\\n     * @return amountBOut Amount of `_assetOut` received.\\n     */\\n    function swapIntoLeverage(\\n        address _sender,\\n        NewPosition memory _pos\\n    ) external returns (uint256 amountAInAfterFee, uint256 amountBOut);\\n\\n    /**\\n     * @notice Swaps out of leverage. This is only callable by the positions NFT.\\n     * @notice Called by the position contract.\\n     * @param _pos The position to swap out of.\\n     * @param _liquidator The incentive receiver if position is liquidated or closed by external caller.\\n     * @return amountAOut The amount of `_assetOut` to receive.\\n     */\\n    function swapOutOfLeverage(Position memory _pos, address _liquidator) external returns (uint256 amountAOut);\\n\\n    /**\\n     * @notice Accumulates fees to deposits as a fixed, instantaneous income.\\n     * @param _incomeAsset the income asset\\n     * @param _amount amount to accumulate\\n     */\\n    function cumulateIncome(address _incomeAsset, uint256 _amount) external;\\n}\\n\",\"keccak256\":\"0x4b3374025742235349fabc6d24ce735212d4c460008c5e2d1d9a8b144a0de766\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/collateral-pool/libs/LibAmounts.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\nimport {CollateralPoolState} from \\\"../CollateralPoolState.sol\\\";\\nimport {ms} from \\\"../../MinterStorage.sol\\\";\\nimport {WadRay} from \\\"../../../libs/WadRay.sol\\\";\\n\\nlibrary LibAmounts {\\n    using WadRay for uint256;\\n    using WadRay for uint128;\\n    using LibAmounts for CollateralPoolState;\\n\\n    /**\\n     * @notice Get accounts interested scaled debt amount for a KreskoAsset.\\n     * @param _asset The asset address\\n     * @param _account The account to get the amount for\\n     * @return Amount of scaled debt.\\n     */\\n    function getAccountDepositsWithFees(\\n        CollateralPoolState storage self,\\n        address _account,\\n        address _asset\\n    ) internal view returns (uint256) {\\n        uint256 deposits = getCollateralAmountRead(_asset, self.deposits[_account][_asset]);\\n        if (deposits == 0) {\\n            return 0;\\n        }\\n        return deposits.rayMul(self.poolCollateral[_asset].liquidityIndex).rayToWad();\\n    }\\n\\n    /**\\n     * @notice Get accounts principle collateral deposits.\\n     * @param _account The account to get the amount for\\n     * @param _collateralAsset The collateral asset address\\n     * @return Amount of scaled debt.\\n     */\\n    function getAccountPrincipalDeposits(\\n        CollateralPoolState storage self,\\n        address _account,\\n        address _collateralAsset\\n    ) internal view returns (uint256) {\\n        uint256 deposits = self.getAccountDepositsWithFees(_account, _collateralAsset);\\n        uint256 depositsPrincipal = getCollateralAmountRead(\\n            _collateralAsset,\\n            self.depositsPrincipal[_account][_collateralAsset]\\n        );\\n\\n        if (deposits == 0) {\\n            return 0;\\n        } else if (deposits < depositsPrincipal) {\\n            return deposits;\\n        }\\n        return depositsPrincipal;\\n    }\\n\\n    /**\\n     * @notice Get pool collateral deposits of an asset.\\n     * @param _asset The asset address\\n     * @return Amount of scaled debt.\\n     */\\n    function getPoolDeposits(CollateralPoolState storage self, address _asset) internal view returns (uint256) {\\n        return getCollateralAmountRead(_asset, self.totalDeposits[_asset]);\\n    }\\n\\n    /**\\n     * @notice Get \\\"swap\\\" collateral deposits.\\n     * @param _asset The asset address\\n     * @return Amount of scaled debt.\\n     */\\n    function getPoolSwapDeposits(CollateralPoolState storage self, address _asset) internal view returns (uint256) {\\n        return getCollateralAmountRead(_asset, self.swapDeposits[_asset]);\\n    }\\n\\n    /**\\n     * @notice Get collateral asset amount for saving, it will be unrebased if the asset is a KreskoAsset\\n     * @param _asset The asset address\\n     * @param _amount The asset amount\\n     * @return possiblyUnrebasedAmount The possibly unrebased amount\\n     */\\n    function getCollateralAmountWrite(\\n        address _asset,\\n        uint256 _amount\\n    ) internal view returns (uint256 possiblyUnrebasedAmount) {\\n        return ms().collateralAssets[_asset].toNonRebasingAmount(_amount);\\n    }\\n\\n    /**\\n     * @notice Get collateral asset amount for viewing, since if the asset is a KreskoAsset, it can be rebased.\\n     * @param _asset The asset address\\n     * @param _amount The asset amount\\n     * @return possiblyRebasedAmount amount of collateral for `_asset`\\n     */\\n    function getCollateralAmountRead(\\n        address _asset,\\n        uint256 _amount\\n    ) internal view returns (uint256 possiblyRebasedAmount) {\\n        return ms().collateralAssets[_asset].toRebasingAmount(_amount);\\n    }\\n}\\n\",\"keccak256\":\"0x603dd1f1ab3c6fdc1b388100a11a021022b21ede3dec564c3b524b8bf3285544\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/collateral-pool/libs/LibCollateralPool.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {SafeERC20, IERC20Permit} from \\\"../../../shared/SafeERC20.sol\\\";\\nimport {WadRay} from \\\"../../../libs/WadRay.sol\\\";\\nimport {LibAmounts} from \\\"./LibAmounts.sol\\\";\\nimport {cps, CollateralPoolState} from \\\"../CollateralPoolState.sol\\\";\\nimport {ms} from \\\"../../MinterStorage.sol\\\";\\n\\n/* solhint-disable not-rely-on-time */\\n\\n/**\\n * @author Kresko\\n * @title Internal functions for shared collateral pool.\\n */\\nlibrary LibCollateralPool {\\n    using WadRay for uint256;\\n    using WadRay for uint128;\\n    using LibAmounts for CollateralPoolState;\\n    using LibCollateralPool for CollateralPoolState;\\n\\n    /**\\n     * @notice Records a deposit of collateral asset.\\n     * @dev Saves principal, scaled and global deposit amounts.\\n     * @param _account depositor\\n     * @param _collateralAsset the collateral asset\\n     * @param _depositAmount amount of collateral asset to deposit\\n     */\\n    function recordCollateralDeposit(\\n        CollateralPoolState storage self,\\n        address _account,\\n        address _collateralAsset,\\n        uint256 _depositAmount\\n    ) internal {\\n        require(self.isEnabled[_collateralAsset], \\\"asset-disabled\\\");\\n        uint256 depositAmount = LibAmounts.getCollateralAmountWrite(_collateralAsset, _depositAmount);\\n        unchecked {\\n            // Save global deposits.\\n            self.totalDeposits[_collateralAsset] += depositAmount;\\n            // Save principal deposits.\\n            self.depositsPrincipal[_account][_collateralAsset] += depositAmount;\\n            // Save scaled deposits.\\n            self.deposits[_account][_collateralAsset] += depositAmount.wadToRay().rayDiv(\\n                self.poolCollateral[_collateralAsset].liquidityIndex\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Records a withdrawal of collateral asset.\\n     * @param self Collateral Pool State\\n     * @param _account withdrawer\\n     * @param _collateralAsset collateral asset\\n     * @param collateralOut The actual amount of collateral withdrawn\\n     */\\n    function recordCollateralWithdrawal(\\n        CollateralPoolState storage self,\\n        address _account,\\n        address _collateralAsset,\\n        uint256 _amount\\n    ) internal returns (uint256 collateralOut, uint256 feesOut) {\\n        // Do not check for isEnabled, always allow withdrawals.\\n\\n        // Get accounts principal deposits.\\n        uint256 depositsPrincipal = self.getAccountPrincipalDeposits(_account, _collateralAsset);\\n\\n        if (depositsPrincipal >= _amount) {\\n            // == Principal can cover possibly rebased `_amount` requested.\\n            // 1. We send out the requested amount.\\n            collateralOut = _amount;\\n            // 2. No fees.\\n            // 3. Possibly un-rebased amount for internal bookeeping.\\n            uint256 withdrawAmountInternal = LibAmounts.getCollateralAmountWrite(_collateralAsset, _amount);\\n            unchecked {\\n                // 4. Reduce global deposits.\\n                self.totalDeposits[_collateralAsset] -= withdrawAmountInternal;\\n                // 5. Reduce principal deposits.\\n                self.depositsPrincipal[_account][_collateralAsset] -= withdrawAmountInternal;\\n                // 6. Reduce scaled deposits.\\n                self.deposits[_account][_collateralAsset] -= withdrawAmountInternal.wadToRay().rayDiv(\\n                    self.poolCollateral[_collateralAsset].liquidityIndex\\n                );\\n            }\\n        } else {\\n            // == Principal can't cover possibly rebased `_amount` requested, send full collateral available.\\n            // 1. We send all collateral.\\n            collateralOut = depositsPrincipal;\\n            // 2. With fees.\\n            feesOut = self.getAccountDepositsWithFees(_account, _collateralAsset) - depositsPrincipal;\\n            // 3. Ensure this is actually the case.\\n            require(feesOut > 0, \\\"withdrawal-violation\\\");\\n            // 4. Wipe account collateral deposits.\\n            self.depositsPrincipal[_account][_collateralAsset] = 0;\\n            self.deposits[_account][_collateralAsset] = 0;\\n            // 5. Reduce global by ONLY by the principal, fees are not collateral.\\n            self.totalDeposits[_collateralAsset] -= LibAmounts.getCollateralAmountWrite(\\n                _collateralAsset,\\n                depositsPrincipal\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks whether the collateral ratio is equal to or above to ratio supplied.\\n     * @param self Collateral Pool State\\n     * @param _collateralRatio ratio to check\\n     */\\n    function checkRatio(CollateralPoolState storage self, uint256 _collateralRatio) internal view returns (bool) {\\n        return\\n            self.getTotalPoolDepositValue(\\n                false // dont ignore cFactor\\n            ) >= self.getTotalPoolKrAssetValueAtRatio(_collateralRatio, false); // dont ignore kFactors or MCR;\\n    }\\n\\n    /**\\n     * @notice Checks whether the collateral ratio is equal to or above to ratio supplied after withdrawal.\\n     * @param self Collateral Pool State\\n     * @param _collateralAsset collateral asset\\n     * @param _withdrawalAmount amount of collateral asset to withdraw\\n     * @param _collateralRatio ratio to check\\n     */\\n    function checkRatio(\\n        CollateralPoolState storage self,\\n        address _collateralAsset,\\n        uint256 _withdrawalAmount,\\n        uint256 _collateralRatio\\n    ) internal view returns (bool) {\\n        // total collateral and withdrawal value\\n        (uint256 totalValue, uint256 withdrawalValue) = self.getTotalPoolDepositValue(\\n            _collateralAsset,\\n            _withdrawalAmount,\\n            false // dont ignore cFactor\\n        );\\n        return totalValue - withdrawalValue >= self.getTotalPoolKrAssetValueAtRatio(_collateralRatio, false); // dont ignore collaterRatio.\\n    }\\n\\n    /**\\n     * @notice Checks whether the shared debt pool can be liquidated.\\n     * @param self Collateral Pool State\\n     */\\n    function isLiquidatable(CollateralPoolState storage self) internal view returns (bool) {\\n        return !self.checkRatio(self.liquidationThreshold);\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                             Value Calculations                             */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /**\\n     * @notice Returns the value of the krAsset held in the pool at a ratio.\\n     * @param self Collateral Pool State\\n     * @param _ratio ratio\\n     * @param _ignorekFactor ignore kFactor\\n     * @return value in USD\\n     */\\n    function getTotalPoolKrAssetValueAtRatio(\\n        CollateralPoolState storage self,\\n        uint256 _ratio,\\n        bool _ignorekFactor\\n    ) internal view returns (uint256 value) {\\n        address[] memory assets = self.krAssets;\\n        for (uint256 i; i < assets.length; i++) {\\n            address asset = assets[i];\\n            value += ms().getKrAssetValue(asset, ms().getKreskoAssetAmount(asset, self.debt[asset]), _ignorekFactor);\\n        }\\n\\n        // We dont need to multiply this.\\n        if (_ratio == 1 ether) {\\n            return value;\\n        }\\n\\n        return value.wadMul(_ratio);\\n    }\\n\\n    /**\\n     * @notice Calculates the total collateral value of collateral assets in the pool.\\n     * @param self Collateral Pool State\\n     * @param _ignoreFactors whether to ignore factors\\n     * @return value in USD\\n     */\\n    function getTotalPoolDepositValue(\\n        CollateralPoolState storage self,\\n        bool _ignoreFactors\\n    ) internal view returns (uint256 value) {\\n        address[] memory assets = self.collaterals;\\n        for (uint256 i; i < assets.length; i++) {\\n            address asset = assets[i];\\n            (uint256 assetValue, ) = ms().getCollateralValueAndOraclePrice(\\n                asset,\\n                self.getPoolDeposits(asset),\\n                _ignoreFactors\\n            );\\n            value += assetValue;\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the value of the collateral asset in the pool and the value of the amount.\\n     * Saves gas for getting the values in the same execution.\\n     * @param _collateralAsset collateral asset\\n     * @param _amount amount of collateral asset\\n     * @param _ignoreFactors whether to ignore cFactor and kFactor\\n     */\\n    function getTotalPoolDepositValue(\\n        CollateralPoolState storage self,\\n        address _collateralAsset,\\n        uint256 _amount,\\n        bool _ignoreFactors\\n    ) internal view returns (uint256 totalValue, uint256 amountValue) {\\n        address[] memory assets = self.collaterals;\\n        for (uint256 i; i < assets.length; i++) {\\n            address asset = assets[i];\\n            (uint256 assetValue, uint256 price) = ms().getCollateralValueAndOraclePrice(\\n                asset,\\n                self.getPoolDeposits(asset),\\n                _ignoreFactors\\n            );\\n\\n            totalValue += assetValue;\\n            if (asset == _collateralAsset) {\\n                amountValue = _amount.wadMul(\\n                    _ignoreFactors ? price : price.wadMul(ms().collateralAssets[asset].factor)\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the value of the collateral assets in the pool for `_account`.\\n     * @param _account account\\n     * @param _ignoreFactors whether to ignore cFactor and kFactor\\n     */\\n    function getAccountTotalDepositValuePrincipal(\\n        CollateralPoolState storage self,\\n        address _account,\\n        bool _ignoreFactors\\n    ) internal view returns (uint256 totalValue) {\\n        address[] memory assets = self.collaterals;\\n        for (uint256 i; i < assets.length; i++) {\\n            address asset = assets[i];\\n            (uint256 assetValue, ) = ms().getCollateralValueAndOraclePrice(\\n                asset,\\n                self.getAccountPrincipalDeposits(_account, asset),\\n                _ignoreFactors\\n            );\\n\\n            totalValue += assetValue;\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the value of the collateral assets in the pool for `_account` with fees.\\n     * @notice Ignores all factors.\\n     * @param _account account\\n     */\\n    function getAccountTotalDepositValueWithFees(\\n        CollateralPoolState storage self,\\n        address _account\\n    ) internal view returns (uint256 totalValue) {\\n        address[] memory assets = self.collaterals;\\n        for (uint256 i; i < assets.length; i++) {\\n            address asset = assets[i];\\n            (uint256 assetValue, ) = ms().getCollateralValueAndOraclePrice(\\n                asset,\\n                self.getAccountDepositsWithFees(_account, asset),\\n                true\\n            );\\n\\n            totalValue += assetValue;\\n        }\\n    }\\n\\n    /// @notice This function seizes collateral from the shared pool\\n    /// @notice Adjusts everyones deposits if swap deposits do not cover the amount.\\n    function adjustSeizedCollateral(\\n        CollateralPoolState storage self,\\n        address _seizeAsset,\\n        uint256 _seizeAmount\\n    ) internal {\\n        uint256 swapDeposits = self.getPoolSwapDeposits(_seizeAsset); // current \\\"swap\\\" collateral\\n\\n        if (swapDeposits >= _seizeAmount) {\\n            uint256 amountOutInternal = LibAmounts.getCollateralAmountWrite(_seizeAsset, _seizeAmount);\\n            // swap deposits cover the amount\\n            self.swapDeposits[_seizeAsset] -= amountOutInternal;\\n            self.totalDeposits[_seizeAsset] -= amountOutInternal;\\n        } else {\\n            // swap deposits do not cover the amount\\n            uint256 amountToCover = _seizeAmount - swapDeposits;\\n            self.swapDeposits[_seizeAsset] = 0;\\n\\n            // reduce everyones deposits by the same ratio\\n            self.poolCollateral[_seizeAsset].liquidityIndex -= uint128(\\n                amountToCover.wadToRay().rayDiv(self.getPoolDeposits(_seizeAsset).wadToRay())\\n            );\\n\\n            self.totalDeposits[_seizeAsset] -= LibAmounts.getCollateralAmountWrite(_seizeAsset, amountToCover);\\n        }\\n    }\\n\\n    // /**\\n    //  * @notice Returns the krAsset value of a single asset in the pool.\\n    //  * Performs possible rebasing conversions for the pool balance.\\n    //  * @param self Collateral Pool State\\n    //  * @param _kreskoAsset krAsset\\n    //  * @param _ignorekFactor whether to ignore the k factor\\n    //  * @return value The krAsset value in USD\\n    //  */\\n    // function getPoolKrAssetValue(\\n    //     CollateralPoolState storage self,\\n    //     address _kreskoAsset,\\n    //     bool _ignorekFactor\\n    // ) internal view returns (uint256 value) {\\n\\n    // }\\n\\n    // /**\\n    //  * @notice Get the current price rate between AMM and oracle pricing\\n    //  * @dev Raw return value of ammPrice == 0 when no AMM pair exists OR liquidity of the pair does not qualify\\n    //  * @param self rate configuration for the asset\\n    //  * @return priceRate the current price rate\\n    //  */\\n    // function getPriceRate(StabilityRateConfig storage self) internal view returns (uint256 priceRate) {\\n    //     FixedPoint.Unsigned memory oraclePrice = ms().getKrAssetValue(self.asset, 1 ether, true);\\n    //     FixedPoint.Unsigned memory ammPrice = ms().getKrAssetAMMPrice(self.asset, 1 ether);\\n    //     // no pair, no effect\\n    //     if (ammPrice.rawValue == 0) {\\n    //         return 0;\\n    //     }\\n    //     return ammPrice.div(oraclePrice).div(10).rawValue;\\n    // }\\n}\\n\",\"keccak256\":\"0xa07ec223cd17f9e32afd85498ef2e73c3d0202280c82462da7e2da33b90de5d8\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/collateral-pool/libs/LibSwap.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {SafeERC20, IERC20Permit} from \\\"../../../shared/SafeERC20.sol\\\";\\n\\nimport {WadRay} from \\\"../../../libs/WadRay.sol\\\";\\nimport {Error} from \\\"../../../libs/Errors.sol\\\";\\n\\nimport {LibAmounts} from \\\"./LibAmounts.sol\\\";\\nimport {cps, CollateralPoolState, PoolKrAsset} from \\\"../CollateralPoolState.sol\\\";\\nimport {ms} from \\\"../../MinterStorage.sol\\\";\\nimport {irs} from \\\"../../InterestRateState.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/* solhint-disable not-rely-on-time */\\n\\n/**\\n * @author Kresko\\n * @title Internal functions for shared collateral pool.\\n */\\nlibrary LibSwap {\\n    using WadRay for uint256;\\n    using WadRay for uint128;\\n    using SafeERC20 for IERC20Permit;\\n\\n    /**\\n     * @notice Check that assets can be swapped.\\n     * @return feePercentage fee percentage for this swap\\n     */\\n    function checkAssets(\\n        CollateralPoolState storage self,\\n        address _assetIn,\\n        address _assetOut\\n    ) internal view returns (uint256 feePercentage, uint256 protocolFee) {\\n        require(self.isSwapEnabled[_assetIn][_assetOut], \\\"swap-disabled\\\");\\n        require(self.isEnabled[_assetIn], \\\"asset-in-disabled\\\");\\n        require(self.isEnabled[_assetOut], \\\"asset-out-disabled\\\");\\n        require(_assetIn != _assetOut, \\\"same-asset\\\");\\n        PoolKrAsset memory assetIn = self.poolKrAsset[_assetIn];\\n        PoolKrAsset memory assetOut = self.poolKrAsset[_assetOut];\\n\\n        feePercentage = assetOut.openFee + assetIn.closeFee;\\n        protocolFee = assetIn.protocolFee + assetOut.protocolFee;\\n    }\\n\\n    /**\\n     * @notice Records the assets received from account in a swap.\\n     * Burning any existing shared debt or increasing collateral deposits.\\n     * @param _assetIn The asset received.\\n     * @param _amountIn The amount of the asset received.\\n     * @param _assetsFrom The account that holds the assets to burn.\\n     * @return valueIn The value of the assets received into the protocol, used to calculate assets out.\\n     */\\n    function handleAssetsIn(\\n        CollateralPoolState storage self,\\n        address _assetIn,\\n        uint256 _amountIn,\\n        address _assetsFrom\\n    ) internal returns (uint256 valueIn) {\\n        uint256 debt = ms().getKreskoAssetAmount(_assetIn, self.debt[_assetIn]);\\n        valueIn = ms().getKrAssetValue(_assetIn, _amountIn, true); // ignore kFactor here\\n\\n        uint256 collateralIn; // assets used increase \\\"swap\\\" owned collateral\\n        uint256 debtOut; // assets used to burn debt\\n\\n        // Bookkeeping\\n        if (debt >= _amountIn) {\\n            // == Debt is equal to or greater than the amount.\\n            // 1. Burn full amount received.\\n            debtOut = _amountIn;\\n            // 2. No increase in collateral.\\n        } else if (debt < _amountIn) {\\n            // == Debt is less than the amount received.\\n            // 1. Burn full debt.\\n            debtOut = debt;\\n            // 2. Increase collateral by remainder.\\n            collateralIn = _amountIn - debt;\\n        } else {\\n            // == Debt is 0.\\n            // 1. Burn nothing.\\n            // 2. Increase collateral by full amount.\\n            collateralIn = _amountIn;\\n        }\\n\\n        if (collateralIn > 0) {\\n            uint256 collateralInInternal = LibAmounts.getCollateralAmountWrite(_assetIn, collateralIn);\\n            // 1. Increase collateral deposits.\\n            self.totalDeposits[_assetIn] += collateralInInternal;\\n            // 2. Increase \\\"swap\\\" collateral.\\n            self.swapDeposits[_assetIn] += collateralInInternal;\\n        }\\n\\n        if (debtOut > 0) {\\n            // 1. Burn debt that was repaid from the assets received.\\n            self.debt[_assetIn] -= ms().repaySwap(_assetIn, debtOut, _assetsFrom);\\n        }\\n\\n        require(_amountIn == debtOut + collateralIn, \\\"assets-in-mismatch\\\");\\n    }\\n\\n    /**\\n     * @notice Records the assets to send out in a swap.\\n     * Increasing debt of the pool by minting new assets when required.\\n     * @param _assetOut The asset to send out.\\n     * @param _valueIn The value received in.\\n     * @param _assetsTo The asset receiver.\\n     * @return amountOut The amount of the asset out.\\n     */\\n    function handleAssetsOut(\\n        CollateralPoolState storage self,\\n        address _assetOut,\\n        uint256 _valueIn,\\n        address _assetsTo\\n    ) internal returns (uint256 amountOut) {\\n        // Calculate amount to send out from value received in.\\n        amountOut = _valueIn.wadDiv(ms().kreskoAssets[_assetOut].uintPrice());\\n        // Well, should be more than 0.\\n        require(amountOut > 0, \\\"amount-out-is-zero\\\");\\n\\n        uint256 swapDeposits = self.getPoolSwapDeposits(_assetOut); // current \\\"swap\\\" collateral\\n\\n        uint256 collateralOut; // decrease in \\\"swap\\\" collateral\\n        uint256 debtIn; // new debt required to mint\\n\\n        // Bookkeeping\\n        if (swapDeposits == 0) {\\n            // == No \\\"swap\\\" owned collateral available.\\n            // 1. Issue full amount as debt.\\n            debtIn = amountOut;\\n            // 2. No decrease in collateral.\\n        } else if (swapDeposits >= amountOut) {\\n            // == \\\"Swap\\\" owned collateral exceeds requested amount\\n            // 1. No debt issued.\\n            // 2. Decrease collateral by full amount.\\n            collateralOut = amountOut;\\n        } else {\\n            // == \\\"Swap\\\" owned collateral is less than requested amount.\\n            // 1. Issue debt for remainder.\\n            debtIn = amountOut - swapDeposits;\\n            // 2. Reduce \\\"swap\\\" owned collateral to zero.\\n            collateralOut = swapDeposits;\\n        }\\n        if (collateralOut > 0) {\\n            uint256 amountOutInternal = LibAmounts.getCollateralAmountWrite(_assetOut, collateralOut);\\n            // 1. Decrease collateral deposits.\\n            self.totalDeposits[_assetOut] -= amountOutInternal;\\n            // 2. Decrease \\\"swap\\\" owned collateral.\\n            self.swapDeposits[_assetOut] -= amountOutInternal;\\n            if (_assetsTo != address(this)) {\\n                // 3. Transfer collateral to receiver if it is not this contract.\\n                IERC20Permit(_assetOut).safeTransfer(_assetsTo, collateralOut);\\n            }\\n        }\\n\\n        if (debtIn > 0) {\\n            // 1. Issue required debt to the pool, minting new assets to receiver.\\n            self.debt[_assetOut] += ms().mintSwap(_assetOut, debtIn, _assetsTo);\\n        }\\n\\n        require(amountOut == debtIn + collateralOut, \\\"amount-out-mismatch\\\");\\n    }\\n\\n    function handleProfitsOut(\\n        CollateralPoolState storage self,\\n        address _assetOut,\\n        uint256 _balanceOut,\\n        uint256 _profitsOut,\\n        address _assetsTo\\n    ) internal returns (uint256 transferOut) {\\n        // Well, should be more than 0.\\n        require(_profitsOut > 0, \\\"amount-out-is-zero\\\");\\n        require(_assetsTo != address(this), \\\"profit-to-this\\\");\\n\\n        uint256 swapDeposits = self.getPoolSwapDeposits(_assetOut); // current \\\"swap\\\" collateral\\n\\n        uint256 collateralOut; // decrease in \\\"swap\\\" collateral\\n        uint256 debtIn; // new debt required to mint\\n\\n        // Bookkeeping\\n        if (swapDeposits == 0) {\\n            // == No \\\"swap\\\" owned collateral available.\\n            // 1. Issue full amount as debt.\\n            debtIn = _profitsOut;\\n            // 2. No decrease in collateral.\\n        } else if (swapDeposits >= _profitsOut) {\\n            // == \\\"Swap\\\" owned collateral exceeds requested amount\\n            // 1. No debt issued.\\n            // 2. Decrease collateral by full amount.\\n            collateralOut = _profitsOut;\\n        } else {\\n            // == \\\"Swap\\\" owned collateral is less than requested amount.\\n            // 1. Issue debt for remainder.\\n            debtIn = _profitsOut - swapDeposits;\\n            // 2. Reduce \\\"swap\\\" owned collateral to zero.\\n            collateralOut = swapDeposits;\\n        }\\n        if (collateralOut > 0) {\\n            uint256 amountOutInternal = LibAmounts.getCollateralAmountWrite(_assetOut, collateralOut);\\n            // 1. Decrease collateral deposits.\\n            self.totalDeposits[_assetOut] -= amountOutInternal;\\n            // 2. Decrease \\\"swap\\\" owned collateral.\\n            self.swapDeposits[_assetOut] -= amountOutInternal;\\n        }\\n        if (debtIn > 0) {\\n            // 1. Issue required debt to the pool, minting new assets to receiver.\\n            self.debt[_assetOut] += ms().mintSwap(_assetOut, debtIn, _assetsTo);\\n        }\\n\\n        require(_profitsOut == debtIn + collateralOut, \\\"profit-out-mismatch\\\");\\n        transferOut = collateralOut > 0 ? _balanceOut + collateralOut : _balanceOut;\\n    }\\n\\n    /**\\n     * @notice Accumulates fees to deposits as a fixed, instantaneous income.\\n     * @param _collateralAsset asset\\n     * @param _amount amount to accumulate\\n     * @return nextLiquidityIndex The next liquidity index of the reserve\\n     */\\n    function cumulateIncome(\\n        CollateralPoolState storage self,\\n        address _collateralAsset,\\n        uint256 _amount\\n    ) internal returns (uint256 nextLiquidityIndex) {\\n        //next liquidity index is calculated this way: `((amount / totalLiquidity) + 1) * liquidityIndex`\\n        //division `amount / totalLiquidity` done in ray for precision\\n        uint256 result = (_amount.wadToRay().rayDiv(self.getPoolDeposits(_collateralAsset).wadToRay()) + WadRay.RAY)\\n            .rayMul(self.poolCollateral[_collateralAsset].liquidityIndex);\\n        self.poolCollateral[_collateralAsset].liquidityIndex = uint128(result);\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x3ec95207555d15d6f844e0322def6e9c4a05297d93d8d82dcd27d4b94de26e2f\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/collateral-pool/position/facets/LayerZeroFacet.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity <=0.8.19;\\n\\nimport {ERC721} from \\\"../state/ERC721Storage.sol\\\";\\nimport {IONFT721CoreUpgradeable} from \\\"../interfaces/IONFT721CoreUpgradeable.sol\\\";\\nimport {IONFT721Upgradeable} from \\\"../interfaces/IONFT721Upgradeable.sol\\\";\\nimport {IERC721Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport {IERC721MetadataUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\\\";\\nimport {IERC165Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\\\";\\nimport {ILayerZeroEndpointUpgradeable} from \\\"../interfaces/ILayerZeroEndpointUpgradeable.sol\\\";\\nimport {ILayerZeroReceiverUpgradeable} from \\\"../interfaces/ILayerZeroReceiverUpgradeable.sol\\\";\\nimport {ILayerZeroUserApplicationConfigUpgradeable} from \\\"../interfaces/ILayerZeroUserApplicationConfigUpgradeable.sol\\\";\\nimport {lz, LibLZ, StoredCredit} from \\\"../state/LZStorage.sol\\\";\\nimport {Meta} from \\\"../../../../libs/Meta.sol\\\";\\nimport {ds} from \\\"../../../../diamond/DiamondStorage.sol\\\";\\nimport {IERC165Facet} from \\\"../../../../diamond/interfaces/IERC165Facet.sol\\\";\\nimport {BytesLib} from \\\"../libs/BytesLib.sol\\\";\\nimport {ExcessivelySafeCall} from \\\"../libs/ExcessivelySafeCall.sol\\\";\\nimport {DiamondModifiers} from \\\"../../../../diamond/DiamondModifiers.sol\\\";\\n\\ncontract LayerZeroFacet is\\n    IERC165Facet,\\n    IONFT721CoreUpgradeable,\\n    ILayerZeroReceiverUpgradeable,\\n    ILayerZeroUserApplicationConfigUpgradeable,\\n    DiamondModifiers\\n{\\n    using BytesLib for bytes;\\n    using ExcessivelySafeCall for address;\\n\\n    function setupLayerZero(uint256 _minGasToTransfer, ILayerZeroEndpointUpgradeable _lzEndpoint) external onlyOwner {\\n        require(_minGasToTransfer != 0, LibLZ.MINGASZERO);\\n        lz().minGasToTransferAndStore = _minGasToTransfer;\\n\\n        require(address(_lzEndpoint) != address(0), LibLZ.INVALID_ENDPOINT);\\n        lz().lzEndpoint = _lzEndpoint;\\n    }\\n\\n    function getConfig(\\n        uint16 _version,\\n        uint16 _chainId,\\n        address,\\n        uint _configType\\n    ) external view returns (bytes memory) {\\n        return lz().lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\\n    }\\n\\n    // generic config for LayerZero user Application\\n    function setConfig(\\n        uint16 _version,\\n        uint16 _chainId,\\n        uint _configType,\\n        bytes calldata _config\\n    ) external override onlyOwner {\\n        lz().lzEndpoint.setConfig(_version, _chainId, _configType, _config);\\n    }\\n\\n    /// @inheritdoc IERC165Facet\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) external view override(IERC165Facet, IERC165Upgradeable) returns (bool) {\\n        return\\n            (interfaceId != 0xffffffff && interfaceId == type(IERC721Upgradeable).interfaceId) ||\\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\\n            interfaceId == type(IONFT721Upgradeable).interfaceId ||\\n            interfaceId == type(IONFT721CoreUpgradeable).interfaceId ||\\n            ds().supportedInterfaces[interfaceId];\\n    }\\n\\n    /// @inheritdoc IERC165Facet\\n    function setERC165(bytes4[] calldata interfaceIds, bytes4[] calldata interfaceIdsToRemove) external onlyOwner {\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            ds().supportedInterfaces[interfaceIds[i]] = true;\\n        }\\n\\n        for (uint256 i = 0; i < interfaceIdsToRemove.length; i++) {\\n            ds().supportedInterfaces[interfaceIdsToRemove[i]] = false;\\n        }\\n    }\\n\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\\n        lz().lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\\n    }\\n\\n    function setSendVersion(uint16 _version) external override onlyOwner {\\n        lz().lzEndpoint.setSendVersion(_version);\\n    }\\n\\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\\n        lz().lzEndpoint.setReceiveVersion(_version);\\n    }\\n\\n    // _path = abi.encodePacked(remoteAddress, localAddress)\\n    // this function set the trusted path for the cross-chain communication\\n    function setTrustedRemote(uint16 _srcChainId, bytes calldata _path) external onlyOwner {\\n        lz().trustedRemoteLookup[_srcChainId] = _path;\\n        emit LibLZ.SetTrustedRemote(_srcChainId, _path);\\n    }\\n\\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\\n        lz().trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\\n        emit LibLZ.SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\\n    }\\n\\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\\n        bytes memory path = lz().trustedRemoteLookup[_remoteChainId];\\n        require(path.length != 0, \\\"LzApp: no trusted path record\\\");\\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\\n    }\\n\\n    function setPrecrime(address _precrime) external onlyOwner {\\n        lz().precrime = _precrime;\\n        emit LibLZ.SetPrecrime(_precrime);\\n    }\\n\\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\\n        require(_minGas > 0, \\\"LzApp: invalid minGas\\\");\\n        lz().minDstGasLookup[_dstChainId][_packetType] = _minGas;\\n        emit LibLZ.SetMinDstGas(_dstChainId, _packetType, _minGas);\\n    }\\n\\n    // if the size is 0, it means default size limit\\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\\n        lz().payloadSizeLimitLookup[_dstChainId] = _size;\\n    }\\n\\n    //--------------------------- VIEW FUNCTION ----------------------------------------\\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\\n        bytes memory trustedSource = lz().trustedRemoteLookup[_srcChainId];\\n        return keccak256(trustedSource) == keccak256(_srcAddress);\\n    }\\n\\n    function setMinGasToTransferAndStore(uint256 _minGasToTransferAndStore) external onlyOwner {\\n        require(_minGasToTransferAndStore > 0, LibLZ.MIN_GAS_NOT_ZERO);\\n        lz().minGasToTransferAndStore = _minGasToTransferAndStore;\\n    }\\n\\n    // ensures enough gas in adapter params to handle batch transfer gas amounts on the dst\\n    function setDstChainIdToTransferGas(uint16 _dstChainId, uint256 _dstChainIdToTransferGas) external onlyOwner {\\n        require(_dstChainIdToTransferGas > 0, LibLZ.MIN_GAS_NOT_ZERO);\\n        lz().dstChainIdToTransferGas[_dstChainId] = _dstChainIdToTransferGas;\\n    }\\n\\n    // limit on src the amount of tokens to batch send\\n    function setDstChainIdToBatchLimit(uint16 _dstChainId, uint256 _dstChainIdToBatchLimit) external onlyOwner {\\n        require(_dstChainIdToBatchLimit > 0, LibLZ.MIN_GAS_NOT_ZERO);\\n        lz().dstChainIdToBatchLimit[_dstChainId] = _dstChainIdToBatchLimit;\\n    }\\n\\n    function sendFrom(\\n        address _from,\\n        uint16 _dstChainId,\\n        bytes memory _toAddress,\\n        uint _tokenId,\\n        address payable _refundAddress,\\n        address _zroPaymentAddress,\\n        bytes memory _adapterParams\\n    ) external payable virtual override {\\n        require(_from == ds().contractOwner, \\\"not supported yet\\\");\\n        lz().send(\\n            _from,\\n            _dstChainId,\\n            _toAddress,\\n            _toSingletonArray(_tokenId),\\n            _refundAddress,\\n            _zroPaymentAddress,\\n            _adapterParams\\n        );\\n    }\\n\\n    function sendBatchFrom(\\n        address _from,\\n        uint16 _dstChainId,\\n        bytes memory _toAddress,\\n        uint[] memory _tokenIds,\\n        address payable _refundAddress,\\n        address _zroPaymentAddress,\\n        bytes memory _adapterParams\\n    ) external payable virtual override {\\n        require(_from == ds().contractOwner, \\\"not supported yet\\\");\\n        lz().send(_from, _dstChainId, _toAddress, _tokenIds, _refundAddress, _zroPaymentAddress, _adapterParams);\\n    }\\n\\n    // Public function for anyone to clear and deliver the remaining batch sent tokenIds\\n    function clearCredits(bytes memory _payload) external {\\n        require(msg.sender == ds().contractOwner, \\\"not supported yet\\\");\\n        bytes32 hashedPayload = keccak256(_payload);\\n        require(lz().storedCredits[hashedPayload].creditsRemain, LibLZ.NO_CREDITS_STORED);\\n\\n        (, uint[] memory tokenIds) = abi.decode(_payload, (bytes, uint[]));\\n\\n        uint nextIndex = lz().creditTill(\\n            lz().storedCredits[hashedPayload].srcChainId,\\n            lz().storedCredits[hashedPayload].toAddress,\\n            lz().storedCredits[hashedPayload].index,\\n            tokenIds\\n        );\\n        require(nextIndex > lz().storedCredits[hashedPayload].index, LibLZ.NO_GAS_REMAINING);\\n\\n        if (nextIndex == tokenIds.length) {\\n            // cleared the credits, delete the element\\n            delete lz().storedCredits[hashedPayload];\\n            emit CreditCleared(hashedPayload);\\n        } else {\\n            // store the next index to mint\\n            lz().storedCredits[hashedPayload] = StoredCredit(\\n                lz().storedCredits[hashedPayload].srcChainId,\\n                lz().storedCredits[hashedPayload].toAddress,\\n                nextIndex,\\n                true\\n            );\\n        }\\n    }\\n\\n    function estimateSendFee(\\n        uint16 _dstChainId,\\n        bytes memory _toAddress,\\n        uint _tokenId,\\n        bool _useZro,\\n        bytes memory _adapterParams\\n    ) public view virtual override returns (uint nativeFee, uint zroFee) {\\n        return lz().estimateFees(_dstChainId, _toAddress, _toSingletonArray(_tokenId), _useZro, _adapterParams);\\n    }\\n\\n    function estimateSendBatchFee(\\n        uint16 _dstChainId,\\n        bytes memory _toAddress,\\n        uint[] memory _tokenIds,\\n        bool _useZro,\\n        bytes memory _adapterParams\\n    ) public view virtual override returns (uint nativeFee, uint zroFee) {\\n        return lz().estimateFees(_dstChainId, _toAddress, _tokenIds, _useZro, _adapterParams);\\n    }\\n\\n    function _toSingletonArray(uint element) internal pure returns (uint[] memory) {\\n        uint[] memory array = new uint[](1);\\n        array[0] = element;\\n        return array;\\n    }\\n\\n    function lzReceive(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress,\\n        uint64 _nonce,\\n        bytes calldata _payload\\n    ) public virtual override {\\n        // lzReceive must be called by the endpoint for security\\n        require(Meta.msgSender() == address(lz().lzEndpoint), \\\"LzApp: invalid endpoint caller\\\");\\n\\n        bytes memory trustedRemote = lz().trustedRemoteLookup[_srcChainId];\\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\\n        require(\\n            _srcAddress.length == trustedRemote.length &&\\n                trustedRemote.length > 0 &&\\n                keccak256(_srcAddress) == keccak256(trustedRemote),\\n            \\\"LzApp: invalid source sending contract\\\"\\n        );\\n\\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\\n    }\\n\\n    // overriding the virtual function in LzReceiver\\n    function _blockingLzReceive(\\n        uint16 _srcChainId,\\n        bytes memory _srcAddress,\\n        uint64 _nonce,\\n        bytes memory _payload\\n    ) internal {\\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(\\n            gasleft(),\\n            150,\\n            abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload)\\n        );\\n        // try-catch all errors/exceptions\\n        if (!success) {\\n            lz().failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\\n            emit LibLZ.MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);\\n        }\\n    }\\n\\n    function nonblockingLzReceive(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress,\\n        uint64 _nonce,\\n        bytes calldata _payload\\n    ) external {\\n        // only internal transaction\\n        require(Meta.msgSender() == address(this), \\\"NonblockingLzApp: caller must be LzApp\\\");\\n        lz().nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\\n    }\\n\\n    function retryMessage(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress,\\n        uint64 _nonce,\\n        bytes calldata _payload\\n    ) external payable virtual {\\n        // assert there is message to retry\\n        bytes32 payloadHash = lz().failedMessages[_srcChainId][_srcAddress][_nonce];\\n        require(payloadHash != bytes32(0), \\\"NonblockingLzApp: no stored message\\\");\\n        require(keccak256(_payload) == payloadHash, \\\"NonblockingLzApp: invalid payload\\\");\\n        // clear the stored message\\n        lz().failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\\n        // execute the message. revert if it fails again\\n        lz().nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\\n        emit LibLZ.RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\\n    }\\n}\\n\",\"keccak256\":\"0xf7a0272fea36799f56dde07ee7e2c516b06c1b205db36938aa80c7040a403a31\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/collateral-pool/position/interfaces/ILayerZeroEndpointUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"./ILayerZeroUserApplicationConfigUpgradeable.sol\\\";\\n\\ninterface ILayerZeroEndpointUpgradeable is ILayerZeroUserApplicationConfigUpgradeable {\\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\\n    // @param _payload - a custom bytes payload to send to the destination contract\\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\\n    function send(\\n        uint16 _dstChainId,\\n        bytes calldata _destination,\\n        bytes calldata _payload,\\n        address payable _refundAddress,\\n        address _zroPaymentAddress,\\n        bytes calldata _adapterParams\\n    ) external payable;\\n\\n    // @notice used by the messaging library to publish verified payload\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source contract (as bytes) at the source chain\\n    // @param _dstAddress - the address on destination chain\\n    // @param _nonce - the unbound message ordering nonce\\n    // @param _gasLimit - the gas limit for external contract execution\\n    // @param _payload - verified payload to send to the destination contract\\n    function receivePayload(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress,\\n        address _dstAddress,\\n        uint64 _nonce,\\n        uint _gasLimit,\\n        bytes calldata _payload\\n    ) external;\\n\\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\\n\\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\\n    // @param _srcAddress - the source chain contract address\\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\\n\\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _userApplication - the user app address on this EVM chain\\n    // @param _payload - the custom message to send over LayerZero\\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\\n    function estimateFees(\\n        uint16 _dstChainId,\\n        address _userApplication,\\n        bytes calldata _payload,\\n        bool _payInZRO,\\n        bytes calldata _adapterParam\\n    ) external view returns (uint nativeFee, uint zroFee);\\n\\n    // @notice get this Endpoint's immutable source identifier\\n    function getChainId() external view returns (uint16);\\n\\n    // @notice the interface to retry failed message on this Endpoint destination\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    // @param _payload - the payload to be retried\\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\\n\\n    // @notice query if any STORED payload (message blocking) at the endpoint.\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\\n\\n    // @notice query if the _libraryAddress is valid for sending msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\\n\\n    // @notice query if the _libraryAddress is valid for receiving msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\\n\\n    // @notice query if the non-reentrancy guard for send() is on\\n    // @return true if the guard is on. false otherwise\\n    function isSendingPayload() external view returns (bool);\\n\\n    // @notice query if the non-reentrancy guard for receive() is on\\n    // @return true if the guard is on. false otherwise\\n    function isReceivingPayload() external view returns (bool);\\n\\n    // @notice get the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _userApplication - the contract address of the user application\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    function getConfig(\\n        uint16 _version,\\n        uint16 _chainId,\\n        address _userApplication,\\n        uint _configType\\n    ) external view returns (bytes memory);\\n\\n    // @notice get the send() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getSendVersion(address _userApplication) external view returns (uint16);\\n\\n    // @notice get the lzReceive() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\\n}\\n\",\"keccak256\":\"0x94df152b24e7395f52570c656e5f1e016bfa8b5c3623ff2fc2ced1c14ecd7c79\",\"license\":\"MIT\"},\"src/contracts/minter/collateral-pool/position/interfaces/ILayerZeroReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.2;\\n\\ninterface ILayerZeroReceiverUpgradeable {\\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\\n    // @param _srcChainId - the source endpoint identifier\\n    // @param _srcAddress - the source sending contract address from the source chain\\n    // @param _nonce - the ordered message nonce\\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\\n}\\n\",\"keccak256\":\"0x6ce5593a1247719f7209cad8068573c249674b41b859c6379ace1baaea0ed2a3\",\"license\":\"MIT\"},\"src/contracts/minter/collateral-pool/position/interfaces/ILayerZeroUserApplicationConfigUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.2;\\n\\ninterface ILayerZeroUserApplicationConfigUpgradeable {\\n    // @notice set the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    // @param _config - configuration in the bytes. can encode arbitrary content.\\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\\n\\n    // @notice set the send() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setSendVersion(uint16 _version) external;\\n\\n    // @notice set the lzReceive() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setReceiveVersion(uint16 _version) external;\\n\\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\\n    // @param _srcChainId - the chainId of the source chain\\n    // @param _srcAddress - the contract address of the source contract at the source chain\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\\n}\\n\",\"keccak256\":\"0xa808baa32db12c453b982320e0c9a8c07aec8c0f3bb36ac2ed26f3ad47476879\",\"license\":\"MIT\"},\"src/contracts/minter/collateral-pool/position/interfaces/IONFT721CoreUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface of the ONFT Core Upgradeable standard\\n */\\ninterface IONFT721CoreUpgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `_tokenIds[]` are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\\n     * `_nonce` is the outbound nonce from\\n     */\\n    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes indexed _toAddress, uint[] _tokenIds);\\n    event ReceiveFromChain(\\n        uint16 indexed _srcChainId,\\n        bytes indexed _srcAddress,\\n        address indexed _toAddress,\\n        uint[] _tokenIds\\n    );\\n\\n    /**\\n     * @dev Emitted when `_payload` was received from lz, but not enough gas to deliver all tokenIds\\n     */\\n    event CreditStored(bytes32 _hashedPayload, bytes _payload);\\n    /**\\n     * @dev Emitted when `_hashedPayload` has been completely delivered\\n     */\\n    event CreditCleared(bytes32 _hashedPayload);\\n\\n    /**\\n     * @dev send token `_tokenId` to (`_dstChainId`, `_toAddress`) from `_from`\\n     * `_toAddress` can be any size depending on the `dstChainId`.\\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\\n     */\\n    function sendFrom(\\n        address _from,\\n        uint16 _dstChainId,\\n        bytes calldata _toAddress,\\n        uint _tokenId,\\n        address payable _refundAddress,\\n        address _zroPaymentAddress,\\n        bytes calldata _adapterParams\\n    ) external payable;\\n\\n    /**\\n     * @dev send tokens `_tokenIds[]` to (`_dstChainId`, `_toAddress`) from `_from`\\n     * `_toAddress` can be any size depending on the `dstChainId`.\\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\\n     */\\n    function sendBatchFrom(\\n        address _from,\\n        uint16 _dstChainId,\\n        bytes calldata _toAddress,\\n        uint[] calldata _tokenIds,\\n        address payable _refundAddress,\\n        address _zroPaymentAddress,\\n        bytes calldata _adapterParams\\n    ) external payable;\\n\\n    /**\\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\\n     * _dstChainId - L0 defined chain id to send tokens too\\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\\n     * _tokenId - token Id to transfer\\n     * _useZro - indicates to use zro to pay L0 fees\\n     * _adapterParams - flexible bytes array to indicate messaging adapter services in L0\\n     */\\n    function estimateSendFee(\\n        uint16 _dstChainId,\\n        bytes calldata _toAddress,\\n        uint _tokenId,\\n        bool _useZro,\\n        bytes calldata _adapterParams\\n    ) external view returns (uint nativeFee, uint zroFee);\\n\\n    /**\\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\\n     * _dstChainId - L0 defined chain id to send tokens too\\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\\n     * _tokenIds[] - token Ids to transfer\\n     * _useZro - indicates to use zro to pay L0 fees\\n     * _adapterParams - flexible bytes array to indicate messaging adapter services in L0\\n     */\\n    function estimateSendBatchFee(\\n        uint16 _dstChainId,\\n        bytes calldata _toAddress,\\n        uint[] calldata _tokenIds,\\n        bool _useZro,\\n        bytes calldata _adapterParams\\n    ) external view returns (uint nativeFee, uint zroFee);\\n}\\n\",\"keccak256\":\"0xd8d7f34b3b0db3f438b6d24e7e0cdd3dad4225be79322d320421256be9c0e325\",\"license\":\"MIT\"},\"src/contracts/minter/collateral-pool/position/interfaces/IONFT721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.2;\\n\\nimport {IONFT721CoreUpgradeable} from \\\"./IONFT721CoreUpgradeable.sol\\\";\\nimport {IERC721Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface of the ONFT Upgradeable standard\\n */\\ninterface IONFT721Upgradeable is IONFT721CoreUpgradeable, IERC721Upgradeable {\\n\\n}\\n\",\"keccak256\":\"0x81d165ef847427192d835076081f16559f1f4a73c7ef9c00d108b32e250f74b4\",\"license\":\"MIT\"},\"src/contracts/minter/collateral-pool/position/interfaces/IPositionsFacet.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity <=0.8.19;\\nimport {NewPosition, Position} from \\\"../state/PositionsStorage.sol\\\";\\n\\ninterface IPositionsFacet {\\n    /**\\n     * @notice Creates a new leveraged position\\n     * @param _position The parameters of the new position\\n     * @return id The ID of the new position\\n     */\\n    function createPosition(NewPosition memory _position) external returns (uint256 id);\\n\\n    /**\\n     * @notice Close a leveraged position\\n     * @param _id The ID of the position to close\\n     */\\n    function closePosition(uint256 _id) external;\\n\\n    /**\\n     * @notice Deposit collateral into a leveraged position.\\n     * @param _id The ID of the position to deposit collateral into.\\n     * @param _amount The amount of collateral to deposit.\\n     */\\n    function deposit(uint256 _id, uint256 _amount) external;\\n\\n    /**\\n     * @notice Withdraw collateral from a leveraged position\\n     * @param _id The ID of the position to withdraw collateral from\\n     * @param _amount The amount of collateral to withdraw\\n     */\\n    function withdraw(uint256 _id, uint256 _amount) external;\\n\\n    /**\\n     * @notice Borrow more assets to a position, keeps the leverage.\\n     * @param _id The ID of the position to borrow more from\\n     * @param _sellAmount The amount of collateral to sell\\n     * @param _buyAmount The min amount of asset to buy\\n     */\\n    function buy(uint256 _id, uint256 _sellAmount, uint256 _buyAmount) external;\\n\\n    /**\\n     * @notice Repay borrowed asset in a position\\n     * @param _id The ID of the position to repay borrowed asset to\\n     * @param _amount The amount of borrowed asset\\n     */\\n    function buyback(uint256 _id, uint256 _amount) external;\\n\\n    /// @notice returns the info of a position for `_id`\\n    /// @return position the position when last modified\\n    /// @return profitPercentage the current profit of the position\\n    function getPosition(uint256 _id) external view returns (Position memory, int128 profitPercentage);\\n\\n    /**\\n     * @notice Get the liquidatable status of a lever positions\\n     * @param _ids The IDs of the positions\\n     * @return array of liquidatable results\\n     */\\n    function isLiquidatable(uint256[] calldata _ids) external view returns (bool[] memory);\\n\\n    /// @notice returns the closable status for positions\\n    function isClosable(uint256[] calldata _ids) external view returns (bool[] memory);\\n}\\n\",\"keccak256\":\"0x7eeebc275bbe11739452a36318e8ee4785e9856685fc0c46993c1970d714e55d\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/collateral-pool/position/libs/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\nlibrary BytesLib {\\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(\\n                0x40,\\n                and(\\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n                    not(31) // Round down to the nearest 32 bytes.\\n                )\\n            )\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1, \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                    // the next line is the loop condition:\\n                    // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {\\n\\n                        } eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0xaa1c57864bd8483bb17f2fa96a0cbebb39006ca7aab1a28ff85e52e487437c4c\",\"license\":\"Unlicense\"},\"src/contracts/minter/collateral-pool/position/libs/ExcessivelySafeCall.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.7.6;\\n\\nlibrary ExcessivelySafeCall {\\n    uint256 constant LOW_28_MASK = 0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    /// @notice Use when you _really_ really _really_ don't trust the called\\n    /// contract. This prevents the called contract from causing reversion of\\n    /// the caller in as many ways as we can.\\n    /// @dev The main difference between this and a solidity low-level call is\\n    /// that we limit the number of bytes that the callee can cause to be\\n    /// copied to caller memory. This prevents stupid things like malicious\\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\\n    /// to memory.\\n    /// @param _target The address to call\\n    /// @param _gas The amount of gas to forward to the remote contract\\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\\n    /// to memory.\\n    /// @param _calldata The data to send to the remote contract\\n    /// @return success and returndata, as `.call()`. Returndata is capped to\\n    /// `_maxCopy` bytes.\\n    function excessivelySafeCall(\\n        address _target,\\n        uint256 _gas,\\n        uint16 _maxCopy,\\n        bytes memory _calldata\\n    ) internal returns (bool, bytes memory) {\\n        // set up for assembly call\\n        uint256 _toCopy;\\n        bool _success;\\n        bytes memory _returnData = new bytes(_maxCopy);\\n        // dispatch message to recipient\\n        // by assembly calling \\\"handle\\\" function\\n        // we call via assembly to avoid memcopying a very large returndata\\n        // returned by a malicious contract\\n        assembly {\\n            _success := call(\\n                _gas, // gas\\n                _target, // recipient\\n                0, // ether value\\n                add(_calldata, 0x20), // inloc\\n                mload(_calldata), // inlen\\n                0, // outloc\\n                0 // outlen\\n            )\\n            // limit our copy to 256 bytes\\n            _toCopy := returndatasize()\\n            if gt(_toCopy, _maxCopy) {\\n                _toCopy := _maxCopy\\n            }\\n            // Store the length of the copied bytes\\n            mstore(_returnData, _toCopy)\\n            // copy the bytes from returndata[0:_toCopy]\\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\\n        }\\n        return (_success, _returnData);\\n    }\\n\\n    /// @notice Use when you _really_ really _really_ don't trust the called\\n    /// contract. This prevents the called contract from causing reversion of\\n    /// the caller in as many ways as we can.\\n    /// @dev The main difference between this and a solidity low-level call is\\n    /// that we limit the number of bytes that the callee can cause to be\\n    /// copied to caller memory. This prevents stupid things like malicious\\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\\n    /// to memory.\\n    /// @param _target The address to call\\n    /// @param _gas The amount of gas to forward to the remote contract\\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\\n    /// to memory.\\n    /// @param _calldata The data to send to the remote contract\\n    /// @return success and returndata, as `.call()`. Returndata is capped to\\n    /// `_maxCopy` bytes.\\n    function excessivelySafeStaticCall(\\n        address _target,\\n        uint256 _gas,\\n        uint16 _maxCopy,\\n        bytes memory _calldata\\n    ) internal view returns (bool, bytes memory) {\\n        // set up for assembly call\\n        uint256 _toCopy;\\n        bool _success;\\n        bytes memory _returnData = new bytes(_maxCopy);\\n        // dispatch message to recipient\\n        // by assembly calling \\\"handle\\\" function\\n        // we call via assembly to avoid memcopying a very large returndata\\n        // returned by a malicious contract\\n        assembly {\\n            _success := staticcall(\\n                _gas, // gas\\n                _target, // recipient\\n                add(_calldata, 0x20), // inloc\\n                mload(_calldata), // inlen\\n                0, // outloc\\n                0 // outlen\\n            )\\n            // limit our copy to 256 bytes\\n            _toCopy := returndatasize()\\n            if gt(_toCopy, _maxCopy) {\\n                _toCopy := _maxCopy\\n            }\\n            // Store the length of the copied bytes\\n            mstore(_returnData, _toCopy)\\n            // copy the bytes from returndata[0:_toCopy]\\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\\n        }\\n        return (_success, _returnData);\\n    }\\n\\n    /**\\n     * @notice Swaps function selectors in encoded contract calls\\n     * @dev Allows reuse of encoded calldata for functions with identical\\n     * argument types but different names. It simply swaps out the first 4 bytes\\n     * for the new selector. This function modifies memory in place, and should\\n     * only be used with caution.\\n     * @param _newSelector The new 4-byte selector\\n     * @param _buf The encoded contract args\\n     */\\n    function swapSelector(bytes4 _newSelector, bytes memory _buf) internal pure {\\n        require(_buf.length >= 4);\\n        uint256 _mask = LOW_28_MASK;\\n        assembly {\\n            // load the first word of\\n            let _word := mload(add(_buf, 0x20))\\n            // mask out the top 4 bytes\\n            // /x\\n            _word := and(_word, _mask)\\n            _word := or(_newSelector, _word)\\n            mstore(add(_buf, 0x20), _word)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8355680ee3db8c855f77a0cb141eedb68e0894ddb2b7ffafdf78303f6dac23e0\",\"license\":\"MIT OR Apache-2.0\"},\"src/contracts/minter/collateral-pool/position/libs/LibERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport {AddressUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport {StringsUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\\\";\\nimport {IERC721ReceiverUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\\\";\\nimport {ERC721, ERC721Storage} from \\\"../state/ERC721Storage.sol\\\";\\nimport {LibLZ} from \\\"./LibLZ.sol\\\";\\nimport {Meta} from \\\"../../../../libs/Meta.sol\\\";\\n\\nlibrary LibERC721 {\\n    using AddressUpgradeable for address;\\n    using StringsUpgradeable for uint256;\\n    using LibERC721 for ERC721Storage;\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(\\n        ERC721Storage storage self,\\n        address owner,\\n        address operator\\n    ) internal view returns (bool) {\\n        return self.operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(ERC721Storage storage self, address operator, bool approved) internal {\\n        require(msg.sender != operator, \\\"ERC721: approve to caller\\\");\\n        self.operatorApprovals[msg.sender][operator] = approved;\\n    }\\n\\n    function isApprovedOrOwner(\\n        ERC721Storage storage self,\\n        address spender,\\n        uint256 tokenId\\n    ) internal view returns (bool) {\\n        address owner = self.ownerOf(tokenId);\\n        return (spender == owner || self.isApprovedForAll(owner, spender) || self.getApproved(tokenId) == spender);\\n    }\\n\\n    function debitFrom(ERC721Storage storage self, address _from, uint16, bytes memory, uint _tokenId) internal {\\n        require(self.isApprovedOrOwner(Meta.msgSender(), _tokenId), LibLZ.INVALID_CALLER);\\n        require(self.ownerOf(_tokenId) == _from, LibLZ.INVALID_TOKEN_OWNER);\\n        self.transfer(_from, address(this), _tokenId);\\n    }\\n\\n    function creditTo(ERC721Storage storage self, uint16, address _toAddress, uint _tokenId) internal {\\n        bool tokenExists = self.exists(_tokenId);\\n        require(!tokenExists || (tokenExists && self.ownerOf(_tokenId) == address(this)));\\n        if (!tokenExists) {\\n            self.safeMint(_toAddress, _tokenId, \\\"\\\");\\n        } else {\\n            self.transfer(address(this), _toAddress, _tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(ERC721Storage storage self, uint256 tokenId) internal view returns (address) {\\n        self.requireMinted(tokenId);\\n\\n        return self.tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function safeMint(ERC721Storage storage self, address to, uint256 tokenId, bytes memory data) internal {\\n        _mint(self, to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    function _mint(ERC721Storage storage self, address to, uint256 tokenId) private {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!self.exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        self.beforeTokenTransfer(address(0), to, tokenId, 1);\\n\\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\\n        require(!self.exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        unchecked {\\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\\n            // Given that tokens are minted one by one, it is impossible in practice that\\n            // this ever happens. Might change if we allow batch minting.\\n            // The ERC fails to describe this case.\\n            self.balances[to] += 1;\\n        }\\n\\n        self.owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        self.afterTokenTransfer(address(0), to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function burn(ERC721Storage storage self, uint256 tokenId) internal {\\n        address owner = self.ownerOf(tokenId);\\n\\n        self.beforeTokenTransfer(owner, address(0), tokenId, 1);\\n\\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\\n        owner = self.ownerOf(tokenId);\\n\\n        // Clear approvals\\n        delete self.tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // Cannot overflow, as that would require more tokens to be burned/transferred\\n            // out than the owner initially received through minting and transferring in.\\n            self.balances[owner] -= 1;\\n        }\\n        delete self.owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        self.afterTokenTransfer(owner, address(0), tokenId, 1);\\n    }\\n\\n    function ownerOf(ERC721Storage storage self, uint256 tokenId) internal view returns (address) {\\n        address owner = self.owners[tokenId];\\n        require(owner != address(0), \\\"ERC721 :address zero is not a valid owner\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function requireMinted(ERC721Storage storage self, uint256 tokenId) internal view {\\n        require(self.exists(tokenId), \\\"ERC721: invalid token ID\\\");\\n    }\\n\\n    /** @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721ReceiverUpgradeable(to).onERC721Received(msg.sender, from, tokenId, data) returns (\\n                bytes4 retval\\n            ) {\\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(ERC721Storage storage self, address to, uint256 tokenId) internal {\\n        self.tokenApprovals[tokenId] = to;\\n        emit Approval(self.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(ERC721Storage storage self, address owner, address operator, bool approved) internal {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        self.operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    function safeTransferFrom(ERC721Storage storage self, address from, address to, uint256 tokenId) internal {\\n        self.safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        ERC721Storage storage self,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal {\\n        require(self.isApprovedOrOwner(msg.sender, tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n        _safeTransfer(self, from, to, tokenId, data);\\n    }\\n\\n    function _safeTransfer(\\n        ERC721Storage storage self,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private {\\n        transfer(self, from, to, tokenId);\\n        _checkOnERC721Received(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(ERC721Storage storage self, address from, address to, uint256 tokenId) internal {\\n        require(self.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        self.beforeTokenTransfer(from, to, tokenId, 1);\\n\\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\\n        require(self.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n\\n        // Clear approvals from the previous owner\\n        delete self.tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\\n            // `from`'s balance is the number of token held, which is at least one before the current\\n            // transfer.\\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\\n            // all 2**256 token ids to be minted, which in practice is impossible.\\n            self.balances[from] -= 1;\\n            self.balances[to] += 1;\\n        }\\n        self.owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        self.afterTokenTransfer(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function exists(ERC721Storage storage self, uint256 tokenId) internal view returns (bool) {\\n        return self.owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\\n     * - When `from` is zero, the tokens will be minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function beforeTokenTransfer(\\n        ERC721Storage storage self,\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize\\n    ) internal {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\\n     * - When `from` is zero, the tokens were minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens were burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function afterTokenTransfer(\\n        ERC721Storage storage self,\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize\\n    ) internal {}\\n\\n    /**\\n     * @dev Unsafe write access to the balances, used by extensions that \\\"mint\\\" tokens using an {ownerOf} override.\\n     *\\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\\n     * that `ownerOf(tokenId)` is `a`.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\\n        ERC721().balances[account] += amount;\\n    }\\n}\\n\",\"keccak256\":\"0xbcd36d49c727c356b63f0c17c356c572a80ed72f2713caaedbb5abbbd8e82234\",\"license\":\"MIT\"},\"src/contracts/minter/collateral-pool/position/libs/LibLZ.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity <=0.8.19;\\nimport {BytesLib} from \\\"../libs/BytesLib.sol\\\";\\nimport {Meta} from \\\"../../../../libs/Meta.sol\\\";\\nimport {ERC721} from \\\"../state/ERC721Storage.sol\\\";\\nimport {lz, LZStorage, StoredCredit, AirdropParams, CallParams} from \\\"../state/LZStorage.sol\\\";\\n\\nlibrary LibLZ {\\n    using BytesLib for bytes;\\n    ///@dev Emitted when `_payload` was received from lz, but not enough gas to deliver all tokenIds\\n    event CreditStored(bytes32 _hashedPayload, bytes _payload);\\n\\n    /// @dev Emitted when `_hashedPayload` has been completely delivered\\n    event CreditCleared(bytes32 _hashedPayload);\\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\\n\\n    /// @dev Emitted when `_tokenIds[]` are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\\n    /// `_nonce` is the outbound nonce from\\n    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes indexed _toAddress, uint[] _tokenIds);\\n    event ReceiveFromChain(\\n        uint16 indexed _srcChainId,\\n        bytes indexed _srcAddress,\\n        address indexed _toAddress,\\n        uint[] _tokenIds\\n    );\\n\\n    event SetPrecrime(address precrime);\\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\\n\\n    uint16 internal constant FUNCTION_TYPE_SEND = 1;\\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\\n    uint256 internal constant DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\\n\\n    string internal constant MINGASZERO = \\\"2\\\"; // ONFT721: minGasToTransferAndStore must be > 0\\\"\\n    string internal constant TOKENIDS_EMPTY = \\\"1\\\"; // LzApp: tokenIds[] is empty\\n    string internal constant BATCH_LIMIT_EXCEEDED = \\\"3\\\"; // \\\"ONFT721: batch size exceeds dst batch limit\\\"\\n    string internal constant NO_CREDITS_STORED = \\\"4\\\"; // \\\"ONFT721: no credits stored\\\"\\n    string internal constant NO_GAS_REMAINING = \\\"5\\\"; // \\\"ONFT721: not enough gas to process credit transfer\\\"\\n    string internal constant MIN_GAS_NOT_ZERO = \\\"6\\\"; // \\\"ONFT721: minGasToTransferAndStore must be > 0\\\"\\n    string internal constant INVALID_CALLER = \\\"7\\\"; // \\\"ONFT721: send caller is not owner nor approved\\\"\\n    string internal constant INVALID_TOKEN_OWNER = \\\"8\\\"; // \\\"ONFT721: send from incorrect owner\\\"\\n    string internal constant INVALID_ENDPOINT = \\\"9\\\"; // Endpoint cannot be 0\\n\\n    function estimateFees(\\n        LZStorage storage self,\\n        uint16 _dstChainId,\\n        bytes memory _toAddress,\\n        uint[] memory _tokenIds,\\n        bool _useZro,\\n        bytes memory _adapterParams\\n    ) internal view returns (uint256, uint256) {\\n        bytes memory payload = abi.encode(_toAddress, _tokenIds);\\n        return self.lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\\n    }\\n\\n    function send(\\n        LZStorage storage self,\\n        address _from,\\n        uint16 _dstChainId,\\n        bytes memory _toAddress,\\n        uint[] memory _tokenIds,\\n        address payable _refundAddress,\\n        address _zroPaymentAddress,\\n        bytes memory _adapterParams\\n    ) internal {\\n        // allow 1 by default\\n        require(_tokenIds.length > 0, \\\"tokenIds[] is empty\\\");\\n        require(\\n            _tokenIds.length == 1 || _tokenIds.length <= self.dstChainIdToBatchLimit[_dstChainId],\\n            \\\"batch size exceeds dst batch limit\\\"\\n        );\\n\\n        for (uint i = 0; i < _tokenIds.length; i++) {\\n            ERC721().debitFrom(_from, _dstChainId, _toAddress, _tokenIds[i]);\\n        }\\n\\n        bytes memory payload = abi.encode(_toAddress, _tokenIds);\\n\\n        checkGasLimit(\\n            self,\\n            _dstChainId,\\n            FUNCTION_TYPE_SEND,\\n            _adapterParams,\\n            self.dstChainIdToTransferGas[_dstChainId] * _tokenIds.length\\n        );\\n        _lzSend(self, _dstChainId, payload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\\n        emit SendToChain(_dstChainId, _from, _toAddress, _tokenIds);\\n    }\\n\\n    function _lzSend(\\n        LZStorage storage self,\\n        uint16 _dstChainId,\\n        bytes memory _payload,\\n        address payable _refundAddress,\\n        address _zroPaymentAddress,\\n        bytes memory _adapterParams,\\n        uint _nativeFee\\n    ) internal {\\n        bytes memory trustedRemote = self.trustedRemoteLookup[_dstChainId];\\n        require(trustedRemote.length != 0, \\\"LzApp: destination chain is not a trusted source\\\");\\n        self.checkPayloadSize(_dstChainId, _payload.length);\\n        self.lzEndpoint.send{value: _nativeFee}(\\n            _dstChainId,\\n            trustedRemote,\\n            _payload,\\n            _refundAddress,\\n            _zroPaymentAddress,\\n            _adapterParams\\n        );\\n    }\\n\\n    function nonblockingLzReceive(\\n        LZStorage storage self,\\n        uint16 _srcChainId,\\n        bytes memory _srcAddress,\\n        uint64 /*_nonce*/,\\n        bytes memory _payload\\n    ) internal {\\n        // decode and load the toAddress\\n        (bytes memory toAddressBytes, uint[] memory tokenIds) = abi.decode(_payload, (bytes, uint[]));\\n\\n        address toAddress;\\n        assembly {\\n            toAddress := mload(add(toAddressBytes, 20))\\n        }\\n\\n        uint nextIndex = self.creditTill(_srcChainId, toAddress, 0, tokenIds);\\n        if (nextIndex < tokenIds.length) {\\n            // not enough gas to complete transfers, store to be cleared in another tx\\n            bytes32 hashedPayload = keccak256(_payload);\\n            self.storedCredits[hashedPayload] = StoredCredit(_srcChainId, toAddress, nextIndex, true);\\n            emit CreditStored(hashedPayload, _payload);\\n        }\\n\\n        emit ReceiveFromChain(_srcChainId, _srcAddress, toAddress, tokenIds);\\n    }\\n\\n    // When a srcChain has the ability to transfer more chainIds in a single tx than the dst can do.\\n    // Needs the ability to iterate and stop if the minGasToTransferAndStore is not met\\n    function creditTill(\\n        LZStorage storage self,\\n        uint16 _srcChainId,\\n        address _toAddress,\\n        uint _startIndex,\\n        uint[] memory _tokenIds\\n    ) internal returns (uint256) {\\n        uint i = _startIndex;\\n        while (i < _tokenIds.length) {\\n            // if not enough gas to process, store this index for next loop\\n            if (gasleft() < self.minGasToTransferAndStore) break;\\n\\n            ERC721().creditTo(_srcChainId, _toAddress, _tokenIds[i]);\\n            i++;\\n        }\\n\\n        // indicates the next index to send of tokenIds,\\n        // if i == tokenIds.length, we are finished\\n        return i;\\n    }\\n\\n    function checkGasLimit(\\n        LZStorage storage self,\\n        uint16 _dstChainId,\\n        uint16 _type,\\n        bytes memory _adapterParams,\\n        uint _extraGas\\n    ) internal view {\\n        uint providedGasLimit = getGasLimit(_adapterParams);\\n        uint minGasLimit = self.minDstGasLookup[_dstChainId][_type] + _extraGas;\\n        require(minGasLimit > 0, \\\"LzApp: minGasLimit not set\\\");\\n        require(providedGasLimit >= minGasLimit, \\\"LzApp: gas limit is too low\\\");\\n    }\\n\\n    function getGasLimit(bytes memory _adapterParams) internal pure returns (uint gasLimit) {\\n        require(_adapterParams.length >= 34, \\\"LzApp: invalid adapterParams\\\");\\n        assembly {\\n            gasLimit := mload(add(_adapterParams, 34))\\n        }\\n    }\\n\\n    function checkPayloadSize(LZStorage storage self, uint16 _dstChainId, uint _payloadSize) internal view {\\n        uint payloadSizeLimit = self.payloadSizeLimitLookup[_dstChainId];\\n        if (payloadSizeLimit == 0) {\\n            // use default if not set\\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\\n        }\\n        require(_payloadSize <= payloadSizeLimit, \\\"LzApp: payload size is too large\\\");\\n    }\\n\\n    function buildAdapterParams(\\n        AirdropParams memory _airdropParams,\\n        uint _uaGasLimit\\n    ) internal pure returns (bytes memory adapterParams) {\\n        if (_airdropParams.airdropAmount == 0 && _airdropParams.airdropAddress == bytes32(0x0)) {\\n            adapterParams = buildDefaultAdapterParams(_uaGasLimit);\\n        } else {\\n            adapterParams = buildAirdropAdapterParams(_uaGasLimit, _airdropParams);\\n        }\\n    }\\n\\n    // Build Adapter Params\\n    function buildDefaultAdapterParams(uint _uaGas) internal pure returns (bytes memory) {\\n        // txType 1\\n        // bytes  [2       32      ]\\n        // fields [txType  extraGas]\\n        return abi.encodePacked(uint16(1), _uaGas);\\n    }\\n\\n    function buildAirdropAdapterParams(uint _uaGas, AirdropParams memory _params) internal pure returns (bytes memory) {\\n        require(_params.airdropAmount > 0, \\\"Airdrop amount must be greater than 0\\\");\\n        require(_params.airdropAddress != bytes32(0x0), \\\"Airdrop address must be set\\\");\\n\\n        // txType 2\\n        // bytes  [2       32        32            bytes[]         ]\\n        // fields [txType  extraGas  dstNativeAmt  dstNativeAddress]\\n        return abi.encodePacked(uint16(2), _uaGas, _params.airdropAmount, _params.airdropAddress);\\n    }\\n\\n    // Decode Adapter Params\\n    function decodeAdapterParams(\\n        bytes memory _adapterParams\\n    ) internal pure returns (uint16 txType, uint uaGas, uint airdropAmount, address payable airdropAddress) {\\n        require(_adapterParams.length == 34 || _adapterParams.length > 66, \\\"Invalid adapterParams\\\");\\n        assembly {\\n            txType := mload(add(_adapterParams, 2))\\n            uaGas := mload(add(_adapterParams, 34))\\n        }\\n        require(txType == 1 || txType == 2, \\\"Unsupported txType\\\");\\n        require(uaGas > 0, \\\"Gas too low\\\");\\n\\n        if (txType == 2) {\\n            assembly {\\n                airdropAmount := mload(add(_adapterParams, 66))\\n                airdropAddress := mload(add(_adapterParams, 86))\\n            }\\n        }\\n    }\\n\\n    //---------------------------------------------------------------------------\\n    // Address type handling\\n    function bytes32ToAddress(bytes32 _bytes32Address) internal pure returns (address _address) {\\n        return address(uint160(uint(_bytes32Address)));\\n    }\\n\\n    function addressToBytes32(address _address) internal pure returns (bytes32 _bytes32Address) {\\n        return bytes32(uint(uint160(_address)));\\n    }\\n}\\n\",\"keccak256\":\"0x99d171bc1a15ec71836a1c7980dfd6e25682f78a5e4bef9eb219e2aa1b81707a\",\"license\":\"MIT\"},\"src/contracts/minter/collateral-pool/position/libs/LibPositions.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity <=0.8.19;\\nimport {WadRay} from \\\"../../../../libs/WadRay.sol\\\";\\nimport {pos, PositionStorage, Position} from \\\"../state/PositionsStorage.sol\\\";\\n\\nlibrary LibPositions {\\n    using WadRay for uint256;\\n    using LibPositions for PositionStorage;\\n\\n    string internal constant INVALID_LT = \\\"PC0\\\";\\n    string internal constant INVALID_MAX_LEVERAGE = \\\"PC1\\\";\\n    string internal constant INVALID_KRESKO = \\\"PC2\\\";\\n    string internal constant ERROR_NOT_OWNER = \\\"PC3\\\";\\n    string internal constant ERROR_POSITION_NOT_OWNED_BY_CALLER = \\\"PC4\\\";\\n    string internal constant ERROR_POSITION_NOT_FOUND = \\\"PC5\\\";\\n    string internal constant INVALID_NAME = \\\"PC6\\\";\\n    string internal constant LEVERAGE_TOO_HIGH = \\\"PC7\\\";\\n    string internal constant LEVERAGE_TOO_LOW = \\\"PC8\\\";\\n\\n    function getPosition(PositionStorage storage self, uint256 _id) internal view returns (Position memory) {\\n        return self.positions[_id];\\n    }\\n\\n    function getLeverage(PositionStorage storage self, uint256 _id) internal view returns (uint256 leverage) {\\n        Position memory position = self.positions[_id];\\n        uint256 priceA = self.kresko.getPrice(position.assetA);\\n        uint256 priceB = self.kresko.getPrice(position.assetB);\\n\\n        if (priceA == 0 || priceB == 0 || position.amountA == 0) return 0;\\n\\n        return position.amountB.wadMul(priceB).wadDiv(position.amountA.wadMul(priceA));\\n    }\\n\\n    function getRatio(PositionStorage storage self, uint256 _id) internal view returns (int256 ratio) {\\n        return int256(self.getLeverage(_id)) - int256(self.positions[_id].leverage);\\n    }\\n\\n    function isLiquidatable(PositionStorage storage self, uint256 _id) internal view returns (bool) {\\n        return self.getRatio(_id) <= self.liquidationThreshold;\\n    }\\n\\n    function isCloseable(PositionStorage storage self, uint256 _id) internal view returns (bool) {\\n        return self.getRatio(_id) >= self.closeThreshold;\\n    }\\n\\n    function getAndIncrementNonce(PositionStorage storage self, uint256 id) internal returns (uint256) {\\n        return uint256(self.positions[id].nonce++);\\n    }\\n}\\n\",\"keccak256\":\"0x3737f34cb726aa4e620e68620f34a31257645e8a402657d285d421b3a8d5a84c\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/collateral-pool/position/state/ERC721Storage.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {LibERC721} from \\\"../libs/LibERC721.sol\\\";\\n\\nstruct ERC721Storage {\\n    uint256 currentId;\\n    // Token name\\n    string name;\\n    // Token symbol\\n    string symbol;\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) owners;\\n    // Mapping owner address to token count\\n    mapping(address => uint256) balances;\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) tokenApprovals;\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) operatorApprovals;\\n    string baseURI;\\n}\\n\\n// Storage position\\nbytes32 constant ERC721_STORAGE_POSITION = keccak256(\\\"kresko.positions.erc721.storage\\\");\\n\\nfunction ERC721() pure returns (ERC721Storage storage state) {\\n    bytes32 position = ERC721_STORAGE_POSITION;\\n    assembly {\\n        state.slot := position\\n    }\\n}\\n\\nusing LibERC721 for ERC721Storage global;\\n\",\"keccak256\":\"0xc0c135c35619ada024ab9f683185278ead6208726df1189798462c04501f006a\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/collateral-pool/position/state/LZStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\nimport {ILayerZeroEndpointUpgradeable} from \\\"../interfaces/ILayerZeroEndpointUpgradeable.sol\\\";\\nimport {ILayerZeroUserApplicationConfigUpgradeable} from \\\"../interfaces/ILayerZeroUserApplicationConfigUpgradeable.sol\\\";\\nimport {LibLZ} from \\\"../libs/LibLZ.sol\\\";\\n\\nusing LibLZ for LZStorage global;\\n\\nstruct StoredCredit {\\n    uint16 srcChainId;\\n    address toAddress;\\n    uint256 index; // which index of the tokenIds remain\\n    bool creditsRemain;\\n}\\n\\nstruct CallParams {\\n    address payable refundAddress;\\n    address zroPaymentAddress;\\n}\\n\\nstruct AirdropParams {\\n    uint airdropAmount;\\n    bytes32 airdropAddress;\\n}\\n\\nstruct LZStorage {\\n    uint256 minGasToTransferAndStore; // min amount of gas required to transfer, and also store the payload\\n    mapping(uint16 => uint256) dstChainIdToBatchLimit;\\n    mapping(uint16 => uint256) dstChainIdToTransferGas; // per transfer amount of gas required to mint/transfer on the dst\\n    mapping(bytes32 => StoredCredit) storedCredits;\\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) failedMessages;\\n    ILayerZeroEndpointUpgradeable lzEndpoint;\\n    mapping(uint16 => bytes) trustedRemoteLookup;\\n    mapping(uint16 => mapping(uint16 => uint)) minDstGasLookup;\\n    mapping(uint16 => uint) payloadSizeLimitLookup;\\n    address precrime;\\n}\\n\\nbytes32 constant LZ_STORAGE_POSITION = keccak256(\\\"kresko.positions.lz.storage\\\");\\n\\nfunction lz() pure returns (LZStorage storage state) {\\n    bytes32 position = LZ_STORAGE_POSITION;\\n    assembly {\\n        state.slot := position\\n    }\\n}\\n\",\"keccak256\":\"0xe515f19edbe39be8bc1fa1708326c16b2c1403265e28b474612b99407bcb7ad5\",\"license\":\"MIT\"},\"src/contracts/minter/collateral-pool/position/state/PositionsStorage.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {LibPositions} from \\\"../libs/LibPositions.sol\\\";\\nimport {ICollateralPoolSwapFacet} from \\\"../../interfaces/ICollateralPoolSwapFacet.sol\\\";\\n\\nstruct NewPosition {\\n    address account;\\n    address assetA;\\n    address assetB;\\n    uint256 amountA;\\n    uint256 amountBMin;\\n    uint256 leverage;\\n}\\n\\nstruct Position {\\n    address account;\\n    address assetA;\\n    address assetB;\\n    uint256 amountA;\\n    uint256 amountB;\\n    uint256 valueBCache;\\n    uint256 leverage;\\n    uint256 liquidationIncentive;\\n    uint256 closeIncentive;\\n    uint256 creationTimestamp;\\n    uint256 lastUpdateTimestamp;\\n    uint256 nonce;\\n}\\n\\nstruct PositionsInitializer {\\n    ICollateralPoolSwapFacet kresko;\\n    string name;\\n    string symbol;\\n    int128 liquidationThreshold;\\n    int128 closeThreshold;\\n    uint256 maxLeverage;\\n    uint256 minLeverage;\\n}\\n\\nstruct PositionStorage {\\n    ICollateralPoolSwapFacet kresko;\\n    uint256 minLeverage;\\n    uint256 maxLeverage;\\n    int128 liquidationThreshold;\\n    int128 closeThreshold;\\n    mapping(uint256 => Position) positions;\\n}\\n\\nusing LibPositions for PositionStorage global;\\n\\n// Storage position\\nbytes32 constant POSITIONS_STORAGE = keccak256(\\\"kresko.positions.positions.storage\\\");\\n\\nfunction pos() pure returns (PositionStorage storage state) {\\n    bytes32 position = POSITIONS_STORAGE;\\n    assembly {\\n        state.slot := position\\n    }\\n}\\n\",\"keccak256\":\"0x26f410dd92b57a1278fc85dd8615c827d1d1b837193ab126a45816e74f6e3359\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/libs/LibAccount.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {MinterState} from \\\"../MinterState.sol\\\";\\nimport {KrAsset, CollateralAsset} from \\\"../MinterTypes.sol\\\";\\nimport {RebaseMath} from \\\"../../kreskoasset/Rebase.sol\\\";\\nimport {IKreskoAsset} from \\\"../../kreskoasset/IKreskoAsset.sol\\\";\\nimport {IKreskoAssetAnchor} from \\\"../../kreskoasset/IKreskoAssetAnchor.sol\\\";\\nimport {irs} from \\\"../InterestRateState.sol\\\";\\nimport {Error} from \\\"../../libs/Errors.sol\\\";\\nimport {LibDecimals} from \\\"../libs/LibDecimals.sol\\\";\\nimport {WadRay} from \\\"../../libs/WadRay.sol\\\";\\n\\nlibrary LibAccount {\\n    using RebaseMath for uint256;\\n    using WadRay for uint256;\\n    using LibDecimals for uint256;\\n\\n    /**\\n     * @notice Gets an array of Kresko assets the account has minted.\\n     * @param _account The account to get the minted Kresko assets for.\\n     * @return An array of addresses of Kresko assets the account has minted.\\n     */\\n    function getMintedKreskoAssets(\\n        MinterState storage self,\\n        address _account\\n    ) internal view returns (address[] memory) {\\n        return self.mintedKreskoAssets[_account];\\n    }\\n\\n    /**\\n     * @notice Gets an array of collateral assets the account has deposited.\\n     * @param _account The account to get the deposited collateral assets for.\\n     * @return An array of addresses of collateral assets the account has deposited.\\n     */\\n    function getDepositedCollateralAssets(\\n        MinterState storage self,\\n        address _account\\n    ) internal view returns (address[] memory) {\\n        return self.depositedCollateralAssets[_account];\\n    }\\n\\n    /**\\n     * @notice Get deposited collateral asset amount for an account\\n     * @notice Performs rebasing conversion for KreskoAssets\\n     * @param _asset The asset address\\n     * @param _account The account to query amount for\\n     * @return uint256 amount of collateral for `_asset`\\n     */\\n    function getCollateralDeposits(\\n        MinterState storage self,\\n        address _account,\\n        address _asset\\n    ) internal view returns (uint256) {\\n        return self.collateralAssets[_asset].toRebasingAmount(self.collateralDeposits[_account][_asset]);\\n    }\\n\\n    /**\\n     * @notice Checks if accounts collateral value is less than required.\\n     * @param _account The account to check.\\n     * @return A boolean indicating if the account can be liquidated.\\n     */\\n    function isAccountLiquidatable(MinterState storage self, address _account) internal view returns (bool) {\\n        return\\n            self.getAccountCollateralValue(_account) <\\n            (self.getAccountMinimumCollateralValueAtRatio(_account, self.liquidationThreshold));\\n    }\\n\\n    /**\\n     * @notice Overload for calculating liquidatable status with a future liquidated collateral value\\n     * @param _account The account to check.\\n     * @param _valueLiquidated Value liquidated, eg. in a batch liquidation\\n     * @return bool indicating if the account can be liquidated.\\n     */\\n    function isAccountLiquidatable(\\n        MinterState storage self,\\n        address _account,\\n        uint256 _valueLiquidated\\n    ) internal view returns (bool) {\\n        return\\n            self.getAccountCollateralValue(_account) - _valueLiquidated <\\n            (self.getAccountMinimumCollateralValueAtRatio(_account, self.liquidationThreshold));\\n    }\\n\\n    /**\\n     * @notice Gets the collateral value of a particular account.\\n     * @dev O(# of different deposited collateral assets by account) complexity.\\n     * @param _account The account to calculate the collateral value for.\\n     * @return totalCollateralValue The collateral value of a particular account.\\n     */\\n    function getAccountCollateralValue(\\n        MinterState storage self,\\n        address _account\\n    ) internal view returns (uint256 totalCollateralValue) {\\n        address[] memory assets = self.depositedCollateralAssets[_account];\\n        for (uint256 i = 0; i < assets.length; i++) {\\n            address asset = assets[i];\\n            (uint256 collateralValue, ) = self.getCollateralValueAndOraclePrice(\\n                asset,\\n                self.getCollateralDeposits(_account, asset),\\n                false // Take the collateral factor into consideration.\\n            );\\n            totalCollateralValue += collateralValue;\\n        }\\n\\n        return totalCollateralValue;\\n    }\\n\\n    /**\\n     * @notice Gets the collateral value of a particular account including extra return value for specific collateral.\\n     * @dev O(# of different deposited collateral assets by account) complexity.\\n     * @param _account The account to calculate the collateral value for.\\n     * @param _collateralAsset The collateral asset to get the collateral value.\\n     * @return totalCollateralValue The collateral value of a particular account.\\n     */\\n    function getAccountCollateralValue(\\n        MinterState storage self,\\n        address _account,\\n        address _collateralAsset\\n    ) internal view returns (uint256 totalCollateralValue, uint256 specificValue) {\\n        address[] memory assets = self.depositedCollateralAssets[_account];\\n        for (uint256 i = 0; i < assets.length; i++) {\\n            address asset = assets[i];\\n            (uint256 collateralValue, ) = self.getCollateralValueAndOraclePrice(\\n                asset,\\n                self.getCollateralDeposits(_account, asset),\\n                false // Take the collateral factor into consideration.\\n            );\\n            totalCollateralValue += collateralValue;\\n            if (asset == _collateralAsset) {\\n                specificValue = collateralValue;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets accounts min collateral value required to cover debt at a given collateralization ratio.\\n     * @dev 1. Account with min collateral value under MCR will not borrow.\\n     *      2. Account with min collateral value under LT can be liquidated.\\n     * @param _account The account to calculate the minimum collateral value for.\\n     * @param _ratio The collateralization ratio to get min collateral value against.\\n     * @return The min collateral value at given collateralization ratio for the account.\\n     */\\n    function getAccountMinimumCollateralValueAtRatio(\\n        MinterState storage self,\\n        address _account,\\n        uint256 _ratio\\n    ) internal view returns (uint256) {\\n        return self.getAccountKrAssetValue(_account).wadMul(_ratio);\\n    }\\n\\n    /**\\n     * @notice Gets the total KreskoAsset value in USD for an account.\\n     * @param _account The account to calculate the KreskoAsset value for.\\n     * @return value The KreskoAsset value of the account.\\n     */\\n    function getAccountKrAssetValue(MinterState storage self, address _account) internal view returns (uint256 value) {\\n        address[] memory assets = self.mintedKreskoAssets[_account];\\n        for (uint256 i = 0; i < assets.length; i++) {\\n            address asset = assets[i];\\n            value += self.getKrAssetValue(asset, self.getKreskoAssetDebtScaled(_account, asset), false);\\n        }\\n        return value;\\n    }\\n\\n    /**\\n     * @notice Get accounts interested scaled debt amount for a KreskoAsset.\\n     * @param _asset The asset address\\n     * @param _account The account to get the amount for\\n     * @return Amount of scaled debt.\\n     */\\n    function getKreskoAssetDebtScaled(\\n        MinterState storage self,\\n        address _account,\\n        address _asset\\n    ) internal view returns (uint256) {\\n        uint256 debt = self.kreskoAssets[_asset].toRebasingAmount(irs().srUserInfo[_account][_asset].debtScaled);\\n        if (debt == 0) {\\n            return 0;\\n        }\\n\\n        return debt.rayMul(irs().srAssets[_asset].getNormalizedDebtIndex()).rayToWad();\\n    }\\n\\n    /**\\n     * @notice Get `_account` principal debt amount for `_asset`\\n     * @dev Principal debt is rebase adjusted due to possible stock splits/reverse splits\\n     * @param _asset The asset address\\n     * @param _account The account to query amount for\\n     * @return Amount of principal debt for `_asset`\\n     */\\n    function getKreskoAssetDebtPrincipal(\\n        MinterState storage self,\\n        address _account,\\n        address _asset\\n    ) internal view returns (uint256) {\\n        return self.kreskoAssets[_asset].toRebasingAmount(self.kreskoAssetDebt[_account][_asset]);\\n    }\\n\\n    /**\\n     * @notice Get the total interest accrued on top of debt: Scaled Debt - Principal Debt\\n     * @return assetAmount Interest denominated in _asset\\n     * @return kissAmount Interest denominated in KISS. Ignores K-factor: $1 of interest = 1 KISS\\n     **/\\n    function getKreskoAssetDebtInterest(\\n        MinterState storage self,\\n        address _account,\\n        address _asset\\n    ) internal view returns (uint256 assetAmount, uint256 kissAmount) {\\n        assetAmount =\\n            self.getKreskoAssetDebtScaled(_account, _asset) -\\n            self.getKreskoAssetDebtPrincipal(_account, _asset);\\n        kissAmount = self.getKrAssetValue(_asset, assetAmount, true).oraclePriceToWad();\\n    }\\n\\n    /**\\n     * @notice Gets an index for the Kresko asset the account has minted.\\n     * @param _account The account to get the minted Kresko assets for.\\n     * @param _kreskoAsset The asset lookup address.\\n     * @return i = index of the minted Kresko asset.\\n     */\\n    function getMintedKreskoAssetsIndex(\\n        MinterState storage self,\\n        address _account,\\n        address _kreskoAsset\\n    ) internal view returns (uint256 i) {\\n        uint256 length = self.mintedKreskoAssets[_account].length;\\n        require(length > 0, Error.NO_KRASSETS_MINTED);\\n        for (i; i < length; i++) {\\n            if (self.mintedKreskoAssets[_account][i] == _kreskoAsset) {\\n                break;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets an index for the collateral asset the account has deposited.\\n     * @param _account The account to get the index for.\\n     * @param _collateralAsset The asset lookup address.\\n     * @return i = index of the minted collateral asset.\\n     */\\n    function getDepositedCollateralAssetIndex(\\n        MinterState storage self,\\n        address _account,\\n        address _collateralAsset\\n    ) internal view returns (uint256 i) {\\n        uint256 length = self.depositedCollateralAssets[_account].length;\\n        require(length > 0, Error.NO_COLLATERAL_DEPOSITS);\\n        for (i; i < length; i++) {\\n            if (self.depositedCollateralAssets[_account][i] == _collateralAsset) {\\n                break;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8c9468def9b6d5c76b0f123f18cb342fc49ee06c9f2fe7b82367ffc91c4526bb\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/libs/LibAssetUtility.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\nimport {CollateralAsset, KrAsset} from \\\"../MinterTypes.sol\\\";\\nimport {LibDecimals} from \\\"../libs/LibDecimals.sol\\\";\\nimport {IKreskoAssetAnchor} from \\\"../../kreskoasset/IKreskoAssetAnchor.sol\\\";\\nimport {WadRay} from \\\"../../libs/WadRay.sol\\\";\\n\\n/**\\n * @title LibAssetUtility\\n * @author Kresko\\n * @notice Utility functions for KrAsset and CollateralAsset structs\\n */\\nlibrary LibAssetUtility {\\n    using WadRay for uint256;\\n    using LibDecimals for int256;\\n\\n    /**\\n     * @notice Amount of non rebasing tokens -> amount of rebasing tokens\\n     * @param self the kresko asset struct\\n     * @param _nonRebasedAmount the amount to convert\\n     */\\n    function toRebasingAmount(KrAsset memory self, uint256 _nonRebasedAmount) internal view returns (uint256) {\\n        return IKreskoAssetAnchor(self.anchor).convertToAssets(_nonRebasedAmount);\\n    }\\n\\n    /**\\n     * @notice Amount of non rebasing tokens -> amount of rebasing tokens\\n     * @dev if collateral is not a kresko asset, returns the input\\n     * @param self the collateral asset struct\\n     * @param _nonRebasedAmount the amount to convert\\n     */\\n    function toRebasingAmount(CollateralAsset memory self, uint256 _nonRebasedAmount) internal view returns (uint256) {\\n        if (self.anchor == address(0)) return _nonRebasedAmount;\\n        return IKreskoAssetAnchor(self.anchor).convertToAssets(_nonRebasedAmount);\\n    }\\n\\n    /**\\n     * @notice Amount of rebasing tokens -> amount of non rebasing tokens\\n     * @param self the kresko asset struct\\n     * @param _maybeRebasedAmount the amount to convert\\n     */\\n    function toNonRebasingAmount(KrAsset memory self, uint256 _maybeRebasedAmount) internal view returns (uint256) {\\n        return IKreskoAssetAnchor(self.anchor).convertToShares(_maybeRebasedAmount);\\n    }\\n\\n    /**\\n     * @notice Amount of rebasing tokens -> amount of non rebasing tokens\\n     * @dev if collateral is not a kresko asset, returns the input\\n     * @param self the collateral asset struct\\n     * @param _maybeRebasedAmount the amount to convert\\n     */\\n    function toNonRebasingAmount(\\n        CollateralAsset memory self,\\n        uint256 _maybeRebasedAmount\\n    ) internal view returns (uint256) {\\n        if (self.anchor == address(0)) return _maybeRebasedAmount;\\n        return IKreskoAssetAnchor(self.anchor).convertToShares(_maybeRebasedAmount);\\n    }\\n\\n    /**\\n     * @notice Get the oracle price of a collateral asset in uint256 with extOracleDecimals\\n     */\\n    function uintPrice(CollateralAsset memory self) internal view returns (uint256) {\\n        return uint256(self.oracle.latestAnswer());\\n    }\\n\\n    /**\\n     * @notice Get the oracle price of a kresko asset in uint256 with extOracleDecimals\\n     */\\n    function uintPrice(KrAsset memory self) internal view returns (uint256) {\\n        return uint256(self.oracle.latestAnswer());\\n    }\\n\\n    /**\\n     * @notice Get the oracle price of a collateral asset in uint256 with 18 decimals\\n     */\\n    function wadPrice(CollateralAsset memory self) internal view returns (uint256) {\\n        return self.oracle.latestAnswer().oraclePriceToWad();\\n    }\\n\\n    /**\\n     * @notice Get the oracle price of a kresko asset in uint256 with 18 decimals\\n     */\\n    function wadPrice(KrAsset memory self) internal view returns (uint256) {\\n        return self.oracle.latestAnswer().oraclePriceToWad();\\n    }\\n\\n    /**\\n     * @notice Get value for @param _assetAmount of @param self in uint256\\n     */\\n    function uintUSD(CollateralAsset memory self, uint256 _assetAmount) internal view returns (uint256) {\\n        return self.uintPrice().wadMul(_assetAmount);\\n    }\\n\\n    /**\\n     * @notice Get value for @param _assetAmount of @param self in uint256\\n     */\\n    function uintUSD(KrAsset memory self, uint256 _assetAmount) internal view returns (uint256) {\\n        return self.uintPrice().wadMul(_assetAmount);\\n    }\\n}\\n\",\"keccak256\":\"0x59d7561f5ffad4fca3e95b533f3dd24e29a9e016277cfc1c4c961b67ebec5614\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/libs/LibBurn.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n// solhint-disable not-rely-on-time\\n\\nimport {Arrays} from \\\"../../libs/Arrays.sol\\\";\\nimport {MinterEvent, InterestRateEvent} from \\\"../../libs/Events.sol\\\";\\nimport {Error} from \\\"../../libs/Errors.sol\\\";\\nimport {WadRay} from \\\"../../libs/WadRay.sol\\\";\\nimport {IERC20Permit} from \\\"../../shared/IERC20Permit.sol\\\";\\nimport {SafeERC20} from \\\"../../shared/SafeERC20.sol\\\";\\nimport {IKreskoAssetIssuer} from \\\"../../kreskoasset/IKreskoAssetIssuer.sol\\\";\\n\\nimport {LibDecimals} from \\\"../libs/LibDecimals.sol\\\";\\nimport {LibCalculation} from \\\"./LibCalculation.sol\\\";\\nimport {KrAsset} from \\\"../MinterTypes.sol\\\";\\nimport {irs} from \\\"../InterestRateState.sol\\\";\\nimport {MinterState} from \\\"../MinterState.sol\\\";\\n\\nlibrary LibBurn {\\n    using Arrays for address[];\\n\\n    using LibDecimals for uint8;\\n    using LibDecimals for uint256;\\n    using WadRay for uint256;\\n\\n    using SafeERC20 for IERC20Permit;\\n    using LibCalculation for MinterState;\\n\\n    /// @notice Repay user kresko asset debt with stability rate updates.\\n    /// @dev Updates the principal in MinterState and stability rate adjusted values in InterestRateState\\n    /// @param _kreskoAsset the asset being repaid\\n    /// @param _anchor the anchor token of the asset being repaid\\n    /// @param _burnAmount the asset amount being burned\\n    /// @param _account the account the debt is subtracted from\\n    function burn(\\n        MinterState storage self,\\n        address _kreskoAsset,\\n        address _anchor,\\n        uint256 _burnAmount,\\n        address _account\\n    ) internal {\\n        // Update global debt index for the asset\\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\\n        // Get the possibly rebalanced amount of destroyed tokens\\n        uint256 destroyed = IKreskoAssetIssuer(_anchor).destroy(_burnAmount, msg.sender);\\n        // Calculate the debt index scaled amount\\n        uint256 amountScaled = destroyed.wadToRay().rayDiv(newDebtIndex);\\n        require(amountScaled != 0, Error.INVALID_SCALED_AMOUNT);\\n\\n        // Decrease the principal debt\\n        self.kreskoAssetDebt[_account][_kreskoAsset] -= destroyed;\\n        // Decrease the scaled debt and set user asset's last debt index\\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled -= uint128(amountScaled);\\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\\n        // Update the stability rate for the asset\\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\\n    }\\n\\n    /// @notice Repay user global asset debt. Updates rates for regular market.\\n    /// @param _kreskoAsset the asset being repaid\\n    /// @param _burnAmount the asset amount being burned\\n    function repaySwap(\\n        MinterState storage self,\\n        address _kreskoAsset,\\n        uint256 _burnAmount,\\n        address _from\\n    ) internal returns (uint256 destroyed) {\\n        // Burn assets from the protocol, as they are sent in. Get the destroyed shares.\\n        destroyed = IKreskoAssetIssuer(self.kreskoAssets[_kreskoAsset].anchor).destroy(_burnAmount, _from);\\n        require(destroyed != 0, \\\"repay-destroyed-amount-invalid\\\");\\n    }\\n\\n    /**\\n     * @notice Repays accrued stability rate interest for a single asset\\n     * @param _account Account to repay interest for\\n     * @param _kreskoAsset Kresko asset to repay interest for\\n     * @return kissRepayAmount amount repaid\\n     */\\n    function repayFullStabilityRateInterest(\\n        MinterState storage self,\\n        address _account,\\n        address _kreskoAsset\\n    ) internal returns (uint256 kissRepayAmount) {\\n        // Update debt index for the asset\\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\\n        // Get the accrued interest in repayment token\\n        (, kissRepayAmount) = self.getKreskoAssetDebtInterest(_account, _kreskoAsset);\\n\\n        // If no interest has accrued no further operations needed\\n        // Do not revert because we want the preserve new debt index and stability rate\\n        if (kissRepayAmount == 0) {\\n            // Update stability rate for asset\\n            irs().srAssets[_kreskoAsset].updateStabilityRate();\\n            return 0;\\n        }\\n\\n        // Transfer the accrued interest\\n        IERC20Permit(irs().kiss).safeTransferFrom(msg.sender, self.feeRecipient, kissRepayAmount);\\n\\n        // Update scaled values for the user\\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled = uint128(\\n            self.getKreskoAssetDebtPrincipal(_account, _kreskoAsset).wadToRay().rayDiv(newDebtIndex)\\n        );\\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\\n\\n        // Remove from minted kresko assets if debt is cleared\\n        if (self.getKreskoAssetDebtPrincipal(_account, _kreskoAsset) == 0) {\\n            self.mintedKreskoAssets[_account].removeAddress(\\n                _kreskoAsset,\\n                self.getMintedKreskoAssetsIndex(_account, _kreskoAsset)\\n            );\\n        }\\n\\n        // Update stability rates\\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\\n        // Emit event with the account, asset and amount repaid\\n        emit InterestRateEvent.StabilityRateInterestRepaid(_account, _kreskoAsset, kissRepayAmount);\\n    }\\n\\n    /**\\n     * @notice Charges the protocol close fee based off the value of the burned asset.\\n     * @dev Takes the fee from the account's collateral assets. Attempts collateral assets\\n     *   in reverse order of the account's deposited collateral assets array.\\n     * @param _account The account to charge the close fee from.\\n     * @param _kreskoAsset The address of the kresko asset being burned.\\n     * @param _burnAmount The amount of the kresko asset being burned.\\n     */\\n    function chargeCloseFee(\\n        MinterState storage self,\\n        address _account,\\n        address _kreskoAsset,\\n        uint256 _burnAmount\\n    ) internal {\\n        KrAsset memory krAsset = self.kreskoAssets[_kreskoAsset];\\n        // Calculate the value of the fee according to the value of the krAssets being burned.\\n        uint256 feeValue = krAsset.uintUSD(_burnAmount).wadMul(krAsset.closeFee);\\n\\n        // Do nothing if the fee value is 0.\\n        if (feeValue == 0) {\\n            return;\\n        }\\n\\n        address[] memory accountCollateralAssets = self.depositedCollateralAssets[_account];\\n        // Iterate backward through the account's deposited collateral assets to safely\\n        // traverse the array while still being able to remove elements if necessary.\\n        // This is because removing the last element of the array does not shift around\\n        // other elements in the array.\\n\\n        for (uint256 i = accountCollateralAssets.length - 1; i >= 0; i--) {\\n            address collateralAssetAddress = accountCollateralAssets[i];\\n\\n            (uint256 transferAmount, uint256 feeValuePaid) = self.calcFee(\\n                collateralAssetAddress,\\n                _account,\\n                feeValue,\\n                i\\n            );\\n\\n            // Remove the transferAmount from the stored deposit for the account.\\n            self.collateralDeposits[_account][collateralAssetAddress] -= self\\n                .collateralAssets[collateralAssetAddress]\\n                .toNonRebasingAmount(transferAmount);\\n\\n            // Transfer the fee to the feeRecipient.\\n            IERC20Permit(collateralAssetAddress).safeTransfer(self.feeRecipient, transferAmount);\\n            emit MinterEvent.CloseFeePaid(_account, collateralAssetAddress, transferAmount, feeValuePaid);\\n\\n            feeValue = feeValue - feeValuePaid;\\n            // If the entire fee has been paid, no more action needed.\\n            if (feeValue == 0) {\\n                return;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Check that debt repaid does not leave a dust position, if it does:\\n     * return an amount that pays up to minDebtValue\\n     * @param _kreskoAsset The address of the kresko asset being burned.\\n     * @param _burnAmount The amount being burned\\n     * @param _debtAmount The debt amount of `_account`\\n     * @return amount == 0 or >= minDebtAmount\\n     */\\n    function ensureNotDustPosition(\\n        MinterState storage self,\\n        address _kreskoAsset,\\n        uint256 _burnAmount,\\n        uint256 _debtAmount\\n    ) internal view returns (uint256 amount) {\\n        // If the requested burn would put the user's debt position below the minimum\\n        // debt value, close up to the minimum debt value instead.\\n        uint256 krAssetValue = self.getKrAssetValue(_kreskoAsset, _debtAmount - _burnAmount, true);\\n        if (krAssetValue > 0 && krAssetValue < self.minimumDebtValue) {\\n            uint256 minDebtValue = self.minimumDebtValue.wadDiv(self.kreskoAssets[_kreskoAsset].uintPrice());\\n            amount = _debtAmount - minDebtValue;\\n        } else {\\n            amount = _burnAmount;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf3c8135a5515f07db399c5df8174e53b0d447639966242183c5cf670dd95ee4b\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/libs/LibCalculation.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {Arrays} from \\\"../../libs/Arrays.sol\\\";\\nimport {MinterEvent} from \\\"../../libs/Events.sol\\\";\\nimport {LibDecimals} from \\\"../libs/LibDecimals.sol\\\";\\nimport {WadRay} from \\\"../../libs/WadRay.sol\\\";\\nimport {MinterState} from \\\"../MinterState.sol\\\";\\nimport {KrAsset, CollateralAsset, Constants} from \\\"../MinterTypes.sol\\\";\\nimport {cps} from \\\"../collateral-pool/CollateralPoolState.sol\\\";\\n\\n/**\\n * @title Calculation library for liquidation & fee values\\n * @author Kresko\\n */\\nlibrary LibCalculation {\\n    struct MaxLiquidationVars {\\n        CollateralAsset collateral;\\n        uint256 accountCollateralValue;\\n        uint256 minCollateralValue;\\n        uint256 seizeCollateralAccountValue;\\n        uint256 maxLiquidationMultiplier;\\n        uint256 minimumDebtValue;\\n        uint256 liquidationThreshold;\\n        uint256 debtFactor;\\n    }\\n\\n    using Arrays for address[];\\n    using LibDecimals for uint8;\\n    using LibDecimals for uint256;\\n    using WadRay for uint256;\\n\\n    /**\\n     * @dev Calculates the total value that can be liquidated for a liquidation pair\\n     * @param _account address to liquidate\\n     * @param _repayKreskoAsset address of the kreskoAsset being repaid on behalf of the liquidatee\\n     * @param _seizedCollateral The collateral asset being seized in the liquidation\\n     * @return maxLiquidatableUSD USD value that can be liquidated, 0 if the pair has no liquidatable value\\n     */\\n    function getMaxLiquidation(\\n        MinterState storage self,\\n        address _account,\\n        KrAsset memory _repayKreskoAsset,\\n        address _seizedCollateral\\n    ) internal view returns (uint256 maxLiquidatableUSD) {\\n        MaxLiquidationVars memory vars = _account != address(0)\\n            ? _getMaxLiquidationParams(self, _account, _repayKreskoAsset, _seizedCollateral)\\n            : _getMaxLiquidationParamsShared(self, _repayKreskoAsset, _seizedCollateral);\\n        // Account is not liquidatable\\n        if (vars.accountCollateralValue >= (vars.minCollateralValue)) {\\n            return 0;\\n        }\\n\\n        maxLiquidatableUSD = _getMaxLiquidatableUSD(vars, _repayKreskoAsset);\\n\\n        if (vars.seizeCollateralAccountValue < maxLiquidatableUSD) {\\n            return vars.seizeCollateralAccountValue;\\n        } else if (maxLiquidatableUSD < vars.minimumDebtValue) {\\n            return vars.minimumDebtValue;\\n        } else {\\n            return maxLiquidatableUSD;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate amount of collateral to seize during the liquidation procesself.\\n     * @param _liquidationIncentiveMultiplier The liquidation incentive multiplier.\\n     * @param _collateralOraclePriceUSD The address of the collateral asset to be seized.\\n     * @param _kreskoAssetRepayAmountUSD Kresko asset amount being repaid in exchange for the seized collateral.\\n     */\\n    function calculateAmountToSeize(\\n        uint256 _liquidationIncentiveMultiplier,\\n        uint256 _collateralOraclePriceUSD,\\n        uint256 _kreskoAssetRepayAmountUSD\\n    ) internal pure returns (uint256) {\\n        // Seize amount = (repay amount USD * liquidation incentive / collateral price USD).\\n        // Denominate seize amount in collateral type\\n        // Apply liquidation incentive multiplier\\n        return _kreskoAssetRepayAmountUSD.wadMul(_liquidationIncentiveMultiplier).wadDiv(_collateralOraclePriceUSD);\\n    }\\n\\n    /**\\n     * @notice Calculates the fee to be taken from a user's deposited collateral assetself.\\n     * @param _collateralAsset The collateral asset from which to take to the fee.\\n     * @param _account The owner of the collateral.\\n     * @param _feeValue The original value of the fee.\\n     * @param _collateralAssetIndex The collateral asset's index in the user's depositedCollateralAssets array.\\n     *\\n     * @return transferAmount to be received as a uint256\\n     * @return feeValuePaid wad representing the fee value paid.\\n     */\\n    function calcFee(\\n        MinterState storage self,\\n        address _collateralAsset,\\n        address _account,\\n        uint256 _feeValue,\\n        uint256 _collateralAssetIndex\\n    ) internal returns (uint256 transferAmount, uint256 feeValuePaid) {\\n        uint256 depositAmount = self.getCollateralDeposits(_account, _collateralAsset);\\n\\n        // Don't take the collateral asset's collateral factor into consideration.\\n        (uint256 depositValue, uint256 oraclePrice) = self.getCollateralValueAndOraclePrice(\\n            _collateralAsset,\\n            depositAmount,\\n            true\\n        );\\n\\n        if (_feeValue < depositValue) {\\n            // If feeValue < depositValue, the entire fee can be charged for this collateral asset.\\n            transferAmount = self.collateralAssets[_collateralAsset].decimals.fromWad(_feeValue.wadDiv(oraclePrice));\\n            feeValuePaid = _feeValue;\\n        } else {\\n            // If the feeValue >= depositValue, the entire deposit should be taken as the fee.\\n            transferAmount = depositAmount;\\n            feeValuePaid = depositValue;\\n            // Because the entire deposit is taken, remove it from the depositCollateralAssets array.\\n            self.depositedCollateralAssets[_account].removeAddress(_collateralAsset, _collateralAssetIndex);\\n        }\\n\\n        return (transferAmount, feeValuePaid);\\n    }\\n\\n    /**\\n     * @notice Calculates the maximum USD value of a given kreskoAsset that can be liquidated given a liquidation pair\\n     *\\n     * 1. Calculates the value gained per USD repaid in liquidation for a given kreskoAsset\\n     *\\n     * debtFactor = debtFactor = k * LT / cFactor;\\n     *\\n     * valPerUSD = (DebtFactor - Asset closeFee - liquidationIncentive) / DebtFactor\\n     *\\n     * 2. Calculates the maximum amount of USD value that can be liquidated given the account's collateral value\\n     *\\n     * maxLiquidatableUSD = (MCV - ACV) / valPerUSD / debtFactor / cFactor * LOM\\n     *\\n     * @dev This function is used by getMaxLiquidation and is factored out for readability\\n     * @param vars liquidation variables struct\\n     * @param _repayKreskoAsset The kreskoAsset being repaid in the liquidation\\n     */\\n    function _getMaxLiquidatableUSD(\\n        MaxLiquidationVars memory vars,\\n        KrAsset memory _repayKreskoAsset\\n    ) private pure returns (uint256) {\\n        uint256 valuePerUSDRepaid = (vars.debtFactor -\\n            vars.collateral.liquidationIncentive -\\n            _repayKreskoAsset.closeFee).wadDiv(vars.debtFactor);\\n        return\\n            (vars.minCollateralValue - vars.accountCollateralValue)\\n                .wadDiv(valuePerUSDRepaid)\\n                .wadDiv(vars.debtFactor)\\n                .wadDiv(vars.collateral.factor)\\n                .wadMul(vars.maxLiquidationMultiplier);\\n    }\\n\\n    function _getMaxLiquidationParams(\\n        MinterState storage state,\\n        address _account,\\n        KrAsset memory _repayKreskoAsset,\\n        address _seizedCollateral\\n    ) private view returns (MaxLiquidationVars memory) {\\n        uint256 liquidationThreshold = state.liquidationThreshold;\\n        uint256 minCollateralValue = state.getAccountMinimumCollateralValueAtRatio(_account, liquidationThreshold);\\n\\n        (uint256 accountCollateralValue, uint256 seizeCollateralAccountValue) = state.getAccountCollateralValue(\\n            _account,\\n            _seizedCollateral\\n        );\\n\\n        CollateralAsset memory collateral = state.collateralAssets[_seizedCollateral];\\n\\n        return\\n            MaxLiquidationVars({\\n                collateral: collateral,\\n                accountCollateralValue: accountCollateralValue,\\n                debtFactor: _repayKreskoAsset.kFactor.wadMul(liquidationThreshold).wadDiv(collateral.factor),\\n                minCollateralValue: minCollateralValue,\\n                minimumDebtValue: state.minimumDebtValue,\\n                seizeCollateralAccountValue: seizeCollateralAccountValue,\\n                liquidationThreshold: liquidationThreshold,\\n                maxLiquidationMultiplier: Constants.MIN_MAX_LIQUIDATION_MULTIPLIER\\n            });\\n    }\\n\\n    function _getMaxLiquidationParamsShared(\\n        MinterState storage state,\\n        KrAsset memory _repayKreskoAsset,\\n        address _seizedCollateral\\n    ) private view returns (MaxLiquidationVars memory) {\\n        uint256 liquidationThreshold = cps().liquidationThreshold;\\n        uint256 minCollateralValue = cps().getTotalPoolKrAssetValueAtRatio(liquidationThreshold, false);\\n\\n        (uint256 totalCollateralValue, uint256 seizeCollateralValue) = cps().getTotalPoolDepositValue(\\n            _seizedCollateral,\\n            cps().totalDeposits[_seizedCollateral],\\n            false\\n        );\\n\\n        CollateralAsset memory collateral = state.collateralAssets[_seizedCollateral];\\n\\n        return\\n            MaxLiquidationVars({\\n                collateral: collateral,\\n                accountCollateralValue: totalCollateralValue,\\n                debtFactor: _repayKreskoAsset.kFactor.wadMul(liquidationThreshold).wadDiv(collateral.factor),\\n                minCollateralValue: minCollateralValue,\\n                minimumDebtValue: state.minimumDebtValue,\\n                seizeCollateralAccountValue: seizeCollateralValue,\\n                liquidationThreshold: liquidationThreshold,\\n                maxLiquidationMultiplier: Constants.MIN_MAX_LIQUIDATION_MULTIPLIER\\n            });\\n    }\\n}\\n\",\"keccak256\":\"0x8a1970334f17c8c789e47e056d7f8677311f3e5d481ad89d6841c53daaca3494\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/libs/LibCollateral.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\nimport {AggregatorV2V3Interface} from \\\"../../vendor/flux/interfaces/AggregatorV2V3Interface.sol\\\";\\nimport {IKreskoAssetAnchor} from \\\"../../kreskoasset/IKreskoAssetAnchor.sol\\\";\\nimport {LibDecimals} from \\\"../libs/LibDecimals.sol\\\";\\nimport {Arrays} from \\\"../../libs/Arrays.sol\\\";\\nimport {Error} from \\\"../../libs/Errors.sol\\\";\\nimport {MinterEvent} from \\\"../../libs/Events.sol\\\";\\nimport {WadRay} from \\\"../../libs/WadRay.sol\\\";\\nimport {CollateralAsset} from \\\"../MinterTypes.sol\\\";\\nimport {MinterState} from \\\"../MinterState.sol\\\";\\n\\n/**\\n * @title Library for collateral related operations\\n * @author Kresko\\n */\\nlibrary LibCollateral {\\n    using LibDecimals for uint8;\\n    using Arrays for address[];\\n    using WadRay for uint256;\\n\\n    /**\\n     * In case a collateral asset is also a kresko asset, convert an amount to anchor shares\\n     * @param _amount amount to possibly convert\\n     * @param _collateralAsset address of the collateral asset\\n     */\\n    function normalizeCollateralAmount(\\n        MinterState storage self,\\n        uint256 _amount,\\n        address _collateralAsset\\n    ) internal view returns (uint256 amount) {\\n        CollateralAsset memory asset = self.collateralAssets[_collateralAsset];\\n        if (asset.anchor != address(0)) {\\n            return IKreskoAssetAnchor(asset.anchor).convertToShares(_amount);\\n        }\\n        return _amount;\\n    }\\n\\n    /**\\n     * @notice Get the state of a specific collateral asset\\n     * @param _asset Address of the asset.\\n     * @return State of assets `CollateralAsset` struct\\n     */\\n    function collateralAsset(MinterState storage self, address _asset) internal view returns (CollateralAsset memory) {\\n        return self.collateralAssets[_asset];\\n    }\\n\\n    /**\\n     * @notice Gets the collateral value for a single collateral asset and amount.\\n     * @param _collateralAsset The address of the collateral asset.\\n     * @param _amount The amount of the collateral asset to calculate the collateral value for.\\n     * @param _ignoreCollateralFactor Boolean indicating if the asset's collateral factor should be ignored.\\n     * @return The collateral value for the provided amount of the collateral asset.\\n     */\\n    function getCollateralValueAndOraclePrice(\\n        MinterState storage self,\\n        address _collateralAsset,\\n        uint256 _amount,\\n        bool _ignoreCollateralFactor\\n    ) internal view returns (uint256, uint256) {\\n        CollateralAsset memory asset = self.collateralAssets[_collateralAsset];\\n\\n        uint256 oraclePrice = asset.uintPrice();\\n        uint256 value = asset.decimals.toWad(_amount).wadMul(oraclePrice);\\n\\n        if (!_ignoreCollateralFactor) {\\n            value = value.wadMul(asset.factor);\\n        }\\n        return (value, oraclePrice);\\n    }\\n\\n    /**\\n     * @notice verifies that the account has sufficient collateral for the requested amount and records the collateral\\n     * @param _account The address of the account to verify the collateral for.\\n     * @param _collateralAsset The address of the collateral asset.\\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\\n     * @param _collateralDeposits Collateral deposits for the account.\\n     * @param _depositedCollateralAssetIndex Index of the collateral asset in the account's deposited collateral assets array.\\n     */\\n    function verifyAndRecordCollateralWithdrawal(\\n        MinterState storage self,\\n        address _account,\\n        address _collateralAsset,\\n        uint256 _withdrawAmount,\\n        uint256 _collateralDeposits,\\n        uint256 _depositedCollateralAssetIndex\\n    ) internal {\\n        require(_withdrawAmount > 0, Error.ZERO_WITHDRAW);\\n        require(\\n            _depositedCollateralAssetIndex <= self.depositedCollateralAssets[_account].length - 1,\\n            Error.ARRAY_OUT_OF_BOUNDS\\n        );\\n\\n        // Ensure that the operation passes checks MCR checks\\n        verifyAccountCollateral(self, _account, _collateralAsset, _withdrawAmount);\\n\\n        // Record the withdrawal.\\n        self.collateralDeposits[_account][_collateralAsset] = self\\n            .collateralAssets[_collateralAsset]\\n            .toNonRebasingAmount(_collateralDeposits - _withdrawAmount);\\n\\n        // If the user is withdrawing all of the collateral asset, remove the collateral asset\\n        // from the user's deposited collateral assets array.\\n        if (_withdrawAmount == _collateralDeposits) {\\n            self.depositedCollateralAssets[_account].removeAddress(_collateralAsset, _depositedCollateralAssetIndex);\\n        }\\n\\n        emit MinterEvent.CollateralWithdrawn(_account, _collateralAsset, _withdrawAmount);\\n    }\\n\\n    /**\\n     * @notice Records account as having deposited an amount of a collateral asset.\\n     * @dev Token transfers are expected to be done by the caller.\\n     * @param _account The address of the collateral asset.\\n     * @param _collateralAsset The address of the collateral asset.\\n     * @param _depositAmount The amount of the collateral asset deposited.\\n     */\\n    function recordCollateralDeposit(\\n        MinterState storage self,\\n        address _account,\\n        address _collateralAsset,\\n        uint256 _depositAmount\\n    ) internal {\\n        // Because the depositedCollateralAssets[_account] is pushed to if the existing\\n        // deposit amount is 0, require the amount to be > 0. Otherwise, the depositedCollateralAssets[_account]\\n        // could be filled with duplicates, causing collateral to be double-counted in the collateral value.\\n        require(_depositAmount > 0, Error.ZERO_DEPOSIT);\\n\\n        // If the account does not have an existing deposit for this collateral asset,\\n        // push it to the list of the account's deposited collateral assets.\\n        uint256 existingDepositAmount = self.getCollateralDeposits(_account, _collateralAsset);\\n        if (existingDepositAmount == 0) {\\n            self.depositedCollateralAssets[_account].push(_collateralAsset);\\n        }\\n        // Record the deposit.\\n        unchecked {\\n            self.collateralDeposits[_account][_collateralAsset] = self\\n                .collateralAssets[_collateralAsset]\\n                .toNonRebasingAmount(existingDepositAmount + _depositAmount);\\n        }\\n\\n        emit MinterEvent.CollateralDeposited(_account, _collateralAsset, _depositAmount);\\n    }\\n\\n    /**\\n     * @notice records the collateral withdrawal\\n     * @param _account The address of the account to verify the collateral for.\\n     * @param _collateralAsset The address of the collateral asset.\\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\\n     * @param _collateralDeposits Collateral deposits for the account.\\n     * @param _depositedCollateralAssetIndex Index of the collateral asset in the account's deposited collateral assets array.\\n     */\\n    function recordCollateralWithdrawal(\\n        MinterState storage self,\\n        address _account,\\n        address _collateralAsset,\\n        uint256 _withdrawAmount,\\n        uint256 _collateralDeposits,\\n        uint256 _depositedCollateralAssetIndex\\n    ) internal {\\n        require(_withdrawAmount > 0, Error.ZERO_WITHDRAW);\\n        require(\\n            _depositedCollateralAssetIndex <= self.depositedCollateralAssets[_account].length - 1,\\n            Error.ARRAY_OUT_OF_BOUNDS\\n        );\\n        // ensure that the handler does not attempt to withdraw more collateral than the account has\\n        require(_collateralDeposits >= _withdrawAmount, Error.COLLATERAL_INSUFFICIENT_AMOUNT);\\n\\n        // Record the withdrawal.\\n        self.collateralDeposits[_account][_collateralAsset] = self\\n            .collateralAssets[_collateralAsset]\\n            .toNonRebasingAmount(_collateralDeposits - _withdrawAmount);\\n\\n        // If the user is withdrawing all of the collateral asset, remove the collateral asset\\n        // from the user's deposited collateral assets array.\\n        if (_withdrawAmount == _collateralDeposits) {\\n            self.depositedCollateralAssets[_account].removeAddress(_collateralAsset, _depositedCollateralAssetIndex);\\n        }\\n\\n        emit MinterEvent.UncheckedCollateralWithdrawn(_account, _collateralAsset, _withdrawAmount);\\n    }\\n\\n    /**\\n     * @notice verifies that the account collateral\\n     * @param _account The address of the account to verify the collateral for.\\n     * @param _collateralAsset The address of the collateral asset.\\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\\n     */\\n    function verifyAccountCollateral(\\n        MinterState storage self,\\n        address _account,\\n        address _collateralAsset,\\n        uint256 _withdrawAmount\\n    ) internal view {\\n        // Ensure the withdrawal does not result in the account having a collateral value\\n        // under the minimum collateral amount required to maintain a healthy position.\\n        // I.e. the new account's collateral value must still exceed the account's minimum\\n        // collateral value.\\n        // Get the account's current collateral value.\\n        uint256 accountCollateralValue = self.getAccountCollateralValue(_account);\\n        // Get the collateral value that the account will lose as a result of this withdrawal.\\n        (uint256 withdrawnCollateralValue, ) = self.getCollateralValueAndOraclePrice(\\n            _collateralAsset,\\n            _withdrawAmount,\\n            false // Take the collateral factor into consideration.\\n        );\\n        // Get the account's minimum collateral value.\\n        uint256 accountMinCollateralValue = self.getAccountMinimumCollateralValueAtRatio(\\n            _account,\\n            self.minimumCollateralizationRatio\\n        );\\n        // Require accountMinCollateralValue <= accountCollateralValue - withdrawnCollateralValue.\\n        require(\\n            accountMinCollateralValue <= accountCollateralValue - withdrawnCollateralValue,\\n            Error.COLLATERAL_INSUFFICIENT_AMOUNT\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x80f24c2b27d4d2fd40f57a9daeaff4d69e57db432a0ee57c07a61712f9dc6fa8\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/libs/LibDecimals.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\nimport {ms} from \\\"../MinterStorage.sol\\\";\\n\\n/**\\n * @title Library for Kresko specific decimals\\n */\\nlibrary LibDecimals {\\n    /**\\n     * @notice For a given collateral asset and amount, returns a wad represenatation.\\n     * @dev If the collateral asset has decimals other than 18, the amount is scaled appropriately.\\n     *   If decimals > 18, there may be a loss of precision.\\n     * @param _decimals The collateral asset's number of decimals\\n     * @param _amount The amount of the collateral asset.\\n     * @return A fp of amount scaled according to the collateral asset's decimals.\\n     */\\n    function toWad(uint256 _decimals, uint256 _amount) internal pure returns (uint256) {\\n        // Initially, use the amount as the raw value for the fixed point.\\n        // which internally uses 18 decimals.\\n        // Most collateral assets will have 18 decimals.\\n\\n        // Handle cases where the collateral asset's decimal amount is not 18.\\n        if (_decimals < 18) {\\n            // If the decimals are less than 18, multiply the amount\\n            // to get the correct wad value.\\n            // E.g. 1 full token of a 17 decimal token will  cause the\\n            // initial setting of amount to be 0.1, so we multiply\\n            // by 10 ** (18 - 17) = 10 to get it to 0.1 * 10 = 1.\\n            return _amount * (10 ** (18 - _decimals));\\n        } else if (_decimals > 18) {\\n            // If the decimals are greater than 18, divide the amount\\n            // to get the correct fixed point value.\\n            // Note because wad numbers are 18 decimals, this results\\n            // in loss of precision. E.g. if the collateral asset has 19\\n            // decimals and the deposit amount is only 1 uint, this will divide\\n            // 1 by 10 ** (19 - 18), resulting in 1 / 10 = 0\\n            return _amount / (10 ** (_decimals - 18));\\n        }\\n        return _amount;\\n    }\\n\\n    /**\\n     * @notice For a given collateral asset and wad amount, returns the collateral amount.\\n     * @dev If the collateral asset has decimals other than 18, the amount is scaled appropriately.\\n     *   If decimals < 18, there may be a loss of precision.\\n     * @param _decimals The collateral asset's number of decimals\\n     * @param _wadAmount The wad amount of the collateral asset.\\n     * @return An amount that is compatible with the collateral asset's decimals.\\n     */\\n    function fromWad(uint256 _decimals, uint256 _wadAmount) internal pure returns (uint256) {\\n        // Initially, use the rawValue, which internally uses 18 decimals.\\n        // Most collateral assets will have 18 decimals.\\n        // Handle cases where the collateral asset's decimal amount is not 18.\\n        if (_decimals < 18) {\\n            // If the decimals are less than 18, divide the depositAmount\\n            // to get the correct collateral amount.\\n            // E.g. 1 full token will result in amount being 1e18 at this point,\\n            // so if the token has 17 decimals, divide by 10 ** (18 - 17) = 10\\n            // to get a value of 1e17.\\n            // This may result in a loss of precision.\\n            return _wadAmount / (10 ** (18 - _decimals));\\n        } else if (_decimals > 18) {\\n            // If the decimals are greater than 18, multiply the depositAmount\\n            // to get the correct fixed point value.\\n            // E.g. 1 full token will result in amount being 1e18 at this point,\\n            // so if the token has 19 decimals, multiply by 10 ** (19 - 18) = 10\\n            // to get a value of 1e19.\\n            return _wadAmount * (10 ** (_decimals - 18));\\n        }\\n        return _wadAmount;\\n    }\\n\\n    /**\\n     * @notice Divides an uint256 @param _value with @param _priceWithOracleDecimals\\n     * @param _value Left side value of the division\\n     * @param wadValue result with 18 decimals\\n     */\\n    function divByPrice(uint256 _value, uint256 _priceWithOracleDecimals) internal view returns (uint256 wadValue) {\\n        uint8 oracleDecimals = ms().extOracleDecimals;\\n        if (oracleDecimals >= 18) return _priceWithOracleDecimals;\\n        return (_value / _priceWithOracleDecimals) * 10 ** (oracleDecimals);\\n    }\\n\\n    /**\\n     * @notice Converts an uint256 with extOracleDecimals into a number with 18 decimals\\n     * @param _wadPrice value with extOracleDecimals\\n     */\\n    function fromWadPriceToUint(uint256 _wadPrice) internal view returns (uint256 priceWithOracleDecimals) {\\n        uint8 oracleDecimals = ms().extOracleDecimals;\\n        if (oracleDecimals == 18) return _wadPrice;\\n        return _wadPrice / 10 ** (18 - oracleDecimals);\\n    }\\n\\n    /**\\n     * @notice Converts an uint256 with extOracleDecimals into a number with 18 decimals\\n     * @param _priceWithOracleDecimals value with extOracleDecimals\\n     * @return wadPrice with 18 decimals\\n     */\\n    function oraclePriceToWad(uint256 _priceWithOracleDecimals) internal view returns (uint256) {\\n        uint8 oracleDecimals = ms().extOracleDecimals;\\n        if (oracleDecimals == 18) {\\n            return _priceWithOracleDecimals;\\n        }\\n        return _priceWithOracleDecimals * 10 ** (18 - oracleDecimals);\\n    }\\n\\n    /**\\n     * @notice Converts an int256 with extOracleDecimals into a number with 18 decimals\\n     * @param _priceWithOracleDecimals value with extOracleDecimals\\n     * @return wadPrice price with 18 decimals\\n     */\\n    function oraclePriceToWad(int256 _priceWithOracleDecimals) internal view returns (uint256) {\\n        uint8 oracleDecimals = ms().extOracleDecimals;\\n        if (oracleDecimals >= 18) return uint256(_priceWithOracleDecimals);\\n        return uint256(_priceWithOracleDecimals) * 10 ** (18 - oracleDecimals);\\n    }\\n}\\n\",\"keccak256\":\"0x518ecb00d349ad5584ac44b92d30be488f51c1359111000c54bf4c45f01b7c5a\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/libs/LibKrAsset.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {WadRay} from \\\"../../libs/WadRay.sol\\\";\\nimport {IUniswapV2OracleCompat} from \\\"../amm-oracle/IUniswapV2OracleCompat.sol\\\";\\nimport {KrAsset} from \\\"../MinterTypes.sol\\\";\\nimport {MinterState} from \\\"../MinterState.sol\\\";\\n\\nlibrary LibKrAsset {\\n    using WadRay for uint256;\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                  Functions                                 */\\n    /* -------------------------------------------------------------------------- */\\n    /**\\n     * @notice Get the state of a specific krAsset\\n     * @param _asset Address of the asset.\\n     * @return State of assets `KrAsset` struct\\n     */\\n    function kreskoAsset(MinterState storage self, address _asset) internal view returns (KrAsset memory) {\\n        return self.kreskoAssets[_asset];\\n    }\\n\\n    /**\\n     * @notice Get possibly rebased amount of kreskoAssets. Use when saving to storage.\\n     * @param _asset The asset address\\n     * @param _amount The account to query amount for\\n     * @return amount Amount of principal debt for `_asset`\\n     */\\n    function getKreskoAssetAmount(\\n        MinterState storage self,\\n        address _asset,\\n        uint256 _amount\\n    ) internal view returns (uint256 amount) {\\n        return self.kreskoAssets[_asset].toRebasingAmount(_amount);\\n    }\\n\\n    /**\\n     * @notice Gets the USD value for a single Kresko asset and amount.\\n     * @param _kreskoAsset The address of the Kresko asset.\\n     * @param _amount The amount of the Kresko asset to calculate the value for.\\n     * @param _ignoreKFactor Boolean indicating if the asset's k-factor should be ignored.\\n     * @return The value for the provided amount of the Kresko asset.\\n     */\\n    function getKrAssetValue(\\n        MinterState storage self,\\n        address _kreskoAsset,\\n        uint256 _amount,\\n        bool _ignoreKFactor\\n    ) internal view returns (uint256) {\\n        KrAsset memory krAsset = self.kreskoAssets[_kreskoAsset];\\n        uint256 value = krAsset.uintUSD(_amount);\\n\\n        if (!_ignoreKFactor) {\\n            value = value.wadMul(krAsset.kFactor);\\n        }\\n\\n        return value;\\n    }\\n\\n    /**\\n     * @notice Gets the AMM price for a Kresko asset.\\n     * @param _kreskoAsset The address of the Kresko asset.\\n     * @param _amount The amount of the Kresko asset to calculate the value for.\\n     * @return The value for the provided amount of the Kresko asset.\\n     */\\n    function getKrAssetAMMPrice(\\n        MinterState storage self,\\n        address _kreskoAsset,\\n        uint256 _amount\\n    ) internal view returns (uint256) {\\n        if (self.ammOracle == address(0)) {\\n            return 0;\\n        }\\n        return IUniswapV2OracleCompat(self.ammOracle).consultKrAsset(_kreskoAsset, _amount);\\n    }\\n\\n    /**\\n     * @notice Get the minimum collateral value required to\\n     * back a Kresko asset amount at a given collateralization ratio.\\n     * @param _krAsset The address of the Kresko asset.\\n     * @param _amount The Kresko Asset debt amount.\\n     * @return minCollateralValue is the minimum collateral value required for this Kresko Asset amount.\\n     * @param _ratio The collateralization ratio required: higher ratio = more collateral required.\\n     */\\n    function getMinimumCollateralValueAtRatio(\\n        MinterState storage self,\\n        address _krAsset,\\n        uint256 _amount,\\n        uint256 _ratio\\n    ) internal view returns (uint256 minCollateralValue) {\\n        // Calculate the collateral value required to back this Kresko asset amount at the given ratio\\n        return self.getKrAssetValue(_krAsset, _amount, false).wadMul(_ratio);\\n    }\\n}\\n\",\"keccak256\":\"0xfd242b5e422dbf511498ae2c27bce92e256dff3f3e99f2fc2fc146fc804e7ecb\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/libs/LibMint.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n// solhint-disable not-rely-on-time\\n// solhint-disable-next-line\\nimport {SafeERC20, IERC20Permit} from \\\"../../shared/SafeERC20.sol\\\";\\nimport {IKreskoAssetIssuer} from \\\"../../kreskoasset/IKreskoAssetIssuer.sol\\\";\\nimport {Arrays} from \\\"../../libs/Arrays.sol\\\";\\nimport {MinterEvent} from \\\"../../libs/Events.sol\\\";\\nimport {Error} from \\\"../../libs/Errors.sol\\\";\\nimport {LibDecimals} from \\\"../libs/LibDecimals.sol\\\";\\nimport {WadRay} from \\\"../../libs/WadRay.sol\\\";\\n\\nimport {LibCalculation} from \\\"./LibCalculation.sol\\\";\\nimport {KrAsset} from \\\"../MinterTypes.sol\\\";\\nimport {MinterState} from \\\"../MinterState.sol\\\";\\nimport {irs} from \\\"../InterestRateState.sol\\\";\\n\\nlibrary LibMint {\\n    using Arrays for address[];\\n\\n    using LibDecimals for uint8;\\n    using LibDecimals for uint256;\\n    using WadRay for uint256;\\n\\n    using SafeERC20 for IERC20Permit;\\n    using LibCalculation for MinterState;\\n\\n    /// @notice Mint kresko assets with stability rate updates.\\n    /// @dev Updates the principal in MinterState and stability rate adjusted values in InterestRateState\\n    /// @param _kreskoAsset the asset being repaid\\n    /// @param _anchor the anchor token of the asset being issued\\n    /// @param _amount the asset amount being minted\\n    /// @param _account the account to mint the assets to\\n    function mint(\\n        MinterState storage self,\\n        address _kreskoAsset,\\n        address _anchor,\\n        uint256 _amount,\\n        address _account\\n    ) internal {\\n        // Update global debt index for the asset\\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\\n        // Get possibly rebalanced amount of kresko asset\\n        uint256 issued = IKreskoAssetIssuer(_anchor).issue(_amount, _account);\\n        // Calculate debt index scaled value\\n        uint256 amountScaled = issued.wadToRay().rayDiv(newDebtIndex);\\n        require(amountScaled != 0, Error.INVALID_SCALED_AMOUNT);\\n        // Increase principal debt\\n        self.kreskoAssetDebt[_account][_kreskoAsset] += issued;\\n        // Update scaled values for the user\\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled += uint128(amountScaled);\\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\\n        // Update the global rate for the asset\\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\\n    }\\n\\n    /// @notice Mint kresko assets for shared debt pool.\\n    /// @dev Updates general markets stability rates and debt index.\\n    /// @param _kreskoAsset the asset requested\\n    /// @param _amount the asset amount requested\\n    /// @param _to the account to mint the assets to\\n    function mintSwap(\\n        MinterState storage self,\\n        address _kreskoAsset,\\n        uint256 _amount,\\n        address _to\\n    ) internal returns (uint256 issued) {\\n        issued = IKreskoAssetIssuer(self.kreskoAssets[_kreskoAsset].anchor).issue(_amount, _to);\\n        require(issued != 0, \\\"invalid-shared-pool-mint\\\");\\n    }\\n\\n    /**\\n     * @notice Charges the protocol open fee based off the value of the minted asset.\\n     * @dev Takes the fee from the account's collateral assets. Attempts collateral assets\\n     *   in reverse order of the account's deposited collateral assets array.\\n     * @param _account The account to charge the open fee from.\\n     * @param _kreskoAsset The address of the kresko asset being burned.\\n     * @param _kreskoAssetAmountMinted The amount of the kresko asset being minted.\\n     */\\n    function chargeOpenFee(\\n        MinterState storage self,\\n        address _account,\\n        address _kreskoAsset,\\n        uint256 _kreskoAssetAmountMinted\\n    ) internal {\\n        KrAsset memory krAsset = self.kreskoAssets[_kreskoAsset];\\n        // Calculate the value of the fee according to the value of the krAssets being minted.\\n        uint256 feeValue = krAsset.uintUSD(_kreskoAssetAmountMinted).wadMul(krAsset.openFee);\\n\\n        // Do nothing if the fee value is 0.\\n        if (feeValue == 0) {\\n            return;\\n        }\\n\\n        address[] memory accountCollateralAssets = self.depositedCollateralAssets[_account];\\n        // Iterate backward through the account's deposited collateral assets to safely\\n        // traverse the array while still being able to remove elements if necessary.\\n        // This is because removing the last element of the array does not shift around\\n        // other elements in the array.\\n        for (uint256 i = accountCollateralAssets.length - 1; i >= 0; i--) {\\n            address collateralAssetAddress = accountCollateralAssets[i];\\n\\n            (uint256 transferAmount, uint256 feeValuePaid) = self.calcFee(\\n                collateralAssetAddress,\\n                _account,\\n                feeValue,\\n                i\\n            );\\n\\n            // Remove the transferAmount from the stored deposit for the account.\\n            self.collateralDeposits[_account][collateralAssetAddress] -= self\\n                .collateralAssets[collateralAssetAddress]\\n                .toNonRebasingAmount(transferAmount);\\n\\n            // Transfer the fee to the feeRecipient.\\n            IERC20Permit(collateralAssetAddress).safeTransfer(self.feeRecipient, transferAmount);\\n            emit MinterEvent.OpenFeePaid(_account, collateralAssetAddress, transferAmount, feeValuePaid);\\n\\n            feeValue = feeValue - feeValuePaid;\\n            // If the entire fee has been paid, no more action needed.\\n            if (feeValue == 0) {\\n                return;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2c7d10c1690d76b6cac4264e3194eac5de53665ada372278d12093b35238b693\",\"license\":\"BUSL-1.1\"},\"src/contracts/minter/libs/LibStabilityRate.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {IKreskoAsset} from \\\"../../kreskoasset/IKreskoAsset.sol\\\";\\nimport {IERC20Permit} from \\\"../../shared/IERC20Permit.sol\\\";\\n\\nimport {WadRay} from \\\"../../libs/WadRay.sol\\\";\\nimport {Error} from \\\"../../libs/Errors.sol\\\";\\nimport {LibKrAsset} from \\\"../libs/LibKrAsset.sol\\\";\\n\\nimport {StabilityRateConfig} from \\\"../InterestRateState.sol\\\";\\nimport {ms} from \\\"../MinterStorage.sol\\\";\\n\\n/* solhint-disable not-rely-on-time */\\n\\n/**\\n * @author Kresko\\n * @title AMM price stability rate library, derived from Aave Protocols VariableDebtToken calculations\\n * @notice Library for performing stability rate related operations\\n */\\nlibrary LibStabilityRate {\\n    using WadRay for uint256;\\n    using WadRay for uint128;\\n\\n    /// @dev Ignoring leap years\\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\\n\\n    /**\\n     * @notice Cumulates the stability rate from previous update and multiplies the debt index with it.\\n     * @dev Updates the updated timestamp\\n     * @dev New debt index cannot overflow uint128\\n     * @param self configuration for the asset\\n     * @return newDebtIndex the updated index\\n     */\\n    function updateDebtIndex(StabilityRateConfig storage self) internal returns (uint256 newDebtIndex) {\\n        if (self.asset == address(0)) return WadRay.RAY;\\n\\n        newDebtIndex = self.debtIndex;\\n        // only cumulating if there is any assets minted and rate is over 0\\n        if (IERC20Permit(self.asset).totalSupply() != 0) {\\n            uint256 cumulatedStabilityRate = self.calculateCompoundedInterest(block.timestamp);\\n            newDebtIndex = cumulatedStabilityRate.rayMul(self.debtIndex);\\n            require(newDebtIndex <= type(uint128).max, Error.DEBT_INDEX_OVERFLOW);\\n            self.debtIndex = uint128(newDebtIndex);\\n        }\\n\\n        self.lastUpdateTimestamp = uint40(block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Updates the current stability rate for an asset\\n     * @dev New stability rate cannot overflow uint128\\n     * @param self rate configuration for the asset\\n     */\\n    function updateStabilityRate(StabilityRateConfig storage self) internal {\\n        if (self.asset == address(0)) return;\\n\\n        uint256 stabilityRate = calculateStabilityRate(self);\\n        require(stabilityRate <= type(uint128).max, Error.STABILITY_RATE_OVERFLOW);\\n        self.stabilityRate = uint128(stabilityRate);\\n    }\\n\\n    /**\\n     * @notice Get the current price rate between AMM and oracle pricing\\n     * @dev Raw return value of ammPrice == 0 when no AMM pair exists OR liquidity of the pair does not qualify\\n     * @param self rate configuration for the asset\\n     * @return priceRate the current price rate\\n     */\\n    function getPriceRate(StabilityRateConfig storage self) internal view returns (uint256 priceRate) {\\n        uint256 oraclePrice = ms().getKrAssetValue(self.asset, 1 ether, true);\\n        uint256 ammPrice = ms().getKrAssetAMMPrice(self.asset, 1 ether);\\n        // no pair, no effect\\n        if (ammPrice == 0) {\\n            return 0;\\n        }\\n        return ammPrice.wadDiv(oraclePrice) / 10;\\n    }\\n\\n    /**\\n     * @notice Calculate new stability rate from the current price rate\\n     * @dev Separate calculations exist for following cases:\\n     * case 1: AMM premium < optimal\\n     * case 2: AMM premium > optimal\\n     * @param self rate configuration for the asset\\n     * @return stabilityRate the current stability rate\\n     */\\n    function calculateStabilityRate(StabilityRateConfig storage self) internal view returns (uint256 stabilityRate) {\\n        uint256 priceRate = self.getPriceRate(); // 0.95 RAY = -5% PREMIUM, 1.05 RAY = +5% PREMIUM\\n        // Return base rate if no AMM price exists\\n        if (priceRate == 0) {\\n            return self.stabilityRateBase;\\n        }\\n        bool rateIsGTOptimal = priceRate > self.optimalPriceRate;\\n\\n        uint256 rateDiff = rateIsGTOptimal ? priceRate - self.optimalPriceRate : self.optimalPriceRate - priceRate;\\n        uint256 rateDiffAdjusted = rateDiff.rayMul(self.rateSlope2.rayDiv(self.rateSlope1 + self.priceRateDelta));\\n\\n        if (!rateIsGTOptimal) {\\n            // Case: AMM price is lower than priceRate\\n            return self.stabilityRateBase + rateDiffAdjusted;\\n        } else {\\n            // Case: AMM price is higher than priceRate\\n            return self.stabilityRateBase.rayDiv(WadRay.RAY + rateDiffAdjusted);\\n        }\\n    }\\n\\n    /**\\n     * @dev Function to calculate the interest using a compounded interest rate formula\\n     * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\\n     *\\n     *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\\n     *\\n     * The approximation slightly underpays liquidity providers and undercharges borrowers\\n     * with the advantage of great gas cost reductions\\n     * The Aave whitepaper contains reference to the approximation\\n     * with a table showing the margin of error per different time periods\\n     *\\n     * @param self rate configuration for the asset\\n     * @param _currentTimestamp The timestamp of the last update of the interest\\n     * @return The interest rate compounded during the timeDelta, in ray\\n     **/\\n    function calculateCompoundedInterest(\\n        StabilityRateConfig storage self,\\n        uint256 _currentTimestamp\\n    ) internal view returns (uint256) {\\n        //solium-disable-next-line\\n        uint256 exp = _currentTimestamp - uint256(self.lastUpdateTimestamp);\\n\\n        if (exp == 0) {\\n            return WadRay.RAY;\\n        }\\n\\n        uint256 expMinusOne;\\n        uint256 expMinusTwo;\\n        uint256 basePowerTwo;\\n        uint256 basePowerThree;\\n        unchecked {\\n            expMinusOne = exp - 1;\\n\\n            expMinusTwo = exp > 2 ? exp - 2 : 0;\\n\\n            basePowerTwo = self.stabilityRate.rayMul(self.stabilityRate) / (SECONDS_PER_YEAR * SECONDS_PER_YEAR);\\n            basePowerThree = basePowerTwo.rayMul(self.stabilityRate) / SECONDS_PER_YEAR;\\n        }\\n\\n        uint256 secondTerm = exp * expMinusOne * basePowerTwo;\\n        unchecked {\\n            secondTerm /= 2;\\n        }\\n        uint256 thirdTerm = exp * expMinusOne * expMinusTwo * basePowerThree;\\n        unchecked {\\n            thirdTerm /= 6;\\n        }\\n\\n        return WadRay.RAY + (self.stabilityRate * exp) / SECONDS_PER_YEAR + secondTerm + thirdTerm;\\n    }\\n\\n    /**\\n     * @dev Returns the ongoing normalized debt index for the borrowers\\n     * A value of 1e27 means there is no interest. As time passes, the interest is accrued\\n     * A value of 2*1e27 means that for each unit of debt, one unit worth of interest has been accumulated\\n     * @param self rate configuration for the asset\\n     * @return The normalized debt index. expressed in ray\\n     **/\\n    function getNormalizedDebtIndex(StabilityRateConfig storage self) internal view returns (uint256) {\\n        if (self.asset == address(0)) return WadRay.RAY;\\n        //solium-disable-next-line\\n        if (self.lastUpdateTimestamp == uint40(block.timestamp)) {\\n            //if the index was updated in the same block, no need to perform any calculation\\n            return self.debtIndex;\\n        }\\n\\n        return self.calculateCompoundedInterest(block.timestamp).rayMul(self.debtIndex);\\n    }\\n}\\n\",\"keccak256\":\"0x181e9a4c3c7e578e95c37f2fe2ae7d6b4b0d147667ab26ee0ffe023e2c4c8214\",\"license\":\"BUSL-1.1\"},\"src/contracts/shared/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.19;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x429fbd28c61fe8369f11daaefc77f0974863b74dd2bd20650c2a32db631c037d\",\"license\":\"AGPL-3.0-only\"},\"src/contracts/shared/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.19;\\n\\n/* solhint-disable func-name-mixedcase */\\n\\ninterface IERC20Permit {\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function allowance(address, address) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function name() external view returns (string memory);\\n\\n    function nonces(address) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function symbol() external view returns (string memory);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4e9d58529386d5a2934c822a0c893efa33c528c902a78f81eee8ef0ced178469\",\"license\":\"AGPL-3.0-only\"},\"src/contracts/shared/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport {IERC20Permit} from \\\"./IERC20Permit.sol\\\";\\nimport {AddressUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(IERC20Permit token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20Permit token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20Permit token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20Permit token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20Permit token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Permit token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcdb25979880d99bc6a47c2ade4399fc9c8bc4dfa7de507c85ed443865696ee2e\",\"license\":\"MIT\"},\"src/contracts/vendor/flux/interfaces/AggregatorInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\ninterface AggregatorInterface {\\n    function latestAnswer() external view returns (int256);\\n\\n    function latestTimestamp() external view returns (uint256);\\n\\n    function latestMarketOpen() external view returns (bool);\\n\\n    function latestRound() external view returns (uint256);\\n\\n    function getAnswer(uint256 roundId) external view returns (int256);\\n\\n    function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n    function getMarketOpen(uint256 roundId) external view returns (bool);\\n\\n    event AnswerUpdated(int256 indexed current, bool marketOpen, uint256 indexed roundId, uint256 updatedAt);\\n    event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\",\"keccak256\":\"0xdb75c655ccf089430cb063b40591f464ba31ce273affc60c4b5a996f8e44fb85\",\"license\":\"MIT\"},\"src/contracts/vendor/flux/interfaces/AggregatorV2V3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n/* solhint-disable no-global-import */\\n/* solhint-disable no-empty-blocks */\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\\n\",\"keccak256\":\"0xc8b21a8d016a10b74e285489581296197264de86337fb23a441229e0016f8d7c\",\"license\":\"MIT\"},\"src/contracts/vendor/flux/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\ninterface AggregatorV3Interface {\\n    function decimals() external view returns (uint8);\\n\\n    function description() external view returns (string memory);\\n\\n    function version() external view returns (uint256);\\n    \\n\\n    // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n    // if they do not have data to report, instead of returning unset values\\n    // which could be misinterpreted as actual reported values.\\n    function getRoundData(uint80 _roundId)\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            bool marketOpen,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            bool marketOpen,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\",\"keccak256\":\"0x5a6b253a6ba193bae6e36ef1e2326727d6e8394cc8d99762f87dbc0193bdc9fb\",\"license\":\"MIT\"},\"src/contracts/vendor/gnosis/IGnosisSafeL2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\ninterface IGnosisSafeL2 {\\n    function isOwner(address owner) external view returns (bool);\\n\\n    function getOwners() external view returns (address[] memory);\\n}\\n\",\"keccak256\":\"0xf1cdc61967b11ebf0351fb6a1e8fc121e5e4287ec99ebdc0c274e3fe242dd1e9\",\"license\":\"MIT\"},\"src/contracts/vendor/uniswap/v2-core/interfaces/IERC20Minimal.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\npragma solidity >=0.5.0;\\n\\ninterface IERC20Minimal {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x853784573ca029a6654da36764bbd748f2e14547e9cad490a49135543664c77f\",\"license\":\"agpl-3.0\"},\"src/contracts/vendor/uniswap/v2-core/interfaces/IUniswapV2Factory.sol\":{\"content\":\"// // SPDX-License-Identifier: agpl-3.0\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\n\\n    function feeTo() external view returns (address);\\n\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n\\n    function setFeeToSetter(address) external;\\n}\\n\",\"keccak256\":\"0x17c3cb3c29020835e4e2d281a2dfbbbc3073fb52894bb9632f924259a0c97f14\",\"license\":\"agpl-3.0\"},\"src/contracts/vendor/uniswap/v2-core/interfaces/IUniswapV2Pair.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\npragma solidity >=0.5.16;\\n\\n/** solhint-disable func-name-mixedcase */\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n\\n    function price1CumulativeLast() external view returns (uint256);\\n\\n    function kLast() external view returns (uint256);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\",\"keccak256\":\"0x61a1ef1aecceeb9cffcb9d6e80ad067b3aa3401f608a04677ebfd793cbc95c4e\",\"license\":\"agpl-3.0\"},\"src/contracts/vendor/uniswap/v2-periphery/libraries/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\npragma solidity >=0.6.6;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x51b3d315e503d85683fb21c3d858d010e10d8b48959c2e437e7cebf5393692a1\",\"license\":\"agpl-3.0\"},\"src/contracts/vendor/uniswap/v2-periphery/libraries/UniswapV2Library.sol\":{\"content\":\"// SPDX-License-Identifier: APGL-3.0\\npragma solidity >=0.5.0;\\n\\nimport \\\"../../v2-core/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"../../v2-core/interfaces/IUniswapV2Factory.sol\\\";\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary UniswapV2Library {\\n    using SafeMath for uint256;\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, \\\"UniswapV2Library: IDENTICAL_ADDRESSES\\\");\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), \\\"UniswapV2Library: ZERO_ADDRESS\\\");\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    ) internal view returns (address pair) {\\n        pair = IUniswapV2Factory(factory).getPair(tokenA, tokenB);\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\\n        (address token0, ) = sortTokens(tokenA, tokenB);\\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) internal pure returns (uint256 amountB) {\\n        require(amountA > 0, \\\"UniswapV2Library: INSUFFICIENT_AMOUNT\\\");\\n        require(reserveA > 0 && reserveB > 0, \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\");\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal pure returns (uint256 amountOut) {\\n        require(amountIn > 0, \\\"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\\\");\\n        require(reserveIn > 0 && reserveOut > 0, \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\");\\n        uint256 amountInWithFee = amountIn.mul(997);\\n        uint256 numerator = amountInWithFee.mul(reserveOut);\\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\\n        amountOut = numerator / denominator;\\n    }\\n\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal pure returns (uint256 amountIn) {\\n        require(amountOut > 0, \\\"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\\\");\\n        require(reserveIn > 0 && reserveOut > 0, \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\");\\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\\n        amountIn = (numerator / denominator).add(1);\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    function getAmountsOut(\\n        address factory,\\n        uint256 amountIn,\\n        address[] memory path\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(path.length >= 2, \\\"UniswapV2Library: INVALID_PATH\\\");\\n        amounts = new uint256[](path.length);\\n        amounts[0] = amountIn;\\n        for (uint256 i; i < path.length - 1; i++) {\\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n\\n    // performs chained getAmountIn calculations on any number of pairs\\n    function getAmountsIn(\\n        address factory,\\n        uint256 amountOut,\\n        address[] memory path\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(path.length >= 2, \\\"UniswapV2Library: INVALID_PATH\\\");\\n        amounts = new uint256[](path.length);\\n        amounts[amounts.length - 1] = amountOut;\\n        for (uint256 i = path.length - 1; i > 0; i--) {\\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb40321d34bb4450e86527ec738712ff475a88d24d8b16cb2af6fe16a16bec978\",\"license\":\"APGL-3.0\"}},\"version\":1}",
  "bytecode": "0x6080806040523461001657614530908161001c8239f35b600080fdfe6080604052600436101561001257600080fd5b60003560e01c80621d3567146101b657806301ffc9a7146101b157806307e0db17146101ac5780630b4cad4c146101a75780630df37483146101a257806310ddb1371461019d57806328314fe5146101985780632a205e3d146101935780632a8480911461018e5780633d8b38f61461018957806342d65a8d14610184578063519056361461017f57806366ad5c8a1461017a5780638ffa1f2a146101755780639ea5d6b1146101705780639f38369a1461016b578063a6c3d16514610166578063ab3ffb9314610161578063baf3292d1461015c578063cbed8b9c14610157578063d12473a514610152578063d1deba1f1461014d578063df2a5b3b14610148578063eb8d72b714610143578063f23536411461013e5763f5ecbdbc1461013957600080fd5b61218e565b6120f3565b611f9b565b611e58565b611ce7565b611c60565b611b1a565b611a27565b61192b565b61173f565b611638565b611532565b611314565b6110e3565b610ff3565b610f24565b610e28565b610c71565b610b9e565b6108b8565b6107b4565b610739565b610680565b61057c565b6103f8565b610296565b6004359061ffff821682036101cc57565b600080fd5b6024359061ffff821682036101cc57565b9181601f840112156101cc5782359167ffffffffffffffff83116101cc57602083818601950101116101cc57565b9060807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8301126101cc5760043561ffff811681036101cc579167ffffffffffffffff906024358281116101cc578161026b916004016101e2565b9390939260443581811681036101cc57926064359182116101cc57610292916004016101e2565b9091565b346101cc576102a436610210565b91929493906102b1612327565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa49035473ffffffffffffffffffffffffffffffffffffffff90811691160361036f5761033261033a926103409761032b61031161030c8a6124c6565b6125ba565b8051908184149182610365575b5081610342575b50612932565b3691610b3a565b923691610b3a565b92612a34565b005b905061034f368486610b3a565b6020815191012090602081519101201438610325565b151591503861031e565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601e60248201527f4c7a4170703a20696e76616c696420656e64706f696e742063616c6c657200006044820152606490fd5b7fffffffff000000000000000000000000000000000000000000000000000000008116036101cc57565b346101cc576020367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc57610496600435610436816103ce565b7fffffffff0000000000000000000000000000000000000000000000000000000081811690811415919082610552575b8215610528575b821561051f575b82156104f5575b50811561049a575b5060405190151581529081906020820190565b0390f35b7fffffffff000000000000000000000000000000000000000000000000000000001660009081527f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0c6020526040902060ff9150541638610483565b7f22bac5d9000000000000000000000000000000000000000000000000000000001491503861047b565b80159250610474565b7f5b5e139f000000000000000000000000000000000000000000000000000000008114925061046d565b7f80ac58cd0000000000000000000000000000000000000000000000000000000081149250610466565b346101cc5760006020367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc011261067d576105b56101bb565b816105be612327565b7f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f5473ffffffffffffffffffffffffffffffffffffffff9161060e918316908316146106086122a4565b906122dd565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4903541691823b1561067957602461ffff918360405195869485936307e0db1760e01b85521660048401525af1801561067457610668575080f35b61067190610a6d565b80f35b6123e2565b5080fd5b80fd5b346101cc576020367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc576004356107026106bd612327565b7f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f5473ffffffffffffffffffffffffffffffffffffffff9182169116146106086122a4565b61071561070d6126f3565b8215156122dd565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa48fe55005b346101cc576040367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc5761ffff6107736101bb565b61077e6106bd612327565b166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4906602052602435604060002055600080f35b346101cc5760006020367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc011261067d576107ed6101bb565b816107f6612327565b7f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f5473ffffffffffffffffffffffffffffffffffffffff91610840918316908316146106086122a4565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4903541691823b1561067957602461ffff918360405195869485936310ddb13760e01b85521660048401525af1801561067457610668575080f35b73ffffffffffffffffffffffffffffffffffffffff8116036101cc57565b346101cc576040367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc576103406024356109f26004356108fc8361089a565b610904612327565b7f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f5473ffffffffffffffffffffffffffffffffffffffff929161094f918416908416146106086122a4565b61099060405161095e81610a86565b600181527f320000000000000000000000000000000000000000000000000000000000000060208201528215156122dd565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa48fe55604051906109bf82610a86565b600182527f39000000000000000000000000000000000000000000000000000000000000006020830152831615156122dd565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa490380547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff909216919091179055565b634e487b7160e01b600052604160045260246000fd5b67ffffffffffffffff8111610a8157604052565b610a57565b6040810190811067ffffffffffffffff821117610a8157604052565b6020810190811067ffffffffffffffff821117610a8157604052565b90601f8019910116810190811067ffffffffffffffff821117610a8157604052565b604051906080820182811067ffffffffffffffff821117610a8157604052565b67ffffffffffffffff8111610a8157601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b929192610b4682610b00565b91610b546040519384610abe565b8294818452818301116101cc578281602093846000960137010152565b9080601f830112156101cc57816020610b8c93359101610b3a565b90565b6064359081151582036101cc57565b346101cc5760a0367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc57610bd56101bb565b67ffffffffffffffff906024358281116101cc57610bf7903690600401610b71565b90610c00610b8f565b906084359384116101cc57610c1c610c2e943690600401610b71565b92610c2860443561290d565b91612e6a565b60408051928352602083019190915290f35b9181601f840112156101cc5782359167ffffffffffffffff83116101cc576020808501948460051b0101116101cc57565b346101cc576040367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc5767ffffffffffffffff6004358181116101cc57610cc1903690600401610c40565b916024359081116101cc57610cda903690600401610c40565b919092610ce86106bd612327565b60005b818110610d8a5750505060005b818110610d0157005b80610d80610d58610d16610d85948688612496565b35610d20816103ce565b63ffffffff60e01b166000527f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0c602052604060002090565b80547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00169055565b61244e565b610cf8565b80610d9c610d16610dca938587612496565b80547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600117905561244e565b610ceb565b9060407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8301126101cc5760043561ffff811681036101cc57916024359067ffffffffffffffff82116101cc57610292916004016101e2565b346101cc57610e42610e3936610dcf565b919290926124c6565b60405181549391906000610e558661252c565b80835260209687840194600191828116908115610ee65750600114610ead575b610496888a610e978a8a8a610e8c818c0382610abe565b519020933691610b3a565b8051910120604051911481529081906020820190565b60009081528881209093505b828410610ed3575050508101850181610e8c610496610e75565b80548585018a0152928801928101610eb9565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00168752505050151560051b82018601905081610e8c610496610e75565b346101cc57610f90610f3536610dcf565b610f3d612327565b917f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f546000958694610f6d6122a4565b73ffffffffffffffffffffffffffffffffffffffff9390918416908416146122dd565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4903541690813b15610fef5783610fdd95604051968795869485936342d65a8d60e01b8552600485016124ab565b03925af1801561067457610668575080f35b8380fd5b60e0367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc576004356110298161089a565b6110316101d1565b67ffffffffffffffff916044358381116101cc57611053903690600401610b71565b90608435906110618261089a565b60a4359261106e8461089a565b60c4359586116101cc57611089610340963690600401610b71565b7f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f549095906110d29073ffffffffffffffffffffffffffffffffffffffff85811691161461272c565b6110dd60643561290d565b926130a8565b346101cc576110f136610210565b93929091506110fe612327565b73ffffffffffffffffffffffffffffffffffffffff9190309083160361128f5761115c7f5b821db8a46f8ecbe1941ba2f51cfeea9643268b56631f70d45e2a745d99026593611154601496611190943691610b3a565b963691610b3a565b94855161117160208089019289010182612829565b9601519661117f8789613d63565b875181106111ac575b505050613077565b936111a761ffff6040519384931697169482613097565b0390a4005b6112757f10e0b70d256bccc84b7027506978bd8b68984a870788b93b479def144c839ad79383519020916111de610ae0565b61ffff8d1681529073ffffffffffffffffffffffffffffffffffffffff8c1660208301525b60408201526001606082015261121883612792565b600260609161ffff8451168154908061ffff19831617835562010000600160b01b03602087015160101b169169ffffffffffffffffffff60b01b16171781556040840151600182015501910151151560ff80198354169116179055565b61128460405192839283613a60565b0390a1388080611188565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4e6f6e626c6f636b696e674c7a4170703a2063616c6c6572206d75737420626560448201527f204c7a41707000000000000000000000000000000000000000000000000000006064820152608490fd5b346101cc576020367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc5760043567ffffffffffffffff81116101cc57611363903690600401610b71565b7f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f546113c4906113bd9073ffffffffffffffffffffffffffffffffffffffff165b73ffffffffffffffffffffffffffffffffffffffff1690565b331461272c565b6113fd81516020808401918220936113f36113eb60026113e388612792565b015460ff1690565b6106086127f0565b8051010190612829565b905061140882612792565b506114498161143661141985612792565b5460101c73ffffffffffffffffffffffffffffffffffffffff1690565b600161144186612792565b015490613f15565b90611464600161145885612792565b015483116106086128c0565b5181036114c457506114bf816114af61149d7fd7be02b8dd0d27bd0517a9cb4d7469ce27df4313821ae5ec1ff69acc594ba23394612792565b60026000918281558260018201550155565b6040519081529081906020820190565b0390a1005b611218826114df6114d761034095612792565b5461ffff1690565b926115216114ef61141984612792565b6115046114fa610ae0565b61ffff9097168752565b73ffffffffffffffffffffffffffffffffffffffff166020860152565b604084015260016060840152612792565b346101cc576040367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc576115696101bb565b61ffff6024359161157b6106bd612327565b61158e6115866126f3565b8415156122dd565b166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa48ff602052604060002055600080f35b60005b8381106115d45750506000910152565b81810151838201526020016115c4565b906020916115fd815180928185528580860191016115c1565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016010190565b906020610b8c9281815201906115e4565b346101cc576020806003193601126101cc5761165a6116556101bb565b6124c6565b9060405190600092805461166d8161252c565b808552916001918083169081156116ff57506001146116c2575b6104966116b68661169a818a0382610abe565b6116a681511515612660565b6116b081516126c6565b90612cff565b60405191829182611627565b6000908152838120939550925b8284106116ec575050508101909101908061169a81610496611687565b80548585018701529285019281016116cf565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001685870152505050151560051b82010191508061169a81610496611687565b346101cc5761174d36610dcf565b916117596106bd612327565b6040516020908484838301376117846034828781013060601b86820152036014810184520182610abe565b61178d836124c6565b9181519167ffffffffffffffff8311610a81576117b4836117ae865461252c565b86612566565b81601f841160011461181f575091806114bf94927f8c0400cfe2d1199b1a725c78960bcc2a344d869b80590d0f2bd005db15a572ce9894600092611814575b50508160011b916000199060031b1c19161790555b604051938493846124ab565b0151905038806117f3565b9190601f19841661183586600052602060002090565b936000905b82821061189d5750509260019285927f8c0400cfe2d1199b1a725c78960bcc2a344d869b80590d0f2bd005db15a572ce9a966114bf989610611884575b505050811b019055611808565b015160001960f88460031b161c19169055388080611877565b8060018697829497870151815501960194019061183a565b67ffffffffffffffff8111610a815760051b60200190565b81601f820112156101cc578035916118e4836118b5565b926118f26040519485610abe565b808452602092838086019260051b8201019283116101cc578301905b82821061191c575050505090565b8135815290830190830161190e565b60e0367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc576004356119618161089a565b6119696101d1565b67ffffffffffffffff91906044358381116101cc5761198c903690600401610b71565b6064358481116101cc576119a49036906004016118cd565b608435916119b18361089a565b60a435936119be8561089a565b60c4359687116101cc576119d9610340973690600401610b71565b7f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f54909690611a229073ffffffffffffffffffffffffffffffffffffffff80841691161461272c565b6130a8565b346101cc576020367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc577f5db758e995a17ec1ad84bdef7e8c3293a0bd6179bcce400dff5d4c3d87db726b6020600435611a858161089a565b611a8d612327565b7f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f5473ffffffffffffffffffffffffffffffffffffffff9291611ad8918416908416146106086122a4565b167fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4907816bffffffffffffffffffffffff60a01b825416179055604051908152a1005b346101cc576080367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc57611b516101bb565b611b596101d1565b60643567ffffffffffffffff81116101cc57611b799036906004016101e2565b9092611b83612327565b7f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f5473ffffffffffffffffffffffffffffffffffffffff91611bcd918316908316146106086122a4565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4903541690813b156101cc5760008094611c3d604051978896879586946332fb62e760e21b865261ffff809216600487015216602485015260443560448501526080606485015260848401916123f9565b03925af1801561067457611c4d57005b80611c5a61034092610a6d565b806123ee565b346101cc576040367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc57611c976101bb565b61ffff60243591611ca96106bd612327565b611cb46115866126f3565b166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4900602052604060002055600080f35b611cf036610210565b91611d2f81611d01889694986124f9565b60206040518092878b8337878201908152030190209067ffffffffffffffff16600052602052604060002090565b54918215611dd357611dc784611dc07fc264d91f3adc5588250e1551f547752ca0cfa8f6b530d243b9f9f4cab10ea8e5996000611db487611d9b8d89611d958f6114bf9f8f611d83611d909236908d610b3a565b6020815191012014612b61565b6124f9565b91612b48565b9067ffffffffffffffff16600052602052604060002090565b5561033236868c610b3a565b9087613a77565b60405195869586612bed565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602360248201527f4e6f6e626c6f636b696e674c7a4170703a206e6f2073746f726564206d65737360448201527f61676500000000000000000000000000000000000000000000000000000000006064820152608490fd5b346101cc576060367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc57611e8f6101bb565b611e976101d1565b9060443591611ea76106bd612327565b8215611f3c5782827f9d5c7c0b934da8fefa9c7760c98383778a12dfbfc0c3b3106518f43fb9508ac094611f2184611f0e60609761ffff166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4905602052604060002090565b9061ffff16600052602052604060002090565b556040519261ffff80921684521660208301526040820152a1005b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4c7a4170703a20696e76616c6964206d696e47617300000000000000000000006044820152606490fd5b346101cc57611fa936610dcf565b91611fb56106bd612327565b611fbe816124c6565b9267ffffffffffffffff8111610a8157611fdc816117ae865461252c565b600093601f821160011461204457906114bf91817ffa41487ad5d6728f0b19276fa1eddc16558578f5109fc39d2dc33c3230470dab96600091612039575b508260011b906000198460031b1c1916179055604051938493846124ab565b90508501353861201a565b601f1982169461205982600052602060002090565b95815b8181106120db5750958392916114bf947ffa41487ad5d6728f0b19276fa1eddc16558578f5109fc39d2dc33c3230470dab98106120a3575b5050600182811b019055611808565b8601357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600385901b60f8161c191690553880612094565b8683013588556001909701966020928301920161205c565b346101cc5760a0367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc5761212a6101bb565b67ffffffffffffffff906024358281116101cc5761214c903690600401610b71565b6044358381116101cc576121649036906004016118cd565b61216c610b8f565b916084359485116101cc57612188610c2e953690600401610b71565b93612e6a565b346101cc576080367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc576121c56101bb565b60006121cf6101d1565b916121db60443561089a565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4903546040517ff5ecbdbc00000000000000000000000000000000000000000000000000000000815261ffff928316600482015293909116602484015230604484015260648035908401528290608490829073ffffffffffffffffffffffffffffffffffffffff165afa80156106745761049691600091612283575b5060405191829182611627565b61229e913d8091833e6122968183610abe565b8101906123bc565b38612276565b604051906122b182610a86565b602082527f6b724469616d6f6e643a204d757374206265206469616d6f6e64206f776e65726020830152565b156122e55750565b6040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201529081906123239060248301906115e4565b0390fd5b3330036123765761233736610b00565b6123446040519182610abe565b3681523660006020830137600060203692909201918201525173ffffffffffffffffffffffffffffffffffffffff1690565b3390565b81601f820112156101cc57805161239081610b00565b9261239e6040519485610abe565b818452602082840101116101cc57610b8c91602080850191016115c1565b906020828203126101cc57815167ffffffffffffffff81116101cc57610b8c920161237a565b6040513d6000823e3d90fd5b60009103126101cc57565b908060209392818452848401376000828201840152601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016010190565b634e487b7160e01b600052601160045260246000fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff811461247b5760010190565b612438565b634e487b7160e01b600052603260045260246000fd5b91908110156124a65760051b0190565b612480565b60409061ffff610b8c959316815281602082015201916123f9565b61ffff166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4904602052604060002090565b61ffff166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4902602052604060002090565b90600182811c9216801561255c575b602083101461254657565b634e487b7160e01b600052602260045260246000fd5b91607f169161253b565b90601f811161257457505050565b600091825260208220906020601f850160051c830194106125b0575b601f0160051c01915b8281106125a557505050565b818155600101612599565b9092508290612590565b90604051918260008254926125ce8461252c565b90818452600194858116908160001461263d57506001146125fa575b50506125f892500383610abe565b565b9093915060005260209081600020936000915b8183106126255750506125f8935082010138806125ea565b8554888401850152948501948794509183019161260d565b9150506125f894506020925060ff191682840152151560051b82010138806125ea565b1561266757565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f4c7a4170703a206e6f20747275737465642070617468207265636f72640000006044820152606490fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec81019190821161247b57565b6040519061270082610a86565b600182527f36000000000000000000000000000000000000000000000000000000000000006020830152565b1561273357565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f6e6f7420737570706f72746564207965740000000000000000000000000000006044820152606490fd5b6000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4901602052604060002090565b6000527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d6602052604060002090565b604051906127fd82610a86565b600182527f34000000000000000000000000000000000000000000000000000000000000006020830152565b91906040838203126101cc5782519267ffffffffffffffff938481116101cc578261285591830161237a565b93602091828101519182116101cc57019180601f840112156101cc57825161287c816118b5565b9361288a6040519586610abe565b818552838086019260051b8201019283116101cc578301905b8282106128b1575050505090565b815181529083019083016128a3565b604051906128cd82610a86565b600182527f35000000000000000000000000000000000000000000000000000000000000006020830152565b80518210156124a65760209160051b010190565b6040519061291a82610a86565b600182526020820160203682378251156124a6575290565b1561293957565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4c7a4170703a20696e76616c696420736f757263652073656e64696e6720636f60448201527f6e747261637400000000000000000000000000000000000000000000000000006064820152608490fd5b6020906129d89282604051948386809551938492016115c1565b82019081520301902090565b9367ffffffffffffffff612a12612a269461ffff610b8c99979516885260a0602089015260a08801906115e4565b9216604086015284820360608601526115e4565b9160808184039101526115e4565b9091612add5a6040517f66ad5c8a00000000000000000000000000000000000000000000000000000000602082015261ffff851660248201526080604482015290612ad782612ac9612a8960a483018a6115e4565b67ffffffffffffffff881660648401528281037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc0160848401528a6115e4565b03601f198101845283610abe565b30612d9d565b9015612aeb575b5050505050565b84612b3b927fe183f33de2837795525b4792ca4cd60535bd77c53b7e7030060bfcf5734d6b0c96516020830120612b2e82611d9b612b28896124f9565b8a6129be565b55604051958695866129e4565b0390a13880808080612ae4565b6020919283604051948593843782019081520301902090565b15612b6857565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602160248201527f4e6f6e626c6f636b696e674c7a4170703a20696e76616c6964207061796c6f6160448201527f64000000000000000000000000000000000000000000000000000000000000006064820152608490fd5b91612c1a9060609461ffff67ffffffffffffffff94999897991685526080602086015260808501916123f9565b951660408201520152565b90601f820180921161247b57565b15612c3a57565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f770000000000000000000000000000000000006044820152606490fd5b15612ca057565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f736c6963655f6f75744f66426f756e64730000000000000000000000000000006044820152606490fd5b612d1382612d0c81612c25565b1015612c33565b612d208282511015612c99565b81612d38575050604051600081526020810160405290565b60405191601f811691821560051b808486010193838501920101905b808410612d8a5750508252601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660405290565b9092835181526020809101930190612d54565b6040519392909160009160c086019167ffffffffffffffff831187841017610a815783926040526096875282602088019560a036883760208451940192f1903d9060968211612df2575b6000908286523e9190565b60969150612de7565b90815180825260208080930193019160005b828110612e1b575050505090565b835185529381019392810192600101612e0d565b9091612e46610b8c936040845260408401906115e4565b916020818403910152612dfb565b91908260409103126101cc576020825192015190565b61ffff90612f2e604095612e9c612ef7999895612e8e895198899260208401612e2f565b03601f198101885287610abe565b60018060a01b037fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa49035416948751998a978896879663040a7bb160e41b885216600487015230602487015260a0604487015260a48601906115e4565b91151560648501528382037ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0160848501526115e4565b03915afa918215610674576000908193612f4757509190565b905061029291925060403d8111612f6b575b612f638183610abe565b810190612e54565b503d612f59565b15612f7957565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f746f6b656e4964735b5d20697320656d707479000000000000000000000000006044820152606490fd5b15612fdf57565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f62617463682073697a65206578636565647320647374206261746368206c696d60448201527f69740000000000000000000000000000000000000000000000000000000000006064820152608490fd5b8181029291811591840414171561247b57565b61308f906020604051928284809451938492016115c1565b810103902090565b906020610b8c928181520190612dfb565b959094939192936130bb85511515612f72565b84516130d46001918281149081156131e8575b50612fd8565b6000815b6131bc575b50509261318661ffff9361318b937fe1b87c47fdeb4f9cbadbca9df3af7aba453bb6e501075d0440d88125b711522a9660405192613131846131238c8960208401612e2f565b03601f198101865285610abe565b61317e61317761316e8d61ffff166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4900602052604060002090565b548c5190613064565b848d61439e565b34938b61390e565b613077565b604051909573ffffffffffffffffffffffffffffffffffffffff16949091169281906131b79082613097565b0390a4565b86518110156131e35780610d806131d66131dd938a6128f9565b518b61329c565b816130d8565b6130dd565b90506132218961ffff166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa48ff602052604060002090565b541015386130ce565b6040519061323782610a86565b600182527f37000000000000000000000000000000000000000000000000000000000000006020830152565b6040519061327082610a86565b600182527f38000000000000000000000000000000000000000000000000000000000000006020830152565b906132a5612327565b916132af8261348e565b73ffffffffffffffffffffffffffffffffffffffff9380851682861681149290919083156133db575b50508115613319575b506125f8936132f56133129261060861322a565b6132fe8461348e565b613306613263565b918085169116146122dd565b30906135ec565b9050613324836137d4565b1561337c576125f8936132f561331292856000527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d8602052613372836040600020541660018060a01b031690565b14925050936132e1565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f4552433732313a20696e76616c696420746f6b656e20494400000000000000006044820152606490fd5b73ffffffffffffffffffffffffffffffffffffffff1660009081527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d96020526040902091925060ff9161343e9160018060a01b0316600052602052604060002090565b54169038806132d8565b73ffffffffffffffffffffffffffffffffffffffff1660009081527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d76020526040902090565b60009081527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d6602052604090205473ffffffffffffffffffffffffffffffffffffffff1680156134db5790565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f455243373231203a61646472657373207a65726f206973206e6f74206120766160448201527f6c6964206f776e657200000000000000000000000000000000000000000000006064820152608490fd5b1561356757565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f4552433732313a207472616e736665722066726f6d20696e636f72726563742060448201527f6f776e65720000000000000000000000000000000000000000000000000000006064820152608490fd5b61361d906135f98461348e565b73ffffffffffffffffffffffffffffffffffffffff82811693909182168414613560565b8316928315613750576136a6613729926136438561363d6113a48a61348e565b14613560565b6136a1613679886000527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d8602052604060002090565b80547fffffffffffffffffffffffff0000000000000000000000000000000000000000169055565b613448565b80547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190556136d581613448565b600181540190556136e5856127c1565b80547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff909216919091179055565b7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef600080a4565b6040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f4552433732313a207472616e7366657220746f20746865207a65726f2061646460448201527f72657373000000000000000000000000000000000000000000000000000000006064820152608490fd5b60009081527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d6602052604090205473ffffffffffffffffffffffffffffffffffffffff16151590565b1561382457565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603060248201527f4c7a4170703a2064657374696e6174696f6e20636861696e206973206e6f742060448201527f61207472757374656420736f75726365000000000000000000000000000000006064820152608490fd5b926138ce610b8c97959361ffff6138dc9416865260c0602087015260c08601906115e4565b9084820360408601526115e4565b73ffffffffffffffffffffffffffffffffffffffff91821660608401529316608082015280830360a0909101526115e4565b9092919461391b826124c6565b916040519283600082549261392f8461252c565b908184526001948581169081600014613a3d57506001146139fa575b505061395992500384610abe565b6139658351151561381d565b61397085518261446c565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4903546139b19073ffffffffffffffffffffffffffffffffffffffff166113a4565b93843b156101cc576000966139dc91604051998a988997889662c5803160e81b8852600488016138a9565b03925af18015610674576139ed5750565b80611c5a6125f892610a6d565b9093915060005260209081600020936000915b818310613a255750506139599350820101388061394b565b85548984018501529485019488945091830191613a0d565b91505061395994506020925060ff191682840152151560051b820101388061394b565b604090610b8c9392815281602082015201906115e4565b9092601490835192602095613a93878088019688010186612829565b9401519460005b8551811015613d2e575a7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa48fe5411613c5057613ad581876128f9565b51613adf816137d4565b801580918115613c1b575b50156101cc5715613c0c57604090815191613b0483610aa2565b6000835273ffffffffffffffffffffffffffffffffffffffff8a16908115613baf5750613baa93928280613ba593613b798e613b51613b4c613b48610d809a6137d4565b1590565b6140fc565b613b60613b4c613b48866137d4565b613b6981613448565b600181540190556136e5846127c1565b60007fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8180a48b6141d2565b6140c2565b613a9a565b517f08c379a0000000000000000000000000000000000000000000000000000000008152600481018d9052602481018d90527f4552433732313a206d696e7420746f20746865207a65726f20616464726573736044820152606490fd5b90610d80613baa9289306135ec565b905080613c29575b38613aea565b50613c338261348e565b73ffffffffffffffffffffffffffffffffffffffff163014613c23565b9083977f5b821db8a46f8ecbe1941ba2f51cfeea9643268b56631f70d45e2a745d99026595998861ffff96613c9596955b8a518110613cb0575b505050505050613077565b936131b760405192839260018060a01b031697169482613097565b611203613d11937f10e0b70d256bccc84b7027506978bd8b68984a870788b93b479def144c839ad7978751902095613cf3613ce9610ae0565b61ffff9096168652565b73ffffffffffffffffffffffffffffffffffffffff90911690840152565b613d2060405192839283613a60565b0390a1388080888a82613c8a565b9083977f5b821db8a46f8ecbe1941ba2f51cfeea9643268b56631f70d45e2a745d99026595998861ffff96613c959695613c81565b919060005b8151811015613f10575a7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa48fe5411613f1057613da381836128f9565b51613dad816137d4565b801580918115613edb575b50156101cc5715613ecc57604090815191613dd283610aa2565b6000835273ffffffffffffffffffffffffffffffffffffffff8716908115613e6f5750613e6a93928280613ba593613e12613b4c613b48610d80986137d4565b613e21613b4c613b48846137d4565b613e2a8b613448565b60018154019055613e3e8b6136e5846127c1565b60007fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8180a4886141d2565b613d68565b517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4552433732313a206d696e7420746f20746865207a65726f20616464726573736044820152606490fd5b90610d80613e6a9286306135ec565b905080613ee9575b38613db8565b50613ef38261348e565b73ffffffffffffffffffffffffffffffffffffffff163014613ee3565b925050565b9291905b8151811015613f10575a7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa48fe5411613f1057613f5481836128f9565b51613f5e816137d4565b80158091811561402f575b50156101cc571561402057604090815191613f8383610aa2565b600080845273ffffffffffffffffffffffffffffffffffffffff8816918215613e6f5750928280613ba59361401b9796613fc5613b4c613b48610d80996137d4565b613fd4613b4c613b48856137d4565b613fdd8c613448565b60018154019055613ff18c6136e5856127c1565b7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8180a4886141d2565b613f19565b90610d8061401b9286306135ec565b90508061403d575b38613f69565b506140478261348e565b73ffffffffffffffffffffffffffffffffffffffff163014614037565b60809060208152603260208201527f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560408201527f63656976657220696d706c656d656e746572000000000000000000000000000060608201520190565b156140c957565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081528061232360048201614064565b1561410357565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f4552433732313a20746f6b656e20616c7265616479206d696e746564000000006044820152606490fd5b908160209103126101cc5751610b8c816103ce565b610b8c939260809260018060a01b0316825260006020830152604082015281606082015201906115e4565b3d156141cd573d906141b382610b00565b916141c16040519384610abe565b82523d6000602084013e565b606090565b909190803b156142ca57614204602091600093604051948580948193630a85bd0160e11b998a84523360048501614177565b039273ffffffffffffffffffffffffffffffffffffffff165af16000918161429a575b50614274576142346141a2565b8051908161426f576040517f08c379a00000000000000000000000000000000000000000000000000000000081528061232360048201614064565b602001fd5b7fffffffff00000000000000000000000000000000000000000000000000000000161490565b6142bc91925060203d81116142c3575b6142b48183610abe565b810190614162565b9038614227565b503d6142aa565b505050600190565b156142d957565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f4c7a4170703a206d696e4761734c696d6974206e6f74207365740000000000006044820152606490fd5b1561433f57565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f4c7a4170703a20676173206c696d697420697320746f6f206c6f7700000000006044820152606490fd5b9190602281511061440d57602261ffff91015192166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa49056020526040600020600160005260205260406000205490810180911161247b576125f8916144068215156142d2565b1015614338565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f4c7a4170703a20696e76616c69642061646170746572506172616d73000000006044820152606490fd5b61ffff166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa49066020526040600020549081156144f0575b116144ac57565b606460405162461bcd60e51b815260206004820152602060248201527f4c7a4170703a207061796c6f61642073697a6520697320746f6f206c617267656044820152fd5b61271091506144a556fea2646970667358221220dcd487394a00e6b75910c16ff99517eda8cefc263838a7a7c4b23ccf50563f8164736f6c63430008130033",
  "deployedBytecode": "0x6080604052600436101561001257600080fd5b60003560e01c80621d3567146101b657806301ffc9a7146101b157806307e0db17146101ac5780630b4cad4c146101a75780630df37483146101a257806310ddb1371461019d57806328314fe5146101985780632a205e3d146101935780632a8480911461018e5780633d8b38f61461018957806342d65a8d14610184578063519056361461017f57806366ad5c8a1461017a5780638ffa1f2a146101755780639ea5d6b1146101705780639f38369a1461016b578063a6c3d16514610166578063ab3ffb9314610161578063baf3292d1461015c578063cbed8b9c14610157578063d12473a514610152578063d1deba1f1461014d578063df2a5b3b14610148578063eb8d72b714610143578063f23536411461013e5763f5ecbdbc1461013957600080fd5b61218e565b6120f3565b611f9b565b611e58565b611ce7565b611c60565b611b1a565b611a27565b61192b565b61173f565b611638565b611532565b611314565b6110e3565b610ff3565b610f24565b610e28565b610c71565b610b9e565b6108b8565b6107b4565b610739565b610680565b61057c565b6103f8565b610296565b6004359061ffff821682036101cc57565b600080fd5b6024359061ffff821682036101cc57565b9181601f840112156101cc5782359167ffffffffffffffff83116101cc57602083818601950101116101cc57565b9060807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8301126101cc5760043561ffff811681036101cc579167ffffffffffffffff906024358281116101cc578161026b916004016101e2565b9390939260443581811681036101cc57926064359182116101cc57610292916004016101e2565b9091565b346101cc576102a436610210565b91929493906102b1612327565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa49035473ffffffffffffffffffffffffffffffffffffffff90811691160361036f5761033261033a926103409761032b61031161030c8a6124c6565b6125ba565b8051908184149182610365575b5081610342575b50612932565b3691610b3a565b923691610b3a565b92612a34565b005b905061034f368486610b3a565b6020815191012090602081519101201438610325565b151591503861031e565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601e60248201527f4c7a4170703a20696e76616c696420656e64706f696e742063616c6c657200006044820152606490fd5b7fffffffff000000000000000000000000000000000000000000000000000000008116036101cc57565b346101cc576020367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc57610496600435610436816103ce565b7fffffffff0000000000000000000000000000000000000000000000000000000081811690811415919082610552575b8215610528575b821561051f575b82156104f5575b50811561049a575b5060405190151581529081906020820190565b0390f35b7fffffffff000000000000000000000000000000000000000000000000000000001660009081527f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0c6020526040902060ff9150541638610483565b7f22bac5d9000000000000000000000000000000000000000000000000000000001491503861047b565b80159250610474565b7f5b5e139f000000000000000000000000000000000000000000000000000000008114925061046d565b7f80ac58cd0000000000000000000000000000000000000000000000000000000081149250610466565b346101cc5760006020367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc011261067d576105b56101bb565b816105be612327565b7f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f5473ffffffffffffffffffffffffffffffffffffffff9161060e918316908316146106086122a4565b906122dd565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4903541691823b1561067957602461ffff918360405195869485936307e0db1760e01b85521660048401525af1801561067457610668575080f35b61067190610a6d565b80f35b6123e2565b5080fd5b80fd5b346101cc576020367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc576004356107026106bd612327565b7f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f5473ffffffffffffffffffffffffffffffffffffffff9182169116146106086122a4565b61071561070d6126f3565b8215156122dd565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa48fe55005b346101cc576040367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc5761ffff6107736101bb565b61077e6106bd612327565b166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4906602052602435604060002055600080f35b346101cc5760006020367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc011261067d576107ed6101bb565b816107f6612327565b7f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f5473ffffffffffffffffffffffffffffffffffffffff91610840918316908316146106086122a4565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4903541691823b1561067957602461ffff918360405195869485936310ddb13760e01b85521660048401525af1801561067457610668575080f35b73ffffffffffffffffffffffffffffffffffffffff8116036101cc57565b346101cc576040367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc576103406024356109f26004356108fc8361089a565b610904612327565b7f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f5473ffffffffffffffffffffffffffffffffffffffff929161094f918416908416146106086122a4565b61099060405161095e81610a86565b600181527f320000000000000000000000000000000000000000000000000000000000000060208201528215156122dd565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa48fe55604051906109bf82610a86565b600182527f39000000000000000000000000000000000000000000000000000000000000006020830152831615156122dd565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa490380547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff909216919091179055565b634e487b7160e01b600052604160045260246000fd5b67ffffffffffffffff8111610a8157604052565b610a57565b6040810190811067ffffffffffffffff821117610a8157604052565b6020810190811067ffffffffffffffff821117610a8157604052565b90601f8019910116810190811067ffffffffffffffff821117610a8157604052565b604051906080820182811067ffffffffffffffff821117610a8157604052565b67ffffffffffffffff8111610a8157601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b929192610b4682610b00565b91610b546040519384610abe565b8294818452818301116101cc578281602093846000960137010152565b9080601f830112156101cc57816020610b8c93359101610b3a565b90565b6064359081151582036101cc57565b346101cc5760a0367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc57610bd56101bb565b67ffffffffffffffff906024358281116101cc57610bf7903690600401610b71565b90610c00610b8f565b906084359384116101cc57610c1c610c2e943690600401610b71565b92610c2860443561290d565b91612e6a565b60408051928352602083019190915290f35b9181601f840112156101cc5782359167ffffffffffffffff83116101cc576020808501948460051b0101116101cc57565b346101cc576040367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc5767ffffffffffffffff6004358181116101cc57610cc1903690600401610c40565b916024359081116101cc57610cda903690600401610c40565b919092610ce86106bd612327565b60005b818110610d8a5750505060005b818110610d0157005b80610d80610d58610d16610d85948688612496565b35610d20816103ce565b63ffffffff60e01b166000527f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0c602052604060002090565b80547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00169055565b61244e565b610cf8565b80610d9c610d16610dca938587612496565b80547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600117905561244e565b610ceb565b9060407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8301126101cc5760043561ffff811681036101cc57916024359067ffffffffffffffff82116101cc57610292916004016101e2565b346101cc57610e42610e3936610dcf565b919290926124c6565b60405181549391906000610e558661252c565b80835260209687840194600191828116908115610ee65750600114610ead575b610496888a610e978a8a8a610e8c818c0382610abe565b519020933691610b3a565b8051910120604051911481529081906020820190565b60009081528881209093505b828410610ed3575050508101850181610e8c610496610e75565b80548585018a0152928801928101610eb9565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00168752505050151560051b82018601905081610e8c610496610e75565b346101cc57610f90610f3536610dcf565b610f3d612327565b917f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f546000958694610f6d6122a4565b73ffffffffffffffffffffffffffffffffffffffff9390918416908416146122dd565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4903541690813b15610fef5783610fdd95604051968795869485936342d65a8d60e01b8552600485016124ab565b03925af1801561067457610668575080f35b8380fd5b60e0367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc576004356110298161089a565b6110316101d1565b67ffffffffffffffff916044358381116101cc57611053903690600401610b71565b90608435906110618261089a565b60a4359261106e8461089a565b60c4359586116101cc57611089610340963690600401610b71565b7f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f549095906110d29073ffffffffffffffffffffffffffffffffffffffff85811691161461272c565b6110dd60643561290d565b926130a8565b346101cc576110f136610210565b93929091506110fe612327565b73ffffffffffffffffffffffffffffffffffffffff9190309083160361128f5761115c7f5b821db8a46f8ecbe1941ba2f51cfeea9643268b56631f70d45e2a745d99026593611154601496611190943691610b3a565b963691610b3a565b94855161117160208089019289010182612829565b9601519661117f8789613d63565b875181106111ac575b505050613077565b936111a761ffff6040519384931697169482613097565b0390a4005b6112757f10e0b70d256bccc84b7027506978bd8b68984a870788b93b479def144c839ad79383519020916111de610ae0565b61ffff8d1681529073ffffffffffffffffffffffffffffffffffffffff8c1660208301525b60408201526001606082015261121883612792565b600260609161ffff8451168154908061ffff19831617835562010000600160b01b03602087015160101b169169ffffffffffffffffffff60b01b16171781556040840151600182015501910151151560ff80198354169116179055565b61128460405192839283613a60565b0390a1388080611188565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4e6f6e626c6f636b696e674c7a4170703a2063616c6c6572206d75737420626560448201527f204c7a41707000000000000000000000000000000000000000000000000000006064820152608490fd5b346101cc576020367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc5760043567ffffffffffffffff81116101cc57611363903690600401610b71565b7f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f546113c4906113bd9073ffffffffffffffffffffffffffffffffffffffff165b73ffffffffffffffffffffffffffffffffffffffff1690565b331461272c565b6113fd81516020808401918220936113f36113eb60026113e388612792565b015460ff1690565b6106086127f0565b8051010190612829565b905061140882612792565b506114498161143661141985612792565b5460101c73ffffffffffffffffffffffffffffffffffffffff1690565b600161144186612792565b015490613f15565b90611464600161145885612792565b015483116106086128c0565b5181036114c457506114bf816114af61149d7fd7be02b8dd0d27bd0517a9cb4d7469ce27df4313821ae5ec1ff69acc594ba23394612792565b60026000918281558260018201550155565b6040519081529081906020820190565b0390a1005b611218826114df6114d761034095612792565b5461ffff1690565b926115216114ef61141984612792565b6115046114fa610ae0565b61ffff9097168752565b73ffffffffffffffffffffffffffffffffffffffff166020860152565b604084015260016060840152612792565b346101cc576040367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc576115696101bb565b61ffff6024359161157b6106bd612327565b61158e6115866126f3565b8415156122dd565b166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa48ff602052604060002055600080f35b60005b8381106115d45750506000910152565b81810151838201526020016115c4565b906020916115fd815180928185528580860191016115c1565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016010190565b906020610b8c9281815201906115e4565b346101cc576020806003193601126101cc5761165a6116556101bb565b6124c6565b9060405190600092805461166d8161252c565b808552916001918083169081156116ff57506001146116c2575b6104966116b68661169a818a0382610abe565b6116a681511515612660565b6116b081516126c6565b90612cff565b60405191829182611627565b6000908152838120939550925b8284106116ec575050508101909101908061169a81610496611687565b80548585018701529285019281016116cf565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001685870152505050151560051b82010191508061169a81610496611687565b346101cc5761174d36610dcf565b916117596106bd612327565b6040516020908484838301376117846034828781013060601b86820152036014810184520182610abe565b61178d836124c6565b9181519167ffffffffffffffff8311610a81576117b4836117ae865461252c565b86612566565b81601f841160011461181f575091806114bf94927f8c0400cfe2d1199b1a725c78960bcc2a344d869b80590d0f2bd005db15a572ce9894600092611814575b50508160011b916000199060031b1c19161790555b604051938493846124ab565b0151905038806117f3565b9190601f19841661183586600052602060002090565b936000905b82821061189d5750509260019285927f8c0400cfe2d1199b1a725c78960bcc2a344d869b80590d0f2bd005db15a572ce9a966114bf989610611884575b505050811b019055611808565b015160001960f88460031b161c19169055388080611877565b8060018697829497870151815501960194019061183a565b67ffffffffffffffff8111610a815760051b60200190565b81601f820112156101cc578035916118e4836118b5565b926118f26040519485610abe565b808452602092838086019260051b8201019283116101cc578301905b82821061191c575050505090565b8135815290830190830161190e565b60e0367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc576004356119618161089a565b6119696101d1565b67ffffffffffffffff91906044358381116101cc5761198c903690600401610b71565b6064358481116101cc576119a49036906004016118cd565b608435916119b18361089a565b60a435936119be8561089a565b60c4359687116101cc576119d9610340973690600401610b71565b7f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f54909690611a229073ffffffffffffffffffffffffffffffffffffffff80841691161461272c565b6130a8565b346101cc576020367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc577f5db758e995a17ec1ad84bdef7e8c3293a0bd6179bcce400dff5d4c3d87db726b6020600435611a858161089a565b611a8d612327565b7f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f5473ffffffffffffffffffffffffffffffffffffffff9291611ad8918416908416146106086122a4565b167fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4907816bffffffffffffffffffffffff60a01b825416179055604051908152a1005b346101cc576080367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc57611b516101bb565b611b596101d1565b60643567ffffffffffffffff81116101cc57611b799036906004016101e2565b9092611b83612327565b7f080f9836d135d84bdc1ee0b4214e5f2ae76516c41178c6f14a73685c9c3e5f0f5473ffffffffffffffffffffffffffffffffffffffff91611bcd918316908316146106086122a4565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4903541690813b156101cc5760008094611c3d604051978896879586946332fb62e760e21b865261ffff809216600487015216602485015260443560448501526080606485015260848401916123f9565b03925af1801561067457611c4d57005b80611c5a61034092610a6d565b806123ee565b346101cc576040367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc57611c976101bb565b61ffff60243591611ca96106bd612327565b611cb46115866126f3565b166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4900602052604060002055600080f35b611cf036610210565b91611d2f81611d01889694986124f9565b60206040518092878b8337878201908152030190209067ffffffffffffffff16600052602052604060002090565b54918215611dd357611dc784611dc07fc264d91f3adc5588250e1551f547752ca0cfa8f6b530d243b9f9f4cab10ea8e5996000611db487611d9b8d89611d958f6114bf9f8f611d83611d909236908d610b3a565b6020815191012014612b61565b6124f9565b91612b48565b9067ffffffffffffffff16600052602052604060002090565b5561033236868c610b3a565b9087613a77565b60405195869586612bed565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602360248201527f4e6f6e626c6f636b696e674c7a4170703a206e6f2073746f726564206d65737360448201527f61676500000000000000000000000000000000000000000000000000000000006064820152608490fd5b346101cc576060367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc57611e8f6101bb565b611e976101d1565b9060443591611ea76106bd612327565b8215611f3c5782827f9d5c7c0b934da8fefa9c7760c98383778a12dfbfc0c3b3106518f43fb9508ac094611f2184611f0e60609761ffff166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4905602052604060002090565b9061ffff16600052602052604060002090565b556040519261ffff80921684521660208301526040820152a1005b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4c7a4170703a20696e76616c6964206d696e47617300000000000000000000006044820152606490fd5b346101cc57611fa936610dcf565b91611fb56106bd612327565b611fbe816124c6565b9267ffffffffffffffff8111610a8157611fdc816117ae865461252c565b600093601f821160011461204457906114bf91817ffa41487ad5d6728f0b19276fa1eddc16558578f5109fc39d2dc33c3230470dab96600091612039575b508260011b906000198460031b1c1916179055604051938493846124ab565b90508501353861201a565b601f1982169461205982600052602060002090565b95815b8181106120db5750958392916114bf947ffa41487ad5d6728f0b19276fa1eddc16558578f5109fc39d2dc33c3230470dab98106120a3575b5050600182811b019055611808565b8601357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600385901b60f8161c191690553880612094565b8683013588556001909701966020928301920161205c565b346101cc5760a0367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc5761212a6101bb565b67ffffffffffffffff906024358281116101cc5761214c903690600401610b71565b6044358381116101cc576121649036906004016118cd565b61216c610b8f565b916084359485116101cc57612188610c2e953690600401610b71565b93612e6a565b346101cc576080367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01126101cc576121c56101bb565b60006121cf6101d1565b916121db60443561089a565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4903546040517ff5ecbdbc00000000000000000000000000000000000000000000000000000000815261ffff928316600482015293909116602484015230604484015260648035908401528290608490829073ffffffffffffffffffffffffffffffffffffffff165afa80156106745761049691600091612283575b5060405191829182611627565b61229e913d8091833e6122968183610abe565b8101906123bc565b38612276565b604051906122b182610a86565b602082527f6b724469616d6f6e643a204d757374206265206469616d6f6e64206f776e65726020830152565b156122e55750565b6040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201529081906123239060248301906115e4565b0390fd5b3330036123765761233736610b00565b6123446040519182610abe565b3681523660006020830137600060203692909201918201525173ffffffffffffffffffffffffffffffffffffffff1690565b3390565b81601f820112156101cc57805161239081610b00565b9261239e6040519485610abe565b818452602082840101116101cc57610b8c91602080850191016115c1565b906020828203126101cc57815167ffffffffffffffff81116101cc57610b8c920161237a565b6040513d6000823e3d90fd5b60009103126101cc57565b908060209392818452848401376000828201840152601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016010190565b634e487b7160e01b600052601160045260246000fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff811461247b5760010190565b612438565b634e487b7160e01b600052603260045260246000fd5b91908110156124a65760051b0190565b612480565b60409061ffff610b8c959316815281602082015201916123f9565b61ffff166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4904602052604060002090565b61ffff166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4902602052604060002090565b90600182811c9216801561255c575b602083101461254657565b634e487b7160e01b600052602260045260246000fd5b91607f169161253b565b90601f811161257457505050565b600091825260208220906020601f850160051c830194106125b0575b601f0160051c01915b8281106125a557505050565b818155600101612599565b9092508290612590565b90604051918260008254926125ce8461252c565b90818452600194858116908160001461263d57506001146125fa575b50506125f892500383610abe565b565b9093915060005260209081600020936000915b8183106126255750506125f8935082010138806125ea565b8554888401850152948501948794509183019161260d565b9150506125f894506020925060ff191682840152151560051b82010138806125ea565b1561266757565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f4c7a4170703a206e6f20747275737465642070617468207265636f72640000006044820152606490fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec81019190821161247b57565b6040519061270082610a86565b600182527f36000000000000000000000000000000000000000000000000000000000000006020830152565b1561273357565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f6e6f7420737570706f72746564207965740000000000000000000000000000006044820152606490fd5b6000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4901602052604060002090565b6000527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d6602052604060002090565b604051906127fd82610a86565b600182527f34000000000000000000000000000000000000000000000000000000000000006020830152565b91906040838203126101cc5782519267ffffffffffffffff938481116101cc578261285591830161237a565b93602091828101519182116101cc57019180601f840112156101cc57825161287c816118b5565b9361288a6040519586610abe565b818552838086019260051b8201019283116101cc578301905b8282106128b1575050505090565b815181529083019083016128a3565b604051906128cd82610a86565b600182527f35000000000000000000000000000000000000000000000000000000000000006020830152565b80518210156124a65760209160051b010190565b6040519061291a82610a86565b600182526020820160203682378251156124a6575290565b1561293957565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4c7a4170703a20696e76616c696420736f757263652073656e64696e6720636f60448201527f6e747261637400000000000000000000000000000000000000000000000000006064820152608490fd5b6020906129d89282604051948386809551938492016115c1565b82019081520301902090565b9367ffffffffffffffff612a12612a269461ffff610b8c99979516885260a0602089015260a08801906115e4565b9216604086015284820360608601526115e4565b9160808184039101526115e4565b9091612add5a6040517f66ad5c8a00000000000000000000000000000000000000000000000000000000602082015261ffff851660248201526080604482015290612ad782612ac9612a8960a483018a6115e4565b67ffffffffffffffff881660648401528281037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc0160848401528a6115e4565b03601f198101845283610abe565b30612d9d565b9015612aeb575b5050505050565b84612b3b927fe183f33de2837795525b4792ca4cd60535bd77c53b7e7030060bfcf5734d6b0c96516020830120612b2e82611d9b612b28896124f9565b8a6129be565b55604051958695866129e4565b0390a13880808080612ae4565b6020919283604051948593843782019081520301902090565b15612b6857565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602160248201527f4e6f6e626c6f636b696e674c7a4170703a20696e76616c6964207061796c6f6160448201527f64000000000000000000000000000000000000000000000000000000000000006064820152608490fd5b91612c1a9060609461ffff67ffffffffffffffff94999897991685526080602086015260808501916123f9565b951660408201520152565b90601f820180921161247b57565b15612c3a57565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f770000000000000000000000000000000000006044820152606490fd5b15612ca057565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f736c6963655f6f75744f66426f756e64730000000000000000000000000000006044820152606490fd5b612d1382612d0c81612c25565b1015612c33565b612d208282511015612c99565b81612d38575050604051600081526020810160405290565b60405191601f811691821560051b808486010193838501920101905b808410612d8a5750508252601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660405290565b9092835181526020809101930190612d54565b6040519392909160009160c086019167ffffffffffffffff831187841017610a815783926040526096875282602088019560a036883760208451940192f1903d9060968211612df2575b6000908286523e9190565b60969150612de7565b90815180825260208080930193019160005b828110612e1b575050505090565b835185529381019392810192600101612e0d565b9091612e46610b8c936040845260408401906115e4565b916020818403910152612dfb565b91908260409103126101cc576020825192015190565b61ffff90612f2e604095612e9c612ef7999895612e8e895198899260208401612e2f565b03601f198101885287610abe565b60018060a01b037fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa49035416948751998a978896879663040a7bb160e41b885216600487015230602487015260a0604487015260a48601906115e4565b91151560648501528382037ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0160848501526115e4565b03915afa918215610674576000908193612f4757509190565b905061029291925060403d8111612f6b575b612f638183610abe565b810190612e54565b503d612f59565b15612f7957565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f746f6b656e4964735b5d20697320656d707479000000000000000000000000006044820152606490fd5b15612fdf57565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f62617463682073697a65206578636565647320647374206261746368206c696d60448201527f69740000000000000000000000000000000000000000000000000000000000006064820152608490fd5b8181029291811591840414171561247b57565b61308f906020604051928284809451938492016115c1565b810103902090565b906020610b8c928181520190612dfb565b959094939192936130bb85511515612f72565b84516130d46001918281149081156131e8575b50612fd8565b6000815b6131bc575b50509261318661ffff9361318b937fe1b87c47fdeb4f9cbadbca9df3af7aba453bb6e501075d0440d88125b711522a9660405192613131846131238c8960208401612e2f565b03601f198101865285610abe565b61317e61317761316e8d61ffff166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4900602052604060002090565b548c5190613064565b848d61439e565b34938b61390e565b613077565b604051909573ffffffffffffffffffffffffffffffffffffffff16949091169281906131b79082613097565b0390a4565b86518110156131e35780610d806131d66131dd938a6128f9565b518b61329c565b816130d8565b6130dd565b90506132218961ffff166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa48ff602052604060002090565b541015386130ce565b6040519061323782610a86565b600182527f37000000000000000000000000000000000000000000000000000000000000006020830152565b6040519061327082610a86565b600182527f38000000000000000000000000000000000000000000000000000000000000006020830152565b906132a5612327565b916132af8261348e565b73ffffffffffffffffffffffffffffffffffffffff9380851682861681149290919083156133db575b50508115613319575b506125f8936132f56133129261060861322a565b6132fe8461348e565b613306613263565b918085169116146122dd565b30906135ec565b9050613324836137d4565b1561337c576125f8936132f561331292856000527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d8602052613372836040600020541660018060a01b031690565b14925050936132e1565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f4552433732313a20696e76616c696420746f6b656e20494400000000000000006044820152606490fd5b73ffffffffffffffffffffffffffffffffffffffff1660009081527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d96020526040902091925060ff9161343e9160018060a01b0316600052602052604060002090565b54169038806132d8565b73ffffffffffffffffffffffffffffffffffffffff1660009081527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d76020526040902090565b60009081527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d6602052604090205473ffffffffffffffffffffffffffffffffffffffff1680156134db5790565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f455243373231203a61646472657373207a65726f206973206e6f74206120766160448201527f6c6964206f776e657200000000000000000000000000000000000000000000006064820152608490fd5b1561356757565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f4552433732313a207472616e736665722066726f6d20696e636f72726563742060448201527f6f776e65720000000000000000000000000000000000000000000000000000006064820152608490fd5b61361d906135f98461348e565b73ffffffffffffffffffffffffffffffffffffffff82811693909182168414613560565b8316928315613750576136a6613729926136438561363d6113a48a61348e565b14613560565b6136a1613679886000527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d8602052604060002090565b80547fffffffffffffffffffffffff0000000000000000000000000000000000000000169055565b613448565b80547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190556136d581613448565b600181540190556136e5856127c1565b80547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff909216919091179055565b7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef600080a4565b6040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f4552433732313a207472616e7366657220746f20746865207a65726f2061646460448201527f72657373000000000000000000000000000000000000000000000000000000006064820152608490fd5b60009081527fa69d290a9fc968e5d4570d812390b00825a2addd4f76316b7e43122b804de8d6602052604090205473ffffffffffffffffffffffffffffffffffffffff16151590565b1561382457565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603060248201527f4c7a4170703a2064657374696e6174696f6e20636861696e206973206e6f742060448201527f61207472757374656420736f75726365000000000000000000000000000000006064820152608490fd5b926138ce610b8c97959361ffff6138dc9416865260c0602087015260c08601906115e4565b9084820360408601526115e4565b73ffffffffffffffffffffffffffffffffffffffff91821660608401529316608082015280830360a0909101526115e4565b9092919461391b826124c6565b916040519283600082549261392f8461252c565b908184526001948581169081600014613a3d57506001146139fa575b505061395992500384610abe565b6139658351151561381d565b61397085518261446c565b7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa4903546139b19073ffffffffffffffffffffffffffffffffffffffff166113a4565b93843b156101cc576000966139dc91604051998a988997889662c5803160e81b8852600488016138a9565b03925af18015610674576139ed5750565b80611c5a6125f892610a6d565b9093915060005260209081600020936000915b818310613a255750506139599350820101388061394b565b85548984018501529485019488945091830191613a0d565b91505061395994506020925060ff191682840152151560051b820101388061394b565b604090610b8c9392815281602082015201906115e4565b9092601490835192602095613a93878088019688010186612829565b9401519460005b8551811015613d2e575a7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa48fe5411613c5057613ad581876128f9565b51613adf816137d4565b801580918115613c1b575b50156101cc5715613c0c57604090815191613b0483610aa2565b6000835273ffffffffffffffffffffffffffffffffffffffff8a16908115613baf5750613baa93928280613ba593613b798e613b51613b4c613b48610d809a6137d4565b1590565b6140fc565b613b60613b4c613b48866137d4565b613b6981613448565b600181540190556136e5846127c1565b60007fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8180a48b6141d2565b6140c2565b613a9a565b517f08c379a0000000000000000000000000000000000000000000000000000000008152600481018d9052602481018d90527f4552433732313a206d696e7420746f20746865207a65726f20616464726573736044820152606490fd5b90610d80613baa9289306135ec565b905080613c29575b38613aea565b50613c338261348e565b73ffffffffffffffffffffffffffffffffffffffff163014613c23565b9083977f5b821db8a46f8ecbe1941ba2f51cfeea9643268b56631f70d45e2a745d99026595998861ffff96613c9596955b8a518110613cb0575b505050505050613077565b936131b760405192839260018060a01b031697169482613097565b611203613d11937f10e0b70d256bccc84b7027506978bd8b68984a870788b93b479def144c839ad7978751902095613cf3613ce9610ae0565b61ffff9096168652565b73ffffffffffffffffffffffffffffffffffffffff90911690840152565b613d2060405192839283613a60565b0390a1388080888a82613c8a565b9083977f5b821db8a46f8ecbe1941ba2f51cfeea9643268b56631f70d45e2a745d99026595998861ffff96613c959695613c81565b919060005b8151811015613f10575a7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa48fe5411613f1057613da381836128f9565b51613dad816137d4565b801580918115613edb575b50156101cc5715613ecc57604090815191613dd283610aa2565b6000835273ffffffffffffffffffffffffffffffffffffffff8716908115613e6f5750613e6a93928280613ba593613e12613b4c613b48610d80986137d4565b613e21613b4c613b48846137d4565b613e2a8b613448565b60018154019055613e3e8b6136e5846127c1565b60007fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8180a4886141d2565b613d68565b517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4552433732313a206d696e7420746f20746865207a65726f20616464726573736044820152606490fd5b90610d80613e6a9286306135ec565b905080613ee9575b38613db8565b50613ef38261348e565b73ffffffffffffffffffffffffffffffffffffffff163014613ee3565b925050565b9291905b8151811015613f10575a7fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa48fe5411613f1057613f5481836128f9565b51613f5e816137d4565b80158091811561402f575b50156101cc571561402057604090815191613f8383610aa2565b600080845273ffffffffffffffffffffffffffffffffffffffff8816918215613e6f5750928280613ba59361401b9796613fc5613b4c613b48610d80996137d4565b613fd4613b4c613b48856137d4565b613fdd8c613448565b60018154019055613ff18c6136e5856127c1565b7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8180a4886141d2565b613f19565b90610d8061401b9286306135ec565b90508061403d575b38613f69565b506140478261348e565b73ffffffffffffffffffffffffffffffffffffffff163014614037565b60809060208152603260208201527f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560408201527f63656976657220696d706c656d656e746572000000000000000000000000000060608201520190565b156140c957565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081528061232360048201614064565b1561410357565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f4552433732313a20746f6b656e20616c7265616479206d696e746564000000006044820152606490fd5b908160209103126101cc5751610b8c816103ce565b610b8c939260809260018060a01b0316825260006020830152604082015281606082015201906115e4565b3d156141cd573d906141b382610b00565b916141c16040519384610abe565b82523d6000602084013e565b606090565b909190803b156142ca57614204602091600093604051948580948193630a85bd0160e11b998a84523360048501614177565b039273ffffffffffffffffffffffffffffffffffffffff165af16000918161429a575b50614274576142346141a2565b8051908161426f576040517f08c379a00000000000000000000000000000000000000000000000000000000081528061232360048201614064565b602001fd5b7fffffffff00000000000000000000000000000000000000000000000000000000161490565b6142bc91925060203d81116142c3575b6142b48183610abe565b810190614162565b9038614227565b503d6142aa565b505050600190565b156142d957565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f4c7a4170703a206d696e4761734c696d6974206e6f74207365740000000000006044820152606490fd5b1561433f57565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f4c7a4170703a20676173206c696d697420697320746f6f206c6f7700000000006044820152606490fd5b9190602281511061440d57602261ffff91015192166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa49056020526040600020600160005260205260406000205490810180911161247b576125f8916144068215156142d2565b1015614338565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f4c7a4170703a20696e76616c69642061646170746572506172616d73000000006044820152606490fd5b61ffff166000527fb0ef2b4863b634f72cc1ab80fbd4ca19f5ac7f001fa644ad4b04f5ce5cfa49066020526040600020549081156144f0575b116144ac57565b606460405162461bcd60e51b815260206004820152602060248201527f4c7a4170703a207061796c6f61642073697a6520697320746f6f206c617267656044820152fd5b61271091506144a556fea2646970667358221220dcd487394a00e6b75910c16ff99517eda8cefc263838a7a7c4b23ccf50563f8164736f6c63430008130033",
  "devdoc": {
    "events": {
      "CreditCleared(bytes32)": {
        "details": "Emitted when `_hashedPayload` has been completely delivered"
      },
      "CreditStored(bytes32,bytes)": {
        "details": "Emitted when `_payload` was received from lz, but not enough gas to deliver all tokenIds"
      },
      "SendToChain(uint16,address,bytes,uint256[])": {
        "details": "Emitted when `_tokenIds[]` are moved from the `_sender` to (`_dstChainId`, `_toAddress`) `_nonce` is the outbound nonce from"
      }
    },
    "kind": "dev",
    "methods": {
      "estimateSendBatchFee(uint16,bytes,uint256[],bool,bytes)": {
        "details": "estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`) _dstChainId - L0 defined chain id to send tokens too _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain _tokenIds[] - token Ids to transfer _useZro - indicates to use zro to pay L0 fees _adapterParams - flexible bytes array to indicate messaging adapter services in L0"
      },
      "estimateSendFee(uint16,bytes,uint256,bool,bytes)": {
        "details": "estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`) _dstChainId - L0 defined chain id to send tokens too _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain _tokenId - token Id to transfer _useZro - indicates to use zro to pay L0 fees _adapterParams - flexible bytes array to indicate messaging adapter services in L0"
      },
      "sendBatchFrom(address,uint16,bytes,uint256[],address,address,bytes)": {
        "details": "send tokens `_tokenIds[]` to (`_dstChainId`, `_toAddress`) from `_from` `_toAddress` can be any size depending on the `dstChainId`. `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token) `_adapterParams` is a flexible bytes array to indicate messaging adapter services"
      },
      "sendFrom(address,uint16,bytes,uint256,address,address,bytes)": {
        "details": "send token `_tokenId` to (`_dstChainId`, `_toAddress`) from `_from` `_toAddress` can be any size depending on the `dstChainId`. `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token) `_adapterParams` is a flexible bytes array to indicate messaging adapter services"
      },
      "setERC165(bytes4[],bytes4[])": {
        "params": {
          "interfaceIds": "list of interface id to set as supported",
          "interfaceIdsToRemove": "list of interface id to unset as supported. Technically, you can remove support of ERC165 by having the IERC165 id itself being part of that array."
        }
      },
      "supportsInterface(bytes4)": {
        "details": "Interface identification is specified in ERC-165. This function  uses less than 30,000 gas.",
        "params": {
          "interfaceId": "The interface identifier, as specified in ERC-165"
        },
        "returns": {
          "_0": "`true` if the contract implements `interfaceID` and  `interfaceID` is not 0xffffffff, `false` otherwise"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "setERC165(bytes4[],bytes4[])": {
        "notice": "set or unset ERC165 using DiamondStorage.supportedInterfaces"
      },
      "supportsInterface(bytes4)": {
        "notice": "Query if a contract implements an interface"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}