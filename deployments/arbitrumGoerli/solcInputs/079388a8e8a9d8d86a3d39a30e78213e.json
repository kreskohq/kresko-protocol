{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneDefaultsLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"../libs/NumericArrayLib.sol\";\n\n/**\n * @title Default implementations of virtual redstone consumer base functions\n * @author The Redstone Oracles team\n */\nlibrary RedstoneDefaultsLib {\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS = 3 minutes;\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS = 1 minutes;\n\n  error TimestampFromTooLongFuture(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\n  error TimestampIsTooOld(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\n\n  function validateTimestamp(uint256 receivedTimestampMilliseconds) internal view {\n    // Getting data timestamp from future seems quite unlikely\n    // But we've already spent too much time with different cases\n    // Where block.timestamp was less than dataPackage.timestamp.\n    // Some blockchains may case this problem as well.\n    // That's why we add MAX_BLOCK_TIMESTAMP_DELAY\n    // and allow data \"from future\" but with a small delay\n    uint256 receivedTimestampSeconds = receivedTimestampMilliseconds / 1000;\n\n    if (block.timestamp < receivedTimestampSeconds) {\n      if ((receivedTimestampSeconds - block.timestamp) > DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS) {\n        revert TimestampFromTooLongFuture(receivedTimestampSeconds, block.timestamp);\n      }\n    } else if ((block.timestamp - receivedTimestampSeconds) > DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS) {\n      revert TimestampIsTooOld(receivedTimestampSeconds, block.timestamp);\n    }\n  }\n\n  function aggregateValues(uint256[] memory values) internal pure returns (uint256) {\n    return NumericArrayLib.pickMedian(values);\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/BitmapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary BitmapLib {\n  function setBitInBitmap(uint256 bitmap, uint256 bitIndex) internal pure returns (uint256) {\n    return bitmap | (1 << bitIndex);\n  }\n\n  function getBitFromBitmap(uint256 bitmap, uint256 bitIndex) internal pure returns (bool) {\n    uint256 bitAtIndex = bitmap & (1 << bitIndex);\n    return bitAtIndex > 0;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/NumericArrayLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nlibrary NumericArrayLib {\n  // This function sort array in memory using bubble sort algorithm,\n  // which performs even better than quick sort for small arrays\n\n  uint256 constant BYTES_ARR_LEN_VAR_BS = 32;\n  uint256 constant UINT256_VALUE_BS = 32;\n\n  error CanNotPickMedianOfEmptyArray();\n\n  // This function modifies the array\n  function pickMedian(uint256[] memory arr) internal pure returns (uint256) {\n    if (arr.length == 0) {\n      revert CanNotPickMedianOfEmptyArray();\n    }\n    sort(arr);\n    uint256 middleIndex = arr.length / 2;\n    if (arr.length % 2 == 0) {\n      uint256 sum = SafeMath.add(arr[middleIndex - 1], arr[middleIndex]);\n      return sum / 2;\n    } else {\n      return arr[middleIndex];\n    }\n  }\n\n  function sort(uint256[] memory arr) internal pure {\n    assembly {\n      let arrLength := mload(arr)\n      let valuesPtr := add(arr, BYTES_ARR_LEN_VAR_BS)\n      let endPtr := add(valuesPtr, mul(arrLength, UINT256_VALUE_BS))\n      for {\n        let arrIPtr := valuesPtr\n      } lt(arrIPtr, endPtr) {\n        arrIPtr := add(arrIPtr, UINT256_VALUE_BS) // arrIPtr += 32\n      } {\n        for {\n          let arrJPtr := valuesPtr\n        } lt(arrJPtr, arrIPtr) {\n          arrJPtr := add(arrJPtr, UINT256_VALUE_BS) // arrJPtr += 32\n        } {\n          let arrI := mload(arrIPtr)\n          let arrJ := mload(arrJPtr)\n          if lt(arrI, arrJ) {\n            mstore(arrIPtr, arrJ)\n            mstore(arrJPtr, arrI)\n          }\n        }\n      }\n    }\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/SignatureLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary SignatureLib {\n  uint256 constant ECDSA_SIG_R_BS = 32;\n  uint256 constant ECDSA_SIG_S_BS = 32;\n\n  function recoverSignerAddress(bytes32 signedHash, uint256 signatureCalldataNegativeOffset)\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n    assembly {\n      let signatureCalldataStartPos := sub(calldatasize(), signatureCalldataNegativeOffset)\n      r := calldataload(signatureCalldataStartPos)\n      signatureCalldataStartPos := add(signatureCalldataStartPos, ECDSA_SIG_R_BS)\n      s := calldataload(signatureCalldataStartPos)\n      signatureCalldataStartPos := add(signatureCalldataStartPos, ECDSA_SIG_S_BS)\n      v := byte(0, calldataload(signatureCalldataStartPos)) // last byte of the signature memory array\n    }\n    return ecrecover(signedHash, v, r, s);\n  }\n}\n"
    },
    "src/contracts/diamond/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable no-complex-fallback  */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable no-empty-blocks */\n\npragma solidity >=0.8.19;\n\nimport {IDiamondCutFacet} from \"./interfaces/IDiamondCutFacet.sol\";\nimport {Authorization, Role} from \"../libs/Authorization.sol\";\nimport {GeneralEvent} from \"../libs/Events.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\nimport {initializeDiamondCut} from \"./libs/LibDiamondCut.sol\";\nimport {ds} from \"./DiamondStorage.sol\";\n\ncontract Diamond {\n    struct Initialization {\n        address initContract;\n        bytes initData;\n    }\n\n    constructor(\n        address _owner,\n        IDiamondCutFacet.FacetCut[] memory _diamondCut,\n        Initialization[] memory _initializations\n    ) {\n        ds().initialize(_owner);\n        ds().diamondCut(_diamondCut, address(0), \"\");\n        Authorization._grantRole(Role.ADMIN, _owner);\n\n        for (uint256 i = 0; i < _initializations.length; i++) {\n            initializeDiamondCut(_initializations[i].initContract, _initializations[i].initData);\n        }\n\n        emit GeneralEvent.Initialized(_owner, ds().storageVersion);\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        // get facet from function selectors\n        address facet = ds().selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), Error.DIAMOND_INVALID_FUNCTION_SIGNATURE);\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice A rescue function for missent msg.value\n     */\n    function rescueNative() external {\n        require(msg.sender == ds().contractOwner, Error.DIAMOND_INVALID_OWNER);\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    receive() external payable {}\n}\n"
    },
    "src/contracts/diamond/DiamondModifiers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {Authorization, Role} from \"../libs/Authorization.sol\";\nimport {Meta} from \"../libs/Meta.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\nimport {Action} from \"../minter/MinterTypes.sol\";\nimport {ms} from \"../minter/MinterStorage.sol\";\n\nimport {ENTERED, NOT_ENTERED} from \"../diamond/DiamondTypes.sol\";\nimport {ds} from \"../diamond/DiamondStorage.sol\";\n\nabstract contract DiamondModifiers {\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^Authorization: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        Authorization.checkRole(role);\n        _;\n    }\n\n    /**\n     * @notice Ensure only trusted contracts can act on behalf of `_account`\n     * @param _accountIsNotMsgSender The address of the collateral asset.\n     */\n    modifier onlyRoleIf(bool _accountIsNotMsgSender, bytes32 role) {\n        if (_accountIsNotMsgSender) {\n            Authorization.checkRole(role);\n        }\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(Meta.msgSender() == ds().contractOwner, Error.DIAMOND_INVALID_OWNER);\n        _;\n    }\n\n    modifier onlyPendingOwner() {\n        require(Meta.msgSender() == ds().pendingOwner, Error.DIAMOND_INVALID_PENDING_OWNER);\n        _;\n    }\n\n    modifier nonReentrant() {\n        require(ds().entered == NOT_ENTERED, Error.RE_ENTRANCY);\n        ds().entered = ENTERED;\n        _;\n        ds().entered = NOT_ENTERED;\n    }\n}\n"
    },
    "src/contracts/diamond/DiamondState.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {EnumerableSet} from \"../libs/EnumerableSet.sol\";\nimport {FacetAddressAndPosition, FacetFunctionSelectors, RoleData, ENTERED, NOT_ENTERED} from \"./DiamondTypes.sol\";\n\nimport {LibDiamondCut} from \"./libs/LibDiamondCut.sol\";\nimport {LibOwnership} from \"./libs/LibOwnership.sol\";\n\nusing LibDiamondCut for DiamondState global;\nusing LibOwnership for DiamondState global;\n\n/* -------------------------------------------------------------------------- */\n/*                                 Main Layout                                */\n/* -------------------------------------------------------------------------- */\n\nstruct DiamondState {\n    /* -------------------------------------------------------------------------- */\n    /*                                   Proxy                                    */\n    /* -------------------------------------------------------------------------- */\n    /// @notice Maps function selector to the facet address and\n    /// the position of the selector in the facetFunctionSelectors.selectors array\n    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n    /// @notice Maps facet addresses to function selectors\n    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n    /// @notice Facet addresses\n    address[] facetAddresses;\n    /// @notice ERC165 query implementation\n    mapping(bytes4 => bool) supportedInterfaces;\n    /* -------------------------------------------------------------------------- */\n    /*                               Initialization                               */\n    /* -------------------------------------------------------------------------- */\n    /// @notice Initialization status\n    bool initialized;\n    /// @notice Domain field separator\n    bytes32 domainSeparator;\n    /* -------------------------------------------------------------------------- */\n    /*                                  Ownership                                 */\n    /* -------------------------------------------------------------------------- */\n    /// @notice Current owner of the diamond\n    address contractOwner;\n    /// @notice Pending new diamond owner\n    address pendingOwner;\n    /// @notice Storage version\n    uint8 storageVersion;\n    /// @notice address(this) replacement for FF\n    address self;\n    /* -------------------------------------------------------------------------- */\n    /*                               Access Control                               */\n    /* -------------------------------------------------------------------------- */\n    mapping(bytes32 => RoleData) _roles;\n    mapping(bytes32 => EnumerableSet.AddressSet) _roleMembers;\n    /* -------------------------------------------------------------------------- */\n    /*                                 Reentrancy                                 */\n    /* -------------------------------------------------------------------------- */\n    uint256 entered;\n}\n"
    },
    "src/contracts/diamond/DiamondStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\npragma solidity >=0.8.19;\n\nimport {DiamondState} from \"./DiamondState.sol\";\n\n// Storage position\nbytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"kresko.diamond.storage\");\n\nfunction ds() pure returns (DiamondState storage state) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n        state.slot := position\n    }\n}\n"
    },
    "src/contracts/diamond/DiamondTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n/// @dev set the initial value to 1 as we do not\n/// wanna hinder possible gas refunds by setting it to 0 on exit.\n\n/* -------------------------------------------------------------------------- */\n/*                                 Reentrancy                                 */\n/* -------------------------------------------------------------------------- */\nuint256 constant NOT_ENTERED = 1;\nuint256 constant ENTERED = 2;\n\n/* ========================================================================== */\n/*                                   STRUCTS                                  */\n/* ========================================================================== */\n\nstruct FacetAddressAndPosition {\n    address facetAddress;\n    // position in facetFunctionSelectors.functionSelectors array\n    uint96 functionSelectorPosition;\n}\n\nstruct FacetFunctionSelectors {\n    bytes4[] functionSelectors;\n    // position of facetAddress in facetAddresses array\n    uint256 facetAddressPosition;\n}\n\nstruct RoleData {\n    mapping(address => bool) members;\n    bytes32 adminRole;\n}\n"
    },
    "src/contracts/diamond/facets/AuthorizationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IAuthorizationFacet} from \"../interfaces/IAuthorizationFacet.sol\";\nimport {Authorization, Role} from \"../../libs/Authorization.sol\";\n\n/**\n * @title Enumerable access control for the EIP2535-pattern following the OZ implementation.\n * @author Kresko\n * @notice The storage area is in the main proxy diamond storage.\n * @dev Difference here is the logic library that is shared and reused, there is no state here.\n */\ncontract AuthorizationFacet is IAuthorizationFacet {\n    using Authorization for bytes32;\n\n    /// @inheritdoc IAuthorizationFacet\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address) {\n        return role.getRoleMember(index);\n    }\n\n    /// @inheritdoc IAuthorizationFacet\n    function getRoleMemberCount(bytes32 role) external view returns (uint256) {\n        return role.getRoleMemberCount();\n    }\n\n    /// @inheritdoc IAuthorizationFacet\n    function grantRole(bytes32 role, address account) external {\n        role.grantRole(account);\n    }\n\n    /// @inheritdoc IAuthorizationFacet\n    function revokeRole(bytes32 role, address account) external {\n        role.revokeRole(account);\n    }\n\n    /// @inheritdoc IAuthorizationFacet\n    function hasRole(bytes32 role, address account) external view returns (bool) {\n        return role.hasRole(account);\n    }\n\n    /// @inheritdoc IAuthorizationFacet\n    function getRoleAdmin(bytes32 role) external view returns (bytes32) {\n        return role.getRoleAdmin();\n    }\n\n    /// @inheritdoc IAuthorizationFacet\n    function renounceRole(bytes32 role, address account) external {\n        role._renounceRole(account);\n    }\n}\n"
    },
    "src/contracts/diamond/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {IDiamondCutFacet} from \"../interfaces/IDiamondCutFacet.sol\";\nimport {DiamondModifiers, Role} from \"../DiamondModifiers.sol\";\nimport {initializeDiamondCut} from \"../libs/LibDiamondCut.sol\";\nimport {ds} from \"../DiamondStorage.sol\";\n\n/**\n * @title EIP2535-pattern upgrades.\n * @author Kresko\n * @notice The storage area is in the main proxy diamond storage.\n */\ncontract DiamondCutFacet is IDiamondCutFacet, DiamondModifiers {\n    /// @inheritdoc IDiamondCutFacet\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external onlyRole(Role.ADMIN) {\n        ds().diamondCut(_diamondCut, _init, _calldata);\n    }\n\n    /// @inheritdoc IDiamondCutFacet\n    function upgradeState(address _init, bytes calldata _calldata) external onlyRole(Role.ADMIN) {\n        initializeDiamondCut(_init, _calldata);\n    }\n}\n"
    },
    "src/contracts/diamond/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {IDiamondLoupeFacet} from \"../interfaces/IDiamondLoupeFacet.sol\";\nimport {ds, DiamondState} from \"../DiamondStorage.sol\";\n\ncontract DiamondLoupeFacet is IDiamondLoupeFacet {\n    /// @inheritdoc IDiamondLoupeFacet\n    function facets() external view override returns (Facet[] memory facets_) {\n        DiamondState storage s = ds();\n        uint256 numFacets = s.facetAddresses.length;\n        facets_ = new Facet[](numFacets);\n        for (uint256 i; i < numFacets; i++) {\n            address facetAddress_ = s.facetAddresses[i];\n            facets_[i].facetAddress = facetAddress_;\n            facets_[i].functionSelectors = s.facetFunctionSelectors[facetAddress_].functionSelectors;\n        }\n    }\n\n    /// @inheritdoc IDiamondLoupeFacet\n    function facetFunctionSelectors(\n        address _facet\n    ) external view override returns (bytes4[] memory facetFunctionSelectors_) {\n        facetFunctionSelectors_ = ds().facetFunctionSelectors[_facet].functionSelectors;\n    }\n\n    /// @inheritdoc IDiamondLoupeFacet\n    function facetAddresses() external view override returns (address[] memory facetAddresses_) {\n        facetAddresses_ = ds().facetAddresses;\n    }\n\n    /// @inheritdoc IDiamondLoupeFacet\n    function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\n        facetAddress_ = ds().selectorToFacetAndPosition[_functionSelector].facetAddress;\n    }\n}\n"
    },
    "src/contracts/diamond/facets/DiamondOwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {IDiamondOwnershipFacet} from \"../interfaces/IDiamondOwnershipFacet.sol\";\nimport {DiamondModifiers} from \"../DiamondModifiers.sol\";\nimport {ds} from \"../DiamondStorage.sol\";\n\ncontract DiamondOwnershipFacet is IDiamondOwnershipFacet, DiamondModifiers {\n    /* -------------------------------------------------------------------------- */\n    /*                                    Write                                   */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IDiamondOwnershipFacet\n    function transferOwnership(address _newOwner) external override {\n        ds().initiateOwnershipTransfer(_newOwner);\n    }\n\n    /// @inheritdoc IDiamondOwnershipFacet\n    function acceptOwnership() external override {\n        ds().finalizeOwnershipTransfer();\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Read                                    */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IDiamondOwnershipFacet\n    function owner() external view override returns (address owner_) {\n        return ds().contractOwner;\n    }\n\n    /// @inheritdoc IDiamondOwnershipFacet\n    function pendingOwner() external view override returns (address pendingOwner_) {\n        return ds().pendingOwner;\n    }\n\n    /// @inheritdoc IDiamondOwnershipFacet\n    function initialized() external view returns (bool initialized_) {\n        return ds().initialized;\n    }\n}\n"
    },
    "src/contracts/diamond/facets/ERC165Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {Error} from \"../../libs/Errors.sol\";\nimport {DiamondModifiers, Role} from \"../DiamondModifiers.sol\";\nimport {IERC165Facet} from \"../interfaces/IERC165Facet.sol\";\nimport {ds, DiamondState} from \"../DiamondStorage.sol\";\n\ncontract ERC165Facet is IERC165Facet, DiamondModifiers {\n    /// @inheritdoc IERC165Facet\n    function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\n        return ds().supportedInterfaces[_interfaceId];\n    }\n\n    /// @inheritdoc IERC165Facet\n    function setERC165(\n        bytes4[] calldata interfaceIds,\n        bytes4[] calldata interfaceIdsToRemove\n    ) external onlyRole(Role.ADMIN) {\n        DiamondState storage s = ds();\n\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            s.supportedInterfaces[interfaceIds[i]] = true;\n        }\n\n        for (uint256 i = 0; i < interfaceIdsToRemove.length; i++) {\n            s.supportedInterfaces[interfaceIdsToRemove[i]] = false;\n        }\n    }\n}\n"
    },
    "src/contracts/diamond/interfaces/IAuthorizationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface IAuthorizationFacet {\n    /**\n     * @dev OpenZeppelin\n     * Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * @notice WARNING:\n     * When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block.\n     *\n     * See the following forum post for more information:\n     * - https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296\n     *\n     * @dev Kresko\n     *\n     * TL;DR above:\n     *\n     * - If you iterate the EnumSet outside a single block scope you might get different results.\n     * - Since when EnumSet member is deleted it is replaced with the highest index.\n     * @return address with the `role`\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     * @notice See warning in {getRoleMember} if combining these two\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * @notice To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Returns true if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * @notice Requirements\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * @notice Requirements\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n}\n"
    },
    "src/contracts/diamond/interfaces/IDiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\nimport {DiamondEvent} from \"../../libs/Events.sol\";\n\ninterface IDiamondCutFacet {\n    /// @dev  Add=0, Replace=1, Remove=2\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /**\n     *@notice Add/replace/remove any number of functions, optionally execute a function with delegatecall\n     * @param _diamondCut Contains the facet addresses and function selectors\n     * @param _init The address of the contract or facet to execute _calldata\n     * @param _calldata A function call, including function selector and arguments\n     *                  _calldata is executed with delegatecall on _init\n     */\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n\n    /**\n     * @notice Use an initializer contract without doing modifications\n     * @param _init The address of the contract or facet to execute _calldata\n     * @param _calldata A function call, including function selector and arguments\n     * - _calldata is executed with delegatecall on _init\n     */\n    function upgradeState(address _init, bytes calldata _calldata) external;\n}\n"
    },
    "src/contracts/diamond/interfaces/IDiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupeFacet {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "src/contracts/diamond/interfaces/IDiamondOwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n/// @title Contract Ownership\ninterface IDiamondOwnershipFacet {\n    /**\n     * @notice Get the address of the owner\n     * @return owner_ The address of the owner.\n     */\n    function owner() external view returns (address owner_);\n\n    /**\n     * @notice Get the address of pending owner\n     * @return pendingOwner_ The address of the pending owner.\n     **/\n    function pendingOwner() external view returns (address pendingOwner_);\n\n    /**\n     * @notice Initiate ownership transfer to a new address\n     * @notice caller must be the current contract owner\n     * @notice the new owner cannot be address(0)\n     * @notice emits a {AuthEvent.PendingOwnershipTransfer} event\n     * @param _newOwner address that is set as the pending new owner\n     */\n    function transferOwnership(address _newOwner) external;\n\n    /**\n     * @notice Transfer the ownership to the new pending owner\n     * @notice caller must be the pending owner\n     * @notice emits a {AuthEvent.OwnershipTransferred} event\n     */\n    function acceptOwnership() external;\n\n    /**\n     * @notice Check if the contract is initialized\n     * @return initialized_ bool True if the contract is initialized, false otherwise.\n     */\n    function initialized() external view returns (bool initialized_);\n}\n"
    },
    "src/contracts/diamond/interfaces/IERC165Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\nimport {DiamondEvent} from \"../../libs/Events.sol\";\n\ninterface IERC165Facet {\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @dev Interface identification is specified in ERC-165. This function\n     *  uses less than 30,000 gas.\n     * @return `true` if the contract implements `interfaceID` and\n     *  `interfaceID` is not 0xffffffff, `false` otherwise\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    /**\n     * @notice set or unset ERC165 using DiamondStorage.supportedInterfaces\n     * @param interfaceIds list of interface id to set as supported\n     * @param interfaceIdsToRemove list of interface id to unset as supported.\n     * Technically, you can remove support of ERC165 by having the IERC165 id itself being part of that array.\n     */\n    function setERC165(bytes4[] calldata interfaceIds, bytes4[] calldata interfaceIdsToRemove) external;\n}\n"
    },
    "src/contracts/diamond/libs/LibDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\nimport {IDiamondCutFacet} from \"../interfaces/IDiamondCutFacet.sol\";\n\nimport {Meta} from \"../../libs/Meta.sol\";\nimport {DiamondEvent} from \"../../libs/Events.sol\";\nimport {DiamondState} from \"../DiamondState.sol\";\n\n// solhint-disable-next-line func-visibility\nfunction initializeDiamondCut(address _init, bytes memory _calldata) {\n    if (_init == address(0)) {\n        require(_calldata.length == 0, \"DiamondCut: _init is address(0) but _calldata is not empty\");\n    } else {\n        require(_calldata.length > 0, \"DiamondCut: _calldata is empty but _init is not address(0)\");\n        Meta.enforceHasContractCode(_init, \"DiamondCut: _init address has no code\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up the error\n                revert(string(error));\n            } else {\n                revert(\"DiamondCut: _init function reverted\");\n            }\n        }\n    }\n}\n\nlibrary LibDiamondCut {\n    /* -------------------------------------------------------------------------- */\n    /*                              Diamond Functions                             */\n    /* -------------------------------------------------------------------------- */\n\n    function diamondCut(\n        DiamondState storage self,\n        IDiamondCutFacet.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCutFacet.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCutFacet.FacetCutAction.Add) {\n                self.addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCutFacet.FacetCutAction.Replace) {\n                self.replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCutFacet.FacetCutAction.Remove) {\n                self.removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"DiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondEvent.DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(\n        DiamondState storage self,\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(_functionSelectors.length > 0, \"DiamondCut: No selectors in facet to cut\");\n        require(_facetAddress != address(0), \"DiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(self.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            self.addFacet(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = self.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"DiamondCut: Can't add function that already exists\");\n            self.addFunction(selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(\n        DiamondState storage self,\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(_functionSelectors.length > 0, \"DiamondCut: No selectors in facet to cut\");\n        require(_facetAddress != address(0), \"DiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(self.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            self.addFacet(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = self.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"DiamondCut: Can't replace function with same function\");\n            self.removeFunction(oldFacetAddress, selector);\n            self.addFunction(selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(\n        DiamondState storage self,\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(_functionSelectors.length > 0, \"DiamondCut: No selectors in facet to cut\");\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"DiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = self.selectorToFacetAndPosition[selector].facetAddress;\n            self.removeFunction(oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondState storage self, address _facetAddress) internal {\n        Meta.enforceHasContractCode(_facetAddress, \"DiamondCut: New facet has no code\");\n        self.facetFunctionSelectors[_facetAddress].facetAddressPosition = self.facetAddresses.length;\n        self.facetAddresses.push(_facetAddress);\n    }\n\n    function addFunction(\n        DiamondState storage self,\n        bytes4 _selector,\n        uint96 _selectorPosition,\n        address _facetAddress\n    ) internal {\n        self.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        self.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        self.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondState storage self, address _facetAddress, bytes4 _selector) internal {\n        require(_facetAddress != address(0), \"DiamondCut: Can't remove function that doesn't exist\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = self.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = self.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = self.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            self.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            self.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        self.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete self.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = self.facetAddresses.length - 1;\n            uint256 facetAddressPosition = self.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = self.facetAddresses[lastFacetAddressPosition];\n                self.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                self.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            self.facetAddresses.pop();\n            delete self.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n}\n"
    },
    "src/contracts/diamond/libs/LibOwnership.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {IERC165} from \"../../shared/IERC165.sol\";\nimport {IDiamondCutFacet} from \"../interfaces/IDiamondCutFacet.sol\";\nimport {IDiamondLoupeFacet} from \"../interfaces/IDiamondLoupeFacet.sol\";\nimport {IDiamondOwnershipFacet} from \"../interfaces/IDiamondOwnershipFacet.sol\";\nimport {IAuthorizationFacet} from \"../interfaces/IAuthorizationFacet.sol\";\n\nimport {GeneralEvent, AuthEvent} from \"../../libs/Events.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Meta} from \"../../libs/Meta.sol\";\n\nimport {NOT_ENTERED} from \"../DiamondTypes.sol\";\nimport {DiamondState} from \"../DiamondState.sol\";\n\nlibrary LibOwnership {\n    /* -------------------------------------------------------------------------- */\n    /*                         Initialization & Ownership                         */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Ownership initializer\n    /// @notice Only called on the first deployment\n    function initialize(DiamondState storage self, address _owner) internal {\n        require(!self.initialized, Error.ALREADY_INITIALIZED);\n        self.entered = NOT_ENTERED;\n        self.initialized = true;\n        self.storageVersion++;\n        self.contractOwner = _owner;\n\n        self.supportedInterfaces[type(IDiamondLoupeFacet).interfaceId] = true;\n        self.supportedInterfaces[type(IERC165).interfaceId] = true;\n        self.supportedInterfaces[type(IDiamondCutFacet).interfaceId] = true;\n        self.supportedInterfaces[type(IDiamondOwnershipFacet).interfaceId] = true;\n        self.supportedInterfaces[type(IAuthorizationFacet).interfaceId] = true;\n\n        emit GeneralEvent.Deployed(_owner, self.storageVersion);\n        emit AuthEvent.OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Initiate ownership transfer to a new address\n     * @param _newOwner address that is set as the pending new owner\n     * @notice caller must be the current contract owner\n     */\n    function initiateOwnershipTransfer(DiamondState storage self, address _newOwner) internal {\n        require(Meta.msgSender() == self.contractOwner, Error.DIAMOND_INVALID_OWNER);\n        require(_newOwner != address(0), \"DS: Owner cannot be 0-address\");\n\n        self.pendingOwner = _newOwner;\n\n        emit AuthEvent.PendingOwnershipTransfer(self.contractOwner, _newOwner);\n    }\n\n    /**\n     * @dev Transfer the ownership to the new pending owner\n     * @notice caller must be the pending owner\n     */\n    function finalizeOwnershipTransfer(DiamondState storage self) internal {\n        address sender = Meta.msgSender();\n        require(sender == self.pendingOwner, Error.DIAMOND_INVALID_PENDING_OWNER);\n        self.contractOwner = self.pendingOwner;\n        self.pendingOwner = address(0);\n\n        emit AuthEvent.OwnershipTransferred(self.contractOwner, sender);\n    }\n}\n"
    },
    "src/contracts/kiss/interfaces/IKISS.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {IERC20Permit} from \"../../shared/IERC20Permit.sol\";\n\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\nimport {IERC165} from \"../../shared/IERC165.sol\";\n\ninterface IKISS is IKreskoAssetIssuer, IERC165 {\n    /* -------------------------------------------------------------------------- */\n    /*                                   Events                                   */\n    /* -------------------------------------------------------------------------- */\n    event NewOperatorInitialized(address indexed pendingNewOperator, uint256 unlockTimestamp);\n    event NewOperator(address indexed newOperator);\n    event NewMaxOperators(uint256 newMaxOperators);\n    event NewPendingOperatorWaitPeriod(uint256 newPeriod);\n\n    function pendingOperatorUnlockTime() external returns (uint256);\n\n    function pendingOperator() external returns (address);\n\n    function maxOperators() external returns (uint256);\n\n    /**\n     * @notice This function adds KISS to circulation\n     * Caller must be a contract and have the OPERATOR_ROLE\n     * @param _to address to mint tokens to\n     * @param _amount amount to mint\n     * @return amount minted\n     */\n    function issue(uint256 _amount, address _to) external returns (uint256);\n\n    /**\n     * @notice Use operator role for minting, so override the parent\n     * Caller must be a contract and have the OPERATOR_ROLE\n     * @param _to address to mint tokens to\n     * @param _amount amount to mint\n     * @dev Does not return a value\n     */\n    function mint(address _to, uint256 _amount) external;\n\n    /**\n     * @notice This function removes KISS from circulation\n     * Caller must be a contract and have the OPERATOR_ROLE\n     * @param _from address to burn tokens from\n     * @param destroyed amount burned\n     * @inheritdoc IKreskoAssetIssuer\n     */\n    function destroy(uint256 _amount, address _from) external returns (uint256 destroyed);\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function pause() external;\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function unpause() external;\n\n    /**\n     * @notice Set a new waiting period for a new operator\n     *\n     * Must be at least 15 minutes\n     *\n     * @param _newPeriod the period, in seconds\n     */\n    function setPendingOperatorWaitPeriod(uint256 _newPeriod) external;\n\n    /**\n     * @notice Allows ADMIN_ROLE to change the maximum operators\n     * @param _maxOperators new maximum amount of operators\n     */\n    function setMaxOperators(uint256 _maxOperators) external;\n\n    /**\n     * @notice Overrides `AccessControl.grantRole` for following:\n     * * Implement a cooldown period of `pendingOperatorWaitPeriod` minutes for setting a new OPERATOR_ROLE\n     * * EOA cannot be granted the operator role\n     * * The first operator can be set without a cooldown period\n     * @notice OPERATOR_ROLE can still be revoked without this cooldown period\n     * @notice PAUSER_ROLE can still be granted without this cooldown period\n     * @param _role role to grant\n     * @param _to address to grant role for\n     */\n    function grantRole(bytes32 _role, address _to) external;\n}\n"
    },
    "src/contracts/kiss/KISS.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n// solhint-disable-next-line\nimport {AccessControlEnumerableUpgradeable, AccessControlUpgradeable, IAccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"../shared/ERC20Upgradeable.sol\";\nimport {IKreskoAssetIssuer} from \"../kreskoasset/IKreskoAssetIssuer.sol\";\nimport {IKISS, IERC165} from \"./interfaces/IKISS.sol\";\nimport {Role} from \"../libs/Authorization.sol\";\nimport {Error} from \"../libs/Errors.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @title Kresko Integrated Stable System\n * This is a non-rebasing Kresko Asset, intended to be paired to a stable-value underlying.\n * @author Kresko\n */\ncontract KISS is IKISS, ERC20Upgradeable, PausableUpgradeable, AccessControlEnumerableUpgradeable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    modifier onlyContract() {\n        require(msg.sender.code.length > 0, Error.CALLER_NOT_CONTRACT);\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Layout                                   */\n    /* -------------------------------------------------------------------------- */\n\n    uint256 public pendingOperatorWaitPeriod;\n    uint256 public pendingOperatorUnlockTime;\n    uint256 public maxOperators;\n    address public pendingOperator;\n    address public kresko;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Writes                                   */\n    /* -------------------------------------------------------------------------- */\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        uint8 dec_,\n        address admin_,\n        address kresko_\n    ) external initializer {\n        // Few sanity checks, we do not want EOA's here\n        require(kresko_.code.length > 0, Error.KRESKO_NOT_CONTRACT);\n        require(admin_.code.length > 0, Error.ADMIN_NOT_A_CONTRACT);\n\n        // ERC20\n        name = name_;\n        symbol = symbol_;\n        decimals = dec_;\n\n        // 2 operators needed at the time of writing, the volative market and the stable market.\n        maxOperators = 2;\n\n        // 15 minutes to wait before the operator can accept the role, this is the minimum value that can be set.\n        pendingOperatorWaitPeriod = 15 minutes;\n\n        // Setup the admin\n        _setupRole(Role.DEFAULT_ADMIN, admin_);\n        _setupRole(Role.ADMIN, admin_);\n\n        // Setup the protocol\n        kresko = kresko_;\n        _setupRole(Role.OPERATOR, kresko_);\n        _setupRole(MINTER_ROLE, kresko_);\n        _setupRole(PAUSER_ROLE, kresko_);\n\n        renounceRole(MINTER_ROLE, msg.sender);\n        renounceRole(PAUSER_ROLE, msg.sender);\n        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view override(AccessControlEnumerableUpgradeable, IERC165) returns (bool) {\n        return (interfaceId != 0xffffffff &&\n            (interfaceId == type(IKISS).interfaceId ||\n                interfaceId == type(IKreskoAssetIssuer).interfaceId ||\n                interfaceId == 0x01ffc9a7 ||\n                interfaceId == 0x36372b07 ||\n                super.supportsInterface(interfaceId)));\n    }\n\n    /// @inheritdoc IKISS\n    function issue(\n        uint256 _amount,\n        address _to\n    ) public override onlyContract onlyRole(Role.OPERATOR) returns (uint256) {\n        _mint(_to, _amount);\n        return _amount;\n    }\n\n    /// @inheritdoc IKISS\n    function mint(address _to, uint256 _amount) public onlyContract onlyRole(Role.OPERATOR) {\n        _mint(_to, _amount);\n    }\n\n    /// @inheritdoc IKISS\n    function destroy(uint256 _amount, address _from) external onlyContract onlyRole(Role.OPERATOR) returns (uint256) {\n        _burn(_from, _amount);\n        return _amount;\n    }\n\n    /// @inheritdoc IKISS\n    function pause() public onlyContract onlyRole(Role.ADMIN) {\n        super._pause();\n    }\n\n    /// @inheritdoc IKISS\n    function unpause() public onlyContract onlyRole(Role.ADMIN) {\n        _unpause();\n    }\n\n    /// @inheritdoc IKISS\n    function setPendingOperatorWaitPeriod(uint256 _newPeriod) external onlyRole(Role.ADMIN) {\n        require(_newPeriod >= 15 minutes, Error.OPERATOR_WAIT_PERIOD_TOO_SHORT);\n        pendingOperatorWaitPeriod = _newPeriod;\n        emit NewPendingOperatorWaitPeriod(_newPeriod);\n    }\n\n    /// @inheritdoc IKISS\n    function setMaxOperators(uint256 _maxOperators) external onlyRole(Role.ADMIN) {\n        maxOperators = _maxOperators;\n        emit NewMaxOperators(_maxOperators);\n    }\n\n    /// @inheritdoc IKISS\n    function grantRole(\n        bytes32 _role,\n        address _to\n    ) public override(IKISS, AccessControlUpgradeable, IAccessControlUpgradeable) onlyRole(Role.ADMIN) {\n        // Default behavior\n        if (_role != Role.OPERATOR) {\n            _grantRole(_role, _to);\n            return;\n        }\n\n        // Handle the operator role\n        require(_to.code.length > 0, Error.OPERATOR_NOT_CONTRACT);\n        if (pendingOperator != address(0)) {\n            // Ensure cooldown period\n            require(pendingOperatorUnlockTime < block.timestamp, Error.OPERATOR_WAIT_PERIOD_NOT_OVER);\n            // Grant role\n            _grantRole(Role.OPERATOR, pendingOperator);\n            emit NewOperator(pendingOperator);\n            // Reset pending owner\n            // No need to touch the timestamp (next call will just trigger the cooldown period)\n            pendingOperator = address(0);\n        } else if (pendingOperatorUnlockTime != 0) {\n            // Do not allow more than `maxOperators` of operators\n            require(getRoleMemberCount(Role.OPERATOR) <= maxOperators, Error.OPERATOR_LIMIT_REACHED);\n            // Set the timestamp for the cooldown period\n            pendingOperatorUnlockTime = block.timestamp + pendingOperatorWaitPeriod;\n            // Set the pending operator, execution to upper if clause next call as this pending operator is set\n            pendingOperator = _to;\n            emit NewOperatorInitialized(_to, pendingOperatorUnlockTime);\n        } else {\n            // Initialize operator for the first time\n            _grantRole(Role.OPERATOR, _to);\n            emit NewOperator(_to);\n            // Set the timestamp, execution will not come here again\n            pendingOperatorUnlockTime = block.timestamp;\n        }\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Views                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IKreskoAssetIssuer\n    function convertToShares(uint256 assets) external pure returns (uint256) {\n        return assets;\n    }\n\n    /// @inheritdoc IKreskoAssetIssuer\n    function convertToAssets(uint256 shares) external pure returns (uint256) {\n        return shares;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  internal                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        super._beforeTokenTransfer(from, to, amount);\n        require(!paused(), \"KISS: Paused\");\n    }\n}\n"
    },
    "src/contracts/kreskoasset/ERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\n\nimport {SafeERC20} from \"../shared/SafeERC20.sol\";\nimport {IKreskoAsset, IERC20Permit} from \"./IKreskoAsset.sol\";\nimport {IERC4626Upgradeable} from \"./IERC4626Upgradeable.sol\";\nimport {ERC20Upgradeable} from \"./KreskoAsset.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\n/* solhint-disable func-name-mixedcase */\n/* solhint-disable no-empty-blocks */\n/* solhint-disable func-visibility */\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @notice Kresko:\n/// Adds issue/destroy functions that are called when KreskoAssets are minted/burned through the protocol.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @author Kresko (https://www.kresko.fi)\nabstract contract ERC4626Upgradeable is IERC4626Upgradeable, ERC20Upgradeable {\n    using SafeERC20 for IKreskoAsset;\n    using FixedPointMathLib for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Events                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event Issue(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Destroy(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Immutables                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IERC4626Upgradeable\n    IKreskoAsset public immutable asset;\n\n    constructor(IKreskoAsset _asset) payable {\n        asset = _asset;\n    }\n\n    /**\n     * @notice Initializes the ERC4626.\n     *\n     * @param _asset The underlying (Kresko) Asset\n     * @param _name Name of the anchor token\n     * @param _symbol Symbol of the anchor token\n     * @dev decimals are read from the underlying asset\n     */\n    function __ERC4626Upgradeable_init(\n        IERC20Permit _asset,\n        string memory _name,\n        string memory _symbol\n    ) internal onlyInitializing {\n        __ERC20Upgradeable_init(_name, _symbol, _asset.decimals());\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Issue & Destroy                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice When new KreskoAssets are minted:\n     * Issues the equivalent amount of anchor tokens to Kresko\n     * Issues the equivalent amount of assets to user\n     */\n    function issue(uint256 assets, address to) public virtual returns (uint256 shares) {\n        require(msg.sender == asset.kresko(), Error.ISSUER_NOT_KRESKO);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewIssue(assets)) != 0, Error.ZERO_SHARES);\n\n        // Mint shares to kresko\n        _mint(asset.kresko(), shares);\n        // Mint assets to receiver\n        asset.mint(to, assets);\n\n        emit Issue(msg.sender, to, assets, shares);\n\n        _afterDeposit(assets, shares);\n    }\n\n    /**\n     * @notice When new KreskoAssets are burned:\n     * Destroys the equivalent amount of anchor tokens from Kresko\n     * Destorys the equivalent amount of assets from user\n     */\n    function destroy(uint256 assets, address from) public virtual returns (uint256 shares) {\n        require(msg.sender == asset.kresko(), Error.REDEEMER_NOT_KRESKO);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewIssue(assets)) != 0, Error.ZERO_SHARES);\n\n        _beforeWithdraw(assets, shares);\n\n        // Burn shares from kresko\n        _burn(asset.kresko(), shares);\n        // Burn assets from user\n        asset.burn(from, assets);\n\n        emit Destroy(msg.sender, from, from, assets, shares);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              Accounting Logic                              */\n    /* -------------------------------------------------------------------------- */\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if _totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    /// @notice amount of shares for amount of @param assets\n    function previewIssue(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @notice amount of assets for amount of @param shares\n    function previewDestroy(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /// @notice amount of shares for amount of @param assets\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @notice amount of assets for amount of @param shares\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if _totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    /// @notice amount of shares for amount of @param assets\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if _totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    /// @notice amount of assets for amount of @param shares\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                       DEPOSIT/WITHDRAWAL LIMIT VIEWS                       */\n    /* -------------------------------------------------------------------------- */\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxIssue(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxDestroy(address owner) public view virtual returns (uint256) {\n        return convertToAssets(_balances[owner]);\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(_balances[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return _balances[owner];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                            INTERNAL HOOKS LOGIC                            */\n    /* -------------------------------------------------------------------------- */\n\n    function _beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function _afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n\n    /* -------------------------------------------------------------------------- */\n    /*                               EXTERNAL USE                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IERC4626Upgradeable\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, Error.ZERO_SHARES);\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        _afterDeposit(assets, shares);\n    }\n\n    /// @inheritdoc IERC4626Upgradeable\n    function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = _allowances[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) {\n                _allowances[owner][msg.sender] = allowed - shares;\n            }\n        }\n\n        _beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /// @inheritdoc IERC4626Upgradeable\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        _afterDeposit(assets, shares);\n    }\n\n    /// @inheritdoc IERC4626Upgradeable\n    function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = _allowances[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) {\n                _allowances[owner][msg.sender] = allowed - shares;\n            }\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, Error.ZERO_ASSETS);\n\n        _beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n}\n"
    },
    "src/contracts/kreskoasset/IERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {IKreskoAsset} from \"./IKreskoAsset.sol\";\n\ninterface IERC4626Upgradeable {\n    /**\n     * @notice The underlying Kresko Asset\n     */\n    function asset() external view returns (IKreskoAsset);\n\n    /**\n     * @notice Deposit KreskoAssets for equivalent amount of anchor tokens\n     * @param assets Amount of KreskoAssets to deposit\n     * @param receiver Address to send shares to\n     * @return shares Amount of shares minted\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @notice Withdraw KreskoAssets for equivalent amount of anchor tokens\n     * @param assets Amount of KreskoAssets to withdraw\n     * @param receiver Address to send KreskoAssets to\n     * @param owner Address to burn shares from\n     * @return shares Amount of shares burned\n     * @dev shares are burned from owner, not msg.sender\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    function maxDeposit(address) external view returns (uint256);\n\n    function maxMint(address) external view returns (uint256 assets);\n\n    function maxRedeem(address owner) external view returns (uint256 assets);\n\n    function maxWithdraw(address owner) external view returns (uint256 assets);\n\n    /**\n     * @notice Mint shares of anchor tokens for equivalent amount of KreskoAssets\n     * @param shares Amount of shares to mint\n     * @param receiver Address to send shares to\n     * @return assets Amount of KreskoAssets redeemed\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @notice Track the underlying amount\n     * @return Total supply for the underlying\n     */\n    function totalAssets() external view returns (uint256);\n\n    /**\n     * @notice Redeem shares of anchor for KreskoAssets\n     * @param shares Amount of shares to redeem\n     * @param receiver Address to send KreskoAssets to\n     * @param owner Address to burn shares from\n     * @return assets Amount of KreskoAssets redeemed\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "src/contracts/kreskoasset/IKreskoAsset.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IAccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\";\nimport {IERC20Permit} from \"../shared/IERC20Permit.sol\";\nimport {IERC165} from \"../shared/IERC165.sol\";\n\ninterface IKreskoAsset is IERC20Permit, IAccessControlEnumerableUpgradeable, IERC165 {\n    /**\n     * @notice Rebase information\n     * @param positive supply increasing/reducing rebase\n     * @param denominator the denominator for the operator, 1 ether = 1\n     */\n    struct Rebase {\n        bool positive;\n        uint256 denominator;\n    }\n\n    /**\n     * @notice Initializes a KreskoAsset ERC20 token.\n     * @dev Intended to be operated by the Kresko smart contract.\n     * @param _name The name of the KreskoAsset.\n     * @param _symbol The symbol of the KreskoAsset.\n     * @param _decimals Decimals for the asset.\n     * @param _admin The adminstrator of this contract.\n     * @param _kresko The protocol, can perform mint and burn.\n     */\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _admin,\n        address _kresko\n    ) external;\n\n    function kresko() external view returns (address);\n\n    function rebaseInfo() external view returns (Rebase memory);\n\n    function isRebased() external view returns (bool);\n\n    /**\n     * @notice Perform a rebase, changing the denumerator and its operator\n     * @param _denominator the denumerator for the operator, 1 ether = 1\n     * @param _positive supply increasing/reducing rebase\n     * @param _pools UniswapV2Pair address to sync so we wont get rekt by skim() calls.\n     * @dev denumerator values 0 and 1 ether will disable the rebase\n     */\n    function rebase(uint256 _denominator, bool _positive, address[] calldata _pools) external;\n\n    /**\n     * @notice Updates ERC20 metadata for the token in case eg. a ticker change\n     * @param _name new name for the asset\n     * @param _symbol new symbol for the asset\n     * @param _version number that must be greater than latest emitted `Initialized` version\n     */\n    function reinitializeERC20(string memory _name, string memory _symbol, uint8 _version) external;\n\n    /**\n     * @notice Returns the total supply of the token.\n     * @notice This amount is adjusted by rebases.\n     * @inheritdoc IERC20Permit\n     */\n    function totalSupply() external view override(IERC20Permit) returns (uint256);\n\n    /**\n     * @notice Returns the balance of @param _account\n     * @notice This amount is adjusted by rebases.\n     * @inheritdoc IERC20Permit\n     */\n    function balanceOf(address _account) external view override(IERC20Permit) returns (uint256);\n\n    /// @inheritdoc IERC20Permit\n    function allowance(address _owner, address _account) external view override(IERC20Permit) returns (uint256);\n\n    /// @inheritdoc IERC20Permit\n    function approve(address spender, uint256 amount) external override returns (bool);\n\n    /// @inheritdoc IERC20Permit\n    function transfer(address _to, uint256 _amount) external override(IERC20Permit) returns (bool);\n\n    /// @inheritdoc IERC20Permit\n    function transferFrom(address _from, address _to, uint256 _amount) external override(IERC20Permit) returns (bool);\n\n    /**\n     * @notice Mints tokens to an address.\n     * @dev Only callable by operator.\n     * @dev Internal balances are always unrebased, events emitted are not.\n     * @param _to The address to mint tokens to.\n     * @param _amount The amount of tokens to mint.\n     */\n    function mint(address _to, uint256 _amount) external;\n\n    /**\n     * @notice Burns tokens from an address.\n     * @dev Only callable by operator.\n     * @dev Internal balances are always unrebased, events emitted are not.\n     * @param _from The address to burn tokens from.\n     * @param _amount The amount of tokens to burn.\n     */\n    function burn(address _from, uint256 _amount) external;\n}\n"
    },
    "src/contracts/kreskoasset/IKreskoAssetAnchor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IAccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\";\nimport {IERC165} from \"../shared/IERC165.sol\";\nimport {IERC20Permit} from \"../shared/IERC20Permit.sol\";\nimport {IKreskoAssetIssuer} from \"./IKreskoAssetIssuer.sol\";\nimport {IKreskoAsset} from \"./IKreskoAsset.sol\";\nimport {IERC4626Upgradeable} from \"./IERC4626Upgradeable.sol\";\n\ninterface IKreskoAssetAnchor is\n    IKreskoAssetIssuer,\n    IERC4626Upgradeable,\n    IERC20Permit,\n    IAccessControlEnumerableUpgradeable,\n    IERC165\n{\n    function totalAssets() external view override(IERC4626Upgradeable) returns (uint256);\n\n    /**\n     * @notice Initializes the Kresko Asset Anchor.\n     *\n     * @param _asset The underlying (Kresko) Asset\n     * @param _name Name of the anchor token\n     * @param _symbol Symbol of the anchor token\n     * @param _admin The adminstrator of this contract.\n     * @dev Decimals are not supplied as they are read from the underlying Kresko Asset\n     */\n    function initialize(IKreskoAsset _asset, string memory _name, string memory _symbol, address _admin) external;\n\n    /**\n     * @notice Updates ERC20 metadata for the token in case eg. a ticker change\n     * @param _name new name for the asset\n     * @param _symbol new symbol for the asset\n     * @param _version number that must be greater than latest emitted `Initialized` version\n     */\n    function reinitializeERC20(string memory _name, string memory _symbol, uint8 _version) external;\n}\n"
    },
    "src/contracts/kreskoasset/IKreskoAssetIssuer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n/// @title KreskoAsset issuer interface\n/// @author Kresko\n/// @notice Contract that can issue/destroy Kresko Assets through Kresko\n/// @dev This interface is used by KISS & KreskoAssetAnchor\ninterface IKreskoAssetIssuer {\n    /**\n     * @notice Mints @param _assets of krAssets for @param _to,\n     * @notice Mints relative @return _shares of wkrAssets\n     */\n    function issue(uint256 _assets, address _to) external returns (uint256 shares);\n\n    /**\n     * @notice Burns @param _assets of krAssets from @param _from,\n     * @notice Burns relative @return _shares of wkrAssets\n     */\n    function destroy(uint256 _assets, address _from) external returns (uint256 shares);\n\n    /**\n     * @notice Returns the total amount of anchor tokens out\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @notice Returns the total amount of krAssets out\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n}\n"
    },
    "src/contracts/kreskoasset/KreskoAsset.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n// solhint-disable-next-line\nimport {AccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Role} from \"../libs/Authorization.sol\";\nimport {Error} from \"../libs/Errors.sol\";\nimport {ERC20Upgradeable} from \"../shared/ERC20Upgradeable.sol\";\nimport {IERC165} from \"../shared/IERC165.sol\";\nimport {RebaseMath} from \"./Rebase.sol\";\nimport {IKreskoAsset} from \"./IKreskoAsset.sol\";\nimport {IUniswapV2Pair} from \"../vendor/uniswap/v2-core/interfaces/IUniswapV2Pair.sol\";\n\n/**\n * @title Kresko Synthethic Asset - rebasing ERC20.\n * @author Kresko\n *\n * @notice Rebases to adjust for stock splits and reverse stock splits\n *\n * @notice Minting, burning and rebasing can only be performed by the `Role.OPERATOR`\n */\n\ncontract KreskoAsset is ERC20Upgradeable, AccessControlEnumerableUpgradeable, IKreskoAsset {\n    using RebaseMath for uint256;\n\n    bool public isRebased;\n    address public kresko;\n    Rebase private _rebaseInfo;\n\n    /// @inheritdoc IKreskoAsset\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _admin,\n        address _kresko\n    ) external initializer {\n        // ERC20\n        __ERC20Upgradeable_init(_name, _symbol, _decimals);\n\n        // This does nothing but doesn't hurt to make sure it's called\n        __AccessControlEnumerable_init();\n\n        // Setup the admin\n        _setupRole(Role.DEFAULT_ADMIN, msg.sender);\n        _setupRole(Role.ADMIN, msg.sender);\n\n        _setupRole(Role.DEFAULT_ADMIN, _admin);\n        _setupRole(Role.ADMIN, _admin);\n\n        // Setup the protocol\n        _setupRole(Role.OPERATOR, _kresko);\n        kresko = _kresko;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Read                                    */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControlEnumerableUpgradeable, IERC165) returns (bool) {\n        return (interfaceId != 0xffffffff &&\n            (interfaceId == type(IKreskoAsset).interfaceId ||\n                interfaceId == 0x01ffc9a7 ||\n                interfaceId == 0x36372b07 ||\n                super.supportsInterface(interfaceId)));\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function rebaseInfo() external view override returns (Rebase memory) {\n        return _rebaseInfo;\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function totalSupply() public view override(ERC20Upgradeable, IKreskoAsset) returns (uint256) {\n        return _totalSupply.rebase(_rebaseInfo);\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function balanceOf(address _account) public view override(ERC20Upgradeable, IKreskoAsset) returns (uint256) {\n        uint256 balance = _balances[_account];\n        return balance.rebase(_rebaseInfo);\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function allowance(\n        address _owner,\n        address _account\n    ) public view override(ERC20Upgradeable, IKreskoAsset) returns (uint256) {\n        return _allowances[_owner][_account];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Write                                   */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IKreskoAsset\n    function reinitializeERC20(\n        string memory _name,\n        string memory _symbol,\n        uint8 _version\n    ) external onlyRole(Role.ADMIN) reinitializer(_version) {\n        __ERC20Upgradeable_init(_name, _symbol, decimals);\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function approve(address spender, uint256 amount) public override(ERC20Upgradeable, IKreskoAsset) returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function transfer(address _to, uint256 _amount) public override(ERC20Upgradeable, IKreskoAsset) returns (bool) {\n        return _transfer(msg.sender, _to, _amount);\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) public override(ERC20Upgradeable, IKreskoAsset) returns (bool) {\n        uint256 allowed = allowance(_from, msg.sender); // Saves gas for unlimited approvals.\n\n        if (allowed != type(uint256).max) {\n            require(_amount <= allowed, Error.NOT_ENOUGH_ALLOWANCE);\n            _allowances[_from][msg.sender] -= _amount;\n        }\n\n        return _transfer(_from, _to, _amount);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Restricted                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IKreskoAsset\n    function rebase(uint256 _denominator, bool _positive, address[] calldata _pools) external onlyRole(Role.ADMIN) {\n        require(_denominator >= 1 ether, Error.REBASING_DENOMINATOR_LOW);\n        if (_denominator == 1 ether) {\n            isRebased = false;\n            _rebaseInfo = Rebase(false, 0);\n        } else {\n            isRebased = true;\n            _rebaseInfo = Rebase(_positive, _denominator);\n        }\n        uint256 length = _pools.length;\n        for (uint256 i; i < length; ) {\n            IUniswapV2Pair(_pools[i]).sync();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function mint(address _to, uint256 _amount) external onlyRole(Role.OPERATOR) {\n        uint256 normalizedAmount = _amount.unrebase(_rebaseInfo);\n        _totalSupply += normalizedAmount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balances[_to] += normalizedAmount;\n        }\n        // Emit user input amount, not the maybe unrebased amount.\n        emit Transfer(address(0), _to, _amount);\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function burn(address _from, uint256 _amount) external onlyRole(Role.OPERATOR) {\n        uint256 normalizedAmount = _amount.unrebase(_rebaseInfo);\n\n        _balances[_from] -= normalizedAmount;\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            _totalSupply -= normalizedAmount;\n        }\n\n        emit Transfer(_from, address(0), _amount);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Internal                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /// @dev Internal balances are always unrebased, events emitted are not.\n    function _transfer(address _from, address _to, uint256 _amount) internal returns (bool) {\n        require(_amount <= balanceOf(_from), Error.NOT_ENOUGH_BALANCE);\n        uint256 normalizedAmount = _amount.unrebase(_rebaseInfo);\n\n        _balances[_from] -= normalizedAmount;\n        unchecked {\n            _balances[_to] += normalizedAmount;\n        }\n\n        // Emit user input amount, not the maybe unrebased amount.\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n}\n"
    },
    "src/contracts/kreskoasset/KreskoAssetAnchor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {AccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\n\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\nimport {Role} from \"../libs/Authorization.sol\";\n\nimport {IKreskoAssetIssuer} from \"./IKreskoAssetIssuer.sol\";\nimport {IKreskoAssetAnchor} from \"./IKreskoAssetAnchor.sol\";\nimport {IERC4626Upgradeable} from \"./IERC4626Upgradeable.sol\";\nimport {ERC4626Upgradeable, IKreskoAsset} from \"./ERC4626Upgradeable.sol\";\nimport {IERC165} from \"../shared/IERC165.sol\";\n\n/* solhint-disable no-empty-blocks */\n\n/**\n * @title Kresko Asset Anchor\n * Pro-rata representation of the underlying kresko asset.\n * Based on ERC-4626 by Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n *\n * @notice Main purpose of this token is to represent a static amount of the possibly rebased underlying KreskoAsset.\n * Main use-cases are normalized book-keeping, bridging and integration with external contracts.\n *\n * @notice Shares means amount of this token.\n * @notice Assets mean amount of KreskoAssets.\n * @author Kresko\n */\ncontract KreskoAssetAnchor is ERC4626Upgradeable, IKreskoAssetAnchor, AccessControlEnumerableUpgradeable {\n    /* -------------------------------------------------------------------------- */\n    /*                                 Immutables                                 */\n    /* -------------------------------------------------------------------------- */\n    constructor(IKreskoAsset _asset) payable ERC4626Upgradeable(_asset) {}\n\n    /// @inheritdoc IKreskoAssetAnchor\n    function initialize(\n        IKreskoAsset _asset,\n        string memory _name,\n        string memory _symbol,\n        address _admin\n    ) external initializer {\n        // ERC4626\n        __ERC4626Upgradeable_init(_asset, _name, _symbol);\n\n        // This does nothing but doesn't hurt to make sure it's called\n        __AccessControlEnumerable_init();\n\n        // Default admin setup\n        _setupRole(Role.DEFAULT_ADMIN, _admin);\n        _setupRole(Role.ADMIN, _admin);\n\n        _setupRole(Role.DEFAULT_ADMIN, msg.sender);\n        _setupRole(Role.ADMIN, msg.sender);\n\n        // Setup the operator, which is the protocol linked to the main asset\n        _setupRole(Role.OPERATOR, asset.kresko());\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControlEnumerableUpgradeable, IERC165) returns (bool) {\n        return\n            interfaceId != 0xffffffff &&\n            (interfaceId == type(IKreskoAssetAnchor).interfaceId ||\n                interfaceId == type(IKreskoAssetIssuer).interfaceId ||\n                interfaceId == 0x01ffc9a7 ||\n                interfaceId == 0x36372b07 ||\n                super.supportsInterface(interfaceId));\n    }\n\n    /// @inheritdoc IKreskoAssetAnchor\n    function reinitializeERC20(\n        string memory _name,\n        string memory _symbol,\n        uint8 _version\n    ) external onlyRole(Role.ADMIN) reinitializer(_version) {\n        __ERC20Upgradeable_init(_name, _symbol, decimals);\n    }\n\n    /// @inheritdoc IKreskoAssetAnchor\n    function totalAssets() public view virtual override(IKreskoAssetAnchor, ERC4626Upgradeable) returns (uint256) {\n        return asset.totalSupply();\n    }\n\n    /// @inheritdoc IKreskoAssetIssuer\n    function convertToAssets(\n        uint256 shares\n    ) public view virtual override(ERC4626Upgradeable, IKreskoAssetIssuer) returns (uint256 assets) {\n        return super.convertToAssets(shares);\n    }\n\n    /// @inheritdoc IKreskoAssetIssuer\n    function convertToShares(\n        uint256 assets\n    ) public view virtual override(ERC4626Upgradeable, IKreskoAssetIssuer) returns (uint256 shares) {\n        return super.convertToShares(assets);\n    }\n\n    /// @inheritdoc IKreskoAssetIssuer\n    function issue(\n        uint256 _assets,\n        address _to\n    ) public virtual override(ERC4626Upgradeable, IKreskoAssetIssuer) onlyRole(Role.OPERATOR) returns (uint256 shares) {\n        shares = super.issue(_assets, _to);\n    }\n\n    /// @inheritdoc IKreskoAssetIssuer\n    function destroy(\n        uint256 _assets,\n        address _from\n    ) public virtual override(ERC4626Upgradeable, IKreskoAssetIssuer) onlyRole(Role.OPERATOR) returns (uint256 shares) {\n        shares = super.destroy(_assets, _from);\n    }\n\n    /// @notice reverting function, kept to maintain compatibility with ERC4626 standard\n    function deposit(uint256, address) public pure override(ERC4626Upgradeable, IERC4626Upgradeable) returns (uint256) {\n        revert(\"NOT_ALLOWED\");\n    }\n\n    /// @notice reverting function, kept to maintain compatibility with ERC4626 standard\n    function withdraw(\n        uint256,\n        address,\n        address\n    ) public pure override(ERC4626Upgradeable, IERC4626Upgradeable) returns (uint256) {\n        revert(\"NOT_ALLOWED\");\n    }\n\n    /// @notice reverting function, kept to maintain compatibility with ERC4626 standard\n    function mint(uint256, address) public pure override(ERC4626Upgradeable, IERC4626Upgradeable) returns (uint256) {\n        revert(\"NOT_ALLOWED\");\n    }\n\n    /// @notice reverting function, kept to maintain compatibility with ERC4626 standard\n    function redeem(\n        uint256,\n        address,\n        address\n    ) public pure override(ERC4626Upgradeable, IERC4626Upgradeable) returns (uint256) {\n        revert(\"NOT_ALLOWED\");\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                            INTERNAL HOOKS LOGIC                            */\n    /* -------------------------------------------------------------------------- */\n\n    function _beforeWithdraw(uint256 assets, uint256 shares) internal virtual override {\n        super._beforeWithdraw(assets, shares);\n    }\n\n    function _afterDeposit(uint256 assets, uint256 shares) internal virtual override {\n        super._afterDeposit(assets, shares);\n    }\n}\n"
    },
    "src/contracts/kreskoasset/Rebase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport {IKreskoAsset} from \"../kreskoasset/IKreskoAsset.sol\";\n\nlibrary RebaseMath {\n    using FixedPointMathLib for uint256;\n\n    /**\n     * @notice Unrebase a value by a given rebase struct.\n     * @param self The value to unrebase.\n     * @param _rebase The rebase struct.\n     * @return The unrebased value.\n     */\n    function unrebase(uint256 self, IKreskoAsset.Rebase memory _rebase) internal pure returns (uint256) {\n        if (_rebase.denominator == 0) return self;\n        return _rebase.positive ? self.divWadDown(_rebase.denominator) : self.mulWadDown(_rebase.denominator);\n    }\n\n    /**\n     * @notice Rebase a value by a given rebase struct.\n     * @param self The value to rebase.\n     * @param _rebase The rebase struct.\n     * @return The rebased value.\n     */\n    function rebase(uint256 self, IKreskoAsset.Rebase memory _rebase) internal pure returns (uint256) {\n        if (_rebase.denominator == 0) return self;\n        return _rebase.positive ? self.mulWadDown(_rebase.denominator) : self.divWadDown(_rebase.denominator);\n    }\n}\n"
    },
    "src/contracts/libs/Arrays.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.19;\n\nimport {Error} from \"./Errors.sol\";\n\n/**\n * @title Library for operations on arrays\n */\nlibrary Arrays {\n    /**\n     * @dev Removes an element by copying the last element to the element to remove's place and removing\n     * the last element.\n     * @param _addresses The address array containing the item to be removed.\n     * @param _elementToRemove The element to be removed.\n     * @param _elementIndex The index of the element to be removed.\n     */\n    function removeAddress(address[] storage _addresses, address _elementToRemove, uint256 _elementIndex) internal {\n        require(_addresses[_elementIndex] == _elementToRemove, Error.INCORRECT_INDEX);\n\n        uint256 lastIndex = _addresses.length - 1;\n        // If the index to remove is not the last one, overwrite the element at the index\n        // with the last element.\n        if (_elementIndex != lastIndex) {\n            _addresses[_elementIndex] = _addresses[lastIndex];\n        }\n        // Remove the last element.\n        _addresses.pop();\n    }\n}\n"
    },
    "src/contracts/libs/Authorization.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {IGnosisSafeL2} from \"../vendor/gnosis/IGnosisSafeL2.sol\";\nimport {Strings} from \"./Strings.sol\";\nimport {AuthEvent} from \"./Events.sol\";\nimport {EnumerableSet} from \"./EnumerableSet.sol\";\nimport {Error} from \"./Errors.sol\";\nimport {Meta} from \"./Meta.sol\";\nimport {ds} from \"../diamond/DiamondStorage.sol\";\n\n/* solhint-disable state-visibility */\n\n/**\n * @title Shared library for access control\n * @author Kresko\n */\n\n/* -------------------------------------------------------------------------- */\n/*                                    Roles                                   */\n/* -------------------------------------------------------------------------- */\n\nlibrary Role {\n    /// @dev role that grants other roles\n    bytes32 constant DEFAULT_ADMIN = 0x00;\n    /// @dev  keccak256(\"kresko.roles.minter.admin\")\n    bytes32 constant ADMIN = 0xb9dacdf02281f2e98ddbadaaf44db270b3d5a916342df47c59f77937a6bcd5d8;\n    /// @dev keccak256(\"kresko.roles.minter.operator\")\n    bytes32 constant OPERATOR = 0x112e48a576fb3a75acc75d9fcf6e0bc670b27b1dbcd2463502e10e68cf57d6fd;\n    /// @dev keccak256(\"kresko.roles.minter.manager\")\n    bytes32 constant MANAGER = 0x46925e0f0cc76e485772167edccb8dc449d43b23b55fc4e756b063f49099e6a0;\n    /// @dev keccak256(\"kresko.roles.minter.safety.council\")\n    bytes32 constant SAFETY_COUNCIL = 0x9c387ecf1663f9144595993e2c602b45de94bf8ba3a110cb30e3652d79b581c0;\n}\n\nlibrary Authorization {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    function hasRole(bytes32 role, address account) internal view returns (bool) {\n        return ds()._roles[role].members[account];\n    }\n\n    function getRoleMemberCount(bytes32 role) internal view returns (uint256) {\n        return ds()._roleMembers[role].length();\n    }\n\n    /**\n     * @dev Revert with a standard message if `Meta.msgSender` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function checkRole(bytes32 role) internal view {\n        _checkRole(role, Meta.msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) internal view returns (bytes32) {\n        return ds()._roles[role].adminRole;\n    }\n\n    function getRoleMember(bytes32 role, uint256 index) internal view returns (address) {\n        return ds()._roleMembers[role].at(index);\n    }\n\n    /**\n     * @notice setups the security council\n     *\n     */\n    function setupSecurityCouncil(address _councilAddress) internal {\n        require(getRoleMemberCount(Role.SAFETY_COUNCIL) == 0, Error.SAFETY_COUNCIL_EXISTS);\n        require(IGnosisSafeL2(_councilAddress).isOwner(msg.sender), Error.ADDRESS_INVALID_SAFETY_COUNCIL);\n\n        ds()._roles[Role.SAFETY_COUNCIL].members[_councilAddress] = true;\n        ds()._roleMembers[Role.SAFETY_COUNCIL].add(_councilAddress);\n\n        emit AuthEvent.RoleGranted(Role.SAFETY_COUNCIL, _councilAddress, Meta.msgSender());\n    }\n\n    function transferSecurityCouncil(address _newCouncil) internal {\n        checkRole(Role.SAFETY_COUNCIL);\n        require(IGnosisSafeL2(_newCouncil).getOwners().length >= 5, Error.MULTISIG_NOT_ENOUGH_OWNERS);\n\n        // As this is called by the multisig - just check that it's not an EOA\n        ds()._roles[Role.SAFETY_COUNCIL].members[msg.sender] = false;\n        ds()._roleMembers[Role.SAFETY_COUNCIL].remove(msg.sender);\n\n        ds()._roles[Role.SAFETY_COUNCIL].members[_newCouncil] = true;\n        ds()._roleMembers[Role.SAFETY_COUNCIL].add(_newCouncil);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) internal {\n        checkRole(getRoleAdmin(role));\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) internal {\n        checkRole(getRoleAdmin(role));\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function _renounceRole(bytes32 role, address account) internal {\n        require(account == Meta.msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        ds()._roles[role].adminRole = adminRole;\n        emit AuthEvent.RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * @notice Cannot grant the role `SAFETY_COUNCIL` - must be done via explicit function.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal ensureNotSafetyCouncil(role) {\n        if (!hasRole(role, account)) {\n            ds()._roles[role].members[account] = true;\n            ds()._roleMembers[role].add(account);\n            emit AuthEvent.RoleGranted(role, account, Meta.msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal {\n        if (hasRole(role, account)) {\n            ds()._roles[role].members[account] = false;\n            ds()._roleMembers[role].remove(account);\n            emit AuthEvent.RoleRevoked(role, account, Meta.msgSender());\n        }\n    }\n\n    /**\n     * @dev Ensure we use the explicit `grantSafetyCouncilRole` function.\n     */\n    modifier ensureNotSafetyCouncil(bytes32 role) {\n        require(role != Role.SAFETY_COUNCIL, Error.ADDRESS_INVALID_SAFETY_COUNCIL);\n        _;\n    }\n}\n"
    },
    "src/contracts/libs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity >=0.8.19;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "src/contracts/libs/Errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity <0.9.0;\n\n/* solhint-disable max-line-length */\n\n/**\n * @author Kresko\n * @title Error codes\n * @notice Kresko-specific revert return values and their explanation\n * @dev First number indicates the domain for the error\n */\nlibrary Error {\n    /* -------------------------------------------------------------------------- */\n    /*                                    Diamond                                 */\n    /* -------------------------------------------------------------------------- */\n\n    // Preserve readability for the diamond proxy\n    string public constant DIAMOND_INVALID_FUNCTION_SIGNATURE = \"krDiamond: function does not exist\";\n    string public constant DIAMOND_INVALID_PENDING_OWNER = \"krDiamond: Must be pending contract owner\";\n    string public constant DIAMOND_INVALID_OWNER = \"krDiamond: Must be diamond owner\";\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   1. General                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant NOT_OWNER = \"100\"; // The sender must be owner\n    string public constant NOT_OPERATOR = \"101\"; // The sender must be operator\n    string public constant ZERO_WITHDRAW = \"102\"; // Withdraw must be greater than 0\n    string public constant ZERO_DEPOSIT = \"103\"; // Deposit must be greater than 0\n    string public constant ZERO_ADDRESS = \"104\"; // Address provided cannot be address(0)\n    string public constant ALREADY_INITIALIZED = \"105\"; // Contract has already been initialized\n    string public constant RE_ENTRANCY = \"106\"; // Function does not allow re-entrant calls\n    string public constant NOT_ENOUGH_BALANCE = \"107\"; // Transfer of rebasing token exceeds value\n    string public constant NOT_ENOUGH_ALLOWANCE = \"108\"; // TransferFrom of rebasing token exceeds allowance\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   2. Minter                                 */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant NOT_LIQUIDATABLE = \"200\"; // Account has collateral deposits exceeding minCollateralValue\n    string public constant ZERO_MINT = \"201\"; // Mint amount must be greater than 0\n    string public constant ZERO_BURN = \"202\"; // Burn amount must be greater than 0\n    string public constant ADDRESS_INVALID_ORACLE = \"203\"; // Oracle address cant be set to address(0)\n    string public constant ADDRESS_INVALID_NRWT = \"204\"; // Underlying rebasing token address cant be set to address(0)\n    string public constant ADDRESS_INVALID_FEERECIPIENT = \"205\"; // Fee recipient address cant be set to address(0)\n    string public constant ADDRESS_INVALID_COLLATERAL = \"206\"; // Collateral address cant be set to address(0)\n    string public constant COLLATERAL_EXISTS = \"207\"; // Collateral has already been added into the protocol\n    string public constant COLLATERAL_INVALID_FACTOR = \"208\"; // cFactor must be greater than 1FP\n    string public constant COLLATERAL_WITHDRAW_OVERFLOW = \"209\"; // Withdraw amount cannot reduce accounts collateral value under minCollateralValue\n    string public constant KRASSET_INVALID_FACTOR = \"210\"; // kFactor must be greater than 1FP\n    string public constant KRASSET_BURN_AMOUNT_OVERFLOW = \"211\"; // Repaying more than account has debt\n    string public constant KRASSET_EXISTS = \"212\"; // KrAsset is already added\n    string public constant PARAM_CLOSE_FEE_TOO_HIGH = \"213\"; // \"Close fee exceeds MAX_CLOSE_FEE\"\n    string public constant PARAM_LIQUIDATION_INCENTIVE_LOW = \"214\"; // \"Liquidation incentive less than MIN_LIQUIDATION_INCENTIVE_MULTIPLIER\"\n    string public constant PARAM_LIQUIDATION_INCENTIVE_HIGH = \"215\"; // \"Liquidation incentive greater than MAX_LIQUIDATION_INCENTIVE_MULTIPLIER\"\n    string public constant PARAM_MIN_COLLATERAL_RATIO_LOW = \"216\"; // Minimum collateral ratio less than MIN_COLLATERALIZATION_RATIO\n    string public constant PARAM_MIN_DEBT_AMOUNT_HIGH = \"217\"; // Minimum debt param argument exceeds MAX_MIN_DEBT_VALUE\n    string public constant COLLATERAL_DOESNT_EXIST = \"218\"; // Collateral does not exist within the protocol\n    string public constant KRASSET_DOESNT_EXIST = \"219\"; // KrAsset does not exist within the protocol\n    string public constant KRASSET_NOT_MINTABLE = \"220\"; // KrAsset is not mintable\n    string public constant KRASSET_SYMBOL_EXISTS = \"221\"; // KrAsset with this symbol is already within the protocl\n    string public constant KRASSET_COLLATERAL_LOW = \"222\"; // Collateral deposits do not cover the amount being minted\n    string public constant KRASSET_MINT_AMOUNT_LOW = \"223\"; // Debt position must be greater than the minimum debt position value\n    string public constant KRASSET_MAX_SUPPLY_REACHED = \"224\"; // KrAsset being minted has reached its current supply limit\n    string public constant SELF_LIQUIDATION = \"225\"; // Account cannot liquidate itself\n    string public constant ZERO_REPAY = \"226\"; // Cannot liquidate zero value\n    string public constant STALE_PRICE = \"227\"; // Price for the asset is stale\n    string public constant LIQUIDATION_OVERFLOW = \"228\"; // Repaying more USD value than allowed\n    string public constant ADDRESS_INVALID_SAFETY_COUNCIL = \"229\"; // Account responsible for the safety council role must be a multisig\n    string public constant SAFETY_COUNCIL_EXISTS = \"230\"; // Only one council role can exist\n    string public constant NOT_SAFETY_COUNCIL = \"231\"; // Sender must have the role `Role.SAFETY_COUNCIL`\n    string public constant ACTION_PAUSED_FOR_ASSET = \"232\"; // This action is currently paused for this asset\n    string public constant INVALID_ASSET_SUPPLIED = \"233\"; // Asset supplied is not a collateral nor a krAsset\n    string public constant KRASSET_NOT_ANCHOR = \"234\"; // Address is not the anchor for the krAsset\n    string public constant INVALID_LT = \"235\"; // Liquidation threshold is greater than minimum collateralization ratio\n    string public constant COLLATERAL_INSUFFICIENT_AMOUNT = \"236\"; // Insufficient amount of collateral to complete the operation\n    string public constant MULTISIG_NOT_ENOUGH_OWNERS = \"237\"; // Multisig has invalid amount of owners\n    string public constant PARAM_OPEN_FEE_TOO_HIGH = \"238\"; // \"Close fee exceeds MAX_OPEN_FEE\"\n    string public constant INVALID_FEE_TYPE = \"239\"; // \"Invalid fee type\n    string public constant KRASSET_INVALID_ANCHOR = \"240\"; // krAsset anchor does not support the correct interfaceId\n    string public constant KRASSET_INVALID_CONTRACT = \"241\"; // krAsset does not support the correct interfaceId\n    string public constant KRASSET_MARKET_CLOSED = \"242\"; // KrAsset's market is currently closed\n    string public constant NO_KRASSETS_MINTED = \"243\"; // Account has no active KreskoAsset positions\n    string public constant NO_COLLATERAL_DEPOSITS = \"244\"; // Account has no active Collateral deposits\n    string public constant INVALID_ORACLE_DECIMALS = \"245\"; // Oracle decimals do not match extOracleDecimals\n    string public constant PARAM_LIQUIDATION_OVERFLOW_LOW = \"246\"; // Liquidation overflow is less than MIN_LIQUIDATION_OVERFLOW\n    string public constant INVALID_ORACLE_DEVIATION_PCT = \"247\"; // Oracle deviation percentage is greater than 100%\n    string public constant SEIZED_COLLATERAL_UNDERFLOW = \"248\"; // Amount of collateral seized is less than the amount calculated.\n    string public constant COLLATERAL_AMOUNT_TOO_LOW = \"249\"; // Amount of krAsset collateral being deposited is less than the minimum amount\n    string public constant PARAM_COLLATERAL_RATIO_LOW_THAN_LT = \"250\"; // Minimum collateral ratio less than LT\n    string public constant ZERO_DEBT = \"251\"; // debt must be greater than 0\n    string public constant ORACLE_PRICE_UNSTABLE = \"252\"; // oracle price deviates too much between oracles\n    string public constant NEGATIVE_ORACLE_PRICE = \"253\"; // Oracle price received is negative\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   3. Staking                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant REWARD_PER_BLOCK_MISSING = \"300\"; // Each reward token must have a reward per block value\n    string public constant REWARD_TOKENS_MISSING = \"301\"; // Pool must include an array of reward token addresses\n    string public constant POOL_EXISTS = \"302\"; // Pool with this deposit token already exists\n    string public constant POOL_DOESNT_EXIST = \"303\"; // Pool with this deposit token does not exist\n    string public constant ADDRESS_INVALID_REWARD_RECIPIENT = \"304\"; // Reward recipient cant be address(0)\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   4. Libraries                             */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant ARRAY_OUT_OF_BOUNDS = \"400\"; // Array out of bounds error\n    string public constant PRICEFEEDS_MUST_MATCH_STATUS_FEEDS = \"401\"; // Supplied price feeds must match status feeds in length\n    string public constant INCORRECT_INDEX = \"402\"; // Array index mismatch\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   5. KrAsset                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant REBASING_DENOMINATOR_LOW = \"500\"; // denominator of rebases must be >= 1\n    string public constant ISSUER_NOT_KRESKO = \"501\"; // issue must be done by kresko\n    string public constant REDEEMER_NOT_KRESKO = \"502\"; // redeem must be done by kresko\n    string public constant DESTROY_OVERFLOW = \"503\"; // trying to destroy more than allowed\n    string public constant ISSUE_OVERFLOW = \"504\"; // trying to destroy more than allowed\n    string public constant MINT_OVERFLOW = \"505\"; // trying to destroy more than allowed\n    string public constant DEPOSIT_OVERFLOW = \"506\"; // trying to destroy more than allowed\n    string public constant REDEEM_OVERFLOW = \"507\"; // trying to destroy more than allowed\n    string public constant WITHDRAW_OVERFLOW = \"508\"; // trying to destroy more than allowed\n    string public constant ZERO_SHARES = \"509\"; // amount of shares must be greater than 0\n    string public constant ZERO_ASSETS = \"510\"; // amount of assets must be greater than 0\n    string public constant INVALID_SCALED_AMOUNT = \"511\"; // amount of debt scaled must be greater than 0\n\n    /* -------------------------------------------------------------------------- */\n    /*                              6. STABILITY RATES                            */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant STABILITY_RATES_ALREADY_INITIALIZED = \"601\"; // stability rates for the asset are already initialized\n    string public constant INVALID_OPTIMAL_RATE = \"602\"; // the optimal price rate configured is less than 1e27 for the asset\n    string public constant INVALID_PRICE_RATE_DELTA = \"603\"; // the price rate delta configured is less than 1e27 for the asset\n    string public constant STABILITY_RATES_NOT_INITIALIZED = \"604\"; // the stability rates for the asset are not initialized\n    string public constant STABILITY_RATE_OVERFLOW = \"605\"; // the stability rates is > max uint128\n    string public constant DEBT_INDEX_OVERFLOW = \"606\"; // the debt index is > max uint128\n    string public constant KISS_NOT_SET = \"607\"; // the debt index is > max uint128\n    string public constant STABILITY_RATE_REPAYMENT_AMOUNT_ZERO = \"608\"; // interest being repaid cannot be 0\n    string public constant STABILITY_RATE_INTEREST_IS_ZERO = \"609\"; // account must have accrued interest to repay it\n    string public constant INTEREST_REPAY_NOT_PARTIAL = \"610\"; // account must have accrued interest to repay it\n    string public constant INVALID_STABILITY_RATE_BASE = \"610\"; // the stability base rate is less than 1e27 for the asset\n\n    /* -------------------------------------------------------------------------- */\n    /*                              7. AMM ORACLE                                 */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant PAIR_ADDRESS_IS_ZERO = \"701\"; // Pair address to configure cannot be zero\n    string public constant INVALID_UPDATE_PERIOD = \"702\"; // Update period must be greater than the minimum\n    string public constant PAIR_ALREADY_EXISTS = \"703\"; // Pair with the address is already initialized\n    string public constant PAIR_DOES_NOT_EXIST = \"704\"; // Pair supplied does not exist\n    string public constant INVALID_LIQUIDITY = \"706\"; // Pair initializaition requires that the pair has liquidity\n    string public constant UPDATE_PERIOD_NOT_FINISHED = \"707\"; // Update can only be called once per update period\n    string public constant INVALID_PAIR = \"708\"; // Pair being consulted does not have the token that the price was requested for\n    string public constant CALLER_NOT_ADMIN = \"709\"; // Caller must be the admin\n    string public constant CONSTRUCTOR_INVALID_ADMIN = \"710\"; // Admin cannot be zero address in the constructor\n    string public constant CONSTRUCTOR_INVALID_FACTORY = \"711\"; // Factory cannot be the zero address\n    string public constant NO_INCENTIVES_LEFT = \"712\"; // No incentives left for updating the price\n    string public constant ADMIN_ADDRESS_IS_ZERO = \"713\"; // admin address to configure cannot be zero\n\n    /* -------------------------------------------------------------------------- */\n    /*                              8. KISS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant OPERATOR_WAIT_PERIOD_NOT_OVER = \"800\"; // Operator role has a cooldown period which has not passed\n    string public constant OPERATOR_LIMIT_REACHED = \"801\"; // More minters cannot be assigned before existing one is removed\n    string public constant CALLER_NOT_CONTRACT = \"802\"; // Caller of the function must be a contract\n    string public constant OPERATOR_NOT_CONTRACT = \"803\"; // Operator role can only be granted to a contract\n    string public constant KRESKO_NOT_CONTRACT = \"804\"; // Operator role can only be granted to a contract\n    string public constant ADMIN_NOT_A_CONTRACT = \"805\"; // Operator role can only be granted to a contract\n    string public constant OPERATOR_WAIT_PERIOD_TOO_SHORT = \"806\"; // Operator assignment cooldown period must be greater than 15 minutes\n}\n"
    },
    "src/contracts/libs/Events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IDiamondCutFacet} from \"../diamond/interfaces/IDiamondCutFacet.sol\";\nimport {Action} from \"../minter/MinterTypes.sol\";\n\n/* solhint-disable var-name-mixedcase */\n\n/**\n * @author Kresko\n * @title Events\n * @notice Event definitions\n */\n\nlibrary GeneralEvent {\n    /**\n     * @dev Triggered when the contract has been deployed\n     */\n    event Deployed(address indexed owner, uint8 version);\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(address indexed operator, uint8 version);\n}\n\nlibrary DiamondEvent {\n    event DiamondCut(IDiamondCutFacet.FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n\nlibrary MinterEvent {\n    /* -------------------------------------------------------------------------- */\n    /*                                 Collateral                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Emitted when a collateral asset is added to the protocol.\n     * @dev Can only be emitted once for a given collateral asset.\n     * @param collateralAsset The address of the collateral asset.\n     * @param factor The collateral factor.\n     * @param oracle The address of the oracle.\n     * @param liquidationIncentive The liquidation incentive\n     */\n    event CollateralAssetAdded(\n        address indexed collateralAsset,\n        uint256 factor,\n        address indexed oracle,\n        address anchor,\n        uint256 liquidationIncentive\n    );\n\n    /**\n     * @notice Emitted when a collateral asset is updated.\n     * @param collateralAsset The address of the collateral asset.\n     * @param factor The collateral factor.\n     * @param oracle The oracle address.\n     * @param liquidationIncentive The liquidation incentive\n     */\n    event CollateralAssetUpdated(\n        address indexed collateralAsset,\n        uint256 factor,\n        address indexed oracle,\n        address anchor,\n        uint256 liquidationIncentive\n    );\n\n    /**\n     * @notice Emitted when an account deposits collateral.\n     * @param account The address of the account depositing collateral.\n     * @param collateralAsset The address of the collateral asset.\n     * @param amount The amount of the collateral asset that was deposited.\n     */\n    event CollateralDeposited(address indexed account, address indexed collateralAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when an account withdraws collateral.\n     * @param account The address of the account withdrawing collateral.\n     * @param collateralAsset The address of the collateral asset.\n     * @param amount The amount of the collateral asset that was withdrawn.\n     */\n    event CollateralWithdrawn(address indexed account, address indexed collateralAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when AMM helper withdraws account collateral without MCR checks.\n     * @param account The address of the account withdrawing collateral.\n     * @param collateralAsset The address of the collateral asset.\n     * @param amount The amount of the collateral asset that was withdrawn.\n     */\n    event UncheckedCollateralWithdrawn(address indexed account, address indexed collateralAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when AMM oracle is set.\n     * @param ammOracle The address of the AMM oracle.\n     */\n    event AMMOracleUpdated(address indexed ammOracle);\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Kresko Assets                               */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Emitted when a KreskoAsset is added to the protocol.\n     * @dev Can only be emitted once for a given Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param anchor anchor token\n     * @param kFactor The k-factor.\n     * @param oracle The address of the oracle.\n     * @param supplyLimit The total supply limit.\n     * @param closeFee The close fee percentage.\n     * @param openFee The open fee percentage.\n     */\n    event KreskoAssetAdded(\n        address indexed kreskoAsset,\n        address anchor,\n        address indexed oracle,\n        uint256 kFactor,\n        uint256 supplyLimit,\n        uint256 closeFee,\n        uint256 openFee\n    );\n\n    /**\n     * @notice Emitted when a Kresko asset's oracle is updated.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param kFactor The k-factor.\n     * @param oracle The address of the oracle.\n     * @param supplyLimit The total supply limit.\n     * @param closeFee The close fee percentage.\n     * @param openFee The open fee percentage.\n     */\n    event KreskoAssetUpdated(\n        address indexed kreskoAsset,\n        address anchor,\n        address indexed oracle,\n        uint256 kFactor,\n        uint256 supplyLimit,\n        uint256 closeFee,\n        uint256 openFee\n    );\n\n    /**\n     * @notice Emitted when an account mints a Kresko asset.\n     * @param account The address of the account minting the Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param amount The amount of the KreskoAsset that was minted.\n     */\n    event KreskoAssetMinted(address indexed account, address indexed kreskoAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when an account burns a Kresko asset.\n     * @param account The address of the account burning the Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param amount The amount of the KreskoAsset that was burned.\n     */\n    event KreskoAssetBurned(address indexed account, address indexed kreskoAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when an account burns a Kresko asset.\n     * @param account The address of the account burning the Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param amount The amount of the KreskoAsset that was burned.\n     * @param interestRepaid The amount of the KISS repaid due to interest accrual\n     */\n    event DebtPositionClosed(\n        address indexed account,\n        address indexed kreskoAsset,\n        uint256 amount,\n        uint256 interestRepaid\n    );\n\n    /**\n     * @notice Emitted when cFactor is updated for a collateral asset.\n     * @param collateralAsset The address of the collateral asset.\n     * @param cFactor The new cFactor\n     */\n    event CFactorUpdated(address indexed collateralAsset, uint256 cFactor);\n    /**\n     * @notice Emitted when kFactor is updated for a KreskoAsset.\n     * @param kreskoAsset The address of the KreskoAsset.\n     * @param kFactor The new kFactor\n     */\n    event KFactorUpdated(address indexed kreskoAsset, uint256 kFactor);\n\n    /**\n     * @notice Emitted when an account pays a close fee with a collateral asset upon burning a KreskoAsset.\n     * @dev This can be emitted multiple times for a single KreskoAsset burn.\n     * @param account The address of the account burning the KreskoAsset.\n     * @param paymentCollateralAsset The address of the collateral asset used to pay the close fee.\n     * @param paymentAmount The amount of the payment collateral asset that was paid.\n     * @param paymentValue The USD value of the payment.\n     */\n    event CloseFeePaid(\n        address indexed account,\n        address indexed paymentCollateralAsset,\n        uint256 paymentAmount,\n        uint256 paymentValue\n    );\n\n    /**\n     * @notice Emitted when an account pays an open fee with a collateral asset upon minting a KreskoAsset.\n     * @dev This can be emitted multiple times for a single KreskoAsset mint.\n     * @param account The address of the account minting the KreskoAsset.\n     * @param paymentCollateralAsset The address of the collateral asset used to pay the open fee.\n     * @param paymentAmount The amount of the payment collateral asset that was paid.\n     * @param paymentValue The USD value of the payment.\n     */\n    event OpenFeePaid(\n        address indexed account,\n        address indexed paymentCollateralAsset,\n        uint256 paymentAmount,\n        uint256 paymentValue\n    );\n\n    /**\n     * @notice Emitted when a liquidation occurs.\n     * @param account The address of the account being liquidated.\n     * @param liquidator The account performing the liquidation.\n     * @param repayKreskoAsset The address of the KreskoAsset being paid back to the protocol by the liquidator.\n     * @param repayAmount The amount of the repay KreskoAsset being paid back to the protocol by the liquidator.\n     * @param seizedCollateralAsset The address of the collateral asset being seized from the account by the liquidator.\n     * @param collateralSent The amount of the seized collateral asset being seized from the account by the liquidator.\n     */\n    event LiquidationOccurred(\n        address indexed account,\n        address indexed liquidator,\n        address indexed repayKreskoAsset,\n        uint256 repayAmount,\n        address seizedCollateralAsset,\n        uint256 collateralSent\n    );\n\n    /**\n     * @notice Emitted when a liquidation of interest occurs.\n     * @param account The address of the account being liquidated.\n     * @param liquidator The account performing the liquidation.\n     * @param repayKreskoAsset The address of the KreskoAsset being paid back to the protocol by the liquidator.\n     * @param repayUSD The value of the repay KreskoAsset being paid back to the protocol by the liquidator.\n     * @param seizedCollateralAsset The address of the collateral asset being seized from the account by the liquidator.\n     * @param collateralSent The amount of the seized collateral asset being seized from the account by the liquidator.\n     */\n    event InterestLiquidationOccurred(\n        address indexed account,\n        address indexed liquidator,\n        address indexed repayKreskoAsset,\n        uint256 repayUSD,\n        address seizedCollateralAsset,\n        uint256 collateralSent\n    );\n    /**\n     * @notice Emitted when a batch liquidation of interest occurs.\n     * @param account The address of the account being liquidated.\n     * @param liquidator The account performing the liquidation.\n     * @param seizedCollateralAsset The address of the collateral asset being seized from the account by the liquidator.\n     * @param repayUSD The value of the repay KreskoAsset being paid back to the protocol by the liquidator.\n     * @param collateralSent The amount of the seized collateral asset being seized from the account by the liquidator.\n     */\n    event BatchInterestLiquidationOccurred(\n        address indexed account,\n        address indexed liquidator,\n        address indexed seizedCollateralAsset,\n        uint256 repayUSD,\n        uint256 collateralSent\n    );\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Parameters                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Emitted when a safety state is triggered for an asset\n     * @param action Target action\n     * @param asset Asset affected\n     * @param description change description\n     */\n    event SafetyStateChange(Action indexed action, address indexed asset, string indexed description);\n\n    /**\n     * @notice Emitted when the fee recipient is updated.\n     * @param feeRecipient The new fee recipient.\n     */\n    event FeeRecipientUpdated(address indexed feeRecipient);\n\n    /**\n     * @notice Emitted when the liquidation incentive multiplier is updated.\n     * @param asset The collateral asset being updated.\n     * @param liquidationIncentiveMultiplier The new liquidation incentive multiplier raw value.\n     */\n    event LiquidationIncentiveMultiplierUpdated(address indexed asset, uint256 liquidationIncentiveMultiplier);\n\n    /**\n     * @notice Emitted when the liquidation overflow multiplier is updated.\n     * @param maxLiquidationMultiplier The new liquidation overflow multiplier value.\n     */\n    event maxLiquidationMultiplierUpdated(uint256 maxLiquidationMultiplier);\n\n    /**\n     * @notice Emitted when the minimum collateralization ratio is updated.\n     * @param minimumCollateralizationRatio The new minimum collateralization ratio raw value.\n     */\n    event MinimumCollateralizationRatioUpdated(uint256 minimumCollateralizationRatio);\n\n    /**\n     * @notice Emitted when the minimum debt value updated.\n     * @param minimumDebtValue The new minimum debt value.\n     */\n    event MinimumDebtValueUpdated(uint256 minimumDebtValue);\n\n    /**\n     * @notice Emitted when the liquidation threshold value is updated\n     * @param liquidationThreshold The new liquidation threshold value.\n     */\n    event LiquidationThresholdUpdated(uint256 liquidationThreshold);\n}\n\nlibrary StakingEvent {\n    event LiquidityAndStakeAdded(address indexed to, uint256 indexed amount, uint256 indexed pid);\n    event LiquidityAndStakeRemoved(address indexed to, uint256 indexed amount, uint256 indexed pid);\n    event Deposit(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event ClaimRewards(address indexed user, address indexed rewardToken, uint256 indexed amount);\n    event ClaimRewardsMulti(address indexed to);\n}\n\nlibrary AuthEvent {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event PendingOwnershipTransfer(address indexed previousOwner, address indexed newOwner);\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n}\n\nlibrary InterestRateEvent {\n    /**\n     * @dev Emitted when @param account repaid their @param asset interest @param value\n     */\n    event StabilityRateConfigured(\n        address indexed asset,\n        uint256 stabilityRateBase,\n        uint256 priceRateDelta,\n        uint256 rateSlope1,\n        uint256 rateSlope2\n    );\n    /**\n     * @dev Emitted when @param account repaid their @param asset interest @param value\n     */\n    event StabilityRateInterestRepaid(address indexed account, address indexed asset, uint256 value);\n    /**\n     * @dev Emitted when @param account repaid all interest @param value\n     */\n    event StabilityRateInterestBatchRepaid(address indexed account, uint256 value);\n\n    /**\n     * @notice Emitted when KISS address is set.\n     * @param KISS The address of KISS.\n     */\n    event KISSUpdated(address indexed KISS);\n}\n"
    },
    "src/contracts/libs/Meta.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable no-inline-assembly */\n\npragma solidity >=0.8.19;\n\nlibrary Meta {\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(bytes(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"));\n\n    function domainSeparator(\n        string memory name,\n        string memory version\n    ) internal view returns (bytes32 domainSeparator_) {\n        domainSeparator_ = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                getChainID(),\n                address(this)\n            )\n        );\n    }\n\n    function getChainID() internal view returns (uint256 id) {\n        assembly {\n            id := chainid()\n        }\n    }\n\n    function msgSender() internal view returns (address sender_) {\n        if (msg.sender == address(this)) {\n            bytes memory array = msg.data;\n            uint256 index = msg.data.length;\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n                sender_ := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n            }\n        } else {\n            sender_ = msg.sender;\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        /// @solidity memory-safe-assembly\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "src/contracts/libs/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity >=0.8.19;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "src/contracts/libs/WadRay.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.10;\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @notice Provides functions to perform calculations with Wad and Ray units\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\n * with 27 digits of precision)\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n **/\nlibrary WadRay {\n    // HALF_WAD and HALF_RAY expressed with extended notation\n    // as constant with operations are not supported in Yul assembly\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant HALF_WAD = 0.5e18;\n\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant HALF_RAY = 0.5e27;\n\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n    /**\n     * @dev Multiplies two wad, rounding half up to the nearest wad\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @param b Wad\n     * @return c = a*b, in wad\n     **/\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\n        assembly {\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, b), HALF_WAD), WAD)\n        }\n    }\n\n    /**\n     * @dev Divides two wad, rounding half up to the nearest wad\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @param b Wad\n     * @return c = a/b, in wad\n     **/\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\n        assembly {\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, WAD), div(b, 2)), b)\n        }\n    }\n\n    /**\n     * @notice Multiplies two ray, rounding half up to the nearest ray\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @param b Ray\n     * @return c = a raymul b\n     **/\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\n        assembly {\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, b), HALF_RAY), RAY)\n        }\n    }\n\n    /**\n     * @notice Divides two ray, rounding half up to the nearest ray\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @param b Ray\n     * @return c = a raydiv b\n     **/\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\n        assembly {\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, RAY), div(b, 2)), b)\n        }\n    }\n\n    /**\n     * @dev Casts ray down to wad\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @return b = a converted to wad, rounded half up to the nearest wad\n     **/\n    function rayToWad(uint256 a) internal pure returns (uint256 b) {\n        assembly {\n            b := div(a, WAD_RAY_RATIO)\n            let remainder := mod(a, WAD_RAY_RATIO)\n            if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\n                b := add(b, 1)\n            }\n        }\n    }\n\n    /**\n     * @dev Converts wad up to ray\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @return b = a converted in ray\n     **/\n    function wadToRay(uint256 a) internal pure returns (uint256 b) {\n        // to avoid overflow, b/WAD_RAY_RATIO == a\n        assembly {\n            b := mul(a, WAD_RAY_RATIO)\n\n            if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/minter/amm-oracle/IUniswapV2OracleCompat.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\nimport {IERC20Minimal} from \"../../vendor/uniswap/v2-core/interfaces/IERC20Minimal.sol\";\nimport {IUniswapV2Factory} from \"../../vendor/uniswap/v2-periphery/libraries/UniswapV2Library.sol\";\n\n/// @notice without UQ values\ninterface IUniswapV2OracleCompat {\n    event NewAdmin(address indexed newAdmin);\n    event NewMinUpdatePeriod(uint256 newMinUpdatePeriod);\n    event NewPair(address indexed pair, address indexed token0, address indexed token1, uint256 updatePeriod);\n    event PairUpdated(address indexed pair, address indexed token0, address indexed token1, uint256 updatePeriod);\n\n    event NewKrAssetPair(address indexed krAsset, address indexed pairAddress);\n\n    /// @notice returns the connected univ2 factory\n    function factory() external view returns (IUniswapV2Factory);\n\n    /// @notice returns the incentive token for the incentivized update\n    function incentiveToken() external view returns (IERC20Minimal);\n\n    /// @notice returns the amount of incentive tokens sent using the incentivized update\n    function incentiveAmount() external view returns (uint256);\n\n    /// @notice returns the current admin of the oracle\n    function admin() external view returns (address);\n\n    /// @notice returns the TWAP time period in seconds\n    function minUpdatePeriod() external view returns (uint256);\n\n    /// @notice returns the pair address for a given krAsset\n    function krAssets(address) external returns (address);\n\n    /**\n     *\n     * @param _newIncentiveToken new incentive token for updater\n     * @param amount amount of incentive tokens\n     */\n    function setIncentiveToken(address _newIncentiveToken, uint256 amount) external;\n\n    /**\n     * @notice Configures existing values of an AMM pair\n     * @param _pairAddress Pair address\n     * @param _updatePeriod Update period (TWAP)\n     */\n    function configurePair(address _pairAddress, uint256 _updatePeriod) external;\n\n    /**\n     * @notice Get the AMM price for an amount of krAsset\n     * @param _kreskoAsset Kresko asset address\n     * @param _amountIn Amount of Kresko Asset to get value for\n     */\n    function consultKrAsset(address _kreskoAsset, uint256 _amountIn) external view returns (uint256 amountOut);\n\n    /**\n     * @notice General consult function, gets a value for `_amountIn` of `_token` in terms of `_tokenOut`\n     * @param _pairAddress Address of the pair that contains the token\n     * @param _token Address of the token to get value for\n     * @param _amountIn Amount of token to get value for\n     * @return amountOut Amount of tokenOut that `_amountIn` of `_token` is worth\n     */\n    function consult(address _pairAddress, address _token, uint256 _amountIn) external view returns (uint256 amountOut);\n\n    /**\n     * @notice Initializes an Uniswap V2 pair to be tracked by this oracle.\n     *\n     * The criteria for a pair to be tracked:\n     * The pair must not already be tracked by this oracle.\n     * The pair must exist.\n     * The pair must have reserves.\n     * The update period must be greater than the minimum update period.\n     * @param _pairAddress Liquidity token address for the pair\n     * @param _krAsset Kresko Asset in the pair we want to add helper functionality for\n     * @param _updatePeriod The update period (TWAP) for this AMM pair\n     *\n     */\n    function initPair(address _pairAddress, address _krAsset, uint256 _updatePeriod) external;\n\n    /**\n     * @notice Updates the oracle values for a pair\n     * @param _pairAddress Pair address\n     */\n    function update(address _pairAddress) external;\n\n    /**\n     * @notice Sets a new admin\n     * @param _newAdmin New admin address\n     */\n    function setAdmin(address _newAdmin) external;\n\n    /**\n     * @notice Set a new min update period\n     * @param _minUpdatePeriod The new minimum period that can be set for a pair\n     */\n    function setMinUpdatePeriod(uint256 _minUpdatePeriod) external;\n\n    /**\n     * @notice Move any missent tokens\n     * @param _erc20 drain any sent tokens\n     * @param _to drain any sent tokens\n     */\n    function drainERC20(address _erc20, address _to) external;\n\n    /**\n     * Update pair data with incentives sent\n     * @param _kreskoAsset Kresko Asset in the pair we want to update pair data for\n     */\n    function updateWithIncentive(address _kreskoAsset) external;\n}\n"
    },
    "src/contracts/minter/facets/AccountStateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IAccountStateFacet} from \"../interfaces/IAccountStateFacet.sol\";\nimport {Fee, KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/**\n * @author Kresko\n * @title AccountStateFacet\n * @notice Views concerning account state\n */\ncontract AccountStateFacet is IAccountStateFacet {\n    using LibDecimals for uint256;\n    using LibDecimals for uint8;\n    using WadRay for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  KrAssets                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IAccountStateFacet\n    function getMintedKreskoAssetsIndex(address _account, address _kreskoAsset) external view returns (uint256) {\n        return ms().getMintedKreskoAssetsIndex(_account, _kreskoAsset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getMintedKreskoAssets(address _account) external view returns (address[] memory) {\n        return ms().mintedKreskoAssets[_account];\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getAccountKrAssetValue(address _account) external view returns (uint256) {\n        return ms().getAccountKrAssetValue(_account);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function kreskoAssetDebt(address _account, address _asset) external view returns (uint256) {\n        return ms().getKreskoAssetDebtScaled(_account, _asset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function kreskoAssetDebtPrincipal(address _account, address _asset) external view returns (uint256) {\n        return ms().getKreskoAssetDebtPrincipal(_account, _asset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function kreskoAssetDebtInterest(\n        address _account,\n        address _asset\n    ) external view returns (uint256 assetAmount, uint256 kissAmount) {\n        return ms().getKreskoAssetDebtInterest(_account, _asset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function kreskoAssetDebtInterestTotal(address _account) external view returns (uint256 kissAmount) {\n        address[] memory mintedKreskoAssets = ms().mintedKreskoAssets[_account];\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            (, uint256 kissAmountForAsset) = ms().getKreskoAssetDebtInterest(_account, mintedKreskoAssets[i]);\n            kissAmount += kissAmountForAsset;\n        }\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Collateral                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IAccountStateFacet\n    function getDepositedCollateralAssets(address _account) external view returns (address[] memory) {\n        return ms().depositedCollateralAssets[_account];\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function collateralDeposits(address _account, address _asset) external view returns (uint256) {\n        return ms().getCollateralDeposits(_account, _asset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getDepositedCollateralAssetIndex(\n        address _account,\n        address _collateralAsset\n    ) external view returns (uint256 i) {\n        return ms().getDepositedCollateralAssetIndex(_account, _collateralAsset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getAccountCollateralValue(address _account) public view returns (uint256) {\n        return ms().getAccountCollateralValue(_account);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getAccountMinimumCollateralValueAtRatio(address _account, uint256 _ratio) public view returns (uint256) {\n        return ms().getAccountMinimumCollateralValueAtRatio(_account, _ratio);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getAccountCollateralRatio(address _account) public view returns (uint256 ratio) {\n        uint256 collateralValue = ms().getAccountCollateralValue(_account);\n        if (collateralValue == 0) {\n            return 0;\n        }\n        uint256 krAssetValue = ms().getAccountKrAssetValue(_account);\n        if (krAssetValue == 0) {\n            return 0;\n        }\n        ratio = collateralValue.wadDiv(krAssetValue);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getCollateralAdjustedAndRealValue(\n        address _account,\n        address _asset\n    ) external view returns (uint256 adjustedValue, uint256 realValue) {\n        uint256 depositAmount = ms().getCollateralDeposits(_account, _asset);\n        return ms().getCollateralValueAndOraclePrice(_asset, depositAmount, false);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getCollateralRatiosFor(address[] calldata _accounts) external view returns (uint256[] memory) {\n        uint256[] memory ratios = new uint256[](_accounts.length);\n        for (uint256 i; i < _accounts.length; i++) {\n            ratios[i] = getAccountCollateralRatio(_accounts[i]);\n        }\n        return ratios;\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function calcExpectedFee(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kreskoAssetAmount,\n        uint256 _feeType\n    ) external view returns (address[] memory, uint256[] memory) {\n        require(_feeType <= 1, Error.INVALID_FEE_TYPE);\n\n        KrAsset memory krAsset = ms().kreskoAssets[_kreskoAsset];\n\n        // Calculate the value of the fee according to the value of the krAsset\n        uint256 feeValue = krAsset.uintUSD(_kreskoAssetAmount, ms().oracleDeviationPct).wadMul(\n            Fee(_feeType) == Fee.Open ? krAsset.openFee : krAsset.closeFee\n        );\n\n        address[] memory accountCollateralAssets = ms().depositedCollateralAssets[_account];\n\n        ExpectedFeeRuntimeInfo memory info; // Using ExpectedFeeRuntimeInfo struct to avoid StackTooDeep error\n        info.assets = new address[](accountCollateralAssets.length);\n        info.amounts = new uint256[](accountCollateralAssets.length);\n\n        // Return empty arrays if the fee value is 0.\n        if (feeValue == 0) {\n            return (info.assets, info.amounts);\n        }\n\n        for (uint256 i = accountCollateralAssets.length - 1; i >= 0; i--) {\n            address collateralAssetAddress = accountCollateralAssets[i];\n\n            uint256 depositAmount = ms().getCollateralDeposits(_account, collateralAssetAddress);\n\n            // Don't take the collateral asset's collateral factor into consideration.\n            (uint256 depositValue, uint256 oraclePrice) = ms().getCollateralValueAndOraclePrice(\n                collateralAssetAddress,\n                depositAmount,\n                true\n            );\n\n            uint256 feeValuePaid;\n            uint256 transferAmount;\n            // If feeValue < depositValue, the entire fee can be charged for this collateral asset.\n            if (feeValue < depositValue) {\n                transferAmount = ms().collateralAssets[collateralAssetAddress].decimals.fromWad(\n                    feeValue.wadDiv(oraclePrice)\n                );\n                feeValuePaid = feeValue;\n            } else {\n                transferAmount = depositAmount;\n                feeValuePaid = depositValue;\n            }\n\n            if (transferAmount > 0) {\n                info.assets[info.collateralTypeCount] = collateralAssetAddress;\n                info.amounts[info.collateralTypeCount] = transferAmount;\n                info.collateralTypeCount = info.collateralTypeCount++;\n            }\n\n            feeValue = feeValue - feeValuePaid;\n            // If the entire fee has been paid, no more action needed.\n            if (feeValue == 0) {\n                return (info.assets, info.amounts);\n            }\n        }\n        return (info.assets, info.amounts);\n    }\n}\n"
    },
    "src/contracts/minter/facets/BurnFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IBurnFacet} from \"../interfaces/IBurnFacet.sol\";\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {MinterModifiers} from \"../MinterModifiers.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\nimport {Action} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title BurnFacet\n * @notice Main end-user functionality concerning burning of kresko assets\n */\ncontract BurnFacet is DiamondModifiers, MinterModifiers, IBurnFacet {\n    using Arrays for address[];\n\n    /// @inheritdoc IBurnFacet\n    function burnKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _burnAmount,\n        uint256 _mintedKreskoAssetIndex\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        require(_burnAmount > 0, Error.ZERO_BURN);\n        MinterState storage s = ms();\n\n        if (s.safetyStateSet) {\n            ensureNotPaused(_kreskoAsset, Action.Repay);\n        }\n\n        // Get accounts principal debt\n        uint256 debtAmount = s.getKreskoAssetDebtPrincipal(_account, _kreskoAsset);\n        require(debtAmount != 0, Error.ZERO_DEBT);\n\n        if (_burnAmount != type(uint256).max) {\n            require(_burnAmount <= debtAmount, Error.KRASSET_BURN_AMOUNT_OVERFLOW);\n            // Ensure principal left is either 0 or >= minDebtValue\n            _burnAmount = s.ensureNotDustPosition(_kreskoAsset, _burnAmount, debtAmount);\n        } else {\n            // _burnAmount of uint256 max, burn all principal debt\n            _burnAmount = debtAmount;\n        }\n\n        // Charge the burn fee from collateral of _account\n        s.chargeCloseFee(_account, _kreskoAsset, _burnAmount);\n\n        // Record the burn\n        s.burn(_kreskoAsset, s.kreskoAssets[_kreskoAsset].anchor, _burnAmount, _account);\n\n        // If sender repays all scaled debt of asset with no stability rate, remove it from minted assets array.\n        // For assets with stability rate the removal is done when repaying interest\n        if (\n            irs().srAssets[_kreskoAsset].asset == address(0) && s.getKreskoAssetDebtScaled(_account, _kreskoAsset) == 0\n        ) {\n            s.mintedKreskoAssets[_account].removeAddress(_kreskoAsset, _mintedKreskoAssetIndex);\n        }\n\n        // Emit logs\n        emit MinterEvent.KreskoAssetBurned(_account, _kreskoAsset, _burnAmount);\n    }\n}\n"
    },
    "src/contracts/minter/facets/BurnHelperFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {IBurnHelperFacet} from \"../interfaces/IBurnHelperFacet.sol\";\nimport {MinterModifiers} from \"../MinterModifiers.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\nimport {Action} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title BurnHelperFacet\n * @notice Helper functions for reducing positions\n */\ncontract BurnHelperFacet is IBurnHelperFacet, DiamondModifiers, MinterModifiers {\n    using Arrays for address[];\n\n    /// @inheritdoc IBurnHelperFacet\n    function closeKrAssetDebtPosition(\n        address _account,\n        address _kreskoAsset\n    ) public nonReentrant kreskoAssetExists(_kreskoAsset) onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        MinterState storage s = ms();\n        if (s.safetyStateSet) {\n            super.ensureNotPaused(_kreskoAsset, Action.Repay);\n        }\n\n        // Get accounts principal debt\n        uint256 principalDebt = s.getKreskoAssetDebtPrincipal(_account, _kreskoAsset);\n        require(principalDebt != 0, Error.ZERO_BURN);\n\n        // Charge the burn fee from collateral of _account\n        s.chargeCloseFee(_account, _kreskoAsset, principalDebt);\n\n        // Record the burn\n        s.burn(_kreskoAsset, s.kreskoAssets[_kreskoAsset].anchor, principalDebt, _account);\n        uint256 kissRepayAmount = ms().repayFullStabilityRateInterest(_account, _kreskoAsset);\n\n        // If all all principal debt of asset with NO stability rate configured\n        // -> remove it from minted assets array.\n        // For assets with stability rate the revomal is done when repaying interest\n        if (irs().srAssets[_kreskoAsset].asset == address(0)) {\n            s.mintedKreskoAssets[_account].removeAddress(\n                _kreskoAsset,\n                ms().getMintedKreskoAssetsIndex(_account, _kreskoAsset)\n            );\n        }\n\n        emit MinterEvent.DebtPositionClosed(_account, _kreskoAsset, principalDebt, kissRepayAmount);\n    }\n\n    /// @inheritdoc IBurnHelperFacet\n    function batchCloseKrAssetDebtPositions(\n        address _account\n    ) external onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        address[] memory mintedKreskoAssets = ms().getMintedKreskoAssets(_account);\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            closeKrAssetDebtPosition(_account, mintedKreskoAssets[i]);\n        }\n    }\n}\n"
    },
    "src/contracts/minter/facets/ConfigurationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IERC165} from \"../../shared/IERC165.sol\";\nimport {IERC20Permit} from \"../../shared/IERC20Permit.sol\";\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\nimport {IKISS} from \"../../kiss/interfaces/IKISS.sol\";\n\nimport {IConfigurationFacet} from \"../interfaces/IConfigurationFacet.sol\";\n\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent, GeneralEvent} from \"../../libs/Events.sol\";\nimport {Authorization, Role} from \"../../libs/Authorization.sol\";\nimport {Meta} from \"../../libs/Meta.sol\";\n\nimport {MinterModifiers} from \"../MinterModifiers.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\n\nimport {ds} from \"../../diamond/DiamondStorage.sol\";\n\nimport {MinterInitArgs, CollateralAsset, KrAsset, IFluxPriceFeed, AggregatorV3Interface, Constants} from \"../MinterTypes.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/**\n * @author Kresko\n * @title ConfigurationFacet\n * @notice Functionality for `Role.ADMIN` level actions.\n * @notice Can be only initialized by the deployer/owner.\n */\ncontract ConfigurationFacet is DiamondModifiers, MinterModifiers, IConfigurationFacet {\n    /* -------------------------------------------------------------------------- */\n    /*                                 Initialize                                 */\n    /* -------------------------------------------------------------------------- */\n\n    function initialize(MinterInitArgs calldata args) external onlyOwner {\n        require(ms().initializations == 0, Error.ALREADY_INITIALIZED);\n        // Temporarily set ADMIN role for deployer\n        Authorization._grantRole(Role.DEFAULT_ADMIN, msg.sender);\n        Authorization._grantRole(Role.ADMIN, msg.sender);\n\n        // Grant the admin role to admin\n        Authorization._grantRole(Role.DEFAULT_ADMIN, args.admin);\n        Authorization._grantRole(Role.ADMIN, args.admin);\n\n        /**\n         * @notice Council can be set only by this specific function.\n         * Requirements:\n         *\n         * - address `_council` must implement ERC165 and a specific multisig interfaceId.\n         * - reverts if above is not true.\n         */\n        Authorization.setupSecurityCouncil(args.council);\n\n        updateFeeRecipient(args.treasury);\n        updateMinimumCollateralizationRatio(args.minimumCollateralizationRatio);\n        updateMinimumDebtValue(args.minimumDebtValue);\n        updateLiquidationThreshold(args.liquidationThreshold);\n        updateExtOracleDecimals(args.extOracleDecimals);\n        updateMaxLiquidationMultiplier(Constants.MIN_MAX_LIQUIDATION_MULTIPLIER);\n        updateOracleDeviationPct(args.oracleDeviationPct);\n        updateSequencerUptimeFeed(args.sequencerUptimeFeed);\n        updateSequencerGracePeriodTime(args.sequencerGracePeriodTime);\n        updateOracleTimeout(args.oracleTimeout);\n\n        ms().initializations = 1;\n        ms().domainSeparator = Meta.domainSeparator(\"Kresko Minter\", \"V1\");\n        emit GeneralEvent.Initialized(args.admin, 1);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateFeeRecipient(address _feeRecipient) public override onlyRole(Role.ADMIN) {\n        require(_feeRecipient != address(0), Error.ADDRESS_INVALID_FEERECIPIENT);\n        ms().feeRecipient = _feeRecipient;\n        emit MinterEvent.FeeRecipientUpdated(_feeRecipient);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateLiquidationIncentiveMultiplier(\n        address _collateralAsset,\n        uint256 _liquidationIncentiveMultiplier\n    ) public override collateralAssetExists(_collateralAsset) onlyRole(Role.ADMIN) {\n        require(\n            _liquidationIncentiveMultiplier >= Constants.MIN_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_LOW\n        );\n        require(\n            _liquidationIncentiveMultiplier <= Constants.MAX_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_HIGH\n        );\n        ms().collateralAssets[_collateralAsset].liquidationIncentive = _liquidationIncentiveMultiplier;\n        emit MinterEvent.LiquidationIncentiveMultiplierUpdated(_collateralAsset, _liquidationIncentiveMultiplier);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateCFactor(\n        address _collateralAsset,\n        uint256 _cFactor\n    ) public override collateralAssetExists(_collateralAsset) onlyRole(Role.ADMIN) {\n        require(_cFactor <= Constants.ONE_HUNDRED_PERCENT, Error.COLLATERAL_INVALID_FACTOR);\n        ms().collateralAssets[_collateralAsset].factor = _cFactor;\n        emit MinterEvent.CFactorUpdated(_collateralAsset, _cFactor);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateKFactor(\n        address _kreskoAsset,\n        uint256 _kFactor\n    ) public override kreskoAssetExists(_kreskoAsset) onlyRole(Role.ADMIN) {\n        require(_kFactor >= Constants.ONE_HUNDRED_PERCENT, Error.KRASSET_INVALID_FACTOR);\n        ms().kreskoAssets[_kreskoAsset].kFactor = _kFactor;\n        emit MinterEvent.CFactorUpdated(_kreskoAsset, _kFactor);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateMinimumCollateralizationRatio(\n        uint256 _minimumCollateralizationRatio\n    ) public override onlyRole(Role.ADMIN) {\n        require(\n            _minimumCollateralizationRatio >= Constants.MIN_COLLATERALIZATION_RATIO,\n            Error.PARAM_MIN_COLLATERAL_RATIO_LOW\n        );\n        require(_minimumCollateralizationRatio >= ms().liquidationThreshold, Error.PARAM_COLLATERAL_RATIO_LOW_THAN_LT);\n        ms().minimumCollateralizationRatio = _minimumCollateralizationRatio;\n        emit MinterEvent.MinimumCollateralizationRatioUpdated(_minimumCollateralizationRatio);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateMinimumDebtValue(uint256 _minimumDebtValue) public override onlyRole(Role.ADMIN) {\n        require(_minimumDebtValue <= Constants.MAX_MIN_DEBT_VALUE, Error.PARAM_MIN_DEBT_AMOUNT_HIGH);\n        ms().minimumDebtValue = _minimumDebtValue;\n        emit MinterEvent.MinimumDebtValueUpdated(_minimumDebtValue);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateLiquidationThreshold(uint256 _liquidationThreshold) public override onlyRole(Role.ADMIN) {\n        // Liquidation threshold cannot be greater than minimum collateralization ratio\n\n        require(_liquidationThreshold <= ms().minimumCollateralizationRatio, Error.INVALID_LT);\n\n        ms().liquidationThreshold = _liquidationThreshold;\n        emit MinterEvent.LiquidationThresholdUpdated(_liquidationThreshold);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateMaxLiquidationMultiplier(uint256 _maxLiquidationMultiplier) public override onlyRole(Role.ADMIN) {\n        require(\n            _maxLiquidationMultiplier >= Constants.MIN_MAX_LIQUIDATION_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_OVERFLOW_LOW\n        );\n        ms().maxLiquidationMultiplier = _maxLiquidationMultiplier;\n        emit MinterEvent.maxLiquidationMultiplierUpdated(_maxLiquidationMultiplier);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateAMMOracle(address _ammOracle) external onlyRole(Role.ADMIN) {\n        require(_ammOracle != address(0), Error.ADDRESS_INVALID_ORACLE);\n        ms().ammOracle = _ammOracle;\n        emit MinterEvent.AMMOracleUpdated(_ammOracle);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateExtOracleDecimals(uint8 _decimals) public onlyRole(Role.ADMIN) {\n        ms().extOracleDecimals = _decimals;\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateOracleDeviationPct(uint256 _oracleDeviationPct) public onlyRole(Role.ADMIN) {\n        require(_oracleDeviationPct <= 1 ether, Error.INVALID_ORACLE_DEVIATION_PCT);\n        ms().oracleDeviationPct = _oracleDeviationPct;\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateSequencerUptimeFeed(address _sequencerUptimeFeed) public override onlyRole(Role.ADMIN) {\n        ms().sequencerUptimeFeed = _sequencerUptimeFeed;\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateSequencerGracePeriodTime(uint256 _sequencerGracePeriodTime) public override onlyRole(Role.ADMIN) {\n        ms().sequencerGracePeriodTime = _sequencerGracePeriodTime;\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateOracleTimeout(uint256 _oracleTimeout) public override onlyRole(Role.ADMIN) {\n        ms().oracleTimeout = _oracleTimeout;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 COLLATERAL                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IConfigurationFacet\n    function addCollateralAsset(\n        address _collateralAsset,\n        CollateralAsset memory _config\n    ) external nonReentrant onlyRole(Role.ADMIN) collateralAssetDoesNotExist(_collateralAsset) {\n        require(_collateralAsset != address(0), Error.ADDRESS_INVALID_COLLATERAL);\n        require(_config.oracle.decimals() == ms().extOracleDecimals, Error.INVALID_ORACLE_DECIMALS);\n        require(_config.factor <= Constants.ONE_HUNDRED_PERCENT, Error.COLLATERAL_INVALID_FACTOR);\n        require(\n            _config.liquidationIncentive >= Constants.MIN_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_LOW\n        );\n        require(\n            _config.liquidationIncentive <= Constants.MAX_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_HIGH\n        );\n        bool isKrAsset = ms().kreskoAssets[_collateralAsset].exists;\n        require(\n            !isKrAsset ||\n                (IERC165(_collateralAsset).supportsInterface(type(IKISS).interfaceId)) ||\n                IERC165(_config.anchor).supportsInterface(type(IKreskoAssetIssuer).interfaceId),\n            Error.KRASSET_INVALID_ANCHOR\n        );\n\n        /* ---------------------------------- Save ---------------------------------- */\n        ms().collateralAssets[_collateralAsset] = CollateralAsset({\n            factor: _config.factor,\n            oracle: _config.oracle,\n            liquidationIncentive: _config.liquidationIncentive,\n            anchor: _config.anchor,\n            exists: true,\n            decimals: IERC20Permit(_collateralAsset).decimals(),\n            redstoneId: _config.redstoneId\n        });\n\n        emit MinterEvent.CollateralAssetAdded(\n            _collateralAsset,\n            _config.factor,\n            address(_config.oracle),\n            _config.anchor,\n            _config.liquidationIncentive\n        );\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateCollateralAsset(\n        address _collateralAsset,\n        CollateralAsset memory _config\n    ) external onlyRole(Role.ADMIN) collateralAssetExists(_collateralAsset) {\n        // Setting the factor to 0 effectively sunsets a collateral asset, which is intentionally allowed.\n        require(_config.factor <= Constants.ONE_HUNDRED_PERCENT, Error.COLLATERAL_INVALID_FACTOR);\n        require(\n            _config.liquidationIncentive >= Constants.MIN_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_LOW\n        );\n        require(\n            _config.liquidationIncentive <= Constants.MAX_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_HIGH\n        );\n\n        CollateralAsset memory collateralAsset = ms().collateralAssets[_collateralAsset];\n\n        /* ------------------------------ Update anchor ----------------------------- */\n        if (_config.anchor != address(0)) {\n            bool krAsset = ms().kreskoAssets[_collateralAsset].exists;\n            require(\n                !krAsset ||\n                    (IERC165(_collateralAsset).supportsInterface(type(IKISS).interfaceId)) ||\n                    IERC165(_config.anchor).supportsInterface(type(IKreskoAssetIssuer).interfaceId),\n                Error.KRASSET_INVALID_ANCHOR\n            );\n            collateralAsset.anchor = _config.anchor;\n        }\n\n        /* ------------------------------- Price feed ------------------------------- */\n        if (address(_config.oracle) != address(0)) {\n            require(_config.oracle.decimals() == ms().extOracleDecimals, Error.INVALID_ORACLE_DECIMALS);\n            collateralAsset.oracle = _config.oracle;\n            require(collateralAsset.uintPrice() != 0, Error.ADDRESS_INVALID_ORACLE);\n        }\n\n        /* --------------------------------- cFactor -------------------------------- */\n        collateralAsset.factor = _config.factor;\n\n        /* ------------------------------ liqIncentive ------------------------------ */\n        collateralAsset.liquidationIncentive = _config.liquidationIncentive;\n\n        ms().collateralAssets[_collateralAsset] = collateralAsset;\n\n        emit MinterEvent.CollateralAssetUpdated(\n            _collateralAsset,\n            collateralAsset.factor,\n            address(collateralAsset.oracle),\n            collateralAsset.anchor,\n            collateralAsset.liquidationIncentive\n        );\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               Kresko Assets                                */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IConfigurationFacet\n    function addKreskoAsset(\n        address _krAsset,\n        KrAsset memory _config\n    ) external onlyRole(Role.ADMIN) kreskoAssetDoesNotExist(_krAsset) {\n        require(_config.kFactor >= Constants.ONE_HUNDRED_PERCENT, Error.KRASSET_INVALID_FACTOR);\n        require(_config.closeFee <= Constants.MAX_CLOSE_FEE, Error.PARAM_CLOSE_FEE_TOO_HIGH);\n        require(_config.openFee <= Constants.MAX_OPEN_FEE, Error.PARAM_OPEN_FEE_TOO_HIGH);\n        require(\n            IERC165(_krAsset).supportsInterface(type(IKISS).interfaceId) ||\n                IERC165(_krAsset).supportsInterface(type(IKreskoAsset).interfaceId),\n            Error.KRASSET_INVALID_CONTRACT\n        );\n        require(\n            IERC165(_config.anchor).supportsInterface(type(IKreskoAssetIssuer).interfaceId),\n            Error.KRASSET_INVALID_ANCHOR\n        );\n        // The diamond needs the operator role\n        require(IKreskoAsset(_krAsset).hasRole(Role.OPERATOR, address(this)), Error.NOT_OPERATOR);\n\n        // Oracle decimals must match the configuration.\n        require(_config.oracle.decimals() == ms().extOracleDecimals, Error.INVALID_ORACLE_DECIMALS);\n\n        /* ---------------------------------- Save ---------------------------------- */\n        ms().kreskoAssets[_krAsset] = KrAsset({\n            kFactor: _config.kFactor,\n            oracle: _config.oracle,\n            anchor: _config.anchor,\n            supplyLimit: _config.supplyLimit,\n            closeFee: _config.closeFee,\n            openFee: _config.openFee,\n            exists: true,\n            redstoneId: _config.redstoneId\n        });\n\n        emit MinterEvent.KreskoAssetAdded(\n            _krAsset,\n            _config.anchor,\n            address(_config.oracle),\n            _config.kFactor,\n            _config.supplyLimit,\n            _config.closeFee,\n            _config.openFee\n        );\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateKreskoAsset(\n        address _krAsset,\n        KrAsset memory _config\n    ) external onlyRole(Role.ADMIN) kreskoAssetExists(_krAsset) {\n        require(_config.kFactor >= Constants.ONE_HUNDRED_PERCENT, Error.KRASSET_INVALID_FACTOR);\n        require(_config.closeFee <= Constants.MAX_CLOSE_FEE, Error.PARAM_CLOSE_FEE_TOO_HIGH);\n        require(_config.openFee <= Constants.MAX_OPEN_FEE, Error.PARAM_OPEN_FEE_TOO_HIGH);\n        require(\n            IERC165(_krAsset).supportsInterface(type(IKISS).interfaceId) ||\n                IERC165(_krAsset).supportsInterface(type(IKreskoAsset).interfaceId),\n            Error.KRASSET_INVALID_CONTRACT\n        );\n\n        KrAsset memory krAsset = ms().kreskoAssets[_krAsset];\n\n        /* --------------------------------- Anchor --------------------------------- */\n        if (_config.anchor != address(0)) {\n            require(\n                IERC165(_config.anchor).supportsInterface(type(IKreskoAssetIssuer).interfaceId),\n                Error.KRASSET_INVALID_ANCHOR\n            );\n            krAsset.anchor = _config.anchor;\n        }\n\n        /* ------------------------------- Price feed ------------------------------- */\n        if (address(_config.oracle) != address(0)) {\n            require(_config.oracle.decimals() == ms().extOracleDecimals, Error.INVALID_ORACLE_DECIMALS);\n            krAsset.oracle = _config.oracle;\n            require(krAsset.uintPrice() != 0, Error.ADDRESS_INVALID_ORACLE);\n        }\n\n        /* -------------------------- Factors, Fees, Limits ------------------------- */\n        krAsset.kFactor = _config.kFactor;\n        krAsset.supplyLimit = _config.supplyLimit;\n        krAsset.closeFee = _config.closeFee;\n        krAsset.openFee = _config.openFee;\n\n        /* ---------------------------------- Save ---------------------------------- */\n        ms().kreskoAssets[_krAsset] = krAsset;\n\n        emit MinterEvent.KreskoAssetUpdated(\n            _krAsset,\n            krAsset.anchor,\n            address(krAsset.oracle),\n            krAsset.kFactor,\n            krAsset.supplyLimit,\n            krAsset.closeFee,\n            krAsset.openFee\n        );\n    }\n}\n"
    },
    "src/contracts/minter/facets/DepositWithdrawFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IDepositWithdrawFacet} from \"../interfaces/IDepositWithdrawFacet.sol\";\n\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\n\nimport {SafeERC20, IERC20Permit} from \"../../shared/SafeERC20.sol\";\nimport {MinterModifiers} from \"../MinterModifiers.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\nimport {Action, KrAsset} from \"../MinterTypes.sol\";\nimport {ms} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {ICollateralReceiver} from \"../interfaces/ICollateralReceiver.sol\";\n\n/**\n * @author Kresko\n * @title DepositWithdrawFacet\n * @notice Main end-user functionality concerning collateral asset deposits and withdrawals within the Kresko protocol\n */\ncontract DepositWithdrawFacet is DiamondModifiers, MinterModifiers, IDepositWithdrawFacet {\n    using SafeERC20 for IERC20Permit;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Collateral                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IDepositWithdrawFacet\n    function depositCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _depositAmount\n    ) external nonReentrant collateralAssetExists(_collateralAsset) {\n        if (ms().safetyStateSet) {\n            super.ensureNotPaused(_collateralAsset, Action.Deposit);\n        }\n\n        // Transfer tokens into this contract prior to any state changes as an extra measure against re-entrancy.\n        IERC20Permit(_collateralAsset).safeTransferFrom(msg.sender, address(this), _depositAmount);\n\n        // Record the collateral deposit.\n        ms().recordCollateralDeposit(_account, _collateralAsset, _depositAmount);\n    }\n\n    /// @inheritdoc IDepositWithdrawFacet\n    function withdrawCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _depositedCollateralAssetIndex\n    ) external nonReentrant collateralAssetExists(_collateralAsset) onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        if (ms().safetyStateSet) {\n            ensureNotPaused(_collateralAsset, Action.Withdraw);\n        }\n\n        uint256 collateralDeposits = ms().getCollateralDeposits(_account, _collateralAsset);\n        _withdrawAmount = (_withdrawAmount > collateralDeposits ? collateralDeposits : _withdrawAmount);\n\n        ms().verifyAndRecordCollateralWithdrawal(\n            _account,\n            _collateralAsset,\n            _withdrawAmount,\n            collateralDeposits,\n            _depositedCollateralAssetIndex\n        );\n\n        IERC20Permit(_collateralAsset).safeTransfer(_account, _withdrawAmount);\n    }\n\n    /// @inheritdoc IDepositWithdrawFacet\n    function withdrawCollateralUnchecked(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _depositedCollateralAssetIndex,\n        bytes memory _userData\n    ) external collateralAssetExists(_collateralAsset) onlyRole(Role.MANAGER) {\n        if (ms().safetyStateSet) {\n            ensureNotPaused(_collateralAsset, Action.Withdraw);\n        }\n\n        uint256 collateralDeposits = ms().getCollateralDeposits(_account, _collateralAsset);\n        _withdrawAmount = (_withdrawAmount > collateralDeposits ? collateralDeposits : _withdrawAmount);\n\n        // perform unchecked withdrawal\n        ms().recordCollateralWithdrawal(\n            _account,\n            _collateralAsset,\n            _withdrawAmount,\n            collateralDeposits,\n            _depositedCollateralAssetIndex\n        );\n\n        // transfer the withdrawn asset to the caller\n        IERC20Permit(_collateralAsset).safeTransfer(msg.sender, _withdrawAmount);\n\n        // Executes the callback on the caller after sending them the withdrawn collateral\n        ICollateralReceiver(msg.sender).onUncheckedCollateralWithdraw(\n            _account,\n            _collateralAsset,\n            _withdrawAmount,\n            _depositedCollateralAssetIndex,\n            _userData\n        );\n\n        /*\n         Perform the MCR check after the callback has been executed\n         Ensures accountCollateralValue remains over accountMinColateralValueAtRatio(MCR)\n         Emits MinterEvent.UncheckedCollateralWithdrawn\n         _withdrawAmount is 0 since deposits reduced in recordCollateralWithdrawal\n        */\n        ms().verifyAccountCollateral(_account, _collateralAsset, 0);\n    }\n}\n"
    },
    "src/contracts/minter/facets/InterestLiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IInterestLiquidationFacet} from \"../interfaces/IInterestLiquidationFacet.sol\";\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {LibCalculation} from \"../libs/LibCalculation.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {MinterEvent, InterestRateEvent} from \"../../libs/Events.sol\";\nimport {SafeERC20, IERC20Permit} from \"../../shared/SafeERC20.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\nimport {KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title InterestLiquidationFacet\n * @notice Main end-user functionality concerning liquidations of accrued KISS interest within the Kresko protocol\n */\ncontract InterestLiquidationFacet is DiamondModifiers, IInterestLiquidationFacet {\n    using Arrays for address[];\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n    using SafeERC20 for IERC20Permit;\n\n    /// @inheritdoc IInterestLiquidationFacet\n    function batchLiquidateInterest(\n        address _account,\n        address _collateralAssetToSeize,\n        bool _allowSeizeUnderflow\n    ) external nonReentrant {\n        // Borrower cannot liquidate themselves\n        require(msg.sender != _account, Error.SELF_LIQUIDATION);\n        // Check that this account is below its minimum collateralization ratio and can be liquidated.\n        require(ms().isAccountLiquidatable(_account), Error.NOT_LIQUIDATABLE);\n        // Collateral exists\n        require(ms().collateralAssets[_collateralAssetToSeize].exists, Error.COLLATERAL_DOESNT_EXIST);\n\n        address[] memory mintedKreskoAssets = ms().getMintedKreskoAssets(_account);\n\n        // Loop all accounts minted assets and sum all accrued kiss interest\n        uint256 kissAmountToRepay;\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            address repayKreskoAsset = mintedKreskoAssets[i];\n            // Repays the full interest of this asset on behalf of the account being liquidated\n            kissAmountToRepay += ms().repayFullStabilityRateInterest(_account, repayKreskoAsset);\n\n            // Check if the status with amount repaid is still underwater, if so no further liquidation is needed\n            if (\n                !ms().isAccountLiquidatable(\n                    _account,\n                    kissAmountToRepay.fromWadPriceToUint().wadMul(\n                        ms().collateralAssets[_collateralAssetToSeize].liquidationIncentive\n                    )\n                )\n            ) break;\n        }\n\n        // Emit a separate event for batch repayment itself\n        emit InterestRateEvent.StabilityRateInterestBatchRepaid(_account, kissAmountToRepay);\n\n        // Seize collateral and send to liquidator according to the repayment made\n        uint256 collateralSeizeAmount = _seizeAndTransferCollateral(\n            _account,\n            _collateralAssetToSeize,\n            ms().getDepositedCollateralAssetIndex(_account, _collateralAssetToSeize),\n            kissAmountToRepay,\n            _allowSeizeUnderflow\n        );\n\n        emit MinterEvent.BatchInterestLiquidationOccurred(\n            _account,\n            msg.sender,\n            _collateralAssetToSeize,\n            kissAmountToRepay,\n            collateralSeizeAmount\n        );\n    }\n\n    /// @inheritdoc IInterestLiquidationFacet\n    function liquidateInterest(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize,\n        bool _allowSeizeUnderflow\n    ) external nonReentrant {\n        // Borrower cannot liquidate themselves\n        require(msg.sender != _account, Error.SELF_LIQUIDATION);\n        // krAsset exists\n        require(ms().kreskoAssets[_repayKreskoAsset].exists, Error.KRASSET_DOESNT_EXIST);\n        // Check that this account is below its minimum collateralization ratio and can be liquidated.\n        require(ms().isAccountLiquidatable(_account), Error.NOT_LIQUIDATABLE);\n        // Collateral exists\n        require(ms().collateralAssets[_collateralAssetToSeize].exists, Error.COLLATERAL_DOESNT_EXIST);\n\n        // Repays the full interest of this asset on behalf of the account being liquidated\n        uint256 kissRepayAmount = ms().repayFullStabilityRateInterest(_account, _repayKreskoAsset);\n\n        uint256 mintedKreskoAssetIndex = ms().getMintedKreskoAssetsIndex(_account, _repayKreskoAsset);\n\n        // Seize collateral and send to liquidator according to the repayment made\n        uint256 collateralAmountSeized = _seizeAndTransferCollateral(\n            _account,\n            _collateralAssetToSeize,\n            ms().getDepositedCollateralAssetIndex(_account, _collateralAssetToSeize),\n            kissRepayAmount,\n            _allowSeizeUnderflow\n        );\n\n        // If the liquidation repays the user's entire Kresko asset balance, remove it from minted assets array.\n        if (ms().kreskoAssetDebt[_account][_repayKreskoAsset] == 0) {\n            ms().mintedKreskoAssets[_account].removeAddress(_repayKreskoAsset, mintedKreskoAssetIndex);\n        }\n\n        emit MinterEvent.InterestLiquidationOccurred(\n            _account,\n            msg.sender,\n            _repayKreskoAsset,\n            kissRepayAmount, // without the liquidation bonus\n            _collateralAssetToSeize,\n            collateralAmountSeized // with the liquidation bonus\n        );\n    }\n\n    /**\n     * @notice Internal function to perform collateral seizing when interest gets liquidated\n     * @dev\n     * @param _account Account being liquidated\n     * @param _collateralAssetToSeize Collateral asset used to liquidate the debt\n     * @param _depositedCollateralAssetIndex Deposit index for the liquidated accounts collateral\n     * @param _kissRepayAmount Accrued KISS interest value being liquidated\n     */\n    function _seizeAndTransferCollateral(\n        address _account,\n        address _collateralAssetToSeize,\n        uint256 _depositedCollateralAssetIndex,\n        uint256 _kissRepayAmount,\n        bool _allowSeizeUnderflow\n    ) internal returns (uint256 seizeAmount) {\n        MinterState storage s = ms();\n\n        seizeAmount = s.collateralAssets[_collateralAssetToSeize].decimals.fromWad(\n            LibCalculation.calculateAmountToSeize(\n                s.collateralAssets[_collateralAssetToSeize].liquidationIncentive,\n                s.collateralAssets[_collateralAssetToSeize].uintPrice(s.oracleDeviationPct),\n                _kissRepayAmount.fromWadPriceToUint()\n            )\n        );\n\n        // Collateral deposits for the seized asset of the account being liquidated\n        uint256 collateralDeposit = s.getCollateralDeposits(_account, _collateralAssetToSeize);\n\n        // Default case where deposits are greater than the seized amount\n        if (collateralDeposit > seizeAmount) {\n            // Convert the value being seized into non-rebasing value\n            s.collateralDeposits[_account][_collateralAssetToSeize] -= ms()\n                .collateralAssets[_collateralAssetToSeize]\n                .toNonRebasingAmount(seizeAmount);\n        } else {\n            if (collateralDeposit < seizeAmount) {\n                require(_allowSeizeUnderflow, Error.SEIZED_COLLATERAL_UNDERFLOW);\n            }\n            // This clause means user either has collateralDeposits equal or less than the _seizeAmount\n            seizeAmount = collateralDeposit;\n            // So we set the collateralDeposits to 0\n            s.collateralDeposits[_account][_collateralAssetToSeize] = 0;\n            // And remove the asset from the deposits array.\n            s.depositedCollateralAssets[_account].removeAddress(\n                _collateralAssetToSeize,\n                _depositedCollateralAssetIndex\n            );\n        }\n\n        // Send liquidator the seized collateral.\n        IERC20Permit(_collateralAssetToSeize).safeTransfer(msg.sender, seizeAmount);\n    }\n}\n"
    },
    "src/contracts/minter/facets/LiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n// solhint-disable not-rely-on-time\n\nimport {ILiquidationFacet} from \"../interfaces/ILiquidationFacet.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {LibCalculation} from \"../libs/LibCalculation.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {SafeERC20, IERC20Permit} from \"../../shared/SafeERC20.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\n\nimport {Constants, KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title LiquidationFacet\n * @notice Main end-user functionality concerning liquidations within the Kresko protocol\n */\ncontract LiquidationFacet is DiamondModifiers, ILiquidationFacet {\n    using Arrays for address[];\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n    using SafeERC20 for IERC20Permit;\n\n    /// @inheritdoc ILiquidationFacet\n    function liquidate(\n        address _account,\n        address _repayAsset,\n        uint256 _repayAmount,\n        address _seizeAsset,\n        uint256 _repayAssetIndex,\n        uint256 _seizeAssetIndex,\n        bool _allowSeizeUnderflow\n    ) external nonReentrant {\n        MinterState storage s = ms();\n\n        CollateralAsset memory collateral = s.collateralAssets[_seizeAsset];\n        KrAsset memory krAsset = s.kreskoAssets[_repayAsset];\n\n        /* ------------------------------ Sanity checks ----------------------------- */\n        {\n            // No zero repays\n            require(_repayAmount != 0, Error.ZERO_REPAY);\n            // Borrower cannot liquidate themselves\n            require(msg.sender != _account, Error.SELF_LIQUIDATION);\n            // krAsset exists\n            require(krAsset.exists, Error.KRASSET_DOESNT_EXIST);\n            // Collateral exists\n            require(collateral.exists, Error.COLLATERAL_DOESNT_EXIST);\n            // Check that this account is below its minimum collateralization ratio and can be liquidated.\n            require(s.isAccountLiquidatable(_account), Error.NOT_LIQUIDATABLE);\n        }\n\n        /* ------------------------------ Amount checks ----------------------------- */\n        // Repay amount USD = repay amount * KR asset USD exchange rate.\n        uint256 repayAmountUSD = krAsset.uintUSD(_repayAmount, s.oracleDeviationPct);\n\n        // Avoid deep stack\n        {\n            // Get the principal debt amount which is unscaled for interest.\n            uint256 krAssetDebt = s.getKreskoAssetDebtPrincipal(_account, _repayAsset);\n            // Cannot liquidate more than the account's debt\n            require(krAssetDebt >= _repayAmount, Error.KRASSET_BURN_AMOUNT_OVERFLOW);\n\n            // We limit liquidations to exactly Liquidation Threshold here.\n            uint256 maxLiquidableUSD = s.getMaxLiquidation(_account, krAsset, _seizeAsset);\n\n            if (repayAmountUSD > maxLiquidableUSD) {\n                _repayAmount = maxLiquidableUSD.wadDiv(krAsset.uintPrice(s.oracleDeviationPct));\n                repayAmountUSD = maxLiquidableUSD;\n            }\n        }\n\n        /* ------------------------------- Charge fee ------------------------------- */\n        s.chargeCloseFee(_account, _repayAsset, _repayAmount);\n\n        /* -------------------------------- Liquidate ------------------------------- */\n        uint256 seizedAmount = _liquidateAssets(\n            ExecutionParams(\n                _account,\n                _repayAmount,\n                collateral.decimals.fromWad(\n                    LibCalculation.calculateAmountToSeize(\n                        collateral.liquidationIncentive,\n                        collateral.uintPrice(s.oracleDeviationPct),\n                        repayAmountUSD\n                    )\n                ),\n                _repayAsset,\n                _repayAssetIndex,\n                _seizeAsset,\n                _seizeAssetIndex,\n                _allowSeizeUnderflow\n            )\n        );\n\n        /* ---------------------------- Balance transfer ---------------------------- */\n        // Send liquidator the seized collateral.\n        IERC20Permit(_seizeAsset).safeTransfer(msg.sender, seizedAmount);\n\n        emit MinterEvent.LiquidationOccurred(\n            _account,\n            // solhint-disable-next-line avoid-tx-origin\n            msg.sender,\n            _repayAsset,\n            _repayAmount,\n            _seizeAsset,\n            seizedAmount\n        );\n    }\n\n    /// @notice Execute the liquidation\n    /// @dev Also updates stability rate and debt index\n    function _liquidateAssets(ExecutionParams memory params) internal returns (uint256 seizedAmount) {\n        MinterState storage s = ms();\n\n        /* -------------------------------------------------------------------------- */\n        /*                                 Reduce debt                                */\n        /* -------------------------------------------------------------------------- */\n        {\n            /* ----------------------------- Destroy assets ----------------------------- */\n            uint256 destroyed = IKreskoAssetIssuer(s.kreskoAssets[params.repayAsset].anchor).destroy(\n                params.repayAmount,\n                msg.sender\n            );\n            s.kreskoAssetDebt[params.account][params.repayAsset] -= destroyed;\n\n            /* ------------------------ Debt index + rate updates ----------------------- */\n\n            uint256 newDebtIndex = irs().srAssets[params.repayAsset].updateDebtIndex();\n            uint256 amountScaled = destroyed.wadToRay().rayDiv(newDebtIndex);\n\n            irs().srUserInfo[params.account][params.repayAsset].debtScaled -= uint128(amountScaled);\n            irs().srUserInfo[params.account][params.repayAsset].lastDebtIndex = uint128(newDebtIndex);\n\n            irs().srAssets[params.repayAsset].updateStabilityRate();\n        }\n\n        // If the liquidation repays entire asset debt, remove from minted assets array.\n        if (s.getKreskoAssetDebtScaled(params.account, params.repayAsset) == 0) {\n            s.mintedKreskoAssets[params.account].removeAddress(params.repayAsset, params.repayAssetIndex);\n        }\n\n        /* -------------------------------------------------------------------------- */\n        /*                              Reduce collateral                             */\n        /* -------------------------------------------------------------------------- */\n\n        uint256 collateralDeposits = s.getCollateralDeposits(params.account, params.seizedAsset);\n\n        /* ------------------------ Above collateral deposits ----------------------- */\n\n        if (collateralDeposits > params.seizeAmount) {\n            uint256 newDepositAmount = collateralDeposits - params.seizeAmount;\n\n            // If the collateral asset is also a kresko asset, ensure that collateral remains over minimum amount required.\n            if (\n                ms().collateralAssets[params.seizedAsset].anchor != address(0) &&\n                newDepositAmount < Constants.MIN_KRASSET_COLLATERAL_AMOUNT\n            ) {\n                params.seizeAmount -= Constants.MIN_KRASSET_COLLATERAL_AMOUNT - newDepositAmount;\n                newDepositAmount = Constants.MIN_KRASSET_COLLATERAL_AMOUNT;\n            }\n\n            s.collateralDeposits[params.account][params.seizedAsset] = ms()\n                .collateralAssets[params.seizedAsset]\n                .toNonRebasingAmount(newDepositAmount);\n\n            return params.seizeAmount;\n        } else if (collateralDeposits < params.seizeAmount) {\n            require(params.allowSeizeUnderflow, Error.SEIZED_COLLATERAL_UNDERFLOW);\n        }\n\n        /* ------------------- Exact or below collateral deposits ------------------- */\n        // Remove the collateral deposits.\n        s.collateralDeposits[params.account][params.seizedAsset] = 0;\n        // Remove from the deposits array.\n        s.depositedCollateralAssets[params.account].removeAddress(params.seizedAsset, params.seizedAssetIndex);\n        // Seized amount is the collateral deposits.\n        return collateralDeposits;\n    }\n\n    /// @inheritdoc ILiquidationFacet\n    function isAccountLiquidatable(address _account) external view returns (bool) {\n        return ms().isAccountLiquidatable(_account);\n    }\n\n    /// @inheritdoc ILiquidationFacet\n    function getMaxLiquidation(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize\n    ) public view returns (uint256 maxLiquidatableUSD) {\n        return ms().getMaxLiquidation(_account, ms().kreskoAssets[_repayKreskoAsset], _collateralAssetToSeize);\n    }\n}\n"
    },
    "src/contracts/minter/facets/MintFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IMintFacet} from \"../interfaces/IMintFacet.sol\";\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {MinterModifiers} from \"../MinterModifiers.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\nimport {Action, KrAsset} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {LibRedstone} from \"../libs/LibRedstone.sol\";\n\n/**\n * @author Kresko\n * @title MintFacet\n * @notice Main end-user functionality concerning minting kresko assets\n */\ncontract MintFacet is DiamondModifiers, MinterModifiers, IMintFacet {\n    using Arrays for address[];\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  KrAssets                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IMintFacet\n    function mintKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _mintAmount\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        require(_mintAmount > 0, Error.ZERO_MINT);\n\n        MinterState storage s = ms();\n        if (s.safetyStateSet) {\n            super.ensureNotPaused(_kreskoAsset, Action.Borrow);\n        }\n        // Enforce krAsset's total supply limit\n        KrAsset memory krAsset = s.kreskoAssets[_kreskoAsset];\n        require(krAsset.marketStatus(), Error.KRASSET_MARKET_CLOSED);\n\n        require(\n            IKreskoAsset(_kreskoAsset).totalSupply() + _mintAmount <= krAsset.supplyLimit,\n            Error.KRASSET_MAX_SUPPLY_REACHED\n        );\n\n        if (krAsset.openFee > 0) {\n            s.chargeOpenFee(_account, _kreskoAsset, _mintAmount);\n        }\n        {\n            // Get the account's current minimum collateral value required to maintain current debts.\n            // Calculate additional collateral amount required to back requested additional mint.\n            // Verify that minter has sufficient collateral to back current debt + new requested debt.\n            require(\n                s.getAccountMinimumCollateralValueAtRatio(_account, s.minimumCollateralizationRatio) +\n                    s.getMinimumCollateralValueAtRatio(_kreskoAsset, _mintAmount, s.minimumCollateralizationRatio) <=\n                    s.getAccountCollateralValue(_account),\n                Error.KRASSET_COLLATERAL_LOW\n            );\n        }\n\n        // The synthetic asset debt position must be greater than the minimum debt position value\n        uint256 existingDebt = s.getKreskoAssetDebtScaled(_account, _kreskoAsset);\n        require(\n            krAsset.uintUSD(existingDebt + _mintAmount, s.oracleDeviationPct) >= s.minimumDebtValue,\n            Error.KRASSET_MINT_AMOUNT_LOW\n        );\n\n        // If the account does not have an existing debt for this Kresko Asset,\n        // push it to the list of the account's minted Kresko Assets.\n        if (existingDebt == 0) {\n            bool exists = false;\n            uint256 length = s.mintedKreskoAssets[_account].length;\n            for (uint256 i; i < length; ) {\n                if (s.mintedKreskoAssets[_account][i] == _kreskoAsset) {\n                    exists = true;\n                    break;\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n\n            if (!exists) {\n                s.mintedKreskoAssets[_account].push(_kreskoAsset);\n            }\n        }\n\n        // Record the mint.\n        s.mint(_kreskoAsset, krAsset.anchor, _mintAmount, _account);\n\n        // Emit logs\n        emit MinterEvent.KreskoAssetMinted(_account, _kreskoAsset, _mintAmount);\n    }\n}\n"
    },
    "src/contracts/minter/facets/SafetyCouncilFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {ISafetyCouncilFacet} from \"../interfaces/ISafetyCouncilFacet.sol\";\n\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {Authorization, Role} from \"../../libs/Authorization.sol\";\n\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\nimport {MinterModifiers} from \"../MinterModifiers.sol\";\n\nimport {Action, SafetyState, Pause} from \"../MinterTypes.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @author Kresko\n * @title SafetyCouncilFacet - protocol safety controls\n * @notice `Role.SAFETY_COUNCIL` must be a multisig.\n */\ncontract SafetyCouncilFacet is MinterModifiers, DiamondModifiers, ISafetyCouncilFacet {\n    /// @inheritdoc ISafetyCouncilFacet\n    function toggleAssetsPaused(\n        address[] calldata _assets,\n        Action _action,\n        bool _withDuration,\n        uint256 _duration\n    ) external override onlyRole(Role.SAFETY_COUNCIL) {\n        bool enabled;\n        /// @dev loop through `_assets` - be it krAsset or collateral\n        for (uint256 i; i < _assets.length; i++) {\n            address asset = _assets[i];\n            // Revert if invalid address is supplied\n            require(\n                ms().collateralAssets[asset].exists || ms().kreskoAssets[asset].exists,\n                Error.INVALID_ASSET_SUPPLIED\n            );\n            // Get the safety state\n            SafetyState memory safetyState = ms().safetyState[asset][_action];\n            // Flip the previous value\n            bool willPause = !safetyState.pause.enabled;\n            // Set a global flag in case any asset gets set to true\n            if (willPause) {\n                enabled = true;\n            }\n            // Update the state for this asset\n            ms().safetyState[asset][_action].pause = Pause(\n                willPause,\n                block.timestamp,\n                _withDuration ? block.timestamp + _duration : 0\n            );\n            // Emit the actions taken\n            emit MinterEvent.SafetyStateChange(_action, asset, willPause ? \"paused\" : \"unpaused\");\n        }\n    }\n\n    /// @inheritdoc ISafetyCouncilFacet\n    function setSafetyStateSet(bool val) external override onlyRole(Role.SAFETY_COUNCIL) {\n        ms().safetyStateSet = val;\n    }\n\n    /// @inheritdoc ISafetyCouncilFacet\n    function safetyStateSet() external view override returns (bool) {\n        return ms().safetyStateSet;\n    }\n\n    /// @inheritdoc ISafetyCouncilFacet\n    function safetyStateFor(address _asset, Action _action) external view override returns (SafetyState memory) {\n        return ms().safetyState[_asset][_action];\n    }\n\n    /// @inheritdoc ISafetyCouncilFacet\n    function assetActionPaused(Action _action, address _asset) external view returns (bool) {\n        return ms().safetyState[_asset][_action].pause.enabled;\n    }\n}\n"
    },
    "src/contracts/minter/facets/StabilityRateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {InterestRateEvent} from \"../../libs/Events.sol\";\nimport {LibStabilityRate} from \"../libs/LibStabilityRate.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {StabilityRateConfig} from \"../InterestRateState.sol\";\nimport {ms} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {IERC20Permit} from \"../../shared/IERC20Permit.sol\";\nimport {IStabilityRateFacet} from \"../interfaces/IStabilityRateFacet.sol\";\nimport {DiamondModifiers, Role} from \"../../diamond/DiamondModifiers.sol\";\nimport {MinterModifiers, Error} from \"../MinterModifiers.sol\";\nimport {SafeERC20, IERC20Permit} from \"../../shared/SafeERC20.sol\";\n\n/* solhint-disable var-name-mixedcase */\n\n// Stability Rate setup params\nstruct StabilityRateParams {\n    uint128 stabilityRateBase;\n    uint128 rateSlope1;\n    uint128 rateSlope2;\n    uint128 optimalPriceRate;\n    uint128 priceRateDelta;\n}\n\n/**\n * @title Stability rate facet\n * @author Kresko\n * @notice Stability rate related views and state operations\n * @dev Uses both MinterState (ms) and InterestRateState (irs)\n */\ncontract StabilityRateFacet is IStabilityRateFacet, MinterModifiers, DiamondModifiers {\n    using Arrays for address[];\n    using SafeERC20 for IERC20Permit;\n    using LibStabilityRate for StabilityRateConfig;\n    using WadRay for uint256;\n    using LibDecimals for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              ASSET STATE WRITES                            */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IStabilityRateFacet\n    function setupStabilityRateParams(address _asset, StabilityRateParams memory _setup) external onlyRole(Role.ADMIN) {\n        require(irs().kiss != address(0), Error.KISS_NOT_SET);\n        require(irs().srAssets[_asset].asset == address(0), Error.STABILITY_RATES_ALREADY_INITIALIZED);\n        require(WadRay.RAY >= _setup.optimalPriceRate, Error.INVALID_OPTIMAL_RATE);\n        require(WadRay.RAY >= _setup.priceRateDelta, Error.INVALID_PRICE_RATE_DELTA);\n\n        irs().srAssets[_asset] = StabilityRateConfig({\n            debtIndex: uint128(WadRay.RAY),\n            stabilityRateBase: _setup.stabilityRateBase,\n            // solhint-disable not-rely-on-time\n            lastUpdateTimestamp: uint40(block.timestamp),\n            asset: _asset,\n            rateSlope1: _setup.rateSlope1,\n            rateSlope2: _setup.rateSlope2,\n            optimalPriceRate: _setup.optimalPriceRate,\n            priceRateDelta: _setup.priceRateDelta,\n            stabilityRate: uint128(WadRay.RAY)\n        });\n\n        emit InterestRateEvent.StabilityRateConfigured(\n            _asset,\n            _setup.stabilityRateBase,\n            _setup.priceRateDelta,\n            _setup.rateSlope1,\n            _setup.rateSlope2\n        );\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function updateStabilityRateParams(\n        address _asset,\n        StabilityRateParams memory _setup\n    ) external onlyRole(Role.ADMIN) {\n        require(irs().srAssets[_asset].asset == _asset, Error.STABILITY_RATES_NOT_INITIALIZED);\n        require(WadRay.RAY >= _setup.optimalPriceRate, Error.INVALID_OPTIMAL_RATE);\n        require(WadRay.RAY >= _setup.priceRateDelta, Error.INVALID_PRICE_RATE_DELTA);\n        require(_setup.stabilityRateBase >= WadRay.RAY, Error.INVALID_STABILITY_RATE_BASE);\n\n        irs().srAssets[_asset].rateSlope1 = _setup.rateSlope1;\n        irs().srAssets[_asset].rateSlope2 = _setup.rateSlope2;\n        irs().srAssets[_asset].optimalPriceRate = _setup.optimalPriceRate;\n        irs().srAssets[_asset].priceRateDelta = _setup.priceRateDelta;\n        irs().srAssets[_asset].stabilityRateBase = _setup.stabilityRateBase;\n\n        emit InterestRateEvent.StabilityRateConfigured(\n            _asset,\n            _setup.stabilityRateBase,\n            _setup.priceRateDelta,\n            _setup.rateSlope1,\n            _setup.rateSlope2\n        );\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function updateStabilityRateAndIndexForAsset(address _asset) external {\n        irs().srAssets[_asset].updateDebtIndex();\n        irs().srAssets[_asset].updateStabilityRate();\n    }\n\n    function updateKiss(address _kiss) external onlyRole(Role.ADMIN) {\n        irs().kiss = _kiss;\n        emit InterestRateEvent.KISSUpdated(_kiss);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                REPAYMENT                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IStabilityRateFacet\n    function repayStabilityRateInterestPartial(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kissRepayAmount\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) {\n        // Update debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n\n        // Get the accrued interest in repayment token\n        (, uint256 maxKissRepayAmount) = ms().getKreskoAssetDebtInterest(_account, _kreskoAsset);\n        require(_kissRepayAmount < maxKissRepayAmount, Error.INTEREST_REPAY_NOT_PARTIAL);\n\n        // If no interest has accrued or 0 amount was supplied as parameter - no further operations needed\n        // Do not revert because we want the preserve new debt index and stability rate\n        // Also removes the need to check if the kresko asset exists as the maxKissAmount will return 0\n        if (_kissRepayAmount == 0 || maxKissRepayAmount == 0) {\n            // Update stability rate for asset\n            irs().srAssets[_kreskoAsset].updateStabilityRate();\n            return;\n        }\n\n        // Transfer the accrued interest\n        IERC20Permit(irs().kiss).safeTransferFrom(msg.sender, ms().feeRecipient, _kissRepayAmount);\n        uint256 assetAmount = _kissRepayAmount.divByPrice(\n            ms().kreskoAssets[_kreskoAsset].uintPrice(ms().oracleDeviationPct)\n        );\n        uint256 amountScaled = assetAmount.wadToRay().rayDiv(newDebtIndex);\n        // Update scaled values for the user\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled -= uint128(amountScaled);\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n        // Update stability rate for asset\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n\n        // Emit event with the account, asset and amount repaid\n        emit InterestRateEvent.StabilityRateInterestRepaid(_account, _kreskoAsset, _kissRepayAmount);\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function repayFullStabilityRateInterest(\n        address _account,\n        address _kreskoAsset\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) returns (uint256 kissRepayAmount) {\n        return ms().repayFullStabilityRateInterest(_account, _kreskoAsset);\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function batchRepayFullStabilityRateInterest(\n        address _account\n    ) external nonReentrant returns (uint256 kissRepayAmount) {\n        address[] memory mintedKreskoAssets = ms().getMintedKreskoAssets(_account);\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            kissRepayAmount += ms().repayFullStabilityRateInterest(_account, mintedKreskoAssets[i]);\n        }\n        emit InterestRateEvent.StabilityRateInterestBatchRepaid(_account, kissRepayAmount);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   VIEWS                                    */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IStabilityRateFacet\n    function getStabilityRateForAsset(address _asset) external view returns (uint256 stabilityRate) {\n        return irs().srAssets[_asset].calculateStabilityRate();\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function getPriceRateForAsset(address _asset) external view returns (uint256 priceRate) {\n        return irs().srAssets[_asset].getPriceRate();\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function getDebtIndexForAsset(address _asset) external view returns (uint256 debtIndex) {\n        return irs().srAssets[_asset].getNormalizedDebtIndex();\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function getStabilityRateConfigurationForAsset(address _asset) external view returns (StabilityRateConfig memory) {\n        return irs().srAssets[_asset];\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function kiss() external view returns (address) {\n        return irs().kiss;\n    }\n\n    function getLastDebtIndexForAccount(\n        address _account,\n        address _asset\n    ) external view returns (uint128 lastDebtIndex) {\n        return irs().srUserInfo[_account][_asset].lastDebtIndex;\n    }\n}\n"
    },
    "src/contracts/minter/facets/StateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IStateFacet} from \"../interfaces/IStateFacet.sol\";\n\nimport {MinterParams, KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {MinterState, ms} from \"../MinterStorage.sol\";\n\n/**\n * @author Kresko\n * @title View functions for protocol parameters and asset values\n * @dev As structs do not create views for members, we must expose most of the state values explicitly.\n */\ncontract StateFacet is IStateFacet {\n    /// @inheritdoc IStateFacet\n    function domainSeparator() external view returns (bytes32) {\n        return ms().domainSeparator;\n    }\n\n    /// @inheritdoc IStateFacet\n    function minterInitializations() external view returns (uint256) {\n        return ms().initializations;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Configurables                               */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IStateFacet\n    function feeRecipient() external view returns (address) {\n        return ms().feeRecipient;\n    }\n\n    /// @inheritdoc IStateFacet\n    function ammOracle() external view returns (address) {\n        return ms().ammOracle;\n    }\n\n    /// @inheritdoc IStateFacet\n    function extOracleDecimals() external view returns (uint8) {\n        return ms().extOracleDecimals;\n    }\n\n    /// @inheritdoc IStateFacet\n    function minimumCollateralizationRatio() external view returns (uint256) {\n        return ms().minimumCollateralizationRatio;\n    }\n\n    /// @inheritdoc IStateFacet\n    function liquidationIncentiveMultiplier() external view returns (uint256) {\n        return ms().liquidationIncentiveMultiplier;\n    }\n\n    /// @inheritdoc IStateFacet\n    function minimumDebtValue() external view returns (uint256) {\n        return ms().minimumDebtValue;\n    }\n\n    /// @inheritdoc IStateFacet\n    function liquidationThreshold() external view returns (uint256) {\n        return ms().liquidationThreshold;\n    }\n\n    /// @inheritdoc IStateFacet\n    function maxLiquidationMultiplier() external view returns (uint256) {\n        return ms().maxLiquidationMultiplier;\n    }\n\n    /// @inheritdoc IStateFacet\n    function oracleDeviationPct() external view returns (uint256) {\n        return ms().oracleDeviationPct;\n    }\n\n    /// @inheritdoc IStateFacet\n    function getAllParams() external view returns (MinterParams memory) {\n        MinterState storage s = ms();\n        return\n            MinterParams(\n                s.minimumCollateralizationRatio,\n                s.minimumDebtValue,\n                s.liquidationThreshold,\n                s.liquidationIncentiveMultiplier,\n                s.feeRecipient,\n                s.extOracleDecimals,\n                s.oracleDeviationPct\n            );\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Assets                                   */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IStateFacet\n    function krAssetExists(address _kreskoAsset) external view returns (bool exists) {\n        return ms().kreskoAssets[_kreskoAsset].exists;\n    }\n\n    /// @inheritdoc IStateFacet\n    function kreskoAsset(address _kreskoAsset) external view returns (KrAsset memory asset) {\n        return ms().kreskoAsset(_kreskoAsset);\n    }\n\n    /// @inheritdoc IStateFacet\n    function collateralExists(address _collateralAsset) external view returns (bool exists) {\n        return ms().collateralAssets[_collateralAsset].exists;\n    }\n\n    /// @inheritdoc IStateFacet\n    function collateralAsset(address _collateralAsset) external view returns (CollateralAsset memory asset) {\n        return ms().collateralAssets[_collateralAsset];\n    }\n\n    /// @inheritdoc IStateFacet\n    function getCollateralValueAndOraclePrice(\n        address _collateralAsset,\n        uint256 _amount,\n        bool _ignoreCollateralFactor\n    ) external view returns (uint256 value, uint256 oraclePrice) {\n        return ms().getCollateralValueAndOraclePrice(_collateralAsset, _amount, _ignoreCollateralFactor);\n    }\n\n    /// @inheritdoc IStateFacet\n    function getKrAssetValue(\n        address _kreskoAsset,\n        uint256 _amount,\n        bool _ignoreKFactor\n    ) external view returns (uint256 value) {\n        return ms().getKrAssetValue(_kreskoAsset, _amount, _ignoreKFactor);\n    }\n}\n"
    },
    "src/contracts/minter/facets/UIDataProviderFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n/* solhint-disable max-line-length */\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable func-name-mixedcase */\n/* solhint-disable contract-name-camelcase */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\nimport {LibUI, IKrStaking, IUniswapV2Pair, IERC20Permit, ms} from \"../libs/LibUI.sol\";\n\n/**\n * @author Kresko\n * @title UIDataProviderFacet\n * @notice UI data aggregation views\n */\ncontract UIDataProviderFacet {\n    function getAccountData(\n        address _account,\n        address[] memory _tokens,\n        address _staking\n    )\n        external\n        view\n        returns (LibUI.KreskoUser memory user, LibUI.Balance[] memory balances, LibUI.StakingData[] memory stakingData)\n    {\n        user = LibUI.kreskoUser(_account);\n        balances = LibUI.getBalances(_tokens, _account);\n        stakingData = LibUI.getStakingData(_account, _staking);\n    }\n\n    function batchOracleValues(\n        address[] memory _assets,\n        address[] memory _oracles,\n        address[] memory _marketStatusOracles\n    ) public view returns (LibUI.Price[] memory result) {\n        return LibUI.batchOracleValues(_assets, _oracles, _marketStatusOracles);\n    }\n\n    function getTokenData(\n        address[] memory _allTokens,\n        address[] memory _assets,\n        address[] memory _priceFeeds,\n        address[] memory _marketStatusOracles\n    ) external view returns (LibUI.TokenMetadata[] memory metadatas, LibUI.Price[] memory prices) {\n        metadatas = new LibUI.TokenMetadata[](_allTokens.length);\n        for (uint256 i; i < _allTokens.length; i++) {\n            metadatas[i] = LibUI.TokenMetadata({\n                decimals: IERC20Permit(_allTokens[i]).decimals(),\n                name: IERC20Permit(_allTokens[i]).name(),\n                symbol: IERC20Permit(_allTokens[i]).symbol(),\n                totalSupply: IERC20Permit(_allTokens[i]).totalSupply()\n            });\n        }\n        prices = LibUI.batchOracleValues(_assets, _priceFeeds, _marketStatusOracles);\n    }\n}\n"
    },
    "src/contracts/minter/facets/UIDataProviderFacet2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n/* solhint-disable max-line-length */\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable func-name-mixedcase */\n/* solhint-disable contract-name-camelcase */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\nimport {LibUI, IKrStaking, IUniswapV2Pair, IERC20Permit, ms} from \"../libs/LibUI.sol\";\n\n/**\n * @author Kresko\n * @title UIDataProviderFacet2\n * @notice UI data aggregation views\n */\ncontract UIDataProviderFacet2 {\n    function getGlobalData(\n        address[] memory _collateralAssets,\n        address[] memory _krAssets\n    )\n        external\n        view\n        returns (\n            LibUI.CollateralAssetInfo[] memory collateralAssets,\n            LibUI.krAssetInfo[] memory krAssets,\n            LibUI.ProtocolParams memory protocolParams\n        )\n    {\n        collateralAssets = LibUI.collateralAssetInfos(_collateralAssets);\n        krAssets = LibUI.krAssetInfos(_krAssets);\n        protocolParams = LibUI.ProtocolParams({\n            minCollateralRatio: ms().minimumCollateralizationRatio,\n            minDebtValue: ms().minimumDebtValue,\n            liquidationThreshold: ms().liquidationThreshold\n        });\n    }\n\n    function getPairsData(address[] memory _pairAddresses) external view returns (LibUI.PairData[] memory result) {\n        result = new LibUI.PairData[](_pairAddresses.length);\n        for (uint256 i; i < _pairAddresses.length; i++) {\n            IUniswapV2Pair pair = IUniswapV2Pair(_pairAddresses[i]);\n            (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\n            result[i] = LibUI.PairData({\n                decimals0: IERC20Permit(pair.token0()).decimals(),\n                decimals1: IERC20Permit(pair.token1()).decimals(),\n                totalSupply: pair.totalSupply(),\n                reserve0: reserve0,\n                reserve1: reserve1\n            });\n        }\n    }\n}\n"
    },
    "src/contracts/minter/initializers/FacetUpgrade16052023.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {ms} from \"../MinterStorage.sol\";\nimport {CollateralAsset} from \"../MinterTypes.sol\";\nimport {IFluxPriceFeed} from \"../../vendor/flux/FluxPriceFeed.sol\";\nimport {AggregatorV3Interface} from \"../../vendor/AggregatorV3Interface.sol\";\n\n/* solhint-disable var-name-mixedcase */\ninterface NewKresko {\n    function collateralAsset(address) external view returns (CollateralAsset memory);\n}\n\ninterface OldKresko {\n    struct CollateralOld {\n        uint256 factor;\n        AggregatorV3Interface oracle;\n        IFluxPriceFeed marketStatusOracle;\n        address anchor;\n        uint8 decimals;\n        bool exists;\n    }\n\n    function collateralAsset(address) external view returns (CollateralOld memory);\n}\n\ncontract FacetUpgrade16052023 {\n    function initialize() external {\n        ms().initializations += 1;\n        address DAI = 0x7ff84e6d3111327ED63eb97691Bf469C7fcE832F;\n        address WETH = 0x4200000000000000000000000000000000000006;\n        address krBTC = 0xf88721B9C87EBc86E3C91E6C98c0f646a75600f4;\n        address krETH = 0xbb37d6016f97Dd369eCB76e2A5036DacD8770f8b;\n        address krTSLA = 0x3502B0329a45011C8FEE033B8eEe6BDA89c03081;\n        address KISS = 0xC0B5aBa9F46bDf4D1bC52a4C3ab05C857aC4Ee80;\n        address[] memory collateralAssets = new address[](6);\n        collateralAssets[0] = DAI;\n        collateralAssets[1] = WETH;\n        collateralAssets[2] = krBTC;\n        collateralAssets[3] = krETH;\n        collateralAssets[4] = krTSLA;\n        collateralAssets[5] = KISS;\n        for (uint i = 0; i < collateralAssets.length; i++) {\n            address asset = collateralAssets[i];\n            ms().collateralAssets[asset].liquidationIncentive = 1.05 ether;\n        }\n\n        require(ms().collateralAssets[DAI].exists, \"!found\");\n        require(ms().collateralAssets[WETH].liquidationIncentive == 1.05 ether, \"!config\");\n\n        uint256 liqIncentive = NewKresko(0x0921a7234a2762aaB3C43d3b1F51dB5D8094a04b)\n            .collateralAsset(krBTC)\n            .liquidationIncentive;\n        require(liqIncentive == 1.05 ether, \"!found-new\");\n    }\n}\n"
    },
    "src/contracts/minter/InterestRateState.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {LibStabilityRate} from \"./libs/LibStabilityRate.sol\";\n\nusing LibStabilityRate for StabilityRateConfig global;\n\n/* solhint-disable var-name-mixedcase */\n\n// Asset data\nstruct StabilityRateConfig {\n    // Interest index for debt\n    uint128 debtIndex;\n    // Represents the optimal price rate between an oracle report and an AMM twap\n    uint128 optimalPriceRate;\n    // Slope of the variable interest curve when rate > 0 and <= optimalPriceRate.\n    // Expressed in ray\n    uint128 rateSlope1;\n    // Slope of the variable interest curve when rate > optimalPriceRate.\n    // Expressed in ray\n    uint128 rateSlope2;\n    /**\n     * Represents the excess price premium in either direction.\n     * Expressed in ray\n     * Eg. 1/20 ray = 5% price premium in either direction is considered excess\n     */\n    uint128 priceRateDelta;\n    // Current accrual rate for debt\n    uint128 stabilityRate;\n    // Base accrual rate for debt\n    uint128 stabilityRateBase;\n    // Asset to configure\n    address asset;\n    // Last update for the asset\n    uint40 lastUpdateTimestamp;\n}\n\n// User data\nstruct StabilityRateUser {\n    uint128 debtScaled;\n    uint128 lastDebtIndex;\n}\n\n// Storage layout\nstruct InterestRateState {\n    // asset address -> asset data\n    mapping(address => StabilityRateConfig) srAssets;\n    // account address -> asset address -> user data\n    mapping(address => mapping(address => StabilityRateUser)) srUserInfo;\n    // interest repayment token is KISS\n    address kiss;\n}\n\n// Storage position\nbytes32 constant INTEREST_RATE_STORAGE_POSITION = keccak256(\"kresko.interest.rate.storage\");\n\n// solhint-disable func-visibility\nfunction irs() pure returns (InterestRateState storage state) {\n    bytes32 position = INTEREST_RATE_STORAGE_POSITION;\n    assembly {\n        state.slot := position\n    }\n}\n"
    },
    "src/contracts/minter/interfaces/IAccountStateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {Action} from \"../MinterTypes.sol\";\n\ninterface IAccountStateFacet {\n    // ExpectedFeeRuntimeInfo is used for stack size optimization\n    struct ExpectedFeeRuntimeInfo {\n        address[] assets;\n        uint256[] amounts;\n        uint256 collateralTypeCount;\n    }\n\n    /**\n     * @notice Gets an array of Kresko assets the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @return An array of addresses of Kresko assets the account has minted.\n     */\n    function getMintedKreskoAssets(address _account) external view returns (address[] memory);\n\n    /**\n     * @notice Gets an index for the Kresko asset the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @param _kreskoAsset The asset lookup address.\n     * @return index of the minted Kresko asset.\n     */\n    function getMintedKreskoAssetsIndex(address _account, address _kreskoAsset) external view returns (uint256);\n\n    /**\n     * @notice Gets the Kresko asset value in USD of a particular account.\n     * @param _account The account to calculate the Kresko asset value for.\n     * @return The Kresko asset value of a particular account.\n     */\n    function getAccountKrAssetValue(address _account) external view returns (uint256);\n\n    /**\n     * @notice Get `_account` debt amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of debt for `_asset`\n     */\n    function kreskoAssetDebt(address _account, address _asset) external view returns (uint256);\n\n    /**\n     * @notice Get `_account` principal debt amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of principal debt for `_asset`\n     */\n    function kreskoAssetDebtPrincipal(address _account, address _asset) external view returns (uint256);\n\n    /**\n     * @notice Get `_account` interest amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return assetAmount the interest denominated in _asset\n     * @return kissAmount the interest denominated in KISS, ignores K-factor\n     */\n    function kreskoAssetDebtInterest(\n        address _account,\n        address _asset\n    ) external view returns (uint256 assetAmount, uint256 kissAmount);\n\n    /**\n     * @notice Get `_account` interest amount for `_asset`\n     * @param _account The account to query amount for\n     * @return kissAmount the interest denominated in KISS, ignores K-factor\n     */\n    function kreskoAssetDebtInterestTotal(address _account) external view returns (uint256 kissAmount);\n\n    /**\n     * @notice Gets the collateral value of a particular account.\n     * @dev O(# of different deposited collateral assets by account) complexity.\n     * @param _account The account to calculate the collateral value for.\n     * @return The collateral value of a particular account.\n     */\n    function getAccountCollateralValue(address _account) external view returns (uint256);\n\n    /**\n     * @notice Get an account's minimum collateral value required\n     * to back a Kresko asset amount at a given collateralization ratio.\n     * @dev Accounts that have their collateral value under the minimum collateral value are considered unhealthy,\n     *      accounts with their collateral value under the liquidation threshold are considered liquidatable.\n     * @param _account The account to calculate the minimum collateral value for.\n     * @param _ratio The collateralization ratio required: higher ratio = more collateral required\n     * @return The minimum collateral value of a particular account.\n     */\n    function getAccountMinimumCollateralValueAtRatio(address _account, uint256 _ratio) external view returns (uint256);\n\n    /**\n     * @notice Get a list of accounts and their collateral ratios\n     * @return ratio for an `_account`\n     */\n    function getAccountCollateralRatio(address _account) external view returns (uint256 ratio);\n\n    /**\n     * @notice Get a list of accounts and their collateral ratios\n     * @return ratios of the accounts\n     */\n    function getCollateralRatiosFor(address[] memory _accounts) external view returns (uint256[] memory);\n\n    /**\n     * @notice Get the adjusted value of collateral and the real value of collateral\n     * @dev The adjusted value of collateral is the value of collateral after adjusting for the cFactor\n     * @param _account The account to get the collateral values for.\n     * @param _asset The asset to get the collateral values for.\n     * @return adjustedValue The adjusted value of the collateral.\n     * @return realValue The real value of the collateral.\n     */\n    function getCollateralAdjustedAndRealValue(\n        address _account,\n        address _asset\n    ) external view returns (uint256 adjustedValue, uint256 realValue);\n\n    /**\n     * @notice Gets an index for the collateral asset the account has deposited.\n     * @param _account The account to get the index for.\n     * @param _collateralAsset The asset lookup address.\n     * @return i = index of the minted collateral asset.\n     */\n    function getDepositedCollateralAssetIndex(\n        address _account,\n        address _collateralAsset\n    ) external view returns (uint256 i);\n\n    /**\n     * @notice Gets an array of collateral assets the account has deposited.\n     * @param _account The account to get the deposited collateral assets for.\n     * @return An array of addresses of collateral assets the account has deposited.\n     */\n    function getDepositedCollateralAssets(address _account) external view returns (address[] memory);\n\n    /**\n     * @notice Get `_account` collateral deposit amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of collateral deposited for `_asset`\n     */\n    function collateralDeposits(address _account, address _asset) external view returns (uint256);\n\n    /**\n     * @notice Calculates the expected fee to be taken from a user's deposited collateral assets,\n     *         by imitating calcFee without modifying state.\n     * @param _account The account to charge the open fee from.\n     * @param _kreskoAsset The address of the kresko asset being burned.\n     * @param _kreskoAssetAmount The amount of the kresko asset being minted.\n     * @param _feeType The fee type (open, close, etc).\n     * @return assets The collateral types as an array of addresses.\n     * @return amounts The collateral amounts as an array of uint256.\n     */\n    function calcExpectedFee(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kreskoAssetAmount,\n        uint256 _feeType\n    ) external view returns (address[] memory, uint256[] memory);\n}\n"
    },
    "src/contracts/minter/interfaces/IBurnFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface IBurnFacet {\n    /**\n     * @notice Burns existing Kresko assets.\n     * @param _account The address to burn kresko assets for\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _burnAmount The amount of the Kresko asset to be burned.\n     * @param _mintedKreskoAssetIndex The index of the kresko asset in the user's minted assets array.\n     * @notice Only needed if burning all principal debt of a particular collateral asset.\n     */\n    function burnKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _burnAmount,\n        uint256 _mintedKreskoAssetIndex\n    ) external;\n}\n"
    },
    "src/contracts/minter/interfaces/IBurnHelperFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\ninterface IBurnHelperFacet {\n    /**\n     * @notice Attempts to close all debt positions and interest\n     * @notice Account must have enough of krAsset balance to burn and enough KISS to cover interest\n     * @param _account The address to close the positions for\n     */\n    function batchCloseKrAssetDebtPositions(address _account) external;\n\n    /**\n     * @notice Burns all Kresko asset debt and repays interest.\n     * @notice Account must have enough of krAsset balance to burn and enough KISS to cover interest\n     * @param _account The address to close the position for\n     * @param _kreskoAsset The address of the Kresko asset.\n     */\n    function closeKrAssetDebtPosition(address _account, address _kreskoAsset) external;\n}\n"
    },
    "src/contracts/minter/interfaces/ICollateralReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface ICollateralReceiver {\n    function onUncheckedCollateralWithdraw(\n        address _account,\n        address _collateralAsset,\n        uint _withdrawalAmount,\n        uint _depositedCollateralAssetIndex,\n        bytes memory _userData\n    ) external returns (bytes memory);\n}\n"
    },
    "src/contracts/minter/interfaces/IConfigurationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {MinterInitArgs, KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\n\ninterface IConfigurationFacet {\n    function initialize(MinterInitArgs calldata args) external;\n\n    /**\n     * @notice Adds a collateral asset to the protocol.\n     * @dev Only callable by the owner and cannot be called more than once for an asset.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _config The configuration for the collateral asset.\n     */\n    function addCollateralAsset(address _collateralAsset, CollateralAsset memory _config) external;\n\n    /**\n     * @notice Adds a KreskoAsset to the protocol.\n     * @dev Only callable by the owner.\n     * @param _krAsset The address of the wrapped KreskoAsset, needs to support IKreskoAsset.\n     * @param _config Configuration for the KreskoAsset.\n     */\n    function addKreskoAsset(address _krAsset, KrAsset memory _config) external;\n\n    /**\n     * @notice Updates a previously added collateral asset.\n     * @dev Only callable by the owner.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _config The configuration for the collateral asset.\n     */\n    function updateCollateralAsset(address _collateralAsset, CollateralAsset memory _config) external;\n\n    /**\n     * @notice Updates a previously added kresko asset.\n     * @dev Only callable by the owner.\n     * @param _krAsset The address of the KreskoAsset.\n     * @param _config Configuration for the KreskoAsset.\n     */\n    function updateKreskoAsset(address _krAsset, KrAsset memory _config) external;\n\n    /**\n     * @notice Updates the fee recipient.\n     * @param _feeRecipient The new fee recipient.\n     */\n    function updateFeeRecipient(address _feeRecipient) external;\n\n    /**\n     * @notice  Updates the cFactor of a KreskoAsset.\n     * @param _collateralAsset The collateral asset.\n     * @param _cFactor The new cFactor.\n     */\n    function updateCFactor(address _collateralAsset, uint256 _cFactor) external;\n\n    /**\n     * @notice Updates the kFactor of a KreskoAsset.\n     * @param _kreskoAsset The KreskoAsset.\n     * @param _kFactor The new kFactor.\n     */\n    function updateKFactor(address _kreskoAsset, uint256 _kFactor) external;\n\n    /**\n     * @notice Updates the liquidation incentive multiplier.\n     * @param _collateralAsset The collateral asset to update it for.\n     * @param _liquidationIncentiveMultiplier The new liquidation incentive multiplie.\n     */\n    function updateLiquidationIncentiveMultiplier(\n        address _collateralAsset,\n        uint256 _liquidationIncentiveMultiplier\n    ) external;\n\n    /**\n     * @notice Updates the max liquidation usd overflow multiplier value.\n     * @param _maxLiquidationMultiplier Overflow value in percent, 18 decimals.\n     */\n    function updateMaxLiquidationMultiplier(uint256 _maxLiquidationMultiplier) external;\n\n    /**\n     * @dev Updates the contract's collateralization ratio.\n     * @param _minimumCollateralizationRatio The new minimum collateralization ratio as wad.\n     */\n    function updateMinimumCollateralizationRatio(uint256 _minimumCollateralizationRatio) external;\n\n    /**\n     * @dev Updates the contract's minimum debt value.\n     * @param _minimumDebtValue The new minimum debt value as a wad.\n     */\n    function updateMinimumDebtValue(uint256 _minimumDebtValue) external;\n\n    /**\n     * @dev Updates the contract's liquidation threshold value\n     * @param _liquidationThreshold The new liquidation threshold value\n     */\n    function updateLiquidationThreshold(uint256 _liquidationThreshold) external;\n\n    /**\n     * @notice Sets the protocol AMM oracle address\n     * @param _ammOracle  The address of the oracle\n     */\n    function updateAMMOracle(address _ammOracle) external;\n\n    /**\n     * @notice Sets the decimal precision of external oracle\n     * @param _decimals Amount of decimals\n     */\n    function updateExtOracleDecimals(uint8 _decimals) external;\n\n    /**\n     * @notice Sets the decimal precision of external oracle\n     * @param _oracleDeviationPct Amount of decimals\n     */\n    function updateOracleDeviationPct(uint256 _oracleDeviationPct) external;\n\n    /**\n     * @notice Sets L2 sequencer uptime feed address\n     * @param _sequencerUptimeFeed sequencer uptime feed address\n     */\n    function updateSequencerUptimeFeed(address _sequencerUptimeFeed) external;\n\n    /**\n     * @notice Sets sequencer grace period time\n     * @param _sequencerGracePeriodTime grace period time\n     */\n    function updateSequencerGracePeriodTime(uint256 _sequencerGracePeriodTime) external;\n\n    /**\n     * @notice Sets oracle timeout\n     * @param _oracleTimeout oracle timeout in seconds\n     */\n    function updateOracleTimeout(uint256 _oracleTimeout) external;\n}\n"
    },
    "src/contracts/minter/interfaces/IDepositWithdrawFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface IDepositWithdrawFacet {\n    /**\n     * @notice Deposits collateral into the protocol.\n     * @param _account The user to deposit collateral for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _depositAmount The amount of the collateral asset to deposit.\n     */\n    function depositCollateral(address _account, address _collateralAsset, uint256 _depositAmount) external;\n\n    /**\n     * @notice Withdraws sender's collateral from the protocol.\n     * @dev Requires that the post-withdrawal collateral value does not violate minimum collateral requirement.\n     * @param _account The address to withdraw assets for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\n     * @param _depositedCollateralAssetIndex The index of the collateral asset in the sender's deposited collateral\n     * assets array. Only needed if withdrawing the entire deposit of a particular collateral asset.\n     */\n    function withdrawCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _depositedCollateralAssetIndex\n    ) external;\n\n    /**\n     * @notice Withdraws sender's collateral from the protocol before checking minimum collateral ratio.\n     * @dev Executes post-withdraw-callback triggering onUncheckedCollateralWithdraw on the caller\n     * @dev Requires that the post-withdraw-callback collateral value does not violate minimum collateral requirement.\n     * @param _account The address to withdraw assets for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\n     * @param _depositedCollateralAssetIndex The index of the collateral asset in the sender's deposited collateral\n     * assets array. Only needed if withdrawing the entire deposit of a particular collateral asset.\n     */\n    function withdrawCollateralUnchecked(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _depositedCollateralAssetIndex,\n        bytes memory _userData\n    ) external;\n}\n"
    },
    "src/contracts/minter/interfaces/IInterestLiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface IInterestLiquidationFacet {\n    /**\n     * @notice Attempts to batch liquidate all KISS interest accrued for an account in a unhealthy position\n     * @notice Liquidator must have the KISS balance required with the Kresko contract approved\n     * @notice Checks liquidatable status on each iteration liquidating only what is necessary\n     * @param _account The account to attempt to liquidate.\n     * @param _collateralAssetToSeize The address of the collateral asset to be seized.\n     * @param _allowSeizeUnderflow Allow the amount of collateral to be seized to be less than the amount calculated.\n     */\n    function batchLiquidateInterest(\n        address _account,\n        address _collateralAssetToSeize,\n        bool _allowSeizeUnderflow\n    ) external;\n\n    /**\n     * @notice Attempts to liquidate all KISS interest accrued for an account in a unhealthy position\n     * @notice Liquidator must have the KISS balance required with the Kresko contract approved\n     * @param _account The account to attempt to liquidate.\n     * @param _repayKreskoAsset The address of the Kresko asset to be repaid.\n     * @param _collateralAssetToSeize The address of the collateral asset to be seized.\n     * @param _allowSeizeUnderflow Allow the amount of collateral to be seized to be less than the amount calculated.\n     */\n    function liquidateInterest(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize,\n        bool _allowSeizeUnderflow\n    ) external;\n}\n"
    },
    "src/contracts/minter/interfaces/ILiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface ILiquidationFacet {\n    /**\n     * @notice Attempts to liquidate an account by repaying the portion of the account's Kresko asset\n     *         princpal debt, receiving in return a portion of the account's collateral at a discounted rate.\n     * @param _account The account to attempt to liquidate.\n     * @param _repayAsset The address of the Kresko asset to be repaid.\n     * @param _repayAmount The amount of the Kresko asset to be repaid.\n     * @param _seizeAsset The address of the collateral asset to be seized.\n     * @param _repayAssetIndex The index of the Kresko asset in the account's minted assets array.\n     * @param _seizeAssetIndex Index of the collateral asset in the account's collateral assets array.\n     * @param _allowSeizeUnderflow Allow the amount of collateral to be seized to be less than the amount calculated.\n     */\n    function liquidate(\n        address _account,\n        address _repayAsset,\n        uint256 _repayAmount,\n        address _seizeAsset,\n        uint256 _repayAssetIndex,\n        uint256 _seizeAssetIndex,\n        bool _allowSeizeUnderflow\n    ) external;\n\n    /**\n     * @notice used execute _liquidateAssets.\n     * @param account The account to attempt to liquidate.\n     * @param repayAmount The amount of the Kresko asset to be repaid.\n     * @param seizeAmount The calculated amount of collateral assets to be seized.\n     * @param repayAsset The address of the Kresko asset to be repaid.\n     * @param repayIndex The index of the Kresko asset in the user's minted assets array.\n     * @param seizeAsset The address of the collateral asset to be seized.\n     * @param seizeAssetIndex The index of the collateral asset in the account's collateral assets array.\n     * @param allowSeizeUnderflow Allow the amount of collateral to be seized to be less than the amount calculated.\n     */\n    struct ExecutionParams {\n        address account;\n        uint256 repayAmount;\n        uint256 seizeAmount;\n        address repayAsset;\n        uint256 repayAssetIndex;\n        address seizedAsset;\n        uint256 seizedAssetIndex;\n        bool allowSeizeUnderflow;\n    }\n\n    /**\n     * @dev Calculates the total value that can be liquidated for a liquidation pair\n     * @param _account address to liquidate\n     * @param _repayKreskoAsset address of the kreskoAsset being repaid on behalf of the liquidatee\n     * @return maxLiquidatableUSD USD value that can be liquidated, 0 if the pair has no liquidatable value\n     */\n    function getMaxLiquidation(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize\n    ) external view returns (uint256 maxLiquidatableUSD);\n\n    /**\n     * @notice Calculates if an account's current collateral value is under its minimum collateral value\n     * @dev Returns true if the account's current collateral value is below the minimum collateral value\n     * required to consider the position healthy.\n     * @param _account The account to check.\n     * @return A boolean indicating if the account can be liquidated.\n     */\n    function isAccountLiquidatable(address _account) external view returns (bool);\n}\n"
    },
    "src/contracts/minter/interfaces/IMintFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface IMintFacet {\n    /**\n     * @notice Mints new Kresko assets.\n     * @param _account The address to mint assets for.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _mintAmount The amount of the Kresko asset to be minted.\n     */\n    function mintKreskoAsset(address _account, address _kreskoAsset, uint256 _mintAmount) external;\n}\n"
    },
    "src/contracts/minter/interfaces/ISafetyCouncilFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {Action, SafetyState, Pause} from \"../MinterTypes.sol\";\n\ninterface ISafetyCouncilFacet {\n    /**\n     * @dev Toggle paused-state of assets in a per-action basis\n     *\n     * @notice These functions are only callable by a multisig quorum.\n     * @param _assets list of addresses of krAssets and/or collateral assets\n     * @param _action One of possible user actions:\n     *  Deposit = 0\n     *  Withdraw = 1,\n     *  Repay = 2,\n     *  Borrow = 3,\n     *  Liquidate = 4\n     * @param _withDuration Set a duration for this pause - @todo: implement it if required\n     * @param _duration Duration for the pause if `_withDuration` is true\n     */\n    function toggleAssetsPaused(\n        address[] memory _assets,\n        Action _action,\n        bool _withDuration,\n        uint256 _duration\n    ) external;\n\n    /**\n     * @notice set the safetyStateSet flag\n     */\n    function setSafetyStateSet(bool val) external;\n\n    /**\n     * @notice For external checks if a safety state has been set for any asset\n     */\n    function safetyStateSet() external view returns (bool);\n\n    /**\n     * @notice View the state of safety measures for an asset on a per-action basis\n     * @param _asset krAsset / collateral asset\n     * @param _action One of possible user actions:\n     *\n     *  Deposit = 0\n     *  Withdraw = 1,\n     *  Repay = 2,\n     *  Borrow = 3,\n     *  Liquidate = 4\n     */\n    function safetyStateFor(address _asset, Action _action) external view returns (SafetyState memory);\n\n    /**\n     * @notice Check if `_asset` has a pause enabled for `_action`\n     * @param _action enum `Action`\n     *  Deposit = 0\n     *  Withdraw = 1,\n     *  Repay = 2,\n     *  Borrow = 3,\n     *  Liquidate = 4\n     * @return true if `_action` is paused\n     */\n    function assetActionPaused(Action _action, address _asset) external view returns (bool);\n}\n"
    },
    "src/contracts/minter/interfaces/IStabilityRateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {StabilityRateParams} from \"../facets/StabilityRateFacet.sol\";\nimport {StabilityRateConfig} from \"../InterestRateState.sol\";\n\ninterface IStabilityRateFacet {\n    /**\n     * @notice Initialize an asset with stability rate setup values\n     * @param _asset asset to setup\n     * @param _setup setup parameters\n     */\n    function setupStabilityRateParams(address _asset, StabilityRateParams memory _setup) external;\n\n    /**\n     * @notice Configure existing stability rate values\n     * @param _asset asset to configure\n     * @param _setup setup parameters\n     */\n    function updateStabilityRateParams(address _asset, StabilityRateParams memory _setup) external;\n\n    /// @notice Updates the debt index and stability rates for an asset\n    /// @param _asset asset to update rate and index for\n    function updateStabilityRateAndIndexForAsset(address _asset) external;\n\n    /**\n     * @notice Sets the protocol AMM oracle address\n     * @param _kiss  The address of the oracle\n     */\n    function updateKiss(address _kiss) external;\n\n    /**\n     * @notice Repays part of accrued stability rate interest for a single asset\n     * @param _account Account to repay interest for\n     * @param _kreskoAsset Kresko asset to repay interest for\n     * @param _kissRepayAmount USD value to repay (KISS)\n     */\n    function repayStabilityRateInterestPartial(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kissRepayAmount\n    ) external;\n\n    /**\n     * @notice Repays accrued stability rate interest for a single asset\n     * @param _account Account to repay interest for\n     * @param _kreskoAsset Kresko asset to repay interest for\n     * @return kissRepayAmount KISS value repaid\n     */\n    function repayFullStabilityRateInterest(\n        address _account,\n        address _kreskoAsset\n    ) external returns (uint256 kissRepayAmount);\n\n    /**\n     * @notice Repays all accrued stability rate interest for an account\n     * @param _account Account to repay all asset interests for\n     * @return kissRepayAmount KISS value repaid\n     */\n    function batchRepayFullStabilityRateInterest(address _account) external returns (uint256 kissRepayAmount);\n\n    /**\n     * @notice Gets the current stability rate for an asset\n     * @param _asset asset to get the stability rate for\n     * @return stabilityRate the return variables of a contract’s function state variable\n     * @dev expressed in ray\n     */\n    function getStabilityRateForAsset(address _asset) external view returns (uint256 stabilityRate);\n\n    /**\n     * @notice Gets the current price rate (difference between AMM <-> Oracle pricing)\n     * for an asset\n     * @param _asset asset to get the rate for\n     * @return priceRate the current\n     * @dev expressed in ray\n     */\n    function getPriceRateForAsset(address _asset) external view returns (uint256 priceRate);\n\n    /**\n     * @notice Gets the current running debt index\n     * @param _asset asset to get the index for\n     * @return debtIndex current running debt index\n     * @dev expressed in ray\n     */\n    function getDebtIndexForAsset(address _asset) external view returns (uint256 debtIndex);\n\n    /**\n     * @notice View stability rate configuration for an asset\n     * @param _asset asset to view configuration for\n     */\n    function getStabilityRateConfigurationForAsset(address _asset) external view returns (StabilityRateConfig memory);\n\n    /**\n     * @notice The configured address of KISS\n     */\n    function kiss() external view returns (address);\n\n    /**\n     * @notice Get user stability rate data for an asset\n     * @param _account asset to view configuration for\n     * @param _asset asset to view configuration for\n     * @return lastDebtIndex the previous debt index for the user\n     */\n    function getLastDebtIndexForAccount(address _account, address _asset) external view returns (uint128 lastDebtIndex);\n}\n"
    },
    "src/contracts/minter/interfaces/IStateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {CollateralAsset, KrAsset, MinterParams} from \"../MinterTypes.sol\";\n\ninterface IStateFacet {\n    /// @notice The EIP-712 typehash for the contract's domain.\n    function domainSeparator() external view returns (bytes32);\n\n    /// @notice amount of times the minter has been initialized\n    function minterInitializations() external view returns (uint256);\n\n    /// @notice The recipient of protocol fees.\n    function feeRecipient() external view returns (address);\n\n    /// @notice The AMM oracle address.\n    function ammOracle() external view returns (address);\n\n    /// @notice Offchain oracle decimals\n    function extOracleDecimals() external view returns (uint8);\n\n    /// @notice The collateralization ratio at which positions may be liquidated.\n    function liquidationThreshold() external view returns (uint256);\n\n    /// @notice The factor used to calculate the incentive a liquidator receives in the form of seized collateral.\n    function liquidationIncentiveMultiplier() external view returns (uint256);\n\n    /// @notice Multiplies max liquidatable value, allowing liquidations to go over LT.\n    function maxLiquidationMultiplier() external view returns (uint256);\n\n    /// @notice max deviation between main oracle and fallback oracle\n    function oracleDeviationPct() external view returns (uint256);\n\n    /// @notice The minimum ratio of collateral to debt that can be taken by direct action.\n    function minimumCollateralizationRatio() external view returns (uint256);\n\n    /// @notice The minimum USD value of an individual synthetic asset debt position.\n    function minimumDebtValue() external view returns (uint256);\n\n    /// @notice simple check if kresko asset exists\n    function krAssetExists(address _krAsset) external view returns (bool);\n\n    /**\n     * @notice Get the state of a specific krAsset\n     * @param _asset Address of the asset.\n     * @return State of assets `KrAsset` struct\n     */\n    function kreskoAsset(address _asset) external view returns (KrAsset memory);\n\n    /// @notice Mapping of collateral asset token address to information on the collateral asset.\n    function collateralAsset(address _asset) external view returns (CollateralAsset memory);\n\n    /// @notice simple check if collateral asset exists\n    function collateralExists(address _collateralAsset) external view returns (bool);\n\n    /// @notice get all meaningful protocol parameters\n    function getAllParams() external view returns (MinterParams memory);\n\n    /**\n     * @notice Gets the USD value for a single collateral asset and amount.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _amount The amount of the collateral asset to calculate the value for.\n     * @param _ignoreCollateralFactor Boolean indicating if the asset's collateral factor should be ignored.\n     */\n    function getCollateralValueAndOraclePrice(\n        address _collateralAsset,\n        uint256 _amount,\n        bool _ignoreCollateralFactor\n    ) external view returns (uint256, uint256);\n\n    /**\n     * @notice Gets the USD value for a single Kresko asset and amount.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _amount The amount of the Kresko asset to calculate the value for.\n     * @param _ignoreKFactor Boolean indicating if the asset's k-factor should be ignored.\n     * @return The value for the provided amount of the Kresko asset.\n     */\n    function getKrAssetValue(\n        address _kreskoAsset,\n        uint256 _amount,\n        bool _ignoreKFactor\n    ) external view returns (uint256);\n}\n"
    },
    "src/contracts/minter/libs/LibAccount.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {MinterState} from \"../MinterState.sol\";\nimport {KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {RebaseMath} from \"../../kreskoasset/Rebase.sol\";\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\n\nlibrary LibAccount {\n    using RebaseMath for uint256;\n    using WadRay for uint256;\n    using LibDecimals for uint256;\n\n    /**\n     * @notice Gets an array of Kresko assets the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @return An array of addresses of Kresko assets the account has minted.\n     */\n    function getMintedKreskoAssets(\n        MinterState storage self,\n        address _account\n    ) internal view returns (address[] memory) {\n        return self.mintedKreskoAssets[_account];\n    }\n\n    /**\n     * @notice Gets an array of collateral assets the account has deposited.\n     * @param _account The account to get the deposited collateral assets for.\n     * @return An array of addresses of collateral assets the account has deposited.\n     */\n    function getDepositedCollateralAssets(\n        MinterState storage self,\n        address _account\n    ) internal view returns (address[] memory) {\n        return self.depositedCollateralAssets[_account];\n    }\n\n    /**\n     * @notice Get deposited collateral asset amount for an account\n     * @notice Performs rebasing conversion for KreskoAssets\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return uint256 amount of collateral for `_asset`\n     */\n    function getCollateralDeposits(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256) {\n        return self.collateralAssets[_asset].toRebasingAmount(self.collateralDeposits[_account][_asset]);\n    }\n\n    /**\n     * @notice Checks if accounts collateral value is less than required.\n     * @param _account The account to check.\n     * @return A boolean indicating if the account can be liquidated.\n     */\n    function isAccountLiquidatable(MinterState storage self, address _account) internal view returns (bool) {\n        return\n            self.getAccountCollateralValue(_account) <\n            (self.getAccountMinimumCollateralValueAtRatio(_account, self.liquidationThreshold));\n    }\n\n    /**\n     * @notice Overload for calculating liquidatable status with a future liquidated collateral value\n     * @param _account The account to check.\n     * @param _valueLiquidated Value liquidated, eg. in a batch liquidation\n     * @return bool indicating if the account can be liquidated.\n     */\n    function isAccountLiquidatable(\n        MinterState storage self,\n        address _account,\n        uint256 _valueLiquidated\n    ) internal view returns (bool) {\n        return\n            self.getAccountCollateralValue(_account) - _valueLiquidated <\n            (self.getAccountMinimumCollateralValueAtRatio(_account, self.liquidationThreshold));\n    }\n\n    /**\n     * @notice Gets the collateral value of a particular account.\n     * @dev O(# of different deposited collateral assets by account) complexity.\n     * @param _account The account to calculate the collateral value for.\n     * @return totalCollateralValue The collateral value of a particular account.\n     */\n    function getAccountCollateralValue(\n        MinterState storage self,\n        address _account\n    ) internal view returns (uint256 totalCollateralValue) {\n        address[] memory assets = self.depositedCollateralAssets[_account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            (uint256 collateralValue, ) = self.getCollateralValueAndOraclePrice(\n                asset,\n                self.getCollateralDeposits(_account, asset),\n                false // Take the collateral factor into consideration.\n            );\n            totalCollateralValue += collateralValue;\n        }\n\n        return totalCollateralValue;\n    }\n\n    /**\n     * @notice Gets the collateral value of a particular account including extra return value for specific collateral.\n     * @dev O(# of different deposited collateral assets by account) complexity.\n     * @param _account The account to calculate the collateral value for.\n     * @param _collateralAsset The collateral asset to get the collateral value.\n     * @return totalCollateralValue The collateral value of a particular account.\n     */\n    function getAccountCollateralValue(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset\n    ) internal view returns (uint256 totalCollateralValue, uint256 specificValue) {\n        address[] memory assets = self.depositedCollateralAssets[_account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            (uint256 collateralValue, ) = self.getCollateralValueAndOraclePrice(\n                asset,\n                self.getCollateralDeposits(_account, asset),\n                false // Take the collateral factor into consideration.\n            );\n            totalCollateralValue += collateralValue;\n            if (asset == _collateralAsset) {\n                specificValue = collateralValue;\n            }\n        }\n    }\n\n    /**\n     * @notice Gets accounts min collateral value required to cover debt at a given collateralization ratio.\n     * @dev 1. Account with min collateral value under MCR will not borrow.\n     *      2. Account with min collateral value under LT can be liquidated.\n     * @param _account The account to calculate the minimum collateral value for.\n     * @param _ratio The collateralization ratio to get min collateral value against.\n     * @return The min collateral value at given collateralization ratio for the account.\n     */\n    function getAccountMinimumCollateralValueAtRatio(\n        MinterState storage self,\n        address _account,\n        uint256 _ratio\n    ) internal view returns (uint256) {\n        return self.getAccountKrAssetValue(_account).wadMul(_ratio);\n    }\n\n    /**\n     * @notice Gets the total KreskoAsset value in USD for an account.\n     * @param _account The account to calculate the KreskoAsset value for.\n     * @return value The KreskoAsset value of the account.\n     */\n    function getAccountKrAssetValue(MinterState storage self, address _account) internal view returns (uint256 value) {\n        address[] memory assets = self.mintedKreskoAssets[_account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            value += self.getKrAssetValue(asset, self.getKreskoAssetDebtScaled(_account, asset), false);\n        }\n        return value;\n    }\n\n    /**\n     * @notice Get accounts interested scaled debt amount for a KreskoAsset.\n     * @param _asset The asset address\n     * @param _account The account to get the amount for\n     * @return Amount of scaled debt.\n     */\n    function getKreskoAssetDebtScaled(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256) {\n        uint256 debt = self.kreskoAssets[_asset].toRebasingAmount(irs().srUserInfo[_account][_asset].debtScaled);\n        if (debt == 0) {\n            return 0;\n        }\n\n        return debt.rayMul(irs().srAssets[_asset].getNormalizedDebtIndex()).rayToWad();\n    }\n\n    /**\n     * @notice Get `_account` principal debt amount for `_asset`\n     * @dev Principal debt is rebase adjusted due to possible stock splits/reverse splits\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of principal debt for `_asset`\n     */\n    function getKreskoAssetDebtPrincipal(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256) {\n        return self.kreskoAssets[_asset].toRebasingAmount(self.kreskoAssetDebt[_account][_asset]);\n    }\n\n    /**\n     * @notice Get the total interest accrued on top of debt: Scaled Debt - Principal Debt\n     * @return assetAmount Interest denominated in _asset\n     * @return kissAmount Interest denominated in KISS. Ignores K-factor: $1 of interest = 1 KISS\n     **/\n    function getKreskoAssetDebtInterest(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256 assetAmount, uint256 kissAmount) {\n        assetAmount =\n            self.getKreskoAssetDebtScaled(_account, _asset) -\n            self.getKreskoAssetDebtPrincipal(_account, _asset);\n        kissAmount = self.getKrAssetValue(_asset, assetAmount, true).oraclePriceToWad();\n    }\n\n    /**\n     * @notice Gets an index for the Kresko asset the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @param _kreskoAsset The asset lookup address.\n     * @return i = index of the minted Kresko asset.\n     */\n    function getMintedKreskoAssetsIndex(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset\n    ) internal view returns (uint256 i) {\n        uint256 length = self.mintedKreskoAssets[_account].length;\n        require(length > 0, Error.NO_KRASSETS_MINTED);\n        for (i; i < length; i++) {\n            if (self.mintedKreskoAssets[_account][i] == _kreskoAsset) {\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Gets an index for the collateral asset the account has deposited.\n     * @param _account The account to get the index for.\n     * @param _collateralAsset The asset lookup address.\n     * @return i = index of the minted collateral asset.\n     */\n    function getDepositedCollateralAssetIndex(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset\n    ) internal view returns (uint256 i) {\n        uint256 length = self.depositedCollateralAssets[_account].length;\n        require(length > 0, Error.NO_COLLATERAL_DEPOSITS);\n        for (i; i < length; i++) {\n            if (self.depositedCollateralAssets[_account][i] == _collateralAsset) {\n                break;\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibAssetUtility.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {CollateralAsset, KrAsset} from \"../MinterTypes.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibRedstone} from \"./LibRedstone.sol\";\nimport {ms} from \"../MinterStorage.sol\";\nimport {AggregatorV3Interface} from \"../../vendor/AggregatorV3Interface.sol\";\n\n/**\n * @title LibAssetUtility\n * @author Kresko\n * @notice Utility functions for KrAsset and CollateralAsset structs\n */\nlibrary LibAssetUtility {\n    using WadRay for uint256;\n    using LibDecimals for uint256;\n\n    /**\n     * @notice Amount of non rebasing tokens -> amount of rebasing tokens\n     * @param self the kresko asset struct\n     * @param _nonRebasedAmount the amount to convert\n     */\n    function toRebasingAmount(KrAsset memory self, uint256 _nonRebasedAmount) internal view returns (uint256) {\n        return IKreskoAssetAnchor(self.anchor).convertToAssets(_nonRebasedAmount);\n    }\n\n    /**\n     * @notice Amount of non rebasing tokens -> amount of rebasing tokens\n     * @dev if collateral is not a kresko asset, returns the input\n     * @param self the collateral asset struct\n     * @param _nonRebasedAmount the amount to convert\n     */\n    function toRebasingAmount(CollateralAsset memory self, uint256 _nonRebasedAmount) internal view returns (uint256) {\n        if (self.anchor == address(0)) return _nonRebasedAmount;\n        return IKreskoAssetAnchor(self.anchor).convertToAssets(_nonRebasedAmount);\n    }\n\n    /**\n     * @notice Amount of rebasing tokens -> amount of non rebasing tokens\n     * @param self the kresko asset struct\n     * @param _maybeRebasedAmount the amount to convert\n     */\n    function toNonRebasingAmount(KrAsset memory self, uint256 _maybeRebasedAmount) internal view returns (uint256) {\n        return IKreskoAssetAnchor(self.anchor).convertToShares(_maybeRebasedAmount);\n    }\n\n    /**\n     * @notice Amount of rebasing tokens -> amount of non rebasing tokens\n     * @dev if collateral is not a kresko asset, returns the input\n     * @param self the collateral asset struct\n     * @param _maybeRebasedAmount the amount to convert\n     */\n    function toNonRebasingAmount(\n        CollateralAsset memory self,\n        uint256 _maybeRebasedAmount\n    ) internal view returns (uint256) {\n        if (self.anchor == address(0)) return _maybeRebasedAmount;\n        return IKreskoAssetAnchor(self.anchor).convertToShares(_maybeRebasedAmount);\n    }\n\n    /**\n     * @notice Get the oracle price of a collateral asset in uint256 with extOracleDecimals\n     */\n    function uintPrice(CollateralAsset memory self) internal view returns (uint256) {\n        (, int256 answer, , uint256 updatedAt, ) = self.oracle.latestRoundData();\n        require(answer >= 0, Error.NEGATIVE_ORACLE_PRICE);\n        // returning zero if oracle price is too old so that fallback oracle is used instead.\n        if (block.timestamp - updatedAt > ms().oracleTimeout) {\n            return 0;\n        }\n        return uint256(answer);\n    }\n\n    /**\n     * @notice Get the oracle price of a kresko asset in uint256 with extOracleDecimals\n     */\n    function redstonePrice(CollateralAsset memory self) internal view returns (uint256) {\n        return LibRedstone.getPrice(self.redstoneId);\n    }\n\n    /**\n     * @notice Get the oracle price of a kresko asset in uint256 with extOracleDecimals\n     */\n    function uintPrice(KrAsset memory self) internal view returns (uint256) {\n        (, int256 answer, , uint256 updatedAt, ) = self.oracle.latestRoundData();\n        require(answer >= 0, Error.NEGATIVE_ORACLE_PRICE);\n        // returning zero if oracle price is too old so that fallback oracle is used instead.\n        if (block.timestamp - updatedAt > ms().oracleTimeout) {\n            return 0;\n        }\n        return uint256(answer);\n    }\n\n    /**\n     * @notice Get the oracle price of a kresko asset in uint256 with extOracleDecimals\n     * @param self the kresko asset struct\n     */\n    function redstonePrice(KrAsset memory self) internal view returns (uint256) {\n        return LibRedstone.getPrice(self.redstoneId);\n    }\n\n    /**\n     * @notice Get the oracle price of a collateral asset in uint256 with 18 decimals\n     */\n    function wadPrice(CollateralAsset memory self) internal view returns (uint256) {\n        return self.uintPrice().oraclePriceToWad();\n    }\n\n    /**\n     * @notice Get the oracle price of a kresko asset in uint256 with 18 decimals\n     */\n    function wadPrice(KrAsset memory self) internal view returns (uint256) {\n        return self.uintPrice().oraclePriceToWad();\n    }\n\n    /**\n     * @notice Get value for @param _assetAmount of @param self in uint256\n     */\n    function uintUSD(CollateralAsset memory self, uint256 _assetAmount) internal view returns (uint256) {\n        return self.uintPrice().wadMul(_assetAmount);\n    }\n\n    /**\n     * @notice Get Redstone value for @param _assetAmount of @param self in uint256\n     * @param self the collateral asset struct\n     * @param _assetAmount the amount to convert\n     */\n    function uintUSDRedstone(CollateralAsset memory self, uint256 _assetAmount) internal view returns (uint256) {\n        return self.redstonePrice().wadMul(_assetAmount);\n    }\n\n    /**\n     * @notice Get value for @param _assetAmount of @param self in uint256\n     */\n    function uintUSD(KrAsset memory self, uint256 _assetAmount) internal view returns (uint256) {\n        return self.uintPrice().wadMul(_assetAmount);\n    }\n\n    /**\n     * @notice Get Redstone value for @param _assetAmount of @param self in uint256\n     * @param self the kresko asset struct\n     * @param _assetAmount the amount to convert\n     */\n    function uintUSDRedstone(KrAsset memory self, uint256 _assetAmount) internal view returns (uint256) {\n        return self.redstonePrice().wadMul(_assetAmount);\n    }\n\n    /**\n     * @notice Get Aggregrated price from chainlink oracle and redstone\n     * @param self the collateral asset struct\n     * @param _oracleDeviationPct the deviation percentage to use for the oracle\n     */\n    function uintPrice(CollateralAsset memory self, uint256 _oracleDeviationPct) internal view returns (uint256) {\n        return _getPrice(self.uintPrice(), self.redstonePrice(), _oracleDeviationPct);\n    }\n\n    /**\n     * @notice Get Aggregrated price from chainlink oracle and redstone\n     * @param self the kresko asset struct\n     * @param _oracleDeviationPct the deviation percentage to use for the oracle\n     */\n    function uintPrice(KrAsset memory self, uint256 _oracleDeviationPct) internal view returns (uint256) {\n        return _getPrice(self.uintPrice(), self.redstonePrice(), _oracleDeviationPct);\n    }\n\n    /**\n     * @notice Get Aggregrated price from chainlink oracle and redstone in USD\n     * @param self the collateral asset struct\n     * @param _assetAmount the amount to convert\n     * @param _oracleDeviationPct the deviation percentage to use for the oracle\n     */\n    function uintUSD(\n        CollateralAsset memory self,\n        uint256 _assetAmount,\n        uint256 _oracleDeviationPct\n    ) internal view returns (uint256) {\n        return _getPrice(self.uintUSD(_assetAmount), self.uintUSDRedstone(_assetAmount), _oracleDeviationPct);\n    }\n\n    /**\n     * @notice Get Aggregrated price from chainlink oracle and redstone in USD\n     * @param self the kresko asset struct\n     * @param _assetAmount the amount to convert\n     * @param _oracleDeviationPct the deviation percentage to use for the oracle\n     */\n    function uintUSD(\n        KrAsset memory self,\n        uint256 _assetAmount,\n        uint256 _oracleDeviationPct\n    ) internal view returns (uint256) {\n        return _getPrice(self.uintUSD(_assetAmount), self.uintUSDRedstone(_assetAmount), _oracleDeviationPct);\n    }\n\n    /**\n     * @notice check the price and return it\n     * @notice reverts if the price deviates more than `_oracleDeviationPct`\n     * @param _chainlinkPrice chainlink price\n     * @param _redstonePrice redstone price\n     * @param _oracleDeviationPct the deviation percentage to use for the oracle\n     */\n    function _getPrice(\n        uint256 _chainlinkPrice,\n        uint256 _redstonePrice,\n        uint256 _oracleDeviationPct\n    ) internal view returns (uint256) {\n        if (ms().sequencerUptimeFeed != address(0)) {\n            (, int256 answer, uint256 startedAt, , ) = AggregatorV3Interface(ms().sequencerUptimeFeed)\n                .latestRoundData();\n            bool isSequencerUp = answer == 0;\n            if (!isSequencerUp) {\n                return _redstonePrice;\n            }\n            // Make sure the grace period has passed after the\n            // sequencer is back up.\n            uint256 timeSinceUp = block.timestamp - startedAt;\n            if (timeSinceUp <= ms().sequencerGracePeriodTime) {\n                return _redstonePrice;\n            }\n        }\n        if (_chainlinkPrice == 0) return _redstonePrice;\n        if (_redstonePrice == 0) return _chainlinkPrice;\n        if (\n            (_redstonePrice.wadMul(1 ether - _oracleDeviationPct) <= _chainlinkPrice) &&\n            (_redstonePrice.wadMul(1 ether + _oracleDeviationPct) >= _chainlinkPrice)\n        ) return _chainlinkPrice;\n\n        // Revert if price deviates more than `_oracleDeviationPct`\n        revert(Error.ORACLE_PRICE_UNSTABLE);\n    }\n\n    function marketStatus(KrAsset memory self) internal pure returns (bool) {\n        return true;\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibBurn.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n// solhint-disable not-rely-on-time\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {MinterEvent, InterestRateEvent} from \"../../libs/Events.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {IERC20Permit} from \"../../shared/IERC20Permit.sol\";\nimport {SafeERC20} from \"../../shared/SafeERC20.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\n\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {LibCalculation} from \"./LibCalculation.sol\";\nimport {KrAsset} from \"../MinterTypes.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {MinterState} from \"../MinterState.sol\";\n\nlibrary LibBurn {\n    using Arrays for address[];\n\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n\n    using SafeERC20 for IERC20Permit;\n    using LibCalculation for MinterState;\n\n    /// @notice Repay user kresko asset debt with stability rate updates.\n    /// @dev Updates the principal in MinterState and stability rate adjusted values in InterestRateState\n    /// @param _kreskoAsset the asset being repaid\n    /// @param _anchor the anchor token of the asset being repaid\n    /// @param _burnAmount the asset amount being burned\n    /// @param _account the account the debt is subtracted from\n    function burn(\n        MinterState storage self,\n        address _kreskoAsset,\n        address _anchor,\n        uint256 _burnAmount,\n        address _account\n    ) internal {\n        // Update global debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n        // Get the possibly rebalanced amount of destroyed tokens\n        uint256 destroyed = IKreskoAssetIssuer(_anchor).destroy(_burnAmount, msg.sender);\n        // Calculate the debt index scaled amount\n        uint256 amountScaled = destroyed.wadToRay().rayDiv(newDebtIndex);\n        require(amountScaled != 0, Error.INVALID_SCALED_AMOUNT);\n\n        // Decrease the principal debt\n        self.kreskoAssetDebt[_account][_kreskoAsset] -= destroyed;\n        // Decrease the scaled debt and set user asset's last debt index\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled -= uint128(amountScaled);\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n        // Update the stability rate for the asset\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n    }\n\n    /**\n     * @notice Repays accrued stability rate interest for a single asset\n     * @param _account Account to repay interest for\n     * @param _kreskoAsset Kresko asset to repay interest for\n     * @return kissRepayAmount amount repaid\n     */\n    function repayFullStabilityRateInterest(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset\n    ) internal returns (uint256 kissRepayAmount) {\n        // Update debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n        // Get the accrued interest in repayment token\n        (, kissRepayAmount) = self.getKreskoAssetDebtInterest(_account, _kreskoAsset);\n\n        // If no interest has accrued no further operations needed\n        // Do not revert because we want the preserve new debt index and stability rate\n        if (kissRepayAmount == 0) {\n            // Update stability rate for asset\n            irs().srAssets[_kreskoAsset].updateStabilityRate();\n            return 0;\n        }\n\n        // Transfer the accrued interest\n        IERC20Permit(irs().kiss).safeTransferFrom(msg.sender, self.feeRecipient, kissRepayAmount);\n\n        // Update scaled values for the user\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled = uint128(\n            self.getKreskoAssetDebtPrincipal(_account, _kreskoAsset).wadToRay().rayDiv(newDebtIndex)\n        );\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n\n        // Remove from minted kresko assets if debt is cleared\n        if (self.getKreskoAssetDebtPrincipal(_account, _kreskoAsset) == 0) {\n            self.mintedKreskoAssets[_account].removeAddress(\n                _kreskoAsset,\n                self.getMintedKreskoAssetsIndex(_account, _kreskoAsset)\n            );\n        }\n\n        // Update stability rates\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n        // Emit event with the account, asset and amount repaid\n        emit InterestRateEvent.StabilityRateInterestRepaid(_account, _kreskoAsset, kissRepayAmount);\n    }\n\n    /**\n     * @notice Charges the protocol close fee based off the value of the burned asset.\n     * @dev Takes the fee from the account's collateral assets. Attempts collateral assets\n     *   in reverse order of the account's deposited collateral assets array.\n     * @param _account The account to charge the close fee from.\n     * @param _kreskoAsset The address of the kresko asset being burned.\n     * @param _burnAmount The amount of the kresko asset being burned.\n     */\n    function chargeCloseFee(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset,\n        uint256 _burnAmount\n    ) internal {\n        KrAsset memory krAsset = self.kreskoAssets[_kreskoAsset];\n        // Calculate the value of the fee according to the value of the krAssets being burned.\n        uint256 feeValue = krAsset.uintUSD(_burnAmount, self.oracleDeviationPct).wadMul(krAsset.closeFee);\n\n        // Do nothing if the fee value is 0.\n        if (feeValue == 0) {\n            return;\n        }\n\n        address[] memory accountCollateralAssets = self.depositedCollateralAssets[_account];\n        // Iterate backward through the account's deposited collateral assets to safely\n        // traverse the array while still being able to remove elements if necessary.\n        // This is because removing the last element of the array does not shift around\n        // other elements in the array.\n\n        for (uint256 i = accountCollateralAssets.length - 1; i >= 0; i--) {\n            address collateralAssetAddress = accountCollateralAssets[i];\n\n            (uint256 transferAmount, uint256 feeValuePaid) = self.calcFee(\n                collateralAssetAddress,\n                _account,\n                feeValue,\n                i\n            );\n\n            // Remove the transferAmount from the stored deposit for the account.\n            self.collateralDeposits[_account][collateralAssetAddress] -= self\n                .collateralAssets[collateralAssetAddress]\n                .toNonRebasingAmount(transferAmount);\n\n            // Transfer the fee to the feeRecipient.\n            IERC20Permit(collateralAssetAddress).safeTransfer(self.feeRecipient, transferAmount);\n            emit MinterEvent.CloseFeePaid(_account, collateralAssetAddress, transferAmount, feeValuePaid);\n\n            feeValue = feeValue - feeValuePaid;\n            // If the entire fee has been paid, no more action needed.\n            if (feeValue == 0) {\n                return;\n            }\n        }\n    }\n\n    /**\n     * @notice Check that debt repaid does not leave a dust position, if it does:\n     * return an amount that pays up to minDebtValue\n     * @param _kreskoAsset The address of the kresko asset being burned.\n     * @param _burnAmount The amount being burned\n     * @param _debtAmount The debt amount of `_account`\n     * @return amount == 0 or >= minDebtAmount\n     */\n    function ensureNotDustPosition(\n        MinterState storage self,\n        address _kreskoAsset,\n        uint256 _burnAmount,\n        uint256 _debtAmount\n    ) internal view returns (uint256 amount) {\n        // If the requested burn would put the user's debt position below the minimum\n        // debt value, close up to the minimum debt value instead.\n        uint256 krAssetValue = self.getKrAssetValue(_kreskoAsset, _debtAmount - _burnAmount, true);\n        if (krAssetValue > 0 && krAssetValue < self.minimumDebtValue) {\n            uint256 minDebtValue = self.minimumDebtValue.wadDiv(\n                self.kreskoAssets[_kreskoAsset].uintPrice(self.oracleDeviationPct)\n            );\n            amount = _debtAmount - minDebtValue;\n        } else {\n            amount = _burnAmount;\n        }\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibCalculation.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {MinterState} from \"../MinterState.sol\";\nimport {KrAsset, CollateralAsset, Constants} from \"../MinterTypes.sol\";\n\n/**\n * @title Calculation library for liquidation & fee values\n * @author Kresko\n */\nlibrary LibCalculation {\n    struct MaxLiquidationVars {\n        CollateralAsset collateral;\n        uint256 accountCollateralValue;\n        uint256 minCollateralValue;\n        uint256 seizeCollateralAccountValue;\n        uint256 maxLiquidationMultiplier;\n        uint256 minimumDebtValue;\n        uint256 liquidationThreshold;\n        uint256 debtFactor;\n    }\n\n    using Arrays for address[];\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n\n    /**\n     * @dev Calculates the total value that can be liquidated for a liquidation pair\n     * @param _account address to liquidate\n     * @param _repayKreskoAsset address of the kreskoAsset being repaid on behalf of the liquidatee\n     * @param _seizedCollateral The collateral asset being seized in the liquidation\n     * @return maxLiquidatableUSD USD value that can be liquidated, 0 if the pair has no liquidatable value\n     */\n    function getMaxLiquidation(\n        MinterState storage self,\n        address _account,\n        KrAsset memory _repayKreskoAsset,\n        address _seizedCollateral\n    ) internal view returns (uint256 maxLiquidatableUSD) {\n        MaxLiquidationVars memory vars = _getMaxLiquidationParams(self, _account, _repayKreskoAsset, _seizedCollateral);\n        // Account is not liquidatable\n        if (vars.accountCollateralValue >= (vars.minCollateralValue)) {\n            return 0;\n        }\n\n        maxLiquidatableUSD = _getMaxLiquidatableUSD(vars, _repayKreskoAsset);\n\n        if (vars.seizeCollateralAccountValue < maxLiquidatableUSD) {\n            return vars.seizeCollateralAccountValue;\n        } else if (maxLiquidatableUSD < vars.minimumDebtValue) {\n            return vars.minimumDebtValue;\n        }\n        return maxLiquidatableUSD;\n    }\n\n    /**\n     * @notice Calculate amount of collateral to seize during the liquidation procesself.\n     * @param _liquidationIncentiveMultiplier The liquidation incentive multiplier.\n     * @param _collateralOraclePriceUSD The address of the collateral asset to be seized.\n     * @param _kreskoAssetRepayAmountUSD Kresko asset amount being repaid in exchange for the seized collateral.\n     */\n    function calculateAmountToSeize(\n        uint256 _liquidationIncentiveMultiplier,\n        uint256 _collateralOraclePriceUSD,\n        uint256 _kreskoAssetRepayAmountUSD\n    ) internal pure returns (uint256) {\n        // Seize amount = (repay amount USD * liquidation incentive / collateral price USD).\n        // Denominate seize amount in collateral type\n        // Apply liquidation incentive multiplier\n        return _kreskoAssetRepayAmountUSD.wadMul(_liquidationIncentiveMultiplier).wadDiv(_collateralOraclePriceUSD);\n    }\n\n    /**\n     * @notice Calculates the fee to be taken from a user's deposited collateral asset.\n     * @param _collateralAsset The collateral asset from which to take to the fee.\n     * @param _account The owner of the collateral.\n     * @param _feeValue The original value of the fee.\n     * @param _collateralAssetIndex The collateral asset's index in the user's depositedCollateralAssets array.\n     *\n     * @return transferAmount to be received as a uint256\n     * @return feeValuePaid wad representing the fee value paid.\n     */\n    function calcFee(\n        MinterState storage self,\n        address _collateralAsset,\n        address _account,\n        uint256 _feeValue,\n        uint256 _collateralAssetIndex\n    ) internal returns (uint256 transferAmount, uint256 feeValuePaid) {\n        uint256 depositAmount = self.getCollateralDeposits(_account, _collateralAsset);\n\n        // Don't take the collateral asset's collateral factor into consideration.\n        (uint256 depositValue, uint256 oraclePrice) = self.getCollateralValueAndOraclePrice(\n            _collateralAsset,\n            depositAmount,\n            true\n        );\n\n        // If feeValue < depositValue, the entire fee can be charged for this collateral asset.\n        if (_feeValue < depositValue) {\n            transferAmount = self.collateralAssets[_collateralAsset].decimals.fromWad(_feeValue.wadDiv(oraclePrice));\n            feeValuePaid = _feeValue;\n        } else {\n            // If the feeValue >= depositValue, the entire deposit\n            // should be taken as the fee.\n            transferAmount = depositAmount;\n            feeValuePaid = depositValue;\n        }\n\n        if (transferAmount == depositAmount) {\n            // Because the entire deposit is taken, remove it from the depositCollateralAssets array.\n            self.depositedCollateralAssets[_account].removeAddress(_collateralAsset, _collateralAssetIndex);\n        }\n\n        return (transferAmount, feeValuePaid);\n    }\n\n    /**\n     * @notice Calculates the maximum USD value of a given kreskoAsset that can be liquidated given a liquidation pair\n     *\n     * 1. Calculates the value gained per USD repaid in liquidation for a given kreskoAsset\n     *\n     * debtFactor = debtFactor = k * LT / cFactor;\n     *\n     * valPerUSD = (DebtFactor - Asset closeFee - liquidationIncentive) / DebtFactor\n     *\n     * 2. Calculates the maximum amount of USD value that can be liquidated given the account's collateral value\n     *\n     * maxLiquidatableUSD = (MCV - ACV) / valPerUSD / debtFactor / cFactor * LOM\n     *\n     * @dev This function is used by getMaxLiquidation and is factored out for readability\n     * @param vars liquidation variables struct\n     * @param _repayKreskoAsset The kreskoAsset being repaid in the liquidation\n     */\n    function _getMaxLiquidatableUSD(\n        MaxLiquidationVars memory vars,\n        KrAsset memory _repayKreskoAsset\n    ) private pure returns (uint256) {\n        uint256 valuePerUSDRepaid = (vars.debtFactor -\n            vars.collateral.liquidationIncentive -\n            _repayKreskoAsset.closeFee).wadDiv(vars.debtFactor);\n        return\n            (vars.minCollateralValue - vars.accountCollateralValue)\n                .wadMul(vars.maxLiquidationMultiplier)\n                .wadDiv(valuePerUSDRepaid)\n                .wadDiv(vars.debtFactor)\n                .wadDiv(vars.collateral.factor);\n    }\n\n    function _getMaxLiquidationParams(\n        MinterState storage state,\n        address _account,\n        KrAsset memory _repayKreskoAsset,\n        address _seizedCollateral\n    ) private view returns (MaxLiquidationVars memory) {\n        uint256 liquidationThreshold = state.liquidationThreshold;\n        uint256 minCollateralValue = state.getAccountMinimumCollateralValueAtRatio(_account, liquidationThreshold);\n\n        (uint256 accountCollateralValue, uint256 seizeCollateralAccountValue) = state.getAccountCollateralValue(\n            _account,\n            _seizedCollateral\n        );\n\n        CollateralAsset memory collateral = state.collateralAssets[_seizedCollateral];\n\n        return\n            MaxLiquidationVars({\n                collateral: collateral,\n                accountCollateralValue: accountCollateralValue,\n                debtFactor: _repayKreskoAsset.kFactor.wadMul(liquidationThreshold).wadDiv(collateral.factor),\n                minCollateralValue: minCollateralValue,\n                minimumDebtValue: state.minimumDebtValue,\n                seizeCollateralAccountValue: seizeCollateralAccountValue,\n                liquidationThreshold: liquidationThreshold,\n                maxLiquidationMultiplier: state.maxLiquidationMultiplier\n            });\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibCollateral.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {CollateralAsset, Constants} from \"../MinterTypes.sol\";\nimport {MinterState} from \"../MinterState.sol\";\n\n/**\n * @title Library for collateral related operations\n * @author Kresko\n */\nlibrary LibCollateral {\n    using LibDecimals for uint8;\n    using Arrays for address[];\n    using WadRay for uint256;\n\n    /**\n     * In case a collateral asset is also a kresko asset, convert an amount to anchor shares\n     * @param _amount amount to possibly convert\n     * @param _collateralAsset address of the collateral asset\n     */\n    function normalizeCollateralAmount(\n        MinterState storage self,\n        uint256 _amount,\n        address _collateralAsset\n    ) internal view returns (uint256 amount) {\n        CollateralAsset memory asset = self.collateralAssets[_collateralAsset];\n        if (asset.anchor != address(0)) {\n            return IKreskoAssetAnchor(asset.anchor).convertToShares(_amount);\n        }\n        return _amount;\n    }\n\n    /**\n     * @notice Get the state of a specific collateral asset\n     * @param _asset Address of the asset.\n     * @return State of assets `CollateralAsset` struct\n     */\n    function collateralAsset(MinterState storage self, address _asset) internal view returns (CollateralAsset memory) {\n        return self.collateralAssets[_asset];\n    }\n\n    /**\n     * @notice Gets the collateral value for a single collateral asset and amount.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _amount The amount of the collateral asset to calculate the collateral value for.\n     * @param _ignoreCollateralFactor Boolean indicating if the asset's collateral factor should be ignored.\n     * @return The collateral value for the provided amount of the collateral asset.\n     */\n    function getCollateralValueAndOraclePrice(\n        MinterState storage self,\n        address _collateralAsset,\n        uint256 _amount,\n        bool _ignoreCollateralFactor\n    ) internal view returns (uint256, uint256) {\n        CollateralAsset memory asset = self.collateralAssets[_collateralAsset];\n\n        uint256 oraclePrice = asset.uintPrice(self.oracleDeviationPct);\n        uint256 value = asset.decimals.toWad(_amount).wadMul(oraclePrice);\n\n        if (!_ignoreCollateralFactor) {\n            value = value.wadMul(asset.factor);\n        }\n        return (value, oraclePrice);\n    }\n\n    /**\n     * @notice verifies that the account has sufficient collateral for the requested amount and records the collateral\n     * @param _account The address of the account to verify the collateral for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\n     * @param _collateralDeposits Collateral deposits for the account.\n     * @param _depositedCollateralAssetIndex Index of the collateral asset in the account's deposited collateral assets array.\n     */\n    function verifyAndRecordCollateralWithdrawal(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _collateralDeposits,\n        uint256 _depositedCollateralAssetIndex\n    ) internal {\n        require(_withdrawAmount > 0, Error.ZERO_WITHDRAW);\n        require(\n            _depositedCollateralAssetIndex <= self.depositedCollateralAssets[_account].length - 1,\n            Error.ARRAY_OUT_OF_BOUNDS\n        );\n\n        // Ensure that the operation passes checks MCR checks\n        verifyAccountCollateral(self, _account, _collateralAsset, _withdrawAmount);\n\n        uint256 newCollateralAmount = _collateralDeposits - _withdrawAmount;\n\n        // If the collateral asset is also a kresko asset, ensure that the deposit amount is above the minimum.\n        // This is done because kresko assets can be rebased.\n        if (self.collateralAssets[_collateralAsset].anchor != address(0)) {\n            require(\n                newCollateralAmount >= Constants.MIN_KRASSET_COLLATERAL_AMOUNT || newCollateralAmount == 0,\n                Error.COLLATERAL_AMOUNT_TOO_LOW\n            );\n        }\n\n        // If the user is withdrawing all of the collateral asset, remove the collateral asset\n        // from the user's deposited collateral assets array.\n        if (newCollateralAmount == 0) {\n            self.depositedCollateralAssets[_account].removeAddress(_collateralAsset, _depositedCollateralAssetIndex);\n        }\n\n        // Record the withdrawal.\n        self.collateralDeposits[_account][_collateralAsset] = self\n            .collateralAssets[_collateralAsset]\n            .toNonRebasingAmount(newCollateralAmount);\n\n        emit MinterEvent.CollateralWithdrawn(_account, _collateralAsset, _withdrawAmount);\n    }\n\n    /**\n     * @notice Records account as having deposited an amount of a collateral asset.\n     * @dev Token transfers are expected to be done by the caller.\n     * @param _account The address of the collateral asset.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _depositAmount The amount of the collateral asset deposited.\n     */\n    function recordCollateralDeposit(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _depositAmount\n    ) internal {\n        // Because the depositedCollateralAssets[_account] is pushed to if the existing\n        // deposit amount is 0, require the amount to be > 0. Otherwise, the depositedCollateralAssets[_account]\n        // could be filled with duplicates, causing collateral to be double-counted in the collateral value.\n        require(_depositAmount > 0, Error.ZERO_DEPOSIT);\n\n        // If the account does not have an existing deposit for this collateral asset,\n        // push it to the list of the account's deposited collateral assets.\n        uint256 existingCollateralAmount = self.getCollateralDeposits(_account, _collateralAsset);\n\n        if (existingCollateralAmount == 0) {\n            self.depositedCollateralAssets[_account].push(_collateralAsset);\n        }\n\n        uint256 newCollateralAmount = existingCollateralAmount + _depositAmount;\n\n        // If the collateral asset is also a kresko asset, ensure that the deposit amount is above the minimum.\n        // This is done because kresko assets can be rebased.\n        if (self.collateralAssets[_collateralAsset].anchor != address(0)) {\n            require(\n                newCollateralAmount >= Constants.MIN_KRASSET_COLLATERAL_AMOUNT || newCollateralAmount == 0,\n                Error.COLLATERAL_AMOUNT_TOO_LOW\n            );\n        }\n\n        // Record the deposit.\n        unchecked {\n            self.collateralDeposits[_account][_collateralAsset] = self\n                .collateralAssets[_collateralAsset]\n                .toNonRebasingAmount(newCollateralAmount);\n        }\n\n        emit MinterEvent.CollateralDeposited(_account, _collateralAsset, _depositAmount);\n    }\n\n    /**\n     * @notice records the collateral withdrawal\n     * @param _account The address of the account to verify the collateral for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\n     * @param _collateralDeposits Collateral deposits for the account.\n     * @param _depositedCollateralAssetIndex Index of the collateral asset in the account's deposited collateral assets array.\n     */\n    function recordCollateralWithdrawal(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _collateralDeposits,\n        uint256 _depositedCollateralAssetIndex\n    ) internal {\n        require(_withdrawAmount > 0, Error.ZERO_WITHDRAW);\n        require(\n            _depositedCollateralAssetIndex <= self.depositedCollateralAssets[_account].length - 1,\n            Error.ARRAY_OUT_OF_BOUNDS\n        );\n        // ensure that the handler does not attempt to withdraw more collateral than the account has\n        require(_collateralDeposits >= _withdrawAmount, Error.COLLATERAL_INSUFFICIENT_AMOUNT);\n\n        uint256 newCollateralAmount = _collateralDeposits - _withdrawAmount;\n\n        // If the collateral asset is also a kresko asset, ensure that the deposit amount is above the minimum.\n        // This is done because kresko assets can be rebased.\n        if (self.collateralAssets[_collateralAsset].anchor != address(0)) {\n            require(\n                newCollateralAmount >= Constants.MIN_KRASSET_COLLATERAL_AMOUNT || newCollateralAmount == 0,\n                Error.COLLATERAL_AMOUNT_TOO_LOW\n            );\n        }\n\n        // If the user is withdrawing all of the collateral asset, remove the collateral asset\n        // from the user's deposited collateral assets array.\n        if (newCollateralAmount == 0) {\n            self.depositedCollateralAssets[_account].removeAddress(_collateralAsset, _depositedCollateralAssetIndex);\n        }\n\n        // Record the withdrawal.\n        self.collateralDeposits[_account][_collateralAsset] = self\n            .collateralAssets[_collateralAsset]\n            .toNonRebasingAmount(newCollateralAmount);\n\n        emit MinterEvent.UncheckedCollateralWithdrawn(_account, _collateralAsset, _withdrawAmount);\n    }\n\n    /**\n     * @notice verifies that the account collateral\n     * @param _account The address of the account to verify the collateral for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\n     */\n    function verifyAccountCollateral(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount\n    ) internal view {\n        // Ensure the withdrawal does not result in the account having a collateral value\n        // under the minimum collateral amount required to maintain a healthy position.\n        // I.e. the new account's collateral value must still exceed the account's minimum\n        // collateral value.\n        // Get the account's current collateral value.\n        uint256 accountCollateralValue = self.getAccountCollateralValue(_account);\n        // Get the collateral value that the account will lose as a result of this withdrawal.\n        (uint256 withdrawnCollateralValue, ) = self.getCollateralValueAndOraclePrice(\n            _collateralAsset,\n            _withdrawAmount,\n            false // Take the collateral factor into consideration.\n        );\n        // Get the account's minimum collateral value.\n        uint256 accountMinCollateralValue = self.getAccountMinimumCollateralValueAtRatio(\n            _account,\n            self.minimumCollateralizationRatio\n        );\n        // Require accountMinCollateralValue <= accountCollateralValue - withdrawnCollateralValue.\n        require(\n            accountMinCollateralValue <= accountCollateralValue - withdrawnCollateralValue,\n            Error.COLLATERAL_INSUFFICIENT_AMOUNT\n        );\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibDecimals.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {ms} from \"../MinterStorage.sol\";\n\n/**\n * @title Library for Kresko specific decimals\n */\nlibrary LibDecimals {\n    /**\n     * @notice For a given collateral asset and amount, returns a wad represenatation.\n     * @dev If the collateral asset has decimals other than 18, the amount is scaled appropriately.\n     *   If decimals > 18, there may be a loss of precision.\n     * @param _decimals The collateral asset's number of decimals\n     * @param _amount The amount of the collateral asset.\n     * @return A fp of amount scaled according to the collateral asset's decimals.\n     */\n    function toWad(uint256 _decimals, uint256 _amount) internal pure returns (uint256) {\n        // Initially, use the amount as the raw value for the fixed point.\n        // which internally uses 18 decimals.\n        // Most collateral assets will have 18 decimals.\n\n        // Handle cases where the collateral asset's decimal amount is not 18.\n        if (_decimals < 18) {\n            // If the decimals are less than 18, multiply the amount\n            // to get the correct wad value.\n            // E.g. 1 full token of a 17 decimal token will  cause the\n            // initial setting of amount to be 0.1, so we multiply\n            // by 10 ** (18 - 17) = 10 to get it to 0.1 * 10 = 1.\n            return _amount * (10 ** (18 - _decimals));\n        } else if (_decimals > 18) {\n            // If the decimals are greater than 18, divide the amount\n            // to get the correct fixed point value.\n            // Note because wad numbers are 18 decimals, this results\n            // in loss of precision. E.g. if the collateral asset has 19\n            // decimals and the deposit amount is only 1 uint, this will divide\n            // 1 by 10 ** (19 - 18), resulting in 1 / 10 = 0\n            return _amount / (10 ** (_decimals - 18));\n        }\n        return _amount;\n    }\n\n    /**\n     * @notice For a given collateral asset and wad amount, returns the collateral amount.\n     * @dev If the collateral asset has decimals other than 18, the amount is scaled appropriately.\n     *   If decimals < 18, there may be a loss of precision.\n     * @param _decimals The collateral asset's number of decimals\n     * @param _wadAmount The wad amount of the collateral asset.\n     * @return An amount that is compatible with the collateral asset's decimals.\n     */\n    function fromWad(uint256 _decimals, uint256 _wadAmount) internal pure returns (uint256) {\n        // Initially, use the rawValue, which internally uses 18 decimals.\n        // Most collateral assets will have 18 decimals.\n        // Handle cases where the collateral asset's decimal amount is not 18.\n        if (_decimals < 18) {\n            // If the decimals are less than 18, divide the depositAmount\n            // to get the correct collateral amount.\n            // E.g. 1 full token will result in amount being 1e18 at this point,\n            // so if the token has 17 decimals, divide by 10 ** (18 - 17) = 10\n            // to get a value of 1e17.\n            // This may result in a loss of precision.\n            return _wadAmount / (10 ** (18 - _decimals));\n        } else if (_decimals > 18) {\n            // If the decimals are greater than 18, multiply the depositAmount\n            // to get the correct fixed point value.\n            // E.g. 1 full token will result in amount being 1e18 at this point,\n            // so if the token has 19 decimals, multiply by 10 ** (19 - 18) = 10\n            // to get a value of 1e19.\n            return _wadAmount * (10 ** (_decimals - 18));\n        }\n        return _wadAmount;\n    }\n\n    /**\n     * @notice Divides an uint256 @param _value with @param _priceWithOracleDecimals\n     * @param _value Left side value of the division\n     * @param wadValue result with 18 decimals\n     */\n    function divByPrice(uint256 _value, uint256 _priceWithOracleDecimals) internal view returns (uint256 wadValue) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals >= 18) return _priceWithOracleDecimals;\n        return (_value * 10 ** oracleDecimals) / _priceWithOracleDecimals;\n    }\n\n    /**\n     * @notice Converts an uint256 with extOracleDecimals into a number with 18 decimals\n     * @param _wadPrice value with extOracleDecimals\n     */\n    function fromWadPriceToUint(uint256 _wadPrice) internal view returns (uint256 priceWithOracleDecimals) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals == 18) return _wadPrice;\n        return _wadPrice / 10 ** (18 - oracleDecimals);\n    }\n\n    /**\n     * @notice Converts an uint256 with extOracleDecimals into a number with 18 decimals\n     * @param _priceWithOracleDecimals value with extOracleDecimals\n     * @return wadPrice with 18 decimals\n     */\n    function oraclePriceToWad(uint256 _priceWithOracleDecimals) internal view returns (uint256) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals == 18) {\n            return _priceWithOracleDecimals;\n        }\n        return _priceWithOracleDecimals * 10 ** (18 - oracleDecimals);\n    }\n\n    /**\n     * @notice Converts an int256 with extOracleDecimals into a number with 18 decimals\n     * @param _priceWithOracleDecimals value with extOracleDecimals\n     * @return wadPrice price with 18 decimals\n     */\n    function oraclePriceToWad(int256 _priceWithOracleDecimals) internal view returns (uint256) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals >= 18) return uint256(_priceWithOracleDecimals);\n        return uint256(_priceWithOracleDecimals) * 10 ** (18 - oracleDecimals);\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibKrAsset.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {IUniswapV2OracleCompat} from \"../amm-oracle/IUniswapV2OracleCompat.sol\";\nimport {KrAsset} from \"../MinterTypes.sol\";\nimport {MinterState} from \"../MinterState.sol\";\n\nlibrary LibKrAsset {\n    using WadRay for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Functions                                 */\n    /* -------------------------------------------------------------------------- */\n    /**\n     * @notice Get the state of a specific krAsset\n     * @param _asset Address of the asset.\n     * @return State of assets `KrAsset` struct\n     */\n    function kreskoAsset(MinterState storage self, address _asset) internal view returns (KrAsset memory) {\n        return self.kreskoAssets[_asset];\n    }\n\n    /**\n     * @notice Gets the USD value for a single Kresko asset and amount.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _amount The amount of the Kresko asset to calculate the value for.\n     * @param _ignoreKFactor Boolean indicating if the asset's k-factor should be ignored.\n     * @return The value for the provided amount of the Kresko asset.\n     */\n    function getKrAssetValue(\n        MinterState storage self,\n        address _kreskoAsset,\n        uint256 _amount,\n        bool _ignoreKFactor\n    ) internal view returns (uint256) {\n        KrAsset memory krAsset = self.kreskoAssets[_kreskoAsset];\n        uint256 value = krAsset.uintUSD(_amount, self.oracleDeviationPct);\n\n        if (!_ignoreKFactor) {\n            value = value.wadMul(krAsset.kFactor);\n        }\n\n        return value;\n    }\n\n    /**\n     * @notice Gets the AMM price for a Kresko asset.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _amount The amount of the Kresko asset to calculate the value for.\n     * @return The value for the provided amount of the Kresko asset.\n     */\n    function getKrAssetAMMPrice(\n        MinterState storage self,\n        address _kreskoAsset,\n        uint256 _amount\n    ) internal view returns (uint256) {\n        if (self.ammOracle == address(0)) {\n            return 0;\n        }\n        return IUniswapV2OracleCompat(self.ammOracle).consultKrAsset(_kreskoAsset, _amount);\n    }\n\n    /**\n     * @notice Get the minimum collateral value required to\n     * back a Kresko asset amount at a given collateralization ratio.\n     * @param _krAsset The address of the Kresko asset.\n     * @param _amount The Kresko Asset debt amount.\n     * @return minCollateralValue is the minimum collateral value required for this Kresko Asset amount.\n     * @param _ratio The collateralization ratio required: higher ratio = more collateral required.\n     */\n    function getMinimumCollateralValueAtRatio(\n        MinterState storage self,\n        address _krAsset,\n        uint256 _amount,\n        uint256 _ratio\n    ) internal view returns (uint256 minCollateralValue) {\n        // Calculate the collateral value required to back this Kresko asset amount at the given ratio\n        return self.getKrAssetValue(_krAsset, _amount, false).wadMul(_ratio);\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibMint.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n// solhint-disable not-rely-on-time\n// solhint-disable-next-line\nimport {SafeERC20, IERC20Permit} from \"../../shared/SafeERC20.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\n\nimport {LibCalculation} from \"./LibCalculation.sol\";\nimport {KrAsset} from \"../MinterTypes.sol\";\nimport {MinterState} from \"../MinterState.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\nlibrary LibMint {\n    using Arrays for address[];\n\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n\n    using SafeERC20 for IERC20Permit;\n    using LibCalculation for MinterState;\n\n    /// @notice Mint kresko assets with stability rate updates.\n    /// @dev Updates the principal in MinterState and stability rate adjusted values in InterestRateState\n    /// @param _kreskoAsset the asset being repaid\n    /// @param _anchor the anchor token of the asset being repaid\n    /// @param _amount the asset amount being minted\n    /// @param _account the account the debt is subtracted from\n    function mint(\n        MinterState storage self,\n        address _kreskoAsset,\n        address _anchor,\n        uint256 _amount,\n        address _account\n    ) internal {\n        // Update global debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n        // Get possibly rebalanced amount of kresko asset\n        uint256 issued = IKreskoAssetIssuer(_anchor).issue(_amount, _account);\n        // Calculate debt index scaled value\n        uint256 amountScaled = issued.wadToRay().rayDiv(newDebtIndex);\n        require(amountScaled != 0, Error.INVALID_SCALED_AMOUNT);\n        // Increase principal debt\n        self.kreskoAssetDebt[_account][_kreskoAsset] += issued;\n        // Update scaled values for the user\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled += uint128(amountScaled);\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n        // Update the global rate for the asset\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n    }\n\n    /**\n     * @notice Charges the protocol open fee based off the value of the minted asset.\n     * @dev Takes the fee from the account's collateral assets. Attempts collateral assets\n     *   in reverse order of the account's deposited collateral assets array.\n     * @param _account The account to charge the open fee from.\n     * @param _kreskoAsset The address of the kresko asset being minted.\n     * @param _kreskoAssetAmountMinted The amount of the kresko asset being minted.\n     */\n    function chargeOpenFee(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset,\n        uint256 _kreskoAssetAmountMinted\n    ) internal {\n        KrAsset memory krAsset = self.kreskoAssets[_kreskoAsset];\n        // Calculate the value of the fee according to the value of the krAssets being minted.\n        uint256 feeValue = krAsset.uintUSD(_kreskoAssetAmountMinted, self.oracleDeviationPct).wadMul(krAsset.openFee);\n\n        // Do nothing if the fee value is 0.\n        if (feeValue == 0) {\n            return;\n        }\n\n        address[] memory accountCollateralAssets = self.depositedCollateralAssets[_account];\n        // Iterate backward through the account's deposited collateral assets to safely\n        // traverse the array while still being able to remove elements if necessary.\n        // This is because removing the last element of the array does not shift around\n        // other elements in the array.\n        for (uint256 i = accountCollateralAssets.length - 1; i >= 0; i--) {\n            address collateralAssetAddress = accountCollateralAssets[i];\n\n            (uint256 transferAmount, uint256 feeValuePaid) = self.calcFee(\n                collateralAssetAddress,\n                _account,\n                feeValue,\n                i\n            );\n\n            // Remove the transferAmount from the stored deposit for the account.\n            self.collateralDeposits[_account][collateralAssetAddress] -= self\n                .collateralAssets[collateralAssetAddress]\n                .toNonRebasingAmount(transferAmount);\n\n            // Transfer the fee to the feeRecipient.\n            IERC20Permit(collateralAssetAddress).safeTransfer(self.feeRecipient, transferAmount);\n            emit MinterEvent.OpenFeePaid(_account, collateralAssetAddress, transferAmount, feeValuePaid);\n\n            feeValue = feeValue - feeValuePaid;\n            // If the entire fee has been paid, no more action needed.\n            if (feeValue == 0) {\n                return;\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibRedstone.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {RedstoneDefaultsLib} from \"@redstone-finance/evm-connector/contracts/core/RedstoneDefaultsLib.sol\";\nimport {BitmapLib} from \"@redstone-finance/evm-connector/contracts/libs/BitmapLib.sol\";\nimport {SignatureLib} from \"@redstone-finance/evm-connector/contracts/libs/SignatureLib.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title The base contract with helpful constants\n * @author The Redstone Oracles team\n * @dev It mainly contains redstone-related values, which improve readability\n * of other contracts (e.g. CalldataExtractor and RedstoneConsumerBase)\n */\nlibrary RedstoneError {\n    // Error messages\n    error CalldataOverOrUnderFlow();\n    error IncorrectUnsignedMetadataSize();\n    error InsufficientNumberOfUniqueSigners(uint256 receivedSignersCount, uint256 requiredSignersCount);\n    error EachSignerMustProvideTheSameValue();\n    error EmptyCalldataPointersArr();\n    error InvalidCalldataPointer();\n    error CalldataMustHaveValidPayload();\n    error SignerNotAuthorised(address receivedSigner);\n}\n\n// === Abbreviations ===\n// BS - Bytes size\n// PTR - Pointer (memory location)\n// SIG - Signature\n\n// Solidity and YUL constants\nuint256 constant STANDARD_SLOT_BS = 32;\nuint256 constant FREE_MEMORY_PTR = 0x40;\nuint256 constant BYTES_ARR_LEN_VAR_BS = 32;\nuint256 constant FUNCTION_SIGNATURE_BS = 4;\nuint256 constant REVERT_MSG_OFFSET = 68; // Revert message structure described here: https://ethereum.stackexchange.com/a/66173/106364\nuint256 constant STRING_ERR_MESSAGE_MASK = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n\n// RedStone protocol consts\nuint256 constant SIG_BS = 65;\nuint256 constant TIMESTAMP_BS = 6;\nuint256 constant DATA_PACKAGES_COUNT_BS = 2;\nuint256 constant DATA_POINTS_COUNT_BS = 3;\nuint256 constant DATA_POINT_VALUE_BYTE_SIZE_BS = 4;\nuint256 constant DATA_POINT_SYMBOL_BS = 32;\nuint256 constant DEFAULT_DATA_POINT_VALUE_BS = 32;\nuint256 constant UNSIGNED_METADATA_BYTE_SIZE_BS = 3;\nuint256 constant REDSTONE_MARKER_BS = 9; // byte size of 0x000002ed57011e0000\nuint256 constant REDSTONE_MARKER_MASK = 0x0000000000000000000000000000000000000000000000000002ed57011e0000;\n\n// Derived values (based on consts)\nuint256 constant TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS = 104; // SIG_BS + DATA_POINTS_COUNT_BS + DATA_POINT_VALUE_BYTE_SIZE_BS + STANDARD_SLOT_BS\nuint256 constant DATA_PACKAGE_WITHOUT_DATA_POINTS_BS = 78; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS + SIG_BS\nuint256 constant DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS = 13; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS\nuint256 constant REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS = 41; // REDSTONE_MARKER_BS + STANDARD_SLOT_BS\n\nlibrary LibRedstone {\n    using SafeMath for uint256;\n\n    /**\n     * @dev This function can be used in a consumer contract to securely extract an\n     * oracle value for a given data feed id. Security is achieved by\n     * signatures verification, timestamp validation, and aggregating values\n     * from different authorised signers into a single numeric value. If any of the\n     * required conditions do not match, the function will revert.\n     * Note! This function expects that tx calldata contains redstone payload in the end\n     * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\n     * @param dataFeedId bytes32 value that uniquely identifies the data feed\n     * @return Extracted and verified numeric oracle value for the given data feed id\n     */\n    function getPrice(bytes32 dataFeedId) internal view returns (uint256) {\n        bytes32[] memory dataFeedIds = new bytes32[](1);\n        dataFeedIds[0] = dataFeedId;\n        return _securelyExtractOracleValuesFromTxMsg(dataFeedIds)[0];\n    }\n\n    function getAuthorisedSignerIndex(address signerAddress) internal pure returns (uint8) {\n        if (signerAddress == 0x926E370fD53c23f8B71ad2B3217b227E41A92b12) return 0;\n        if (signerAddress == 0x0C39486f770B26F5527BBBf942726537986Cd7eb) return 1;\n        // For testing hardhat signer 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 is authorised\n        // will be removed in production deployment\n        if (signerAddress == 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266) return 2;\n\n        revert RedstoneError.SignerNotAuthorised(signerAddress);\n    }\n\n    /**\n     * @dev This function can be used in a consumer contract to securely extract several\n     * numeric oracle values for a given array of data feed ids. Security is achieved by\n     * signatures verification, timestamp validation, and aggregating values\n     * from different authorised signers into a single numeric value. If any of the\n     * required conditions do not match, the function will revert.\n     * Note! This function expects that tx calldata contains redstone payload in the end\n     * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\n     * @param dataFeedIds An array of unique data feed identifiers\n     * @return An array of the extracted and verified oracle values in the same order\n     * as they are requested in the dataFeedIds array\n     */\n    function getPrices(bytes32[] memory dataFeedIds) internal view returns (uint256[] memory) {\n        return _securelyExtractOracleValuesFromTxMsg(dataFeedIds);\n    }\n\n    /**\n     * @dev This function may be overridden by the child consumer contract.\n     * It should validate the timestamp against the current time (block.timestamp)\n     * It should revert with a helpful message if the timestamp is not valid\n     * @param receivedTimestampMilliseconds Timestamp extracted from calldata\n     */\n    function validateTimestamp(uint256 receivedTimestampMilliseconds) internal view {\n        // For testing this function is disabled\n        // Uncomment this line to enable timestamp validation in prod\n        // RedstoneDefaultsLib.validateTimestamp(receivedTimestampMilliseconds);\n    }\n\n    /**\n     * @dev This function should be overridden by the child consumer contract.\n     * @return The minimum required value of unique authorised signers\n     */\n    function getUniqueSignersThreshold() internal pure returns (uint8) {\n        return 1;\n    }\n\n    /**\n     * @dev This function may be overridden by the child consumer contract.\n     * It should aggregate values from different signers to a single uint value.\n     * By default, it calculates the median value\n     * @param values An array of uint256 values from different signers\n     * @return Result of the aggregation in the form of a single number\n     */\n    function aggregateValues(uint256[] memory values) internal pure returns (uint256) {\n        return RedstoneDefaultsLib.aggregateValues(values);\n    }\n\n    /**\n     * @dev This is an internal helpful function for secure extraction oracle values\n     * from the tx calldata. Security is achieved by signatures verification, timestamp\n     * validation, and aggregating values from different authorised signers into a\n     * single numeric value. If any of the required conditions (e.g. too old timestamp or\n     * insufficient number of authorised signers) do not match, the function will revert.\n     *\n     * Note! You should not call this function in a consumer contract. You can use\n     * `getOracleNumericValuesFromTxMsg` or `getOracleNumericValueFromTxMsg` instead.\n     *\n     * @param dataFeedIds An array of unique data feed identifiers\n     * @return An array of the extracted and verified oracle values in the same order\n     * as they are requested in dataFeedIds array\n     */\n    function _securelyExtractOracleValuesFromTxMsg(\n        bytes32[] memory dataFeedIds\n    ) private view returns (uint256[] memory) {\n        // Initializing helpful variables and allocating memory\n        uint256[] memory uniqueSignerCountForDataFeedIds = new uint256[](dataFeedIds.length);\n        uint256[] memory signersBitmapForDataFeedIds = new uint256[](dataFeedIds.length);\n        uint256[][] memory valuesForDataFeeds = new uint256[][](dataFeedIds.length);\n        for (uint256 i = 0; i < dataFeedIds.length; i++) {\n            // The line below is commented because newly allocated arrays are filled with zeros\n            // But we left it for better readability\n            // signersBitmapForDataFeedIds[i] = 0; // <- setting to an empty bitmap\n            valuesForDataFeeds[i] = new uint256[](getUniqueSignersThreshold());\n        }\n\n        // Extracting the number of data packages from calldata\n        uint256 calldataNegativeOffset = _extractByteSizeOfUnsignedMetadata();\n        uint256 dataPackagesCount = _extractDataPackagesCountFromCalldata(calldataNegativeOffset);\n        calldataNegativeOffset += DATA_PACKAGES_COUNT_BS;\n\n        // Saving current free memory pointer\n        uint256 freeMemPtr;\n        assembly {\n            freeMemPtr := mload(FREE_MEMORY_PTR)\n        }\n\n        // Data packages extraction in a loop\n        for (uint256 dataPackageIndex = 0; dataPackageIndex < dataPackagesCount; dataPackageIndex++) {\n            // Extract data package details and update calldata offset\n            uint256 dataPackageByteSize = _extractDataPackage(\n                dataFeedIds,\n                uniqueSignerCountForDataFeedIds,\n                signersBitmapForDataFeedIds,\n                valuesForDataFeeds,\n                calldataNegativeOffset\n            );\n            calldataNegativeOffset += dataPackageByteSize;\n\n            // Shifting memory pointer back to the \"safe\" value\n            assembly {\n                mstore(FREE_MEMORY_PTR, freeMemPtr)\n            }\n        }\n\n        // Validating numbers of unique signers and calculating aggregated values for each dataFeedId\n        return _getAggregatedValues(valuesForDataFeeds, uniqueSignerCountForDataFeedIds);\n    }\n\n    /**\n     * @dev This is a private helpful function, which extracts data for a data package based\n     * on the given negative calldata offset, verifies them, and in the case of successful\n     * verification updates the corresponding data package values in memory\n     *\n     * @param dataFeedIds an array of unique data feed identifiers\n     * @param uniqueSignerCountForDataFeedIds an array with the numbers of unique signers\n     * for each data feed\n     * @param signersBitmapForDataFeedIds an array of signer bitmaps for data feeds\n     * @param valuesForDataFeeds 2-dimensional array, valuesForDataFeeds[i][j] contains\n     * j-th value for the i-th data feed\n     * @param calldataNegativeOffset negative calldata offset for the given data package\n     *\n     * @return An array of the aggregated values\n     */\n    function _extractDataPackage(\n        bytes32[] memory dataFeedIds,\n        uint256[] memory uniqueSignerCountForDataFeedIds,\n        uint256[] memory signersBitmapForDataFeedIds,\n        uint256[][] memory valuesForDataFeeds,\n        uint256 calldataNegativeOffset\n    ) private view returns (uint256) {\n        uint256 signerIndex;\n\n        (uint256 dataPointsCount, uint256 eachDataPointValueByteSize) = _extractDataPointsDetailsForDataPackage(\n            calldataNegativeOffset\n        );\n\n        // We use scopes to resolve problem with too deep stack\n        {\n            uint48 extractedTimestamp;\n            address signerAddress;\n            bytes32 signedHash;\n            bytes memory signedMessage;\n            uint256 signedMessageBytesCount;\n\n            signedMessageBytesCount =\n                dataPointsCount.mul(eachDataPointValueByteSize + DATA_POINT_SYMBOL_BS) +\n                DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS; //DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS\n\n            uint256 timestampCalldataOffset = msg.data.length.sub(\n                calldataNegativeOffset + TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS\n            );\n\n            uint256 signedMessageCalldataOffset = msg.data.length.sub(\n                calldataNegativeOffset + SIG_BS + signedMessageBytesCount\n            );\n\n            assembly {\n                // Extracting the signed message\n                signedMessage := extractBytesFromCalldata(signedMessageCalldataOffset, signedMessageBytesCount)\n\n                // Hashing the signed message\n                signedHash := keccak256(add(signedMessage, BYTES_ARR_LEN_VAR_BS), signedMessageBytesCount)\n\n                // Extracting timestamp\n                extractedTimestamp := calldataload(timestampCalldataOffset)\n\n                function initByteArray(bytesCount) -> ptr {\n                    ptr := mload(FREE_MEMORY_PTR)\n                    mstore(ptr, bytesCount)\n                    ptr := add(ptr, BYTES_ARR_LEN_VAR_BS)\n                    mstore(FREE_MEMORY_PTR, add(ptr, bytesCount))\n                }\n\n                function extractBytesFromCalldata(offset, bytesCount) -> extractedBytes {\n                    let extractedBytesStartPtr := initByteArray(bytesCount)\n                    calldatacopy(extractedBytesStartPtr, offset, bytesCount)\n                    extractedBytes := sub(extractedBytesStartPtr, BYTES_ARR_LEN_VAR_BS)\n                }\n            }\n\n            // Validating timestamp\n            validateTimestamp(extractedTimestamp);\n\n            // Verifying the off-chain signature against on-chain hashed data\n            signerAddress = SignatureLib.recoverSignerAddress(signedHash, calldataNegativeOffset + SIG_BS);\n            signerIndex = getAuthorisedSignerIndex(signerAddress);\n        }\n\n        // Updating helpful arrays\n        {\n            bytes32 dataPointDataFeedId;\n            uint256 dataPointValue;\n            for (uint256 dataPointIndex = 0; dataPointIndex < dataPointsCount; dataPointIndex++) {\n                // Extracting data feed id and value for the current data point\n                (dataPointDataFeedId, dataPointValue) = _extractDataPointValueAndDataFeedId(\n                    calldataNegativeOffset,\n                    eachDataPointValueByteSize,\n                    dataPointIndex\n                );\n\n                for (uint256 dataFeedIdIndex = 0; dataFeedIdIndex < dataFeedIds.length; dataFeedIdIndex++) {\n                    if (dataPointDataFeedId == dataFeedIds[dataFeedIdIndex]) {\n                        uint256 bitmapSignersForDataFeedId = signersBitmapForDataFeedIds[dataFeedIdIndex];\n\n                        if (\n                            !BitmapLib.getBitFromBitmap(\n                                bitmapSignersForDataFeedId,\n                                signerIndex\n                            ) /* current signer was not counted for current dataFeedId */ &&\n                            uniqueSignerCountForDataFeedIds[dataFeedIdIndex] < getUniqueSignersThreshold()\n                        ) {\n                            // Increase unique signer counter\n                            uniqueSignerCountForDataFeedIds[dataFeedIdIndex]++;\n\n                            // Add new value\n                            valuesForDataFeeds[dataFeedIdIndex][\n                                uniqueSignerCountForDataFeedIds[dataFeedIdIndex] - 1\n                            ] = dataPointValue;\n\n                            // Update signers bitmap\n                            signersBitmapForDataFeedIds[dataFeedIdIndex] = BitmapLib.setBitInBitmap(\n                                bitmapSignersForDataFeedId,\n                                signerIndex\n                            );\n                        }\n\n                        // Breaking, as there couldn't be several indexes for the same feed ID\n                        break;\n                    }\n                }\n            }\n        }\n\n        // Return total data package byte size\n        return\n            DATA_PACKAGE_WITHOUT_DATA_POINTS_BS + (eachDataPointValueByteSize + DATA_POINT_SYMBOL_BS) * dataPointsCount;\n    }\n\n    /**\n     * @dev This is a private helpful function, which aggregates values from different\n     * authorised signers for the given arrays of values for each data feed\n     *\n     * @param valuesForDataFeeds 2-dimensional array, valuesForDataFeeds[i][j] contains\n     * j-th value for the i-th data feed\n     * @param uniqueSignerCountForDataFeedIds an array with the numbers of unique signers\n     * for each data feed\n     *\n     * @return An array of the aggregated values\n     */\n    function _getAggregatedValues(\n        uint256[][] memory valuesForDataFeeds,\n        uint256[] memory uniqueSignerCountForDataFeedIds\n    ) private pure returns (uint256[] memory) {\n        uint256[] memory aggregatedValues = new uint256[](valuesForDataFeeds.length);\n        uint256 uniqueSignersThreshold = getUniqueSignersThreshold();\n\n        for (uint256 dataFeedIndex = 0; dataFeedIndex < valuesForDataFeeds.length; dataFeedIndex++) {\n            if (uniqueSignerCountForDataFeedIds[dataFeedIndex] < uniqueSignersThreshold) {\n                revert RedstoneError.InsufficientNumberOfUniqueSigners(\n                    uniqueSignerCountForDataFeedIds[dataFeedIndex],\n                    uniqueSignersThreshold\n                );\n            }\n            uint256 aggregatedValueForDataFeedId = aggregateValues(valuesForDataFeeds[dataFeedIndex]);\n            aggregatedValues[dataFeedIndex] = aggregatedValueForDataFeedId;\n        }\n\n        return aggregatedValues;\n    }\n\n    function _extractDataPointsDetailsForDataPackage(\n        uint256 calldataNegativeOffsetForDataPackage\n    ) private pure returns (uint256 dataPointsCount, uint256 eachDataPointValueByteSize) {\n        // Using uint24, because data points count byte size number has 3 bytes\n        uint24 dataPointsCount_;\n\n        // Using uint32, because data point value byte size has 4 bytes\n        uint32 eachDataPointValueByteSize_;\n\n        // Extract data points count\n        uint256 negativeCalldataOffset = calldataNegativeOffsetForDataPackage + SIG_BS;\n        uint256 calldataOffset = msg.data.length.sub(negativeCalldataOffset + STANDARD_SLOT_BS);\n        assembly {\n            dataPointsCount_ := calldataload(calldataOffset)\n        }\n\n        // Extract each data point value size\n        calldataOffset = calldataOffset.sub(DATA_POINTS_COUNT_BS);\n        assembly {\n            eachDataPointValueByteSize_ := calldataload(calldataOffset)\n        }\n\n        // Prepare returned values\n        dataPointsCount = dataPointsCount_;\n        eachDataPointValueByteSize = eachDataPointValueByteSize_;\n    }\n\n    function _extractByteSizeOfUnsignedMetadata() private pure returns (uint256) {\n        // Checking if the calldata ends with the RedStone marker\n        bool hasValidRedstoneMarker;\n        assembly {\n            let calldataLast32Bytes := calldataload(sub(calldatasize(), STANDARD_SLOT_BS))\n            hasValidRedstoneMarker := eq(REDSTONE_MARKER_MASK, and(calldataLast32Bytes, REDSTONE_MARKER_MASK))\n        }\n        if (!hasValidRedstoneMarker) {\n            revert RedstoneError.CalldataMustHaveValidPayload();\n        }\n\n        // Using uint24, because unsigned metadata byte size number has 3 bytes\n        uint24 unsignedMetadataByteSize;\n        if (REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS > msg.data.length) {\n            revert RedstoneError.CalldataOverOrUnderFlow();\n        }\n        assembly {\n            unsignedMetadataByteSize := calldataload(sub(calldatasize(), REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS))\n        }\n        uint256 calldataNegativeOffset = unsignedMetadataByteSize + UNSIGNED_METADATA_BYTE_SIZE_BS + REDSTONE_MARKER_BS;\n        if (calldataNegativeOffset + DATA_PACKAGES_COUNT_BS > msg.data.length) {\n            revert RedstoneError.IncorrectUnsignedMetadataSize();\n        }\n        return calldataNegativeOffset;\n    }\n\n    function _extractDataPackagesCountFromCalldata(\n        uint256 calldataNegativeOffset\n    ) private pure returns (uint16 dataPackagesCount) {\n        uint256 calldataNegativeOffsetWithStandardSlot = calldataNegativeOffset + STANDARD_SLOT_BS;\n        if (calldataNegativeOffsetWithStandardSlot > msg.data.length) {\n            revert RedstoneError.CalldataOverOrUnderFlow();\n        }\n        assembly {\n            dataPackagesCount := calldataload(sub(calldatasize(), calldataNegativeOffsetWithStandardSlot))\n        }\n        return dataPackagesCount;\n    }\n\n    function _extractDataPointValueAndDataFeedId(\n        uint256 calldataNegativeOffsetForDataPackage,\n        uint256 defaultDataPointValueByteSize,\n        uint256 dataPointIndex\n    ) private pure returns (bytes32 dataPointDataFeedId, uint256 dataPointValue) {\n        uint256 negativeOffsetToDataPoints = calldataNegativeOffsetForDataPackage + DATA_PACKAGE_WITHOUT_DATA_POINTS_BS;\n        uint256 dataPointNegativeOffset = negativeOffsetToDataPoints.add(\n            (1 + dataPointIndex).mul((defaultDataPointValueByteSize + DATA_POINT_SYMBOL_BS))\n        );\n        uint256 dataPointCalldataOffset = msg.data.length.sub(dataPointNegativeOffset);\n        assembly {\n            dataPointDataFeedId := calldataload(dataPointCalldataOffset)\n            dataPointValue := calldataload(add(dataPointCalldataOffset, DATA_POINT_SYMBOL_BS))\n        }\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibStabilityRate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\nimport {IERC20Permit} from \"../../shared/IERC20Permit.sol\";\n\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibKrAsset} from \"../libs/LibKrAsset.sol\";\n\nimport {StabilityRateConfig} from \"../InterestRateState.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @author Kresko\n * @title AMM price stability rate library, derived from Aave Protocols VariableDebtToken calculations\n * @notice Library for performing stability rate related operations\n */\nlibrary LibStabilityRate {\n    using WadRay for uint256;\n    using WadRay for uint128;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /**\n     * @notice Cumulates the stability rate from previous update and multiplies the debt index with it.\n     * @dev Updates the updated timestamp\n     * @dev New debt index cannot overflow uint128\n     * @param self configuration for the asset\n     * @return newDebtIndex the updated index\n     */\n    function updateDebtIndex(StabilityRateConfig storage self) internal returns (uint256 newDebtIndex) {\n        if (self.asset == address(0)) return WadRay.RAY;\n\n        newDebtIndex = self.debtIndex;\n        // only cumulating if there is any assets minted and rate is over 0\n        if (IERC20Permit(self.asset).totalSupply() != 0) {\n            uint256 cumulatedStabilityRate = self.calculateCompoundedInterest(block.timestamp);\n            newDebtIndex = cumulatedStabilityRate.rayMul(self.debtIndex);\n            require(newDebtIndex <= type(uint128).max, Error.DEBT_INDEX_OVERFLOW);\n            self.debtIndex = uint128(newDebtIndex);\n        }\n\n        self.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /**\n     * @notice Updates the current stability rate for an asset\n     * @dev New stability rate cannot overflow uint128\n     * @param self rate configuration for the asset\n     */\n    function updateStabilityRate(StabilityRateConfig storage self) internal {\n        if (self.asset == address(0)) return;\n\n        uint256 stabilityRate = calculateStabilityRate(self);\n        require(stabilityRate <= type(uint128).max, Error.STABILITY_RATE_OVERFLOW);\n        self.stabilityRate = uint128(stabilityRate);\n    }\n\n    /**\n     * @notice Get the current price rate between AMM and oracle pricing\n     * @dev Raw return value of ammPrice == 0 when no AMM pair exists OR liquidity of the pair does not qualify\n     * @param self rate configuration for the asset\n     * @return priceRate the current price rate\n     */\n    function getPriceRate(StabilityRateConfig storage self) internal view returns (uint256 priceRate) {\n        uint256 oraclePrice = ms().getKrAssetValue(self.asset, 1 ether, true);\n        uint256 ammPrice = ms().getKrAssetAMMPrice(self.asset, 1 ether);\n        // no pair, no effect\n        if (ammPrice == 0) {\n            return 0;\n        }\n        return ammPrice.wadDiv(oraclePrice) / 10;\n    }\n\n    /**\n     * @notice Calculate new stability rate from the current price rate\n     * @dev Separate calculations exist for following cases:\n     * case 1: AMM premium < optimal\n     * case 2: AMM premium > optimal\n     * @param self rate configuration for the asset\n     * @return stabilityRate the current stability rate\n     */\n    function calculateStabilityRate(StabilityRateConfig storage self) internal view returns (uint256 stabilityRate) {\n        uint256 priceRate = self.getPriceRate(); // 0.95 RAY = -5% PREMIUM, 1.05 RAY = +5% PREMIUM\n        // Return base rate if no AMM price exists\n        if (priceRate == 0) {\n            return self.stabilityRateBase;\n        }\n        bool rateIsGTOptimal = priceRate > self.optimalPriceRate;\n\n        uint256 rateDiff = rateIsGTOptimal ? priceRate - self.optimalPriceRate : self.optimalPriceRate - priceRate;\n        uint256 rateDiffAdjusted = rateDiff.rayMul(self.rateSlope2.rayDiv(self.rateSlope1 + self.priceRateDelta));\n\n        if (!rateIsGTOptimal) {\n            // Case: AMM price is lower than priceRate\n            return self.stabilityRateBase + rateDiffAdjusted;\n        } else {\n            // Case: AMM price is higher than priceRate\n            return self.stabilityRateBase.rayDiv(WadRay.RAY + rateDiffAdjusted);\n        }\n    }\n\n    /**\n     * @dev Function to calculate the interest using a compounded interest rate formula\n     * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\n     *\n     *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n     *\n     * The approximation slightly underpays liquidity providers and undercharges borrowers\n     * with the advantage of great gas cost reductions\n     * The Aave whitepaper contains reference to the approximation\n     * with a table showing the margin of error per different time periods\n     *\n     * @param self rate configuration for the asset\n     * @param _currentTimestamp The timestamp of the last update of the interest\n     * @return The interest rate compounded during the timeDelta, in ray\n     **/\n    function calculateCompoundedInterest(\n        StabilityRateConfig storage self,\n        uint256 _currentTimestamp\n    ) internal view returns (uint256) {\n        //solium-disable-next-line\n        uint256 exp = _currentTimestamp - uint256(self.lastUpdateTimestamp);\n\n        if (exp == 0) {\n            return WadRay.RAY;\n        }\n\n        uint256 expMinusOne;\n        uint256 expMinusTwo;\n        uint256 basePowerTwo;\n        uint256 basePowerThree;\n        unchecked {\n            expMinusOne = exp - 1;\n\n            expMinusTwo = exp > 2 ? exp - 2 : 0;\n\n            basePowerTwo = self.stabilityRate.rayMul(self.stabilityRate) / (SECONDS_PER_YEAR * SECONDS_PER_YEAR);\n            basePowerThree = basePowerTwo.rayMul(self.stabilityRate) / SECONDS_PER_YEAR;\n        }\n\n        uint256 secondTerm = exp * expMinusOne * basePowerTwo;\n        unchecked {\n            secondTerm /= 2;\n        }\n        uint256 thirdTerm = exp * expMinusOne * expMinusTwo * basePowerThree;\n        unchecked {\n            thirdTerm /= 6;\n        }\n\n        return WadRay.RAY + (self.stabilityRate * exp) / SECONDS_PER_YEAR + secondTerm + thirdTerm;\n    }\n\n    /**\n     * @dev Returns the ongoing normalized debt index for the borrowers\n     * A value of 1e27 means there is no interest. As time passes, the interest is accrued\n     * A value of 2*1e27 means that for each unit of debt, one unit worth of interest has been accumulated\n     * @param self rate configuration for the asset\n     * @return The normalized debt index. expressed in ray\n     **/\n    function getNormalizedDebtIndex(StabilityRateConfig storage self) internal view returns (uint256) {\n        if (self.asset == address(0)) return WadRay.RAY;\n        //solium-disable-next-line\n        if (self.lastUpdateTimestamp == uint40(block.timestamp)) {\n            //if the index was updated in the same block, no need to perform any calculation\n            return self.debtIndex;\n        }\n\n        return self.calculateCompoundedInterest(block.timestamp).rayMul(self.debtIndex);\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibUI.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n// solhint-disable-next-line\nimport {IERC20Permit} from \"../../shared/IERC20Permit.sol\";\nimport {IFluxPriceFeed} from \"../../vendor/flux/interfaces/IFluxPriceFeed.sol\";\nimport {AggregatorV3Interface} from \"../../vendor/AggregatorV3Interface.sol\";\nimport {IUniswapV2Pair} from \"../../vendor/uniswap/v2-core/interfaces/IUniswapV2Pair.sol\";\nimport {IKrStaking} from \"../../staking/interfaces/IKrStaking.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {IUniswapV2OracleCompat} from \"../amm-oracle/IUniswapV2OracleCompat.sol\";\nimport {KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {MinterState, ms} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/* solhint-disable contract-name-camelcase */\n/* solhint-disable var-name-mixedcase */\n\n/**\n * @title Library for UI related views\n * @author Kresko\n */\nlibrary LibUI {\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n\n    struct CollateralAssetInfoUser {\n        address assetAddress;\n        address oracleAddress;\n        address anchorAddress;\n        uint256 amount;\n        uint256 amountUSD;\n        uint256 cFactor;\n        uint256 liquidationIncentive;\n        uint8 decimals;\n        uint256 index;\n        uint256 price;\n        string symbol;\n        string name;\n    }\n\n    struct CollateralAssetInfo {\n        address assetAddress;\n        address oracleAddress;\n        address anchorAddress;\n        uint256 price;\n        uint256 value;\n        uint256 liquidationIncentive;\n        uint256 cFactor;\n        uint8 decimals;\n        string symbol;\n        string name;\n        bool marketOpen;\n    }\n\n    struct ProtocolParams {\n        uint256 minDebtValue;\n        uint256 minCollateralRatio;\n        uint256 liquidationThreshold;\n    }\n\n    struct krAssetInfo {\n        address oracleAddress;\n        address assetAddress;\n        address anchorAddress;\n        uint256 price;\n        uint256 ammPrice;\n        uint256 priceRate;\n        uint256 stabilityRate;\n        uint256 value;\n        uint256 openFee;\n        uint256 closeFee;\n        uint256 kFactor;\n        string symbol;\n        string name;\n        bool marketOpen;\n    }\n\n    struct KreskoUser {\n        krAssetInfoUser[] krAssets;\n        CollateralAssetInfoUser[] collateralAssets;\n        uint256 healthFactor;\n        uint256 debtActualUSD;\n        uint256 debtUSD;\n        uint256 collateralActualUSD;\n        uint256 collateralUSD;\n        uint256 minCollateralUSD;\n        uint256 borrowingPowerUSD;\n    }\n\n    struct PairData {\n        uint8 decimals0;\n        uint8 decimals1;\n        uint256 reserve0;\n        uint256 reserve1;\n        uint256 totalSupply;\n    }\n\n    struct GenericInfo {\n        address assetAddress;\n        uint256 kFactor;\n        uint256 cFactor;\n        uint256 price;\n        bool isKrAsset;\n        bool isCollateral;\n        uint256 debtAmount;\n        uint256 depositAmount;\n        uint256 walletBalance;\n    }\n\n    struct Price {\n        uint256 price;\n        uint256 timestamp;\n        address assetAddress;\n        uint80 roundId;\n        bool marketOpen;\n    }\n\n    struct Allowance {\n        address owner;\n        address spender;\n        uint256 allowance;\n    }\n\n    struct Balance {\n        address token;\n        uint256 balance;\n    }\n\n    struct TokenMetadata {\n        uint8 decimals;\n        string symbol;\n        string name;\n        uint256 totalSupply;\n    }\n\n    struct StakingData {\n        uint256 pid;\n        address depositToken;\n        uint256 totalDeposits;\n        uint256 allocPoint;\n        uint256 rewardPerBlocks;\n        uint256 lastRewardBlock;\n        uint256 depositAmount;\n        address[] rewardTokens;\n        uint256[] rewardAmounts;\n    }\n\n    struct krAssetInfoUser {\n        address assetAddress;\n        address oracleAddress;\n        address anchorAddress;\n        uint256 amount;\n        uint256 amountScaled;\n        uint256 priceRate;\n        uint256 stabilityRate;\n        uint256 amountUSD;\n        uint256 index;\n        uint256 kFactor;\n        uint256 price;\n        uint256 ammPrice;\n        string symbol;\n        string name;\n        uint256 openFee;\n        uint256 closeFee;\n    }\n\n    function getBalances(address[] memory _tokens, address account) internal view returns (Balance[] memory balances) {\n        balances = new Balance[](_tokens.length);\n        for (uint256 i; i < _tokens.length; i++) {\n            balances[i] = Balance({token: address(_tokens[i]), balance: IERC20Permit(_tokens[i]).balanceOf(account)});\n        }\n    }\n\n    function getAllowances(\n        address[] memory _tokens,\n        address owner,\n        address spender\n    ) internal view returns (Allowance[] memory allowances) {\n        allowances = new Allowance[](_tokens.length);\n        for (uint256 i; i < _tokens.length; i++) {\n            allowances[i] = Allowance({\n                allowance: IERC20Permit(_tokens[i]).allowance(owner, spender),\n                spender: spender,\n                owner: owner\n            });\n        }\n    }\n\n    function getStakingData(address _account, address _staking) internal view returns (StakingData[] memory result) {\n        IKrStaking staking = IKrStaking(_staking);\n        IKrStaking.Reward[] memory rewards = staking.allPendingRewards(_account);\n        result = new StakingData[](rewards.length);\n\n        for (uint256 i; i < rewards.length; i++) {\n            IKrStaking.PoolInfo memory poolInfo = staking.poolInfo(rewards[i].pid);\n            address depositTokenAddress = address(poolInfo.depositToken);\n            result[i] = StakingData({\n                pid: rewards[i].pid,\n                totalDeposits: poolInfo.depositToken.balanceOf(_staking),\n                allocPoint: poolInfo.allocPoint,\n                depositToken: depositTokenAddress,\n                depositAmount: staking.userInfo(rewards[i].pid, _account).amount,\n                rewardTokens: rewards[i].tokens,\n                rewardAmounts: rewards[i].amounts,\n                rewardPerBlocks: staking.rewardPerBlockFor(depositTokenAddress),\n                lastRewardBlock: poolInfo.lastRewardBlock\n            });\n        }\n    }\n\n    function borrowingPowerUSD(address _account) internal view returns (uint256) {\n        uint256 minCollateral = ms().getAccountMinimumCollateralValueAtRatio(\n            _account,\n            ms().minimumCollateralizationRatio\n        );\n        uint256 collateral = ms().getAccountCollateralValue(_account);\n\n        if (collateral < minCollateral) {\n            return 0;\n        } else {\n            return collateral - minCollateral;\n        }\n    }\n\n    function batchOracleValues(\n        address[] memory _assets,\n        address[] memory _priceFeeds,\n        address[] memory _marketStatusFeeds\n    ) internal view returns (Price[] memory result) {\n        require(_marketStatusFeeds.length == _priceFeeds.length, Error.PRICEFEEDS_MUST_MATCH_STATUS_FEEDS);\n        result = new Price[](_assets.length);\n\n        for (uint256 i; i < _assets.length; i++) {\n            (uint80 roundId, int256 answer, , uint256 timestamp, ) = AggregatorV3Interface(_priceFeeds[i])\n                .latestRoundData();\n            result[i] = Price({\n                price: uint256(answer),\n                timestamp: timestamp,\n                assetAddress: _assets[i],\n                roundId: roundId,\n                marketOpen: true\n            });\n        }\n    }\n\n    function krAssetInfos(address[] memory assetAddresses) internal view returns (krAssetInfo[] memory result) {\n        result = new krAssetInfo[](assetAddresses.length);\n        for (uint256 i; i < assetAddresses.length; i++) {\n            address assetAddress = assetAddresses[i];\n            KrAsset memory krAsset = ms().kreskoAssets[assetAddress];\n            uint256 ammPrice;\n            uint256 stabilityRate;\n            uint256 priceRate;\n            if (irs().srAssets[assetAddress].asset != address(0)) {\n                ammPrice = IUniswapV2OracleCompat(ms().ammOracle).consultKrAsset(assetAddress, 1 ether);\n                stabilityRate = irs().srAssets[assetAddress].calculateStabilityRate();\n                priceRate = irs().srAssets[assetAddress].getPriceRate();\n            }\n            (, int256 answer, , , ) = krAsset.oracle.latestRoundData();\n            result[i] = krAssetInfo({\n                value: ms().getKrAssetValue(assetAddress, 1 ether, false),\n                oracleAddress: address(krAsset.oracle),\n                anchorAddress: krAsset.anchor,\n                assetAddress: assetAddress,\n                closeFee: krAsset.closeFee,\n                openFee: krAsset.openFee,\n                kFactor: krAsset.kFactor,\n                price: uint256(answer),\n                stabilityRate: stabilityRate,\n                priceRate: priceRate,\n                ammPrice: ammPrice,\n                marketOpen: true,\n                symbol: IERC20Permit(assetAddress).symbol(),\n                name: IERC20Permit(assetAddress).name()\n            });\n        }\n    }\n\n    function collateralAssetInfos(\n        address[] memory assetAddresses\n    ) internal view returns (CollateralAssetInfo[] memory result) {\n        result = new CollateralAssetInfo[](assetAddresses.length);\n        for (uint256 i; i < assetAddresses.length; i++) {\n            address assetAddress = assetAddresses[i];\n            CollateralAsset memory collateralAsset = ms().collateralAssets[assetAddress];\n            uint8 decimals = IERC20Permit(assetAddress).decimals();\n\n            (uint256 value, uint256 price) = ms().getCollateralValueAndOraclePrice(\n                assetAddress,\n                1 * 10 ** decimals,\n                false\n            );\n\n            result[i] = CollateralAssetInfo({\n                value: value,\n                oracleAddress: address(collateralAsset.oracle),\n                anchorAddress: collateralAsset.anchor,\n                assetAddress: assetAddress,\n                liquidationIncentive: collateralAsset.liquidationIncentive,\n                cFactor: collateralAsset.factor,\n                decimals: decimals,\n                price: price,\n                marketOpen: true,\n                symbol: IERC20Permit(assetAddress).symbol(),\n                name: IERC20Permit(assetAddress).name()\n            });\n        }\n    }\n\n    function collateralAssetInfoFor(\n        address _account\n    ) internal view returns (CollateralAssetInfoUser[] memory result, uint256 totalCollateralUSD) {\n        address[] memory collateralAssetAddresses = ms().getDepositedCollateralAssets(_account);\n        if (collateralAssetAddresses.length > 0) {\n            result = new CollateralAssetInfoUser[](collateralAssetAddresses.length);\n            for (uint256 i; i < collateralAssetAddresses.length; i++) {\n                address assetAddress = collateralAssetAddresses[i];\n                uint8 decimals = IERC20Permit(assetAddress).decimals();\n\n                uint256 amount = ms().getCollateralDeposits(_account, assetAddress);\n\n                (uint256 amountUSD, uint256 price) = ms().getCollateralValueAndOraclePrice(assetAddress, amount, true);\n\n                totalCollateralUSD + amountUSD;\n                result[i] = CollateralAssetInfoUser({\n                    amount: amount,\n                    amountUSD: amountUSD,\n                    liquidationIncentive: ms().collateralAssets[assetAddress].liquidationIncentive,\n                    anchorAddress: ms().collateralAssets[assetAddress].anchor,\n                    oracleAddress: address(ms().collateralAssets[assetAddress].oracle),\n                    assetAddress: assetAddress,\n                    cFactor: ms().collateralAssets[assetAddress].factor,\n                    decimals: decimals,\n                    index: i,\n                    price: price,\n                    symbol: IERC20Permit(assetAddress).symbol(),\n                    name: IERC20Permit(assetAddress).name()\n                });\n            }\n        }\n    }\n\n    function krAssetInfoFor(\n        address _account\n    ) internal view returns (krAssetInfoUser[] memory result, uint256 totalDebtUSD) {\n        address[] memory krAssetAddresses = ms().mintedKreskoAssets[_account];\n        if (krAssetAddresses.length > 0) {\n            result = new krAssetInfoUser[](krAssetAddresses.length);\n            for (uint256 i; i < krAssetAddresses.length; i++) {\n                address assetAddress = krAssetAddresses[i];\n                KrAsset memory krAsset = ms().kreskoAssets[assetAddress];\n                uint256 amount = ms().getKreskoAssetDebtPrincipal(_account, assetAddress);\n                uint256 amountScaled = ms().getKreskoAssetDebtScaled(_account, assetAddress);\n\n                uint256 amountUSD = ms().getKrAssetValue(assetAddress, amount, true);\n                uint256 ammPrice;\n                uint256 stabilityRate;\n                uint256 priceRate;\n                if (irs().srAssets[assetAddress].asset != address(0)) {\n                    stabilityRate = irs().srAssets[assetAddress].calculateStabilityRate();\n                    priceRate = irs().srAssets[assetAddress].getPriceRate();\n                    ammPrice = IUniswapV2OracleCompat(ms().ammOracle).consultKrAsset(assetAddress, 1 ether);\n                }\n                totalDebtUSD + amountUSD;\n                (, int256 answer, , , ) = krAsset.oracle.latestRoundData();\n                result[i] = krAssetInfoUser({\n                    assetAddress: assetAddress,\n                    oracleAddress: address(krAsset.oracle),\n                    anchorAddress: krAsset.anchor,\n                    openFee: krAsset.openFee,\n                    closeFee: krAsset.closeFee,\n                    amount: amount,\n                    amountScaled: amountScaled,\n                    amountUSD: amountUSD,\n                    stabilityRate: stabilityRate,\n                    priceRate: priceRate,\n                    index: i,\n                    kFactor: krAsset.kFactor,\n                    price: uint256(answer),\n                    ammPrice: ammPrice,\n                    symbol: IERC20Permit(assetAddress).symbol(),\n                    name: IERC20Permit(assetAddress).name()\n                });\n            }\n        }\n    }\n\n    function healthFactorFor(address _account) internal view returns (uint256) {\n        uint256 userDebt = ms().getAccountKrAssetValue(_account);\n        uint256 userCollateral = ms().getAccountCollateralValue(_account);\n\n        if (userDebt > 0) {\n            return userCollateral.wadDiv(userDebt);\n        } else {\n            return 0;\n        }\n    }\n\n    function kreskoUser(address _account) internal view returns (KreskoUser memory user) {\n        (krAssetInfoUser[] memory krInfos, uint256 totalDebtUSD) = krAssetInfoFor(_account);\n        (CollateralAssetInfoUser[] memory collateralInfos, uint256 totalCollateralUSD) = collateralAssetInfoFor(\n            _account\n        );\n\n        if (krInfos.length > 0 || collateralInfos.length > 0) {\n            user = KreskoUser({\n                collateralAssets: collateralInfos,\n                krAssets: krInfos,\n                borrowingPowerUSD: borrowingPowerUSD(_account),\n                healthFactor: healthFactorFor(_account),\n                debtActualUSD: totalDebtUSD,\n                debtUSD: ms().getAccountKrAssetValue(_account),\n                collateralActualUSD: totalCollateralUSD,\n                collateralUSD: ms().getAccountCollateralValue(_account),\n                minCollateralUSD: ms().getAccountMinimumCollateralValueAtRatio(\n                    _account,\n                    ms().minimumCollateralizationRatio\n                )\n            });\n        }\n    }\n}\n"
    },
    "src/contracts/minter/MinterModifiers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {ms} from \"./MinterStorage.sol\";\nimport {Action} from \"./MinterTypes.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\nabstract contract MinterModifiers {\n    /**\n     * @notice Reverts if a collateral asset does not exist within the protocol.\n     * @param _collateralAsset The address of the collateral asset.\n     */\n    modifier collateralAssetExists(address _collateralAsset) {\n        require(ms().collateralAssets[_collateralAsset].exists, Error.COLLATERAL_DOESNT_EXIST);\n        _;\n    }\n\n    /**\n     * @notice Reverts if a collateral asset already exists within the protocol.\n     * @param _collateralAsset The address of the collateral asset.\n     */\n    modifier collateralAssetDoesNotExist(address _collateralAsset) {\n        require(!ms().collateralAssets[_collateralAsset].exists, Error.COLLATERAL_EXISTS);\n        _;\n    }\n\n    /**\n     * @notice Reverts if a Kresko asset does not exist within the protocol. Does not revert if\n     * the Kresko asset is not mintable.\n     * @param _kreskoAsset The address of the Kresko asset.\n     */\n    modifier kreskoAssetExists(address _kreskoAsset) {\n        require(ms().kreskoAssets[_kreskoAsset].exists, Error.KRASSET_DOESNT_EXIST);\n        _;\n    }\n\n    /**\n     * @notice Reverts if the symbol of a Kresko asset already exists within the protocol.\n     * @param _kreskoAsset The address of the Kresko asset.\n     */\n    modifier kreskoAssetDoesNotExist(address _kreskoAsset) {\n        require(!ms().kreskoAssets[_kreskoAsset].exists, Error.KRASSET_EXISTS);\n        _;\n    }\n\n    /// @dev Simple check for the enabled flag\n    function ensureNotPaused(address _asset, Action _action) internal view virtual {\n        require(!ms().safetyState[_asset][_action].pause.enabled, Error.ACTION_PAUSED_FOR_ASSET);\n    }\n}\n"
    },
    "src/contracts/minter/MinterState.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {LibKrAsset} from \"./libs/LibKrAsset.sol\";\nimport {LibAccount} from \"./libs/LibAccount.sol\";\nimport {LibCollateral} from \"./libs/LibCollateral.sol\";\nimport {LibCalculation} from \"./libs/LibCalculation.sol\";\nimport {LibBurn} from \"./libs/LibBurn.sol\";\nimport {LibMint} from \"./libs/LibMint.sol\";\nimport {Action, SafetyState, CollateralAsset, KrAsset} from \"./MinterTypes.sol\";\n\n/* solhint-disable state-visibility */\nusing LibCalculation for MinterState global;\nusing LibKrAsset for MinterState global;\nusing LibCollateral for MinterState global;\nusing LibAccount for MinterState global;\nusing LibBurn for MinterState global;\nusing LibMint for MinterState global;\n\n/**\n * @title Storage layout for the minter state\n * @author Kresko\n */\nstruct MinterState {\n    /* -------------------------------------------------------------------------- */\n    /*                               Initialization                               */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Initialization version\n    uint256 initializations;\n    bytes32 domainSeparator;\n    /* -------------------------------------------------------------------------- */\n    /*                           Configurable Parameters                          */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice The recipient of protocol fees.\n    address feeRecipient;\n    /// @notice The factor used to calculate the incentive a liquidator receives in the form of seized collateral.\n    uint256 liquidationIncentiveMultiplier;\n    /// @notice The minimum ratio of collateral to debt that can be taken by direct action.\n    uint256 minimumCollateralizationRatio;\n    /// @notice The minimum USD value of an individual synthetic asset debt position.\n    uint256 minimumDebtValue;\n    /// @notice The collateralization ratio at which positions may be liquidated.\n    uint256 liquidationThreshold;\n    /// @notice Flag tells if there is a need to perform safety checks on user actions\n    bool safetyStateSet;\n    /// @notice asset -> action -> state\n    mapping(address => mapping(Action => SafetyState)) safetyState;\n    /* -------------------------------------------------------------------------- */\n    /*                              Collateral Assets                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Mapping of collateral asset token address to information on the collateral asset.\n    mapping(address => CollateralAsset) collateralAssets;\n    /**\n     * @notice Mapping of account -> asset -> deposit amount\n     */\n    mapping(address => mapping(address => uint256)) collateralDeposits;\n    /// @notice Mapping of account -> collateral asset addresses deposited\n    mapping(address => address[]) depositedCollateralAssets;\n    /* -------------------------------------------------------------------------- */\n    /*                                Kresko Assets                               */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Mapping of kresko asset token address to information on the Kresko asset.\n    mapping(address => KrAsset) kreskoAssets;\n    /// @notice Mapping of account -> krAsset -> debt amount owed to the protocol\n    mapping(address => mapping(address => uint256)) kreskoAssetDebt;\n    /// @notice Mapping of account -> addresses of borrowed krAssets\n    mapping(address => address[]) mintedKreskoAssets;\n    /// @notice The AMM oracle address.\n    address ammOracle;\n    /// @notice Offchain oracle decimals\n    uint8 extOracleDecimals;\n    /// @notice Liquidation Overflow Multiplier, multiplies max liquidatable value.\n    uint256 maxLiquidationMultiplier;\n    /* -------------------------------------------------------------------------- */\n    /*                                  ORACLE                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice The oracle deviation percentage between the main oracle and fallback oracle.\n    uint256 oracleDeviationPct;\n    /// @notice L2 sequencer feed address\n    address sequencerUptimeFeed;\n    /// @notice grace period of sequencer in seconds\n    uint256 sequencerGracePeriodTime;\n    /// @notice timeout for oracle in seconds\n    uint256 oracleTimeout;\n}\n"
    },
    "src/contracts/minter/MinterStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\npragma solidity >=0.8.19;\n\nimport {MinterState} from \"./MinterState.sol\";\n\n// Storage position\nbytes32 constant MINTER_STORAGE_POSITION = keccak256(\"kresko.minter.storage\");\n\nfunction ms() pure returns (MinterState storage state) {\n    bytes32 position = MINTER_STORAGE_POSITION;\n    assembly {\n        state.slot := position\n    }\n}\n"
    },
    "src/contracts/minter/MinterTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IFluxPriceFeed} from \"../vendor/flux/interfaces/IFluxPriceFeed.sol\";\nimport {AggregatorV3Interface} from \"../vendor/AggregatorV3Interface.sol\";\nimport {IKreskoAssetAnchor} from \"../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {LibAssetUtility} from \"./libs/LibAssetUtility.sol\";\n\n/* solhint-disable state-visibility */\n\n/* -------------------------------------------------------------------------- */\n/*                                  CONSTANTS                                 */\n/* -------------------------------------------------------------------------- */\n\nlibrary Constants {\n    uint256 constant FP_DECIMALS = 18;\n\n    uint256 constant FP_SCALING_FACTOR = 10 ** FP_DECIMALS;\n\n    uint256 constant ONE_HUNDRED_PERCENT = 1 ether;\n\n    uint256 constant BASIS_POINT = 1e14;\n\n    /// @dev The maximum configurable close fee.\n    uint256 constant MAX_CLOSE_FEE = 0.1 ether; // 10%\n\n    /// @dev The maximum configurable open fee.\n    uint256 constant MAX_OPEN_FEE = 0.1 ether; // 10%\n\n    /// @dev Overflow over maximum liquidatable value to allow leeway for users after one happens.\n    uint256 constant MIN_MAX_LIQUIDATION_MULTIPLIER = ONE_HUNDRED_PERCENT + BASIS_POINT; // 100.01% or .01% over\n\n    /// @dev The minimum configurable minimum collateralization ratio.\n    uint256 constant MIN_COLLATERALIZATION_RATIO = ONE_HUNDRED_PERCENT;\n\n    /// @dev The minimum configurable liquidation incentive multiplier.\n    /// This means liquidator only receives equal amount of collateral to debt repaid.\n    uint256 constant MIN_LIQUIDATION_INCENTIVE_MULTIPLIER = ONE_HUNDRED_PERCENT;\n\n    /// @dev The maximum configurable liquidation incentive multiplier.\n    /// This means liquidator receives 25% bonus collateral compared to the debt repaid.\n    uint256 constant MAX_LIQUIDATION_INCENTIVE_MULTIPLIER = 1.25 ether; // 125%\n\n    /// @dev The minimum collateral amount for a kresko asset.\n    uint256 constant MIN_KRASSET_COLLATERAL_AMOUNT = 1e12;\n\n    /// @dev The maximum configurable minimum debt USD value. 8 decimals.\n    uint256 constant MAX_MIN_DEBT_VALUE = 1_000 * 1e8; // $1,000\n}\n\n/* -------------------------------------------------------------------------- */\n/*                                    ENUM                                    */\n/* -------------------------------------------------------------------------- */\n\n/**\n * @dev Protocol user facing actions\n *\n * Deposit = 0\n * Withdraw = 1,\n * Repay = 2,\n * Borrow = 3,\n * Liquidate = 4\n */\nenum Action {\n    Deposit,\n    Withdraw,\n    Repay,\n    Borrow,\n    Liquidation\n}\n/**\n * @dev Fee types\n *\n * Open = 0\n * Close = 1\n */\nenum Fee {\n    Open,\n    Close\n}\n\n/* ========================================================================== */\n/*                                   STRUCTS                                  */\n/* ========================================================================== */\n\n/**\n * @notice Initialization arguments for the protocol\n */\nstruct MinterInitArgs {\n    address admin;\n    address council;\n    address treasury;\n    uint8 extOracleDecimals;\n    uint256 minimumCollateralizationRatio;\n    uint256 minimumDebtValue;\n    uint256 liquidationThreshold;\n    uint256 oracleDeviationPct;\n    address sequencerUptimeFeed;\n    uint256 sequencerGracePeriodTime;\n    uint256 oracleTimeout;\n}\n\n/**\n * @notice Configurable parameters within the protocol\n */\n\nstruct MinterParams {\n    uint256 minimumCollateralizationRatio;\n    uint256 minimumDebtValue;\n    uint256 liquidationThreshold;\n    uint256 liquidationOverflowPercentage;\n    address feeRecipient;\n    uint8 extOracleDecimals;\n    uint256 oracleDeviationPct;\n}\n\n/**\n * @notice Information on a token that is a KreskoAsset.\n * @dev Each KreskoAsset has 18 decimals.\n * @param kFactor The k-factor used for calculating the required collateral value for KreskoAsset debt.\n * @param oracle The oracle that provides the USD price of one KreskoAsset.\n * @param supplyLimit The total supply limit of the KreskoAsset.\n * @param anchor The anchor address\n * @param closeFee The percentage paid in fees when closing a debt position of this type.\n * @param openFee The percentage paid in fees when opening a debt position of this type.\n * @param exists Whether the KreskoAsset exists within the protocol.\n */\nstruct KrAsset {\n    uint256 kFactor;\n    AggregatorV3Interface oracle;\n    uint256 supplyLimit;\n    address anchor;\n    uint256 closeFee;\n    uint256 openFee;\n    bool exists;\n    bytes32 redstoneId;\n}\n\nusing LibAssetUtility for KrAsset global;\n\n/**\n * @notice Information on a token that can be used as collateral.\n * @dev Setting the factor to zero effectively makes the asset useless as collateral while still allowing\n * it to be deposited and withdrawn.\n * @param factor The collateral factor used for calculating the value of the collateral.\n * @param oracle The oracle that provides the USD price of one collateral asset.\n * @param anchor If the collateral is a KreskoAsset, the anchor address\n * @param decimals The decimals for the token, stored here to avoid repetitive external calls.\n * @param exists Whether the collateral asset exists within the protocol.\n * @param liquidationIncentive The liquidation incentive for the asset\n */\nstruct CollateralAsset {\n    uint256 factor;\n    AggregatorV3Interface oracle;\n    address anchor;\n    uint8 decimals;\n    bool exists;\n    uint256 liquidationIncentive;\n    bytes32 redstoneId;\n}\nusing LibAssetUtility for CollateralAsset global;\n\n/// @notice Configuration for pausing `Action`\nstruct Pause {\n    bool enabled;\n    uint256 timestamp0;\n    uint256 timestamp1;\n}\n\n/// @notice Safety configuration for assets\nstruct SafetyState {\n    Pause pause;\n}\n"
    },
    "src/contracts/shared/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.19;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\n\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable not-rely-on-time */\n/* solhint-disable func-name-mixedcase */\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @author Kresko: modified to an upgradeable\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\n\ncontract ERC20Upgradeable is Initializable, IERC20Permit {\n    /* -------------------------------------------------------------------------- */\n    /*                                   Events                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /* -------------------------------------------------------------------------- */\n    /*                                ERC20 Storage                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  EIP-2612                                  */\n    /* -------------------------------------------------------------------------- */\n\n    mapping(address => uint256) public nonces;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Immutables                                 */\n    /* -------------------------------------------------------------------------- */\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    constructor() payable initializer {\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20Upgradeable_init(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) internal onlyInitializing {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    READ                                    */\n    /* -------------------------------------------------------------------------- */\n\n    function balanceOf(address _account) public view virtual returns (uint256) {\n        return _balances[_account];\n    }\n\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    function allowance(address _owner, address _spender) public view virtual returns (uint256) {\n        return _allowances[_owner][_spender];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 ERC20 Logic                                */\n    /* -------------------------------------------------------------------------- */\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(msg.sender, to, amount);\n\n        _balances[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balances[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 allowed = _allowances[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) _allowances[from][msg.sender] = allowed - amount;\n\n        _balances[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               EIP-2612 Logic                               */\n    /* -------------------------------------------------------------------------- */\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            _allowances[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Internals                                 */\n    /* -------------------------------------------------------------------------- */\n\n    function _mint(address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), to, amount);\n\n        _totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balances[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, address(0), amount);\n\n        _balances[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {\n        // Silence state mutability warning without generating bytecode.\n    }\n}\n"
    },
    "src/contracts/shared/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/contracts/shared/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n/* solhint-disable func-name-mixedcase */\n\ninterface IERC20Permit {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function allowance(address, address) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function name() external view returns (string memory);\n\n    function nonces(address) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "src/contracts/shared/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(IERC20Permit token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20Permit token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Permit token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20Permit token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20Permit token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Permit token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "src/contracts/staking/interfaces/IKrStaking.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IKrStaking {\n    struct UserInfo {\n        uint256 amount;\n        uint256[] rewardDebts;\n    }\n\n    struct PoolInfo {\n        IERC20 depositToken; // Address of LP token contract.\n        uint128 allocPoint; // How many allocation points assigned to this pool.\n        uint128 lastRewardBlock; // Last block number that rewards distribution occurs.\n        uint256[] accRewardPerShares; // Accumulated rewards per share, times 1e12.\n        address[] rewardTokens; // Reward tokens for this pool.\n    }\n\n    struct Reward {\n        uint256 pid;\n        address[] tokens;\n        uint256[] amounts;\n    }\n\n    /**\n     * @notice Get id for a token\n     * @notice Useful for external contracts\n     * @param _depositToken depositToken in `_poolInfo`\n     * @return pid of pool with `_depositToken`\n     * @return found ensure 0 index\n     */\n    function getPidFor(address _depositToken) external view returns (uint256 pid, bool found);\n\n    /**\n     * @notice Amount of pools\n     */\n    function poolLength() external view returns (uint256);\n\n    /**\n     * @notice Deposits tokens for @param _to\n     * @param _to address that msg.sender deposits tokens for\n     * @param _pid in `_poolInfo`\n     * @param _amount amount of tokens to deposit\n     */\n    function deposit(address _to, uint256 _pid, uint256 _amount) external payable;\n\n    /**\n     * @notice Trusted helper contract can withdraw rewards and deposits on behalf of an account\n     * @notice For eg. withdraw + remove liquidity\n     * @param _for account to withdraw from\n     * @param _pid id in `_poolInfo`\n     * @param _amount amount to withdraw\n     * @param _rewardRecipient reward recipient\n     */\n    function withdrawFor(address _for, uint256 _pid, uint256 _amount, address _rewardRecipient) external payable;\n\n    /**\n     * @notice Trusted helper contract can claim rewards on behalf of an account\n     * @param _for account to claim for\n     * @param _pid id in `_poolInfo`\n     * @param _rewardRecipient address that receives rewards\n     */\n    function claimFor(address _for, uint256 _pid, address _rewardRecipient) external payable;\n\n    /**\n     * @notice Get all pending rewards for an account\n     * @param _account to get rewards for\n     * @return all pending rewards\n     */\n    function allPendingRewards(address _account) external view returns (Reward[] memory);\n\n    /**\n     * @notice Get account information on a pool\n     * @param _pid in `_poolInfo`\n     * @param _account to get information for\n     * @return information on the account\n     */\n    function userInfo(uint256 _pid, address _account) external view returns (UserInfo memory);\n\n    /**\n     * @notice Get pool information\n     * @param _pid in `_poolInfo`\n     * @return pool information\n     */\n    function poolInfo(uint256 _pid) external view returns (PoolInfo memory);\n\n    function rewardPerBlockFor(address depositTokenAddress) external view returns (uint256 rewardPerBlocks);\n\n    /**\n     * @notice A rescue function for missent msg.value\n     * @notice Since we are using payable functions to save gas on calls\n     */\n    function rescueNative() external payable;\n\n    /**\n     * @notice A rescue function for missent tokens / airdrops\n     * @notice This cannot withdraw any deposits due `ensurePoolDoesNotExist` modifier.\n     */\n    function rescueNonPoolToken(IERC20 _tokenToRescue, uint256 _amount) external payable;\n\n    /**\n     * @notice Set new allocations for a pool\n     * @notice Set `_newAllocPoint` to 0 to retire a pool\n     * @param _pid pool to modify\n     * @param _newAllocPoint new allocation (weight) for rewards\n     */\n    function setPool(uint256 _pid, uint128 _newAllocPoint) external payable;\n\n    /**\n     * @notice Adds a new reward pool\n     * @notice Updates reward token count in case of adding extra tokens\n     * @param _rewardTokens tokens to reward from this pool\n     * @param _depositToken token to deposit for rewards\n     * @param _allocPoint weight of rewards this pool receives\n     * @param _startBlock block when rewards start\n     */\n    function addPool(\n        address[] calldata _rewardTokens,\n        IERC20 _depositToken,\n        uint128 _allocPoint,\n        uint128 _startBlock\n    ) external payable;\n\n    /**\n     * @notice Adjust/Set reward per block for a particular reward token\n     * @param _rewardToken token to adjust the drip for\n     * @param _rewardPerBlock tokens to drip per block\n     */\n    function setRewardPerBlockFor(address _rewardToken, uint256 _rewardPerBlock) external payable;\n\n    /**\n     * @notice Emergency function, withdraws deposits from a pool\n     * @notice This will forfeit your rewards.\n     * @param _pid pool id to withdraw tokens from\n     */\n    function emergencyWithdraw(uint256 _pid) external payable;\n\n    /**\n     * @notice Claim rewards only\n     * @param _pid id in `_poolInfo`\n     * @param _rewardRecipient address to send rewards to\n     */\n    function claim(uint256 _pid, address _rewardRecipient) external payable;\n\n    /**\n     * @notice Withdraw deposited tokens and rewards.\n     * @param _pid id in `_poolInfo`\n     * @param _amount amount to withdraw\n     * @param _rewardRecipient address to send rewards to\n     */\n    function withdraw(uint256 _pid, uint256 _amount, address _rewardRecipient) external payable;\n\n    /**\n     * @notice Updates all pools to be up-to date\n     */\n    function massUpdatePools() external payable;\n\n    /**\n     * @notice Updates a pools reward variables to be up-to date\n     * @param _pid pool to update\n     */\n    function updatePool(uint256 _pid) external payable returns (PoolInfo memory pool);\n\n    /**\n     * @notice Get pending rewards from a certain pool\n     * @param _pid id in `_poolInfo`\n     * @param _user id in `_userInfo[_pid]`\n     * @return rewards pending rewards\n     */\n    function pendingRewards(uint256 _pid, address _user) external view returns (Reward memory rewards);\n}\n"
    },
    "src/contracts/test/Funder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IERC20Permit} from \"../shared/IERC20Permit.sol\";\nimport {WETH} from \"./WETH.sol\";\nimport {IAccountStateFacet} from \"../minter/interfaces/IAccountStateFacet.sol\";\n\n/* solhint-disable no-empty-blocks */\n\nstruct Token {\n    uint256 amount;\n    address token;\n}\n\ncontract Funder {\n    mapping(address => bool) public owners;\n    mapping(address => bool) public funded;\n    IAccountStateFacet public kresko;\n\n    event Funded(address indexed account);\n\n    constructor(address _kresko) {\n        owners[msg.sender] = true;\n        kresko = IAccountStateFacet(_kresko);\n    }\n\n    function toggleOwners(address[] calldata accounts) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < accounts.length; i++) {\n            owners[accounts[i]] = !owners[accounts[i]];\n        }\n    }\n\n    function isEligible(address account) public view returns (bool) {\n        return account.balance < 0.001 ether && kresko.getAccountKrAssetValue(account) > 0 && !funded[account];\n    }\n\n    function distribute(address[] calldata accounts, uint256 ethAmount) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < accounts.length; i++) {\n            if (!isEligible(accounts[i])) continue;\n\n            funded[accounts[i]] = true;\n            payable(accounts[i]).transfer(ethAmount);\n            emit Funded(accounts[i]);\n        }\n    }\n\n    function drain() external {\n        require(owners[msg.sender], \"!o\");\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}\n"
    },
    "src/contracts/test/FunderTestnetExtended.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {MockERC20} from \"./MockERC20.sol\";\nimport {WETH} from \"./WETH.sol\";\nimport {IAccountStateFacet} from \"../minter/interfaces/IAccountStateFacet.sol\";\n\n/* solhint-disable no-empty-blocks */\n\nstruct Token {\n    uint256 amount;\n    address token;\n}\n\ncontract FunderTestnetExtended {\n    mapping(address => bool) public owners;\n    mapping(address => bool) public funded;\n    IAccountStateFacet public kresko;\n    MockERC20 public tokenToFund;\n    uint256 public fundAmount = 10000 ether;\n    event Funded(address indexed account);\n\n    constructor(address _kresko, address _tokenToFund) {\n        owners[msg.sender] = true;\n        kresko = IAccountStateFacet(_kresko);\n        tokenToFund = MockERC20(_tokenToFund);\n    }\n\n    function toggleOwners(address[] calldata accounts) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < accounts.length; i++) {\n            owners[accounts[i]] = !owners[accounts[i]];\n        }\n    }\n\n    function isEligible(address account) public view returns (bool) {\n        return !funded[account];\n    }\n\n    function setFundAmount(uint256 amount) external {\n        require(owners[msg.sender], \"!o\");\n        fundAmount = amount;\n    }\n\n    function distribute() external {\n        if (!isEligible(msg.sender)) return;\n        tokenToFund.mint(msg.sender, fundAmount);\n        funded[msg.sender] = true;\n        emit Funded(msg.sender);\n    }\n\n    function drain() external {\n        require(owners[msg.sender], \"!o\");\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}\n"
    },
    "src/contracts/test/interfaces/ISmockFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\ninterface ISmockFacet {\n    event NewMessage(address indexed caller, string message);\n\n    function activate() external;\n\n    function disable() external;\n\n    function setMessage(string memory message) external;\n}\n"
    },
    "src/contracts/test/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.19;\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    mapping(address => bool) public minters;\n    address public owner;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _initialSupply\n    ) ERC20(_name, _symbol, _decimals) {\n        _mint(msg.sender, _initialSupply);\n        minters[msg.sender] = true;\n    }\n\n    function reinitializeERC20(string memory _name, string memory _symbol) external {\n        require(msg.sender == owner, \"!owner\");\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function toggleMinters(address[] calldata _minters) external {\n        require(minters[msg.sender], \"!minter\");\n        for (uint256 i; i < _minters.length; i++) {\n            minters[_minters[i]] = !minters[_minters[i]];\n        }\n    }\n\n    function mint(address to, uint256 value) public virtual {\n        require(minters[msg.sender], \"!minter\");\n        _mint(to, value);\n    }\n\n    function burn(address from, uint256 value) public virtual {\n        require(minters[msg.sender], \"!minter\");\n        _burn(from, value);\n    }\n}\n"
    },
    "src/contracts/test/SmockFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {ISmockFacet} from \"./interfaces/ISmockFacet.sol\";\nimport {DiamondModifiers} from \"../diamond/DiamondModifiers.sol\";\nimport {SmockStorage, Errors} from \"./SmockStorage.sol\";\n\nbytes32 constant TEST_OPERATOR_ROLE = keccak256(\"kresko.test.operator\");\n\n/**\n * @dev Use for Smock fakes / mocks.\n */\ncontract SmockFacet is DiamondModifiers, ISmockFacet {\n    uint256 public constant MESSAGE_THROTTLE = 2;\n\n    function operator() external view returns (address) {\n        return SmockStorage.state().operator;\n    }\n\n    function activate() external override onlyRole(TEST_OPERATOR_ROLE) onlyDisabled {\n        SmockStorage.activate();\n    }\n\n    function disable() external override onlyRole(TEST_OPERATOR_ROLE) onlyActive {\n        SmockStorage.disable();\n    }\n\n    function smockInitialized() external view returns (bool) {\n        return SmockStorage.state().initialized;\n    }\n\n    function setMessage(string memory message) external override onlyActive {\n        require(block.number >= SmockStorage.state().lastMessageBlock + MESSAGE_THROTTLE, \"Cant set message yet\");\n\n        SmockStorage.state().message = message;\n        SmockStorage.state().callers[msg.sender] = true;\n\n        emit SmockStorage.Call(msg.sender);\n        emit NewMessage(msg.sender, message);\n    }\n\n    modifier onlyActive() {\n        require(SmockStorage.state().isActive, Errors.ACTIVE);\n        _;\n    }\n    modifier onlyDisabled() {\n        require(!SmockStorage.state().isActive, Errors.NOT_ACTIVE);\n        _;\n    }\n}\n"
    },
    "src/contracts/test/SmockFacet2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {GeneralEvent} from \"../libs/Events.sol\";\nimport {ISmockFacet} from \"./interfaces/ISmockFacet.sol\";\nimport {TEST_OPERATOR_ROLE} from \"./SmockFacet.sol\";\nimport {SmockStorage} from \"./SmockStorage.sol\";\n\ncontract SmockFacet2 {\n    function initialize() external {\n        SmockStorage.stateExtended().extended = true;\n    }\n\n    function getOldStructValueFromExtended() external view returns (bool) {\n        return SmockStorage.stateExtended().initialized;\n    }\n\n    function getNewStructValueFromExtended() external view returns (bool) {\n        return SmockStorage.stateExtended().extended;\n    }\n}\n"
    },
    "src/contracts/test/SmockInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {GeneralEvent} from \"../libs/Events.sol\";\nimport {Authorization, ds, Role, DiamondModifiers} from \"../diamond/DiamondModifiers.sol\";\n\nimport {ISmockFacet} from \"./interfaces/ISmockFacet.sol\";\nimport {TEST_OPERATOR_ROLE} from \"./SmockFacet.sol\";\nimport {SmockStorage} from \"./SmockStorage.sol\";\n\ncontract SmockInit is DiamondModifiers {\n    function initialize(address _operator) external onlyOwner onlyRole(Role.ADMIN) {\n        require(msg.sender == ds().contractOwner, \"WithStorage: Not owner\");\n        SmockStorage.initialize(_operator);\n\n        Authorization.grantRole(TEST_OPERATOR_ROLE, _operator);\n\n        ds().supportedInterfaces[type(ISmockFacet).interfaceId] = true;\n        emit GeneralEvent.Initialized(msg.sender, 1);\n    }\n\n    function getNumber() public pure returns (uint8) {\n        return 1;\n    }\n\n    function getBool() public pure returns (bool) {\n        return false;\n    }\n\n    function upgradeState() external {\n        ds().initialized = getBool();\n    }\n}\n"
    },
    "src/contracts/test/SmockStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nlibrary Errors {\n    string public constant INITIALIZED = \"Already initialized\";\n    string public constant NOT_ACTIVE = \"SmockFacet: Not active\";\n    string public constant ACTIVE = \"SmockFacet: Active\";\n}\n\nstruct SmockState {\n    bool initialized;\n    bool isActive;\n    address operator;\n    mapping(address => bool) callers;\n    string message;\n    uint256 lastMessageBlock;\n}\n// This is not how it has to be done in reality\n// We can just extend the original\nstruct SmockState2 {\n    bool initialized;\n    bool isActive;\n    address operator;\n    mapping(address => bool) callers;\n    string message;\n    uint256 lastMessageBlock;\n    bool extended;\n}\n\nlibrary SmockStorage {\n    event Call(address indexed caller);\n\n    bytes32 public constant SMOCK_STORAGE_POSITION = keccak256(\"kresko.smock.storage\");\n\n    function initialize(address _operator) internal {\n        SmockState storage ss = state();\n        require(!ss.initialized, Errors.INITIALIZED);\n        ss.initialized = true;\n        ss.operator = _operator;\n        emit Call(msg.sender);\n    }\n\n    function state() internal pure returns (SmockState storage ss) {\n        bytes32 position = SMOCK_STORAGE_POSITION;\n        assembly {\n            ss.slot := position\n        }\n    }\n\n    // This is not how it has to be done in reality\n    function stateExtended() internal pure returns (SmockState2 storage ss) {\n        bytes32 position = SMOCK_STORAGE_POSITION;\n        assembly {\n            ss.slot := position\n        }\n    }\n\n    function activate() internal {\n        state().isActive = true;\n        state().callers[msg.sender] = true;\n        emit Call(msg.sender);\n    }\n\n    function disable() internal {\n        state().isActive = false;\n        state().callers[msg.sender] = true;\n        emit Call(msg.sender);\n    }\n}\n"
    },
    "src/contracts/test/WETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {WETH9} from \"../vendor/WETH9.sol\";\n\ncontract WETH is WETH9 {\n    mapping(address => bool) public minters;\n\n    constructor() {\n        minters[msg.sender] = true;\n    }\n\n    function deposit(uint256 amount) public {\n        require(minters[msg.sender], \"Not a minter\");\n        balanceOf[msg.sender] += amount;\n        emit Deposit(msg.sender, amount);\n    }\n}\n"
    },
    "src/contracts/vendor/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}"
    },
    "src/contracts/vendor/flux/FluxPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IFluxPriceFeed} from \"./interfaces/IFluxPriceFeed.sol\";\n\n/** solhint-disable var-name-mixedcase */\n/**\n * @notice Simple data posting on chain of a scalar value, compatible with Chainlink V2 and V3 aggregator interface\n */\ncontract FluxPriceFeed is AccessControl, IFluxPriceFeed {\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant VALIDATOR_ROLE = keccak256(\"VALIDATOR_ROLE\");\n    uint32 public latestAggregatorRoundId;\n\n    // Transmission records the answer from the transmit transaction at\n    // time timestamp\n    struct Transmission {\n        int192 answer; // 192 bits ought to be enough for anyone\n        uint64 timestamp;\n        bool marketOpen;\n    }\n    mapping(uint32 => Transmission) internal s_transmissions; /* aggregator round ID */\n       \n\n    /**\n     * @param _validator the initial validator that can post data to this contract\n     * @param _decimals answers are stored in fixed-point format, with this many digits of precision\n     * @param _description short human-readable description of observable this contract's answers pertain to\n     */\n    constructor(\n        address _validator,\n        uint8 _decimals,\n        string memory _description\n    ) {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setupRole(VALIDATOR_ROLE, _validator);\n        decimals = _decimals;\n        s_description = _description;\n    }\n\n    /*\n     * Versioning\n     */\n    function typeAndVersion() external pure virtual returns (string memory) {\n        return \"FluxPriceFeed 1.0.0\";\n    }\n\n    /*\n     * Transmission logic\n     */\n\n    /**\n     * @notice indicates that a new report was transmitted\n     * @param aggregatorRoundId the round to which this report was assigned\n     * @param answer value posted by validator\n     * @param marketOpen bool indicating if the market is open\n     * @param transmitter address from which the report was transmitted\n     */\n    event NewTransmission(uint32 indexed aggregatorRoundId, int192 answer, bool marketOpen, address transmitter);\n        \n    /**\n     * @notice details about the most recent report\n     * @return _latestAnswer value from latest report\n     * @return _latestTimestamp when the latest report was transmitted\n     * @return _marketOpen value from latest report\n     */\n    function latestTransmissionDetails() external view returns (int192 _latestAnswer, uint64 _latestTimestamp, bool _marketOpen) {\n        // solhint-disable-next-line avoid-tx-origin\n        require(msg.sender == tx.origin, \"Only callable by EOA\");\n        return (\n            s_transmissions[latestAggregatorRoundId].answer,\n            s_transmissions[latestAggregatorRoundId].timestamp,\n            s_transmissions[latestAggregatorRoundId].marketOpen\n        );\n    }\n\n    /**\n     * @notice transmit is called to post a new report to the contract\n     * @param _answer latest answer\n     */\n    function transmit(int192 _answer, bool _marketOpen) external {\n        require(hasRole(VALIDATOR_ROLE, msg.sender), \"Caller is not a validator\");\n\n        // Check the report contents, and record the result\n        latestAggregatorRoundId++;\n        // solhint-disable-next-line not-rely-on-time\n        s_transmissions[latestAggregatorRoundId] = Transmission(_answer, uint64(block.timestamp), true);\n\n        emit NewTransmission(latestAggregatorRoundId, _answer, true, msg.sender);\n    }\n\n    /*\n     * v2 Aggregator interface\n     */\n\n    /**\n     * @notice answer from the most recent report\n     */\n    function latestAnswer() public view virtual override returns (int256) {\n        return s_transmissions[latestAggregatorRoundId].answer;\n    }\n\n    /**\n     * @notice timestamp of block in which last report was transmitted\n     */\n    function latestTimestamp() public view virtual override returns (uint256) {\n        return s_transmissions[latestAggregatorRoundId].timestamp;\n    }\n\n     /**\n     * @notice market open indicator from the most recent report\n     */\n    function latestMarketOpen() public view virtual override returns (bool) {\n        return s_transmissions[latestAggregatorRoundId].marketOpen;\n    }\n\n    /**\n     * @notice Aggregator round in which last report was transmitted\n     */\n    function latestRound() public view virtual override returns (uint256) {\n        return latestAggregatorRoundId;\n    }\n\n    /**\n     * @notice answer of report from given aggregator round\n     * @param _roundId the aggregator round of the target report\n     */\n    function getAnswer(uint256 _roundId) public view virtual override returns (int256) {\n        if (_roundId > 0xFFFFFFFF) {\n            return 0;\n        }\n        return s_transmissions[uint32(_roundId)].answer;\n    }\n\n    /**\n     * @notice timestamp of block in which report from given aggregator round was transmitted\n     * @param _roundId aggregator round of target report\n     */\n    function getTimestamp(uint256 _roundId) public view virtual override returns (uint256) {\n        if (_roundId > 0xFFFFFFFF) {\n            return 0;\n        }\n        return s_transmissions[uint32(_roundId)].timestamp;\n    }\n\n    /**\n     * @notice market open of report from given aggregator round\n     * @param _roundId the aggregator round of the target report\n     */\n    function getMarketOpen(uint256 _roundId) public view virtual override returns (bool) {\n        require(_roundId <= 0xFFFFFFFF, \"FluxPriceFeed: round ID\");\n        return s_transmissions[uint32(_roundId)].marketOpen;\n    }\n\n    /*\n     * v3 Aggregator interface\n     */\n\n    string private constant V3_NO_DATA_ERROR = \"No data present\";\n\n    /**\n     * @return answers are stored in fixed-point format, with this many digits of precision\n     */\n    uint8 public immutable override decimals;\n\n    /**\n     * @notice aggregator contract version\n     */\n    uint256 public constant override version = 1;\n\n    string internal s_description;\n\n    /**\n     * @notice human-readable description of observable this contract is reporting on\n     */\n    function description() public view virtual override returns (string memory) {\n        return s_description;\n    }\n\n    /**\n     * @notice details for the given aggregator round\n     * @param _roundId target aggregator round. Must fit in uint32\n     * @return roundId _roundId\n     * @return answer answer of report from given _roundId\n     * @return marketOpen of report from given _roundId\n     * @return startedAt timestamp of block in which report from given _roundId was transmitted\n     * @return updatedAt timestamp of block in which report from given _roundId was transmitted\n     * @return answeredInRound _roundId\n     */\n    function getRoundData(uint80 _roundId)\n        public\n        view\n        virtual\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            bool marketOpen,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        require(_roundId <= 0xFFFFFFFF, V3_NO_DATA_ERROR);\n        Transmission memory transmission = s_transmissions[uint32(_roundId)];\n        return (_roundId, transmission.answer, transmission.marketOpen, transmission.timestamp, transmission.timestamp, _roundId);\n    }\n\n    /**\n     * @notice aggregator details for the most recently transmitted report\n     * @return roundId aggregator round of latest report\n     * @return answer answer of latest report\n     * @return marketOpen of latest report\n     * @return startedAt timestamp of block containing latest report\n     * @return updatedAt timestamp of block containing latest report\n     * @return answeredInRound aggregator round of latest report\n     */\n    function latestRoundData()\n        public\n        view\n        virtual\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            bool marketOpen,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        roundId = latestAggregatorRoundId;\n\n        // Skipped for compatability with existing FluxAggregator in which latestRoundData never reverts.\n        // require(roundId != 0, V3_NO_DATA_ERROR);\n\n        Transmission memory transmission = s_transmissions[uint32(roundId)];\n        return (roundId, transmission.answer, transmission.marketOpen, transmission.timestamp, transmission.timestamp, roundId);\n    }\n}\n"
    },
    "src/contracts/vendor/flux/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\ninterface AggregatorInterface {\n    function latestAnswer() external view returns (int256);\n\n    function latestTimestamp() external view returns (uint256);\n\n    function latestMarketOpen() external view returns (bool);\n\n    function latestRound() external view returns (uint256);\n\n    function getAnswer(uint256 roundId) external view returns (int256);\n\n    function getTimestamp(uint256 roundId) external view returns (uint256);\n\n    function getMarketOpen(uint256 roundId) external view returns (bool);\n\n    event AnswerUpdated(int256 indexed current, bool marketOpen, uint256 indexed roundId, uint256 updatedAt);\n    event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "src/contracts/vendor/flux/interfaces/FluxAggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\ninterface FluxAggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n    \n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            bool marketOpen,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            bool marketOpen,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "src/contracts/vendor/flux/interfaces/IFluxPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n/* solhint-disable no-global-import */\n/* solhint-disable no-empty-blocks */\nimport \"./AggregatorInterface.sol\";\nimport \"./FluxAggregatorV3Interface.sol\";\n\ninterface IFluxPriceFeed is AggregatorInterface, FluxAggregatorV3Interface {}\n"
    },
    "src/contracts/vendor/gnosis/IGnosisSafeL2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\ninterface IGnosisSafeL2 {\n    function isOwner(address owner) external view returns (bool);\n\n    function getOwners() external view returns (address[] memory);\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-core/interfaces/IERC20Minimal.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IERC20Minimal {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-core/interfaces/IUniswapV2Factory.sol": {
      "content": "// // SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-core/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.16;\n\n/** solhint-disable func-name-mixedcase */\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.6.6;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/libraries/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: APGL-3.0\npragma solidity >=0.5.0;\n\nimport \"../../v2-core/interfaces/IUniswapV2Pair.sol\";\nimport \"../../v2-core/interfaces/IUniswapV2Factory.sol\";\n\nimport \"./SafeMath.sol\";\n\nlibrary UniswapV2Library {\n    using SafeMath for uint256;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (address pair) {\n        pair = IUniswapV2Factory(factory).getPair(tokenA, tokenB);\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n        require(reserveA > 0 && reserveB > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        uint256 amountOut,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "src/contracts/vendor/WETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.19;\n\ncontract WETH9 {\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    function deposit() public payable virtual {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public virtual {\n        require(balanceOf[msg.sender] >= wad, \"WETH9: Error\");\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public virtual returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public virtual returns (bool) {\n        require(balanceOf[src] >= wad, \"WETH9: Error\");\n\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\n            require(allowance[src][msg.sender] >= wad, \"WETH9: Error\");\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 2000000,
      "details": {
        "constantOptimizer": false,
        "deduplicate": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "metadata",
          "abi",
          "storageLayout",
          "evm.methodIdentifiers",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "evm.byteCode",
          "evm.bytecode",
          "evm.deployedBytecode"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}