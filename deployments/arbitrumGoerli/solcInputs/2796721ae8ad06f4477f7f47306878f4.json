{
  "language": "Solidity",
  "sources": {
    "@kreskolabs/gnosis-safe-contracts/contracts/base/Executor.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/Enum.sol\";\n\n/// @title Executor - A contract that can execute transactions\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Executor {\n    function execute(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 txGas\n    ) internal returns (bool success) {\n        if (operation == Enum.Operation.DelegateCall) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n            }\n        } else {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n            }\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/base/FallbackManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../common/SelfAuthorized.sol\";\n\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract FallbackManager is SelfAuthorized {\n    event ChangedFallbackHandler(address handler);\n\n    // keccak256(\"fallback_manager.handler.address\")\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\n\n    function internalSetFallbackHandler(address handler) internal {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, handler)\n        }\n    }\n\n    /// @dev Allows to add a contract to handle fallback calls.\n    ///      Only fallback calls without value and with data will be forwarded.\n    ///      This can only be done via a Safe transaction.\n    /// @param handler contract to handle fallback calls.\n    function setFallbackHandler(address handler) public authorized {\n        internalSetFallbackHandler(handler);\n        emit ChangedFallbackHandler(handler);\n    }\n\n    // solhint-disable-next-line payable-fallback,no-complex-fallback\n    fallback() external {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let handler := sload(slot)\n            if iszero(handler) {\n                return(0, 0)\n            }\n            calldatacopy(0, 0, calldatasize())\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            mstore(calldatasize(), shl(96, caller()))\n            // Add 20 bytes for the address appended add the end\n            let success := call(gas(), handler, 0, 0, add(calldatasize(), 20), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if iszero(success) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/base/GuardManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\nimport \"../interfaces/IERC165.sol\";\n\ninterface Guard is IERC165 {\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address msgSender\n    ) external;\n\n    function checkAfterExecution(bytes32 txHash, bool success) external;\n}\n\nabstract contract BaseGuard is Guard {\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n        return\n            interfaceId == type(Guard).interfaceId || // 0xe6d7a83a\n            interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n}\n\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract GuardManager is SelfAuthorized {\n    event ChangedGuard(address guard);\n    // keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    /// @dev Set a guard that checks transactions before execution\n    /// @param guard The address of the guard to be used or the 0 address to disable the guard\n    function setGuard(address guard) external authorized {\n        if (guard != address(0)) {\n            require(Guard(guard).supportsInterface(type(Guard).interfaceId), \"GS300\");\n        }\n        bytes32 slot = GUARD_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, guard)\n        }\n        emit ChangedGuard(guard);\n    }\n\n    function getGuard() internal view returns (address guard) {\n        bytes32 slot = GUARD_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            guard := sload(slot)\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/base/ModuleManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\nimport \"./Executor.sol\";\n\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract ModuleManager is SelfAuthorized, Executor {\n    event EnabledModule(address module);\n    event DisabledModule(address module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    address internal constant SENTINEL_MODULES = address(0x1);\n\n    mapping(address => address) internal modules;\n\n    function setupModules(address to, bytes memory data) internal {\n        require(modules[SENTINEL_MODULES] == address(0), \"GS100\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0))\n            // Setup has to complete successfully or transaction fails.\n            require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), \"GS000\");\n    }\n\n    /// @dev Allows to add a module to the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Enables the module `module` for the Safe.\n    /// @param module Module to be whitelisted.\n    function enableModule(address module) public authorized {\n        // Module address cannot be null or sentinel.\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\n        // Module cannot be added twice.\n        require(modules[module] == address(0), \"GS102\");\n        modules[module] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = module;\n        emit EnabledModule(module);\n    }\n\n    /// @dev Allows to remove a module from the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Disables the module `module` for the Safe.\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\n    /// @param module Module to be removed.\n    function disableModule(address prevModule, address module) public authorized {\n        // Validate module address and check that it corresponds to module index.\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\n        require(modules[prevModule] == module, \"GS103\");\n        modules[prevModule] = modules[module];\n        modules[module] = address(0);\n        emit DisabledModule(module);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public virtual returns (bool success) {\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"GS104\");\n        // Execute transaction without further confirmations.\n        success = execute(to, value, data, operation, gasleft());\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public returns (bool success, bytes memory returnData) {\n        success = execTransactionFromModule(to, value, data, operation);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }\n\n    /// @dev Returns if an module is enabled\n    /// @return True if the module is enabled\n    function isModuleEnabled(address module) public view returns (bool) {\n        return SENTINEL_MODULES != module && modules[module] != address(0);\n    }\n\n    /// @dev Returns array of modules.\n    /// @param start Start of the page.\n    /// @param pageSize Maximum number of modules that should be returned.\n    /// @return array Array of modules.\n    /// @return next Start of the next page.\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next) {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        address currentModule = modules[start];\n        while (currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = currentModule;\n            currentModule = modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/base/OwnerManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/SelfAuthorized.sol\";\n\n/// @title OwnerManager - Manages a set of owners and a threshold to perform actions.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract OwnerManager is SelfAuthorized {\n    event AddedOwner(address owner);\n    event RemovedOwner(address owner);\n    event ChangedThreshold(uint256 threshold);\n\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    mapping(address => address) internal owners;\n    uint256 internal ownerCount;\n    uint256 internal threshold;\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    function setupOwners(address[] memory _owners, uint256 _threshold) internal {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"GS200\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"GS201\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"GS202\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this) && currentOwner != owner, \"GS203\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"GS204\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`.\n    /// @param owner New owner address.\n    /// @param _threshold New threshold.\n    function addOwnerWithThreshold(address owner, uint256 _threshold) public authorized {\n        // Owner address cannot be null, the sentinel or the Safe itself.\n        require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this), \"GS203\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"GS204\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.\n    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\n    /// @param owner Owner address to be removed.\n    /// @param _threshold New threshold.\n    function removeOwner(\n        address prevOwner,\n        address owner,\n        uint256 _threshold\n    ) public authorized {\n        // Only allow to remove an owner, if threshold can still be reached.\n        require(ownerCount - 1 >= _threshold, \"GS201\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"GS203\");\n        require(owners[prevOwner] == owner, \"GS205\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to swap/replace an owner from the Safe with another address.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\n    /// @param oldOwner Owner address to be replaced.\n    /// @param newOwner New owner address.\n    function swapOwner(\n        address prevOwner,\n        address oldOwner,\n        address newOwner\n    ) public authorized {\n        // Owner address cannot be null, the sentinel or the Safe itself.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS && newOwner != address(this), \"GS203\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"GS204\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"GS203\");\n        require(owners[prevOwner] == oldOwner, \"GS205\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }\n\n    /// @dev Allows to update the number of required confirmations by Safe owners.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Changes the threshold of the Safe to `_threshold`.\n    /// @param _threshold New threshold.\n    function changeThreshold(uint256 _threshold) public authorized {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"GS201\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"GS202\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }\n\n    function getThreshold() public view returns (uint256) {\n        return threshold;\n    }\n\n    function isOwner(address owner) public view returns (bool) {\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\n    }\n\n    /// @dev Returns array of owners.\n    /// @return Array of Safe owners.\n    function getOwners() public view returns (address[] memory) {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while (currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index++;\n        }\n        return array;\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/Enum.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {Call, DelegateCall}\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/EtherPaymentFallback.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract EtherPaymentFallback {\n    event SafeReceived(address indexed sender, uint256 value);\n\n    /// @dev Fallback function accepts Ether transactions.\n    receive() external payable {\n        emit SafeReceived(msg.sender, msg.value);\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/SecuredTokenTransfer.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SecuredTokenTransfer - Secure token transfer\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SecuredTokenTransfer {\n    /// @dev Transfers a token and returns if it was a success\n    /// @param token Token that should be transferred\n    /// @param receiver Receiver to whom the token should be transferred\n    /// @param amount The amount of tokens that should be transferred\n    function transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal returns (bool transferred) {\n        // 0xa9059cbb - keccack(\"transfer(address,uint256)\")\n        bytes memory data = abi.encodeWithSelector(0xa9059cbb, receiver, amount);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We write the return value to scratch space.\n            // See https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory\n            let success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            switch returndatasize()\n                case 0 {\n                    transferred := success\n                }\n                case 0x20 {\n                    transferred := iszero(or(iszero(success), iszero(mload(0))))\n                }\n                default {\n                    transferred := 0\n                }\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/SelfAuthorized.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SelfAuthorized - authorizes current contract to perform actions\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SelfAuthorized {\n    function requireSelfCall() private view {\n        require(msg.sender == address(this), \"GS031\");\n    }\n\n    modifier authorized() {\n        // This is a function call as it minimized the bytecode size\n        requireSelfCall();\n        _;\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/SignatureDecoder.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SignatureDecoder - Decodes signatures that a encoded as bytes\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SignatureDecoder {\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\n    /// @notice Make sure to perform a bounds check for @param pos, to avoid out of bounds access on @param signatures\n    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\n    /// @param signatures concatenated rsv signatures\n    function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/Singleton.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Singleton - Base for singleton contracts (should always be first super contract)\n///         This contract is tightly coupled to our proxy contract (see `proxies/GnosisSafeProxy.sol`)\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract Singleton {\n    // singleton always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\n    // It should also always be ensured that the address is stored alone (uses a full word)\n    address private singleton;\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/common/StorageAccessible.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title StorageAccessible - generic base contract that allows callers to access all internal storage.\n/// @notice See https://github.com/gnosis/util-contracts/blob/bb5fe5fb5df6d8400998094fb1b32a178a47c3a1/contracts/StorageAccessible.sol\ncontract StorageAccessible {\n    /**\n     * @dev Reads `length` bytes of storage in the currents contract\n     * @param offset - the offset in the current contract's storage in words to start reading from\n     * @param length - the number of words (32 bytes) of data to read\n     * @return the bytes that were read.\n     */\n    function getStorageAt(uint256 offset, uint256 length) public view returns (bytes memory) {\n        bytes memory result = new bytes(length * 32);\n        for (uint256 index = 0; index < length; index++) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let word := sload(add(offset, index))\n                mstore(add(add(result, 0x20), mul(index, 0x20)), word)\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Performs a delegatecall on a targetContract in the context of self.\n     * Internally reverts execution to avoid side effects (making it static).\n     *\n     * This method reverts with data equal to `abi.encode(bool(success), bytes(response))`.\n     * Specifically, the `returndata` after a call to this method will be:\n     * `success:bool || response.length:uint256 || response:bytes`.\n     *\n     * @param targetContract Address of the contract containing the code to execute.\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\n     */\n    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let success := delegatecall(gas(), targetContract, add(calldataPayload, 0x20), mload(calldataPayload), 0, 0)\n\n            mstore(0x00, success)\n            mstore(0x20, returndatasize())\n            returndatacopy(0x40, 0, returndatasize())\n            revert(0, add(returndatasize(), 0x40))\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/external/GnosisSafeMath.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title GnosisSafeMath\n * @dev Math operations with safety checks that revert on error\n * Renamed from SafeMath to GnosisSafeMath to avoid conflicts\n * TODO: remove once open zeppelin update to solc 0.5.0\n */\nlibrary GnosisSafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @notice More details at https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/IERC165.sol\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/interfaces/ISignatureValidator.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\ncontract ISignatureValidatorConstants {\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;\n}\n\nabstract contract ISignatureValidator is ISignatureValidatorConstants {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param _data Arbitrary length data signed on the behalf of address(this)\n     * @param _signature Signature byte array associated with _data\n     *\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(bytes memory _data, bytes memory _signature) public view virtual returns (bytes4);\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/proxies/GnosisSafeProxy.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\n/// @author Richard Meissner - <richard@gnosis.io>\ninterface IProxy {\n    function masterCopy() external view returns (address);\n}\n\n/// @title GnosisSafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract GnosisSafeProxy {\n    // singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\n    address internal singleton;\n\n    /// @dev Constructor function sets address of singleton contract.\n    /// @param _singleton Singleton address.\n    constructor(address _singleton) {\n        require(_singleton != address(0), \"Invalid singleton address provided\");\n        singleton = _singleton;\n    }\n\n    /// @dev Fallback function forwards all transactions and returns all received return data.\n    fallback() external payable {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\n                mstore(0, _singleton)\n                return(0, 0x20)\n            }\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n}\n"
    },
    "@kreskolabs/gnosis-safe-contracts/contracts/proxies/IProxyCreationCallback.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"./GnosisSafeProxy.sol\";\n\ninterface IProxyCreationCallback {\n    function proxyCreated(\n        GnosisSafeProxy proxy,\n        address _singleton,\n        bytes calldata initializer,\n        uint256 saltNonce\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/CalldataExtractor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./RedstoneConstants.sol\";\n\n/**\n * @title The base contract with the main logic of data extraction from calldata\n * @author The Redstone Oracles team\n * @dev This contract was created to reuse the same logic in the RedstoneConsumerBase\n * and the ProxyConnector contracts\n */\ncontract CalldataExtractor is RedstoneConstants {\n  using SafeMath for uint256;\n\n  function _extractByteSizeOfUnsignedMetadata() internal pure returns (uint256) {\n    // Checking if the calldata ends with the RedStone marker\n    bool hasValidRedstoneMarker;\n    assembly {\n      let calldataLast32Bytes := calldataload(sub(calldatasize(), STANDARD_SLOT_BS))\n      hasValidRedstoneMarker := eq(\n        REDSTONE_MARKER_MASK,\n        and(calldataLast32Bytes, REDSTONE_MARKER_MASK)\n      )\n    }\n    if (!hasValidRedstoneMarker) {\n      revert CalldataMustHaveValidPayload();\n    }\n\n    // Using uint24, because unsigned metadata byte size number has 3 bytes\n    uint24 unsignedMetadataByteSize;\n    if (REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n    assembly {\n      unsignedMetadataByteSize := calldataload(\n        sub(calldatasize(), REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS)\n      )\n    }\n    uint256 calldataNegativeOffset = unsignedMetadataByteSize\n      + UNSIGNED_METADATA_BYTE_SIZE_BS\n      + REDSTONE_MARKER_BS;\n    if (calldataNegativeOffset + DATA_PACKAGES_COUNT_BS > msg.data.length) {\n      revert IncorrectUnsignedMetadataSize();\n    }\n    return calldataNegativeOffset;\n  }\n\n  // We return uint16, because unsigned metadata byte size number has 2 bytes\n  function _extractDataPackagesCountFromCalldata(uint256 calldataNegativeOffset)\n    internal\n    pure\n    returns (uint16 dataPackagesCount)\n  {\n    uint256 calldataNegativeOffsetWithStandardSlot = calldataNegativeOffset + STANDARD_SLOT_BS;\n    if (calldataNegativeOffsetWithStandardSlot > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n    assembly {\n      dataPackagesCount := calldataload(\n        sub(calldatasize(), calldataNegativeOffsetWithStandardSlot)\n      )\n    }\n    return dataPackagesCount;\n  }\n\n  function _extractDataPointValueAndDataFeedId(\n    uint256 calldataNegativeOffsetForDataPackage,\n    uint256 defaultDataPointValueByteSize,\n    uint256 dataPointIndex\n  ) internal pure virtual returns (bytes32 dataPointDataFeedId, uint256 dataPointValue) {\n    uint256 negativeOffsetToDataPoints = calldataNegativeOffsetForDataPackage + DATA_PACKAGE_WITHOUT_DATA_POINTS_BS;\n    uint256 dataPointNegativeOffset = negativeOffsetToDataPoints.add(\n      (1 + dataPointIndex).mul((defaultDataPointValueByteSize + DATA_POINT_SYMBOL_BS))\n    );\n    uint256 dataPointCalldataOffset = msg.data.length.sub(dataPointNegativeOffset);\n    assembly {\n      dataPointDataFeedId := calldataload(dataPointCalldataOffset)\n      dataPointValue := calldataload(add(dataPointCalldataOffset, DATA_POINT_SYMBOL_BS))\n    }\n  }\n\n  function _extractDataPointsDetailsForDataPackage(uint256 calldataNegativeOffsetForDataPackage)\n    internal\n    pure\n    returns (uint256 dataPointsCount, uint256 eachDataPointValueByteSize)\n  {\n    // Using uint24, because data points count byte size number has 3 bytes\n    uint24 dataPointsCount_;\n\n    // Using uint32, because data point value byte size has 4 bytes\n    uint32 eachDataPointValueByteSize_;\n\n    // Extract data points count\n    uint256 negativeCalldataOffset = calldataNegativeOffsetForDataPackage + SIG_BS;\n    uint256 calldataOffset = msg.data.length.sub(negativeCalldataOffset + STANDARD_SLOT_BS);\n    assembly {\n      dataPointsCount_ := calldataload(calldataOffset)\n    }\n\n    // Extract each data point value size\n    calldataOffset = calldataOffset.sub(DATA_POINTS_COUNT_BS);\n    assembly {\n      eachDataPointValueByteSize_ := calldataload(calldataOffset)\n    }\n\n    // Prepare returned values\n    dataPointsCount = dataPointsCount_;\n    eachDataPointValueByteSize = eachDataPointValueByteSize_;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/ProxyConnector.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"./RedstoneConstants.sol\";\nimport \"./CalldataExtractor.sol\";\n\n/**\n * @title The base contract for forwarding redstone payload to other contracts\n * @author The Redstone Oracles team\n */\ncontract ProxyConnector is RedstoneConstants, CalldataExtractor {\n  error ProxyCalldataFailedWithoutErrMsg();\n  error ProxyCalldataFailedWithStringMessage(string message);\n  error ProxyCalldataFailedWithCustomError(bytes result);\n\n  function proxyCalldata(\n    address contractAddress,\n    bytes memory encodedFunction,\n    bool forwardValue\n  ) internal returns (bytes memory) {\n    bytes memory message = _prepareMessage(encodedFunction);\n\n    (bool success, bytes memory result) =\n      contractAddress.call{value: forwardValue ? msg.value : 0}(message);\n\n    return _prepareReturnValue(success, result);\n  }\n\n  function proxyDelegateCalldata(address contractAddress, bytes memory encodedFunction)\n    internal\n    returns (bytes memory)\n  {\n    bytes memory message = _prepareMessage(encodedFunction);\n    (bool success, bytes memory result) = contractAddress.delegatecall(message);\n    return _prepareReturnValue(success, result);\n  }\n\n  function proxyCalldataView(address contractAddress, bytes memory encodedFunction)\n    internal\n    view\n    returns (bytes memory)\n  {\n    bytes memory message = _prepareMessage(encodedFunction);\n    (bool success, bytes memory result) = contractAddress.staticcall(message);\n    return _prepareReturnValue(success, result);\n  }\n\n  function _prepareMessage(bytes memory encodedFunction) private pure returns (bytes memory) {\n    uint256 encodedFunctionBytesCount = encodedFunction.length;\n    uint256 redstonePayloadByteSize = _getRedstonePayloadByteSize();\n    uint256 resultMessageByteSize = encodedFunctionBytesCount + redstonePayloadByteSize;\n\n    if (redstonePayloadByteSize > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n\n    bytes memory message;\n\n    assembly {\n      message := mload(FREE_MEMORY_PTR) // sets message pointer to first free place in memory\n\n      // Saving the byte size of the result message (it's a standard in EVM)\n      mstore(message, resultMessageByteSize)\n\n      // Copying function and its arguments\n      for {\n        let from := add(BYTES_ARR_LEN_VAR_BS, encodedFunction)\n        let fromEnd := add(from, encodedFunctionBytesCount)\n        let to := add(BYTES_ARR_LEN_VAR_BS, message)\n      } lt (from, fromEnd) {\n        from := add(from, STANDARD_SLOT_BS)\n        to := add(to, STANDARD_SLOT_BS)\n      } {\n        // Copying data from encodedFunction to message (32 bytes at a time)\n        mstore(to, mload(from))\n      }\n\n      // Copying redstone payload to the message bytes\n      calldatacopy(\n        add(message, add(BYTES_ARR_LEN_VAR_BS, encodedFunctionBytesCount)), // address\n        sub(calldatasize(), redstonePayloadByteSize), // offset\n        redstonePayloadByteSize // bytes length to copy\n      )\n\n      // Updating free memory pointer\n      mstore(\n        FREE_MEMORY_PTR,\n        add(\n          add(message, add(redstonePayloadByteSize, encodedFunctionBytesCount)),\n          BYTES_ARR_LEN_VAR_BS\n        )\n      )\n    }\n\n    return message;\n  }\n\n  function _getRedstonePayloadByteSize() private pure returns (uint256) {\n    uint256 calldataNegativeOffset = _extractByteSizeOfUnsignedMetadata();\n    uint256 dataPackagesCount = _extractDataPackagesCountFromCalldata(calldataNegativeOffset);\n    calldataNegativeOffset += DATA_PACKAGES_COUNT_BS;\n    for (uint256 dataPackageIndex = 0; dataPackageIndex < dataPackagesCount; dataPackageIndex++) {\n      uint256 dataPackageByteSize = _getDataPackageByteSize(calldataNegativeOffset);\n      calldataNegativeOffset += dataPackageByteSize;\n    }\n\n    return calldataNegativeOffset;\n  }\n\n  function _getDataPackageByteSize(uint256 calldataNegativeOffset) private pure returns (uint256) {\n    (\n      uint256 dataPointsCount,\n      uint256 eachDataPointValueByteSize\n    ) = _extractDataPointsDetailsForDataPackage(calldataNegativeOffset);\n\n    return\n      dataPointsCount *\n      (DATA_POINT_SYMBOL_BS + eachDataPointValueByteSize) +\n      DATA_PACKAGE_WITHOUT_DATA_POINTS_BS;\n  }\n\n\n  function _prepareReturnValue(bool success, bytes memory result)\n    internal\n    pure\n    returns (bytes memory)\n  {\n    if (!success) {\n\n      if (result.length == 0) {\n        revert ProxyCalldataFailedWithoutErrMsg();\n      } else {\n        bool isStringErrorMessage;\n        assembly {\n          let first32BytesOfResult := mload(add(result, BYTES_ARR_LEN_VAR_BS))\n          isStringErrorMessage := eq(first32BytesOfResult, STRING_ERR_MESSAGE_MASK)\n        }\n\n        if (isStringErrorMessage) {\n          string memory receivedErrMsg;\n          assembly {\n            receivedErrMsg := add(result, REVERT_MSG_OFFSET)\n          }\n          revert ProxyCalldataFailedWithStringMessage(receivedErrMsg);\n        } else {\n          revert ProxyCalldataFailedWithCustomError(result);\n        }\n      }\n    }\n\n    return result;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\n/**\n * @title The base contract with helpful constants\n * @author The Redstone Oracles team\n * @dev It mainly contains redstone-related values, which improve readability\n * of other contracts (e.g. CalldataExtractor and RedstoneConsumerBase)\n */\ncontract RedstoneConstants {\n  // === Abbreviations ===\n  // BS - Bytes size\n  // PTR - Pointer (memory location)\n  // SIG - Signature\n\n  // Solidity and YUL constants\n  uint256 internal constant STANDARD_SLOT_BS = 32;\n  uint256 internal constant FREE_MEMORY_PTR = 0x40;\n  uint256 internal constant BYTES_ARR_LEN_VAR_BS = 32;\n  uint256 internal constant FUNCTION_SIGNATURE_BS = 4;\n  uint256 internal constant REVERT_MSG_OFFSET = 68; // Revert message structure described here: https://ethereum.stackexchange.com/a/66173/106364\n  uint256 internal constant STRING_ERR_MESSAGE_MASK = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n\n  // RedStone protocol consts\n  uint256 internal constant SIG_BS = 65;\n  uint256 internal constant TIMESTAMP_BS = 6;\n  uint256 internal constant DATA_PACKAGES_COUNT_BS = 2;\n  uint256 internal constant DATA_POINTS_COUNT_BS = 3;\n  uint256 internal constant DATA_POINT_VALUE_BYTE_SIZE_BS = 4;\n  uint256 internal constant DATA_POINT_SYMBOL_BS = 32;\n  uint256 internal constant DEFAULT_DATA_POINT_VALUE_BS = 32;\n  uint256 internal constant UNSIGNED_METADATA_BYTE_SIZE_BS = 3;\n  uint256 internal constant REDSTONE_MARKER_BS = 9; // byte size of 0x000002ed57011e0000\n  uint256 internal constant REDSTONE_MARKER_MASK = 0x0000000000000000000000000000000000000000000000000002ed57011e0000;\n\n  // Derived values (based on consts)\n  uint256 internal constant TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS = 104; // SIG_BS + DATA_POINTS_COUNT_BS + DATA_POINT_VALUE_BYTE_SIZE_BS + STANDARD_SLOT_BS\n  uint256 internal constant DATA_PACKAGE_WITHOUT_DATA_POINTS_BS = 78; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS + SIG_BS\n  uint256 internal constant DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS = 13; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS\n  uint256 internal constant REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS = 41; // REDSTONE_MARKER_BS + STANDARD_SLOT_BS\n\n  // Error messages\n  error CalldataOverOrUnderFlow();\n  error IncorrectUnsignedMetadataSize();\n  error InsufficientNumberOfUniqueSigners(uint256 receivedSignersCount, uint256 requiredSignersCount);\n  error EachSignerMustProvideTheSameValue();\n  error EmptyCalldataPointersArr();\n  error InvalidCalldataPointer();\n  error CalldataMustHaveValidPayload();\n  error SignerNotAuthorised(address receivedSigner);\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneDefaultsLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"../libs/NumericArrayLib.sol\";\n\n/**\n * @title Default implementations of virtual redstone consumer base functions\n * @author The Redstone Oracles team\n */\nlibrary RedstoneDefaultsLib {\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS = 3 minutes;\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS = 1 minutes;\n\n  error TimestampFromTooLongFuture(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\n  error TimestampIsTooOld(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\n\n  function validateTimestamp(uint256 receivedTimestampMilliseconds) internal view {\n    // Getting data timestamp from future seems quite unlikely\n    // But we've already spent too much time with different cases\n    // Where block.timestamp was less than dataPackage.timestamp.\n    // Some blockchains may case this problem as well.\n    // That's why we add MAX_BLOCK_TIMESTAMP_DELAY\n    // and allow data \"from future\" but with a small delay\n    uint256 receivedTimestampSeconds = receivedTimestampMilliseconds / 1000;\n\n    if (block.timestamp < receivedTimestampSeconds) {\n      if ((receivedTimestampSeconds - block.timestamp) > DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS) {\n        revert TimestampFromTooLongFuture(receivedTimestampSeconds, block.timestamp);\n      }\n    } else if ((block.timestamp - receivedTimestampSeconds) > DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS) {\n      revert TimestampIsTooOld(receivedTimestampSeconds, block.timestamp);\n    }\n  }\n\n  function aggregateValues(uint256[] memory values) internal pure returns (uint256) {\n    return NumericArrayLib.pickMedian(values);\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/BitmapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary BitmapLib {\n  function setBitInBitmap(uint256 bitmap, uint256 bitIndex) internal pure returns (uint256) {\n    return bitmap | (1 << bitIndex);\n  }\n\n  function getBitFromBitmap(uint256 bitmap, uint256 bitIndex) internal pure returns (bool) {\n    uint256 bitAtIndex = bitmap & (1 << bitIndex);\n    return bitAtIndex > 0;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/NumericArrayLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nlibrary NumericArrayLib {\n  // This function sort array in memory using bubble sort algorithm,\n  // which performs even better than quick sort for small arrays\n\n  uint256 constant BYTES_ARR_LEN_VAR_BS = 32;\n  uint256 constant UINT256_VALUE_BS = 32;\n\n  error CanNotPickMedianOfEmptyArray();\n\n  // This function modifies the array\n  function pickMedian(uint256[] memory arr) internal pure returns (uint256) {\n    if (arr.length == 0) {\n      revert CanNotPickMedianOfEmptyArray();\n    }\n    sort(arr);\n    uint256 middleIndex = arr.length / 2;\n    if (arr.length % 2 == 0) {\n      uint256 sum = SafeMath.add(arr[middleIndex - 1], arr[middleIndex]);\n      return sum / 2;\n    } else {\n      return arr[middleIndex];\n    }\n  }\n\n  function sort(uint256[] memory arr) internal pure {\n    assembly {\n      let arrLength := mload(arr)\n      let valuesPtr := add(arr, BYTES_ARR_LEN_VAR_BS)\n      let endPtr := add(valuesPtr, mul(arrLength, UINT256_VALUE_BS))\n      for {\n        let arrIPtr := valuesPtr\n      } lt(arrIPtr, endPtr) {\n        arrIPtr := add(arrIPtr, UINT256_VALUE_BS) // arrIPtr += 32\n      } {\n        for {\n          let arrJPtr := valuesPtr\n        } lt(arrJPtr, arrIPtr) {\n          arrJPtr := add(arrJPtr, UINT256_VALUE_BS) // arrJPtr += 32\n        } {\n          let arrI := mload(arrIPtr)\n          let arrJ := mload(arrJPtr)\n          if lt(arrI, arrJ) {\n            mstore(arrIPtr, arrJ)\n            mstore(arrJPtr, arrI)\n          }\n        }\n      }\n    }\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/SignatureLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary SignatureLib {\n  uint256 constant ECDSA_SIG_R_BS = 32;\n  uint256 constant ECDSA_SIG_S_BS = 32;\n\n  function recoverSignerAddress(bytes32 signedHash, uint256 signatureCalldataNegativeOffset)\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n    assembly {\n      let signatureCalldataStartPos := sub(calldatasize(), signatureCalldataNegativeOffset)\n      r := calldataload(signatureCalldataStartPos)\n      signatureCalldataStartPos := add(signatureCalldataStartPos, ECDSA_SIG_R_BS)\n      s := calldataload(signatureCalldataStartPos)\n      signatureCalldataStartPos := add(signatureCalldataStartPos, ECDSA_SIG_S_BS)\n      v := byte(0, calldataload(signatureCalldataStartPos)) // last byte of the signature memory array\n    }\n    return ecrecover(signedHash, v, r, s);\n  }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "src/contracts/diamond/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable no-complex-fallback  */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable no-empty-blocks */\n\npragma solidity >=0.8.19;\n\nimport {IDiamondCutFacet} from \"./interfaces/IDiamondCutFacet.sol\";\nimport {Authorization, Role} from \"../libs/Authorization.sol\";\nimport {GeneralEvent} from \"../libs/Events.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\nimport {initializeDiamondCut} from \"./libs/LibDiamondCut.sol\";\nimport {ds} from \"./DiamondStorage.sol\";\n\ncontract Diamond {\n    struct Initialization {\n        address initContract;\n        bytes initData;\n    }\n\n    constructor(\n        address _owner,\n        IDiamondCutFacet.FacetCut[] memory _diamondCut,\n        Initialization[] memory _initializations\n    ) {\n        ds().initialize(_owner);\n        ds().diamondCut(_diamondCut, address(0), \"\");\n        Authorization._grantRole(Role.ADMIN, _owner);\n\n        for (uint256 i = 0; i < _initializations.length; i++) {\n            initializeDiamondCut(_initializations[i].initContract, _initializations[i].initData);\n        }\n\n        emit GeneralEvent.Initialized(_owner, ds().storageVersion);\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        // get facet from function selectors\n        address facet = ds().selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), Error.DIAMOND_INVALID_FUNCTION_SIGNATURE);\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice A rescue function for missent msg.value\n     */\n    function rescueNative() external {\n        require(msg.sender == ds().contractOwner, Error.DIAMOND_INVALID_OWNER);\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    receive() external payable {}\n}\n"
    },
    "src/contracts/diamond/DiamondModifiers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {Authorization, Role} from \"../libs/Authorization.sol\";\nimport {Meta} from \"../libs/Meta.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\nimport {Action} from \"../minter/MinterTypes.sol\";\nimport {ms} from \"../minter/MinterStorage.sol\";\n\nimport {ENTERED, NOT_ENTERED} from \"../diamond/DiamondTypes.sol\";\nimport {ds} from \"../diamond/DiamondStorage.sol\";\n\nabstract contract DiamondModifiers {\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^Authorization: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        Authorization.checkRole(role);\n        _;\n    }\n\n    /**\n     * @notice Ensure only trusted contracts can act on behalf of `_account`\n     * @param _accountIsNotMsgSender The address of the collateral asset.\n     */\n    modifier onlyRoleIf(bool _accountIsNotMsgSender, bytes32 role) {\n        if (_accountIsNotMsgSender) {\n            Authorization.checkRole(role);\n        }\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(Meta.msgSender() == ds().contractOwner, Error.DIAMOND_INVALID_OWNER);\n        _;\n    }\n\n    modifier onlyPendingOwner() {\n        require(Meta.msgSender() == ds().pendingOwner, Error.DIAMOND_INVALID_PENDING_OWNER);\n        _;\n    }\n\n    modifier nonReentrant() {\n        require(ds().entered == NOT_ENTERED, Error.RE_ENTRANCY);\n        ds().entered = ENTERED;\n        _;\n        ds().entered = NOT_ENTERED;\n    }\n}\n"
    },
    "src/contracts/diamond/DiamondState.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {EnumerableSet} from \"../libs/EnumerableSet.sol\";\nimport {FacetAddressAndPosition, FacetFunctionSelectors, RoleData, ENTERED, NOT_ENTERED} from \"./DiamondTypes.sol\";\n\nimport {LibDiamondCut} from \"./libs/LibDiamondCut.sol\";\nimport {LibOwnership} from \"./libs/LibOwnership.sol\";\n\nusing LibDiamondCut for DiamondState global;\nusing LibOwnership for DiamondState global;\n\n/* -------------------------------------------------------------------------- */\n/*                                 Main Layout                                */\n/* -------------------------------------------------------------------------- */\n\nstruct DiamondState {\n    /* -------------------------------------------------------------------------- */\n    /*                                   Proxy                                    */\n    /* -------------------------------------------------------------------------- */\n    /// @notice Maps function selector to the facet address and\n    /// the position of the selector in the facetFunctionSelectors.selectors array\n    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n    /// @notice Maps facet addresses to function selectors\n    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n    /// @notice Facet addresses\n    address[] facetAddresses;\n    /// @notice ERC165 query implementation\n    mapping(bytes4 => bool) supportedInterfaces;\n    /* -------------------------------------------------------------------------- */\n    /*                               Initialization                               */\n    /* -------------------------------------------------------------------------- */\n    /// @notice Initialization status\n    bool initialized;\n    /// @notice Domain field separator\n    bytes32 domainSeparator;\n    /* -------------------------------------------------------------------------- */\n    /*                                  Ownership                                 */\n    /* -------------------------------------------------------------------------- */\n    /// @notice Current owner of the diamond\n    address contractOwner;\n    /// @notice Pending new diamond owner\n    address pendingOwner;\n    /// @notice Storage version\n    uint8 storageVersion;\n    /// @notice address(this) replacement for FF\n    address self;\n    /* -------------------------------------------------------------------------- */\n    /*                               Access Control                               */\n    /* -------------------------------------------------------------------------- */\n    mapping(bytes32 => RoleData) _roles;\n    mapping(bytes32 => EnumerableSet.AddressSet) _roleMembers;\n    /* -------------------------------------------------------------------------- */\n    /*                                 Reentrancy                                 */\n    /* -------------------------------------------------------------------------- */\n    uint256 entered;\n}\n"
    },
    "src/contracts/diamond/DiamondStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\npragma solidity >=0.8.19;\n\nimport {DiamondState} from \"./DiamondState.sol\";\n\n// Storage position\nbytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"kresko.diamond.storage\");\n\nfunction ds() pure returns (DiamondState storage state) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n        state.slot := position\n    }\n}\n"
    },
    "src/contracts/diamond/DiamondTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n/// @dev set the initial value to 1 as we do not\n/// wanna hinder possible gas refunds by setting it to 0 on exit.\n\n/* -------------------------------------------------------------------------- */\n/*                                 Reentrancy                                 */\n/* -------------------------------------------------------------------------- */\nuint256 constant NOT_ENTERED = 1;\nuint256 constant ENTERED = 2;\n\n/* ========================================================================== */\n/*                                   STRUCTS                                  */\n/* ========================================================================== */\n\nstruct FacetAddressAndPosition {\n    address facetAddress;\n    // position in facetFunctionSelectors.functionSelectors array\n    uint96 functionSelectorPosition;\n}\n\nstruct FacetFunctionSelectors {\n    bytes4[] functionSelectors;\n    // position of facetAddress in facetAddresses array\n    uint256 facetAddressPosition;\n}\n\nstruct RoleData {\n    mapping(address => bool) members;\n    bytes32 adminRole;\n}\n"
    },
    "src/contracts/diamond/facets/AuthorizationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IAuthorizationFacet} from \"../interfaces/IAuthorizationFacet.sol\";\nimport {Authorization, Role} from \"../../libs/Authorization.sol\";\n\n/**\n * @title Enumerable access control for the EIP2535-pattern following the OZ implementation.\n * @author Kresko\n * @notice The storage area is in the main proxy diamond storage.\n * @dev Difference here is the logic library that is shared and reused, there is no state here.\n */\ncontract AuthorizationFacet is IAuthorizationFacet {\n    using Authorization for bytes32;\n\n    /// @inheritdoc IAuthorizationFacet\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address) {\n        return role.getRoleMember(index);\n    }\n\n    /// @inheritdoc IAuthorizationFacet\n    function getRoleMemberCount(bytes32 role) external view returns (uint256) {\n        return role.getRoleMemberCount();\n    }\n\n    /// @inheritdoc IAuthorizationFacet\n    function grantRole(bytes32 role, address account) external {\n        role.grantRole(account);\n    }\n\n    /// @inheritdoc IAuthorizationFacet\n    function revokeRole(bytes32 role, address account) external {\n        role.revokeRole(account);\n    }\n\n    /// @inheritdoc IAuthorizationFacet\n    function hasRole(bytes32 role, address account) external view returns (bool) {\n        return role.hasRole(account);\n    }\n\n    /// @inheritdoc IAuthorizationFacet\n    function getRoleAdmin(bytes32 role) external view returns (bytes32) {\n        return role.getRoleAdmin();\n    }\n\n    /// @inheritdoc IAuthorizationFacet\n    function renounceRole(bytes32 role, address account) external {\n        role._renounceRole(account);\n    }\n}\n"
    },
    "src/contracts/diamond/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {IDiamondCutFacet} from \"../interfaces/IDiamondCutFacet.sol\";\nimport {DiamondModifiers, Role} from \"../DiamondModifiers.sol\";\nimport {initializeDiamondCut} from \"../libs/LibDiamondCut.sol\";\nimport {ds} from \"../DiamondStorage.sol\";\n\n/**\n * @title EIP2535-pattern upgrades.\n * @author Kresko\n * @notice The storage area is in the main proxy diamond storage.\n */\ncontract DiamondCutFacet is IDiamondCutFacet, DiamondModifiers {\n    /// @inheritdoc IDiamondCutFacet\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external onlyRole(Role.ADMIN) {\n        ds().diamondCut(_diamondCut, _init, _calldata);\n    }\n\n    /// @inheritdoc IDiamondCutFacet\n    function upgradeState(address _init, bytes calldata _calldata) external onlyRole(Role.ADMIN) {\n        initializeDiamondCut(_init, _calldata);\n    }\n}\n"
    },
    "src/contracts/diamond/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {IDiamondLoupeFacet} from \"../interfaces/IDiamondLoupeFacet.sol\";\nimport {ds, DiamondState} from \"../DiamondStorage.sol\";\n\ncontract DiamondLoupeFacet is IDiamondLoupeFacet {\n    /// @inheritdoc IDiamondLoupeFacet\n    function facets() external view override returns (Facet[] memory facets_) {\n        DiamondState storage s = ds();\n        uint256 numFacets = s.facetAddresses.length;\n        facets_ = new Facet[](numFacets);\n        for (uint256 i; i < numFacets; i++) {\n            address facetAddress_ = s.facetAddresses[i];\n            facets_[i].facetAddress = facetAddress_;\n            facets_[i].functionSelectors = s.facetFunctionSelectors[facetAddress_].functionSelectors;\n        }\n    }\n\n    /// @inheritdoc IDiamondLoupeFacet\n    function facetFunctionSelectors(\n        address _facet\n    ) external view override returns (bytes4[] memory facetFunctionSelectors_) {\n        facetFunctionSelectors_ = ds().facetFunctionSelectors[_facet].functionSelectors;\n    }\n\n    /// @inheritdoc IDiamondLoupeFacet\n    function facetAddresses() external view override returns (address[] memory facetAddresses_) {\n        facetAddresses_ = ds().facetAddresses;\n    }\n\n    /// @inheritdoc IDiamondLoupeFacet\n    function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\n        facetAddress_ = ds().selectorToFacetAndPosition[_functionSelector].facetAddress;\n    }\n}\n"
    },
    "src/contracts/diamond/facets/DiamondOwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {IDiamondOwnershipFacet} from \"../interfaces/IDiamondOwnershipFacet.sol\";\nimport {DiamondModifiers} from \"../DiamondModifiers.sol\";\nimport {ds} from \"../DiamondStorage.sol\";\n\ncontract DiamondOwnershipFacet is IDiamondOwnershipFacet, DiamondModifiers {\n    /* -------------------------------------------------------------------------- */\n    /*                                    Write                                   */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IDiamondOwnershipFacet\n    function transferOwnership(address _newOwner) external override {\n        ds().initiateOwnershipTransfer(_newOwner);\n    }\n\n    /// @inheritdoc IDiamondOwnershipFacet\n    function acceptOwnership() external override {\n        ds().finalizeOwnershipTransfer();\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Read                                    */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IDiamondOwnershipFacet\n    function owner() external view override returns (address owner_) {\n        return ds().contractOwner;\n    }\n\n    /// @inheritdoc IDiamondOwnershipFacet\n    function pendingOwner() external view override returns (address pendingOwner_) {\n        return ds().pendingOwner;\n    }\n\n    /// @inheritdoc IDiamondOwnershipFacet\n    function initialized() external view returns (bool initialized_) {\n        return ds().initialized;\n    }\n}\n"
    },
    "src/contracts/diamond/facets/ERC165Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {Error} from \"../../libs/Errors.sol\";\nimport {DiamondModifiers, Role} from \"../DiamondModifiers.sol\";\nimport {IERC165Facet} from \"../interfaces/IERC165Facet.sol\";\nimport {ds, DiamondState} from \"../DiamondStorage.sol\";\n\ncontract ERC165Facet is IERC165Facet, DiamondModifiers {\n    /// @inheritdoc IERC165Facet\n    function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\n        return ds().supportedInterfaces[_interfaceId];\n    }\n\n    /// @inheritdoc IERC165Facet\n    function setERC165(\n        bytes4[] calldata interfaceIds,\n        bytes4[] calldata interfaceIdsToRemove\n    ) external onlyRole(Role.ADMIN) {\n        DiamondState storage s = ds();\n\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            s.supportedInterfaces[interfaceIds[i]] = true;\n        }\n\n        for (uint256 i = 0; i < interfaceIdsToRemove.length; i++) {\n            s.supportedInterfaces[interfaceIdsToRemove[i]] = false;\n        }\n    }\n}\n"
    },
    "src/contracts/diamond/interfaces/IAuthorizationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface IAuthorizationFacet {\n    /**\n     * @dev OpenZeppelin\n     * Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * @notice WARNING:\n     * When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block.\n     *\n     * See the following forum post for more information:\n     * - https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296\n     *\n     * @dev Kresko\n     *\n     * TL;DR above:\n     *\n     * - If you iterate the EnumSet outside a single block scope you might get different results.\n     * - Since when EnumSet member is deleted it is replaced with the highest index.\n     * @return address with the `role`\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     * @notice See warning in {getRoleMember} if combining these two\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * @notice To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Returns true if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * @notice Requirements\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * @notice Requirements\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n}\n"
    },
    "src/contracts/diamond/interfaces/IDiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\nimport {DiamondEvent} from \"../../libs/Events.sol\";\n\ninterface IDiamondCutFacet {\n    /// @dev  Add=0, Replace=1, Remove=2\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /**\n     *@notice Add/replace/remove any number of functions, optionally execute a function with delegatecall\n     * @param _diamondCut Contains the facet addresses and function selectors\n     * @param _init The address of the contract or facet to execute _calldata\n     * @param _calldata A function call, including function selector and arguments\n     *                  _calldata is executed with delegatecall on _init\n     */\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n\n    /**\n     * @notice Use an initializer contract without doing modifications\n     * @param _init The address of the contract or facet to execute _calldata\n     * @param _calldata A function call, including function selector and arguments\n     * - _calldata is executed with delegatecall on _init\n     */\n    function upgradeState(address _init, bytes calldata _calldata) external;\n}\n"
    },
    "src/contracts/diamond/interfaces/IDiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupeFacet {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "src/contracts/diamond/interfaces/IDiamondOwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n/// @title Contract Ownership\ninterface IDiamondOwnershipFacet {\n    /**\n     * @notice Get the address of the owner\n     * @return owner_ The address of the owner.\n     */\n    function owner() external view returns (address owner_);\n\n    /**\n     * @notice Get the address of pending owner\n     * @return pendingOwner_ The address of the pending owner.\n     **/\n    function pendingOwner() external view returns (address pendingOwner_);\n\n    /**\n     * @notice Initiate ownership transfer to a new address\n     * @notice caller must be the current contract owner\n     * @notice the new owner cannot be address(0)\n     * @notice emits a {AuthEvent.PendingOwnershipTransfer} event\n     * @param _newOwner address that is set as the pending new owner\n     */\n    function transferOwnership(address _newOwner) external;\n\n    /**\n     * @notice Transfer the ownership to the new pending owner\n     * @notice caller must be the pending owner\n     * @notice emits a {AuthEvent.OwnershipTransferred} event\n     */\n    function acceptOwnership() external;\n\n    /**\n     * @notice Check if the contract is initialized\n     * @return initialized_ bool True if the contract is initialized, false otherwise.\n     */\n    function initialized() external view returns (bool initialized_);\n}\n"
    },
    "src/contracts/diamond/interfaces/IERC165Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\nimport {DiamondEvent} from \"../../libs/Events.sol\";\n\ninterface IERC165Facet {\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @dev Interface identification is specified in ERC-165. This function\n     *  uses less than 30,000 gas.\n     * @return `true` if the contract implements `interfaceID` and\n     *  `interfaceID` is not 0xffffffff, `false` otherwise\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    /**\n     * @notice set or unset ERC165 using DiamondStorage.supportedInterfaces\n     * @param interfaceIds list of interface id to set as supported\n     * @param interfaceIdsToRemove list of interface id to unset as supported.\n     * Technically, you can remove support of ERC165 by having the IERC165 id itself being part of that array.\n     */\n    function setERC165(bytes4[] calldata interfaceIds, bytes4[] calldata interfaceIdsToRemove) external;\n}\n"
    },
    "src/contracts/diamond/libs/LibDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\nimport {IDiamondCutFacet} from \"../interfaces/IDiamondCutFacet.sol\";\n\nimport {Meta} from \"../../libs/Meta.sol\";\nimport {DiamondEvent} from \"../../libs/Events.sol\";\nimport {DiamondState} from \"../DiamondState.sol\";\n\n// solhint-disable-next-line func-visibility\nfunction initializeDiamondCut(address _init, bytes memory _calldata) {\n    if (_init == address(0)) {\n        require(_calldata.length == 0, \"DiamondCut: _init is address(0) but _calldata is not empty\");\n    } else {\n        require(_calldata.length > 0, \"DiamondCut: _calldata is empty but _init is not address(0)\");\n        Meta.enforceHasContractCode(_init, \"DiamondCut: _init address has no code\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up the error\n                revert(string(error));\n            } else {\n                revert(\"DiamondCut: _init function reverted\");\n            }\n        }\n    }\n}\n\nlibrary LibDiamondCut {\n    /* -------------------------------------------------------------------------- */\n    /*                              Diamond Functions                             */\n    /* -------------------------------------------------------------------------- */\n\n    function diamondCut(\n        DiamondState storage self,\n        IDiamondCutFacet.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCutFacet.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCutFacet.FacetCutAction.Add) {\n                self.addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCutFacet.FacetCutAction.Replace) {\n                self.replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCutFacet.FacetCutAction.Remove) {\n                self.removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"DiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondEvent.DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(\n        DiamondState storage self,\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(_functionSelectors.length > 0, \"DiamondCut: No selectors in facet to cut\");\n        require(_facetAddress != address(0), \"DiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(self.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            self.addFacet(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = self.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"DiamondCut: Can't add function that already exists\");\n            self.addFunction(selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(\n        DiamondState storage self,\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(_functionSelectors.length > 0, \"DiamondCut: No selectors in facet to cut\");\n        require(_facetAddress != address(0), \"DiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(self.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            self.addFacet(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = self.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"DiamondCut: Can't replace function with same function\");\n            self.removeFunction(oldFacetAddress, selector);\n            self.addFunction(selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(\n        DiamondState storage self,\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(_functionSelectors.length > 0, \"DiamondCut: No selectors in facet to cut\");\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"DiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = self.selectorToFacetAndPosition[selector].facetAddress;\n            self.removeFunction(oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondState storage self, address _facetAddress) internal {\n        Meta.enforceHasContractCode(_facetAddress, \"DiamondCut: New facet has no code\");\n        self.facetFunctionSelectors[_facetAddress].facetAddressPosition = self.facetAddresses.length;\n        self.facetAddresses.push(_facetAddress);\n    }\n\n    function addFunction(\n        DiamondState storage self,\n        bytes4 _selector,\n        uint96 _selectorPosition,\n        address _facetAddress\n    ) internal {\n        self.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        self.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        self.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondState storage self, address _facetAddress, bytes4 _selector) internal {\n        require(_facetAddress != address(0), \"DiamondCut: Can't remove function that doesn't exist\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = self.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = self.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = self.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            self.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            self.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        self.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete self.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = self.facetAddresses.length - 1;\n            uint256 facetAddressPosition = self.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = self.facetAddresses[lastFacetAddressPosition];\n                self.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                self.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            self.facetAddresses.pop();\n            delete self.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n}\n"
    },
    "src/contracts/diamond/libs/LibOwnership.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {IERC165} from \"../../shared/IERC165.sol\";\nimport {IDiamondCutFacet} from \"../interfaces/IDiamondCutFacet.sol\";\nimport {IDiamondLoupeFacet} from \"../interfaces/IDiamondLoupeFacet.sol\";\nimport {IDiamondOwnershipFacet} from \"../interfaces/IDiamondOwnershipFacet.sol\";\nimport {IAuthorizationFacet} from \"../interfaces/IAuthorizationFacet.sol\";\n\nimport {GeneralEvent, AuthEvent} from \"../../libs/Events.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Meta} from \"../../libs/Meta.sol\";\n\nimport {NOT_ENTERED} from \"../DiamondTypes.sol\";\nimport {DiamondState} from \"../DiamondState.sol\";\n\nlibrary LibOwnership {\n    /* -------------------------------------------------------------------------- */\n    /*                         Initialization & Ownership                         */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Ownership initializer\n    /// @notice Only called on the first deployment\n    function initialize(DiamondState storage self, address _owner) internal {\n        require(!self.initialized, Error.ALREADY_INITIALIZED);\n        self.entered = NOT_ENTERED;\n        self.initialized = true;\n        self.storageVersion++;\n        self.contractOwner = _owner;\n\n        self.supportedInterfaces[type(IDiamondLoupeFacet).interfaceId] = true;\n        self.supportedInterfaces[type(IERC165).interfaceId] = true;\n        self.supportedInterfaces[type(IDiamondCutFacet).interfaceId] = true;\n        self.supportedInterfaces[type(IDiamondOwnershipFacet).interfaceId] = true;\n        self.supportedInterfaces[type(IAuthorizationFacet).interfaceId] = true;\n\n        emit GeneralEvent.Deployed(_owner, self.storageVersion);\n        emit AuthEvent.OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Initiate ownership transfer to a new address\n     * @param _newOwner address that is set as the pending new owner\n     * @notice caller must be the current contract owner\n     */\n    function initiateOwnershipTransfer(DiamondState storage self, address _newOwner) internal {\n        require(Meta.msgSender() == self.contractOwner, Error.DIAMOND_INVALID_OWNER);\n        require(_newOwner != address(0), \"DS: Owner cannot be 0-address\");\n\n        self.pendingOwner = _newOwner;\n\n        emit AuthEvent.PendingOwnershipTransfer(self.contractOwner, _newOwner);\n    }\n\n    /**\n     * @dev Transfer the ownership to the new pending owner\n     * @notice caller must be the pending owner\n     */\n    function finalizeOwnershipTransfer(DiamondState storage self) internal {\n        address sender = Meta.msgSender();\n        require(sender == self.pendingOwner, Error.DIAMOND_INVALID_PENDING_OWNER);\n        self.contractOwner = self.pendingOwner;\n        self.pendingOwner = address(0);\n\n        emit AuthEvent.OwnershipTransferred(self.contractOwner, sender);\n    }\n}\n"
    },
    "src/contracts/kiss/interfaces/IKISS.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {IERC20Permit} from \"../../shared/IERC20Permit.sol\";\n\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\nimport {IERC165} from \"../../shared/IERC165.sol\";\n\ninterface IKISS is IKreskoAssetIssuer, IERC165 {\n    /* -------------------------------------------------------------------------- */\n    /*                                   Events                                   */\n    /* -------------------------------------------------------------------------- */\n    event NewOperatorInitialized(address indexed pendingNewOperator, uint256 unlockTimestamp);\n    event NewOperator(address indexed newOperator);\n    event NewMaxOperators(uint256 newMaxOperators);\n    event NewPendingOperatorWaitPeriod(uint256 newPeriod);\n\n    function pendingOperatorUnlockTime() external returns (uint256);\n\n    function pendingOperator() external returns (address);\n\n    function maxOperators() external returns (uint256);\n\n    /**\n     * @notice This function adds KISS to circulation\n     * Caller must be a contract and have the OPERATOR_ROLE\n     * @param _to address to mint tokens to\n     * @param _amount amount to mint\n     * @return amount minted\n     */\n    function issue(uint256 _amount, address _to) external returns (uint256);\n\n    /**\n     * @notice Use operator role for minting, so override the parent\n     * Caller must be a contract and have the OPERATOR_ROLE\n     * @param _to address to mint tokens to\n     * @param _amount amount to mint\n     * @dev Does not return a value\n     */\n    function mint(address _to, uint256 _amount) external;\n\n    /**\n     * @notice This function removes KISS from circulation\n     * Caller must be a contract and have the OPERATOR_ROLE\n     * @param _from address to burn tokens from\n     * @param destroyed amount burned\n     * @inheritdoc IKreskoAssetIssuer\n     */\n    function destroy(uint256 _amount, address _from) external returns (uint256 destroyed);\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function pause() external;\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function unpause() external;\n\n    /**\n     * @notice Set a new waiting period for a new operator\n     *\n     * Must be at least 15 minutes\n     *\n     * @param _newPeriod the period, in seconds\n     */\n    function setPendingOperatorWaitPeriod(uint256 _newPeriod) external;\n\n    /**\n     * @notice Allows ADMIN_ROLE to change the maximum operators\n     * @param _maxOperators new maximum amount of operators\n     */\n    function setMaxOperators(uint256 _maxOperators) external;\n\n    /**\n     * @notice Overrides `AccessControl.grantRole` for following:\n     * * Implement a cooldown period of `pendingOperatorWaitPeriod` minutes for setting a new OPERATOR_ROLE\n     * * EOA cannot be granted the operator role\n     * * The first operator can be set without a cooldown period\n     * @notice OPERATOR_ROLE can still be revoked without this cooldown period\n     * @notice PAUSER_ROLE can still be granted without this cooldown period\n     * @param _role role to grant\n     * @param _to address to grant role for\n     */\n    function grantRole(bytes32 _role, address _to) external;\n}\n"
    },
    "src/contracts/kiss/KISS.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n// solhint-disable-next-line\nimport {AccessControlEnumerableUpgradeable, AccessControlUpgradeable, IAccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"../shared/ERC20Upgradeable.sol\";\nimport {IKreskoAssetIssuer} from \"../kreskoasset/IKreskoAssetIssuer.sol\";\nimport {IKISS, IERC165} from \"./interfaces/IKISS.sol\";\nimport {Role} from \"../libs/Authorization.sol\";\nimport {Error} from \"../libs/Errors.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @title Kresko Integrated Stable System\n * This is a non-rebasing Kresko Asset, intended to be paired to a stable-value underlying.\n * @author Kresko\n */\ncontract KISS is IKISS, ERC20Upgradeable, PausableUpgradeable, AccessControlEnumerableUpgradeable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    modifier onlyContract() {\n        require(msg.sender.code.length > 0, Error.CALLER_NOT_CONTRACT);\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Layout                                   */\n    /* -------------------------------------------------------------------------- */\n\n    uint256 public pendingOperatorWaitPeriod;\n    uint256 public pendingOperatorUnlockTime;\n    uint256 public maxOperators;\n    address public pendingOperator;\n    address public kresko;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Writes                                   */\n    /* -------------------------------------------------------------------------- */\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        uint8 dec_,\n        address admin_,\n        address kresko_\n    ) external initializer {\n        // Few sanity checks, we do not want EOA's here\n        require(kresko_.code.length > 0, Error.KRESKO_NOT_CONTRACT);\n        require(admin_.code.length > 0, Error.ADMIN_NOT_A_CONTRACT);\n\n        // ERC20\n        name = name_;\n        symbol = symbol_;\n        decimals = dec_;\n\n        // 2 operators needed at the time of writing, the volative market and the stable market.\n        maxOperators = 2;\n\n        // 15 minutes to wait before the operator can accept the role, this is the minimum value that can be set.\n        pendingOperatorWaitPeriod = 15 minutes;\n\n        // Setup the admin\n        _setupRole(Role.DEFAULT_ADMIN, admin_);\n        _setupRole(Role.ADMIN, admin_);\n\n        // Setup the protocol\n        kresko = kresko_;\n        _setupRole(Role.OPERATOR, kresko_);\n        _setupRole(MINTER_ROLE, kresko_);\n        _setupRole(PAUSER_ROLE, kresko_);\n\n        renounceRole(MINTER_ROLE, msg.sender);\n        renounceRole(PAUSER_ROLE, msg.sender);\n        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view override(AccessControlEnumerableUpgradeable, IERC165) returns (bool) {\n        return (interfaceId != 0xffffffff &&\n            (interfaceId == type(IKISS).interfaceId ||\n                interfaceId == type(IKreskoAssetIssuer).interfaceId ||\n                interfaceId == 0x01ffc9a7 ||\n                interfaceId == 0x36372b07 ||\n                super.supportsInterface(interfaceId)));\n    }\n\n    /// @inheritdoc IKISS\n    function issue(\n        uint256 _amount,\n        address _to\n    ) public override onlyContract onlyRole(Role.OPERATOR) returns (uint256) {\n        _mint(_to, _amount);\n        return _amount;\n    }\n\n    /// @inheritdoc IKISS\n    function mint(address _to, uint256 _amount) public onlyContract onlyRole(Role.OPERATOR) {\n        _mint(_to, _amount);\n    }\n\n    /// @inheritdoc IKISS\n    function destroy(uint256 _amount, address _from) external onlyContract onlyRole(Role.OPERATOR) returns (uint256) {\n        _burn(_from, _amount);\n        return _amount;\n    }\n\n    /// @inheritdoc IKISS\n    function pause() public onlyContract onlyRole(Role.ADMIN) {\n        super._pause();\n    }\n\n    /// @inheritdoc IKISS\n    function unpause() public onlyContract onlyRole(Role.ADMIN) {\n        _unpause();\n    }\n\n    /// @inheritdoc IKISS\n    function setPendingOperatorWaitPeriod(uint256 _newPeriod) external onlyRole(Role.ADMIN) {\n        require(_newPeriod >= 15 minutes, Error.OPERATOR_WAIT_PERIOD_TOO_SHORT);\n        pendingOperatorWaitPeriod = _newPeriod;\n        emit NewPendingOperatorWaitPeriod(_newPeriod);\n    }\n\n    /// @inheritdoc IKISS\n    function setMaxOperators(uint256 _maxOperators) external onlyRole(Role.ADMIN) {\n        maxOperators = _maxOperators;\n        emit NewMaxOperators(_maxOperators);\n    }\n\n    /// @inheritdoc IKISS\n    function grantRole(\n        bytes32 _role,\n        address _to\n    ) public override(IKISS, AccessControlUpgradeable, IAccessControlUpgradeable) onlyRole(Role.ADMIN) {\n        // Default behavior\n        if (_role != Role.OPERATOR) {\n            _grantRole(_role, _to);\n            return;\n        }\n\n        // Handle the operator role\n        require(_to.code.length > 0, Error.OPERATOR_NOT_CONTRACT);\n        if (pendingOperator != address(0)) {\n            // Ensure cooldown period\n            require(pendingOperatorUnlockTime < block.timestamp, Error.OPERATOR_WAIT_PERIOD_NOT_OVER);\n            // Grant role\n            _grantRole(Role.OPERATOR, pendingOperator);\n            emit NewOperator(pendingOperator);\n            // Reset pending owner\n            // No need to touch the timestamp (next call will just trigger the cooldown period)\n            pendingOperator = address(0);\n        } else if (pendingOperatorUnlockTime != 0) {\n            // Do not allow more than `maxOperators` of operators\n            require(getRoleMemberCount(Role.OPERATOR) <= maxOperators, Error.OPERATOR_LIMIT_REACHED);\n            // Set the timestamp for the cooldown period\n            pendingOperatorUnlockTime = block.timestamp + pendingOperatorWaitPeriod;\n            // Set the pending operator, execution to upper if clause next call as this pending operator is set\n            pendingOperator = _to;\n            emit NewOperatorInitialized(_to, pendingOperatorUnlockTime);\n        } else {\n            // Initialize operator for the first time\n            _grantRole(Role.OPERATOR, _to);\n            emit NewOperator(_to);\n            // Set the timestamp, execution will not come here again\n            pendingOperatorUnlockTime = block.timestamp;\n        }\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Views                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IKreskoAssetIssuer\n    function convertToShares(uint256 assets) external pure returns (uint256) {\n        return assets;\n    }\n\n    /// @inheritdoc IKreskoAssetIssuer\n    function convertToAssets(uint256 shares) external pure returns (uint256) {\n        return shares;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  internal                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        super._beforeTokenTransfer(from, to, amount);\n        require(!paused(), \"KISS: Paused\");\n    }\n}\n"
    },
    "src/contracts/kreskoasset/ERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\n\nimport {SafeERC20} from \"../shared/SafeERC20.sol\";\nimport {IKreskoAsset, IERC20Permit} from \"./IKreskoAsset.sol\";\nimport {IERC4626Upgradeable} from \"./IERC4626Upgradeable.sol\";\nimport {ERC20Upgradeable} from \"./KreskoAsset.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\n/* solhint-disable func-name-mixedcase */\n/* solhint-disable no-empty-blocks */\n/* solhint-disable func-visibility */\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @notice Kresko:\n/// Adds issue/destroy functions that are called when KreskoAssets are minted/burned through the protocol.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @author Kresko (https://www.kresko.fi)\nabstract contract ERC4626Upgradeable is IERC4626Upgradeable, ERC20Upgradeable {\n    using SafeERC20 for IKreskoAsset;\n    using FixedPointMathLib for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Events                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event Issue(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Destroy(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Immutables                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IERC4626Upgradeable\n    IKreskoAsset public immutable asset;\n\n    constructor(IKreskoAsset _asset) payable {\n        asset = _asset;\n    }\n\n    /**\n     * @notice Initializes the ERC4626.\n     *\n     * @param _asset The underlying (Kresko) Asset\n     * @param _name Name of the anchor token\n     * @param _symbol Symbol of the anchor token\n     * @dev decimals are read from the underlying asset\n     */\n    function __ERC4626Upgradeable_init(\n        IERC20Permit _asset,\n        string memory _name,\n        string memory _symbol\n    ) internal onlyInitializing {\n        __ERC20Upgradeable_init(_name, _symbol, _asset.decimals());\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Issue & Destroy                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice When new KreskoAssets are minted:\n     * Issues the equivalent amount of anchor tokens to Kresko\n     * Issues the equivalent amount of assets to user\n     */\n    function issue(uint256 assets, address to) public virtual returns (uint256 shares) {\n        require(msg.sender == asset.kresko(), Error.ISSUER_NOT_KRESKO);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewIssue(assets)) != 0, Error.ZERO_SHARES);\n\n        // Mint shares to kresko\n        _mint(asset.kresko(), shares);\n        // Mint assets to receiver\n        asset.mint(to, assets);\n\n        emit Issue(msg.sender, to, assets, shares);\n\n        _afterDeposit(assets, shares);\n    }\n\n    /**\n     * @notice When new KreskoAssets are burned:\n     * Destroys the equivalent amount of anchor tokens from Kresko\n     * Destorys the equivalent amount of assets from user\n     */\n    function destroy(uint256 assets, address from) public virtual returns (uint256 shares) {\n        require(msg.sender == asset.kresko(), Error.REDEEMER_NOT_KRESKO);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewIssue(assets)) != 0, Error.ZERO_SHARES);\n\n        _beforeWithdraw(assets, shares);\n\n        // Burn shares from kresko\n        _burn(asset.kresko(), shares);\n        // Burn assets from user\n        asset.burn(from, assets);\n\n        emit Destroy(msg.sender, from, from, assets, shares);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              Accounting Logic                              */\n    /* -------------------------------------------------------------------------- */\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if _totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    /// @notice amount of shares for amount of @param assets\n    function previewIssue(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @notice amount of assets for amount of @param shares\n    function previewDestroy(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /// @notice amount of shares for amount of @param assets\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @notice amount of assets for amount of @param shares\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if _totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    /// @notice amount of shares for amount of @param assets\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = _totalSupply; // Saves an extra SLOAD if _totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    /// @notice amount of assets for amount of @param shares\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                       DEPOSIT/WITHDRAWAL LIMIT VIEWS                       */\n    /* -------------------------------------------------------------------------- */\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxIssue(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxDestroy(address owner) public view virtual returns (uint256) {\n        return convertToAssets(_balances[owner]);\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(_balances[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return _balances[owner];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                            INTERNAL HOOKS LOGIC                            */\n    /* -------------------------------------------------------------------------- */\n\n    function _beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function _afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n\n    /* -------------------------------------------------------------------------- */\n    /*                               EXTERNAL USE                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IERC4626Upgradeable\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, Error.ZERO_SHARES);\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        _afterDeposit(assets, shares);\n    }\n\n    /// @inheritdoc IERC4626Upgradeable\n    function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = _allowances[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) {\n                _allowances[owner][msg.sender] = allowed - shares;\n            }\n        }\n\n        _beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /// @inheritdoc IERC4626Upgradeable\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        _afterDeposit(assets, shares);\n    }\n\n    /// @inheritdoc IERC4626Upgradeable\n    function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = _allowances[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) {\n                _allowances[owner][msg.sender] = allowed - shares;\n            }\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, Error.ZERO_ASSETS);\n\n        _beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n}\n"
    },
    "src/contracts/kreskoasset/IERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {IKreskoAsset} from \"./IKreskoAsset.sol\";\n\ninterface IERC4626Upgradeable {\n    /**\n     * @notice The underlying Kresko Asset\n     */\n    function asset() external view returns (IKreskoAsset);\n\n    /**\n     * @notice Deposit KreskoAssets for equivalent amount of anchor tokens\n     * @param assets Amount of KreskoAssets to deposit\n     * @param receiver Address to send shares to\n     * @return shares Amount of shares minted\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @notice Withdraw KreskoAssets for equivalent amount of anchor tokens\n     * @param assets Amount of KreskoAssets to withdraw\n     * @param receiver Address to send KreskoAssets to\n     * @param owner Address to burn shares from\n     * @return shares Amount of shares burned\n     * @dev shares are burned from owner, not msg.sender\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    function maxDeposit(address) external view returns (uint256);\n\n    function maxMint(address) external view returns (uint256 assets);\n\n    function maxRedeem(address owner) external view returns (uint256 assets);\n\n    function maxWithdraw(address owner) external view returns (uint256 assets);\n\n    /**\n     * @notice Mint shares of anchor tokens for equivalent amount of KreskoAssets\n     * @param shares Amount of shares to mint\n     * @param receiver Address to send shares to\n     * @return assets Amount of KreskoAssets redeemed\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @notice Track the underlying amount\n     * @return Total supply for the underlying\n     */\n    function totalAssets() external view returns (uint256);\n\n    /**\n     * @notice Redeem shares of anchor for KreskoAssets\n     * @param shares Amount of shares to redeem\n     * @param receiver Address to send KreskoAssets to\n     * @param owner Address to burn shares from\n     * @return assets Amount of KreskoAssets redeemed\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "src/contracts/kreskoasset/IKreskoAsset.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IAccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\";\nimport {IERC20Permit} from \"../shared/IERC20Permit.sol\";\nimport {IERC165} from \"../shared/IERC165.sol\";\n\ninterface IKreskoAsset is IERC20Permit, IAccessControlEnumerableUpgradeable, IERC165 {\n    /**\n     * @notice Rebase information\n     * @param positive supply increasing/reducing rebase\n     * @param denominator the denominator for the operator, 1 ether = 1\n     */\n    struct Rebase {\n        bool positive;\n        uint256 denominator;\n    }\n\n    /**\n     * @notice Initializes a KreskoAsset ERC20 token.\n     * @dev Intended to be operated by the Kresko smart contract.\n     * @param _name The name of the KreskoAsset.\n     * @param _symbol The symbol of the KreskoAsset.\n     * @param _decimals Decimals for the asset.\n     * @param _admin The adminstrator of this contract.\n     * @param _kresko The protocol, can perform mint and burn.\n     */\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _admin,\n        address _kresko\n    ) external;\n\n    function kresko() external view returns (address);\n\n    function rebaseInfo() external view returns (Rebase memory);\n\n    function isRebased() external view returns (bool);\n\n    /**\n     * @notice Perform a rebase, changing the denumerator and its operator\n     * @param _denominator the denumerator for the operator, 1 ether = 1\n     * @param _positive supply increasing/reducing rebase\n     * @param _pools UniswapV2Pair address to sync so we wont get rekt by skim() calls.\n     * @dev denumerator values 0 and 1 ether will disable the rebase\n     */\n    function rebase(uint256 _denominator, bool _positive, address[] calldata _pools) external;\n\n    /**\n     * @notice Updates ERC20 metadata for the token in case eg. a ticker change\n     * @param _name new name for the asset\n     * @param _symbol new symbol for the asset\n     * @param _version number that must be greater than latest emitted `Initialized` version\n     */\n    function reinitializeERC20(string memory _name, string memory _symbol, uint8 _version) external;\n\n    /**\n     * @notice Returns the total supply of the token.\n     * @notice This amount is adjusted by rebases.\n     * @inheritdoc IERC20Permit\n     */\n    function totalSupply() external view override(IERC20Permit) returns (uint256);\n\n    /**\n     * @notice Returns the balance of @param _account\n     * @notice This amount is adjusted by rebases.\n     * @inheritdoc IERC20Permit\n     */\n    function balanceOf(address _account) external view override(IERC20Permit) returns (uint256);\n\n    /// @inheritdoc IERC20Permit\n    function allowance(address _owner, address _account) external view override(IERC20Permit) returns (uint256);\n\n    /// @inheritdoc IERC20Permit\n    function approve(address spender, uint256 amount) external override returns (bool);\n\n    /// @inheritdoc IERC20Permit\n    function transfer(address _to, uint256 _amount) external override(IERC20Permit) returns (bool);\n\n    /// @inheritdoc IERC20Permit\n    function transferFrom(address _from, address _to, uint256 _amount) external override(IERC20Permit) returns (bool);\n\n    /**\n     * @notice Mints tokens to an address.\n     * @dev Only callable by operator.\n     * @dev Internal balances are always unrebased, events emitted are not.\n     * @param _to The address to mint tokens to.\n     * @param _amount The amount of tokens to mint.\n     */\n    function mint(address _to, uint256 _amount) external;\n\n    /**\n     * @notice Burns tokens from an address.\n     * @dev Only callable by operator.\n     * @dev Internal balances are always unrebased, events emitted are not.\n     * @param _from The address to burn tokens from.\n     * @param _amount The amount of tokens to burn.\n     */\n    function burn(address _from, uint256 _amount) external;\n}\n"
    },
    "src/contracts/kreskoasset/IKreskoAssetAnchor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IAccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\";\nimport {IERC165} from \"../shared/IERC165.sol\";\nimport {IERC20Permit} from \"../shared/IERC20Permit.sol\";\nimport {IKreskoAssetIssuer} from \"./IKreskoAssetIssuer.sol\";\nimport {IKreskoAsset} from \"./IKreskoAsset.sol\";\nimport {IERC4626Upgradeable} from \"./IERC4626Upgradeable.sol\";\n\ninterface IKreskoAssetAnchor is\n    IKreskoAssetIssuer,\n    IERC4626Upgradeable,\n    IERC20Permit,\n    IAccessControlEnumerableUpgradeable,\n    IERC165\n{\n    function totalAssets() external view override(IERC4626Upgradeable) returns (uint256);\n\n    /**\n     * @notice Initializes the Kresko Asset Anchor.\n     *\n     * @param _asset The underlying (Kresko) Asset\n     * @param _name Name of the anchor token\n     * @param _symbol Symbol of the anchor token\n     * @param _admin The adminstrator of this contract.\n     * @dev Decimals are not supplied as they are read from the underlying Kresko Asset\n     */\n    function initialize(IKreskoAsset _asset, string memory _name, string memory _symbol, address _admin) external;\n\n    /**\n     * @notice Updates ERC20 metadata for the token in case eg. a ticker change\n     * @param _name new name for the asset\n     * @param _symbol new symbol for the asset\n     * @param _version number that must be greater than latest emitted `Initialized` version\n     */\n    function reinitializeERC20(string memory _name, string memory _symbol, uint8 _version) external;\n}\n"
    },
    "src/contracts/kreskoasset/IKreskoAssetIssuer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n/// @title KreskoAsset issuer interface\n/// @author Kresko\n/// @notice Contract that can issue/destroy Kresko Assets through Kresko\n/// @dev This interface is used by KISS & KreskoAssetAnchor\ninterface IKreskoAssetIssuer {\n    /**\n     * @notice Mints @param _assets of krAssets for @param _to,\n     * @notice Mints relative @return _shares of wkrAssets\n     */\n    function issue(uint256 _assets, address _to) external returns (uint256 shares);\n\n    /**\n     * @notice Burns @param _assets of krAssets from @param _from,\n     * @notice Burns relative @return _shares of wkrAssets\n     */\n    function destroy(uint256 _assets, address _from) external returns (uint256 shares);\n\n    /**\n     * @notice Returns the total amount of anchor tokens out\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @notice Returns the total amount of krAssets out\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n}\n"
    },
    "src/contracts/kreskoasset/KreskoAsset.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n// solhint-disable-next-line\nimport {AccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Role} from \"../libs/Authorization.sol\";\nimport {Error} from \"../libs/Errors.sol\";\nimport {ERC20Upgradeable} from \"../shared/ERC20Upgradeable.sol\";\nimport {IERC165} from \"../shared/IERC165.sol\";\nimport {RebaseMath} from \"./Rebase.sol\";\nimport {IKreskoAsset} from \"./IKreskoAsset.sol\";\nimport {IUniswapV2Pair} from \"../vendor/uniswap/v2-core/interfaces/IUniswapV2Pair.sol\";\n\n/**\n * @title Kresko Synthethic Asset - rebasing ERC20.\n * @author Kresko\n *\n * @notice Rebases to adjust for stock splits and reverse stock splits\n *\n * @notice Minting, burning and rebasing can only be performed by the `Role.OPERATOR`\n */\n\ncontract KreskoAsset is ERC20Upgradeable, AccessControlEnumerableUpgradeable, IKreskoAsset {\n    using RebaseMath for uint256;\n\n    bool public isRebased;\n    address public kresko;\n    Rebase private _rebaseInfo;\n\n    /// @inheritdoc IKreskoAsset\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _admin,\n        address _kresko\n    ) external initializer {\n        // ERC20\n        __ERC20Upgradeable_init(_name, _symbol, _decimals);\n\n        // This does nothing but doesn't hurt to make sure it's called\n        __AccessControlEnumerable_init();\n\n        // Setup the admin\n        _setupRole(Role.DEFAULT_ADMIN, msg.sender);\n        _setupRole(Role.ADMIN, msg.sender);\n\n        _setupRole(Role.DEFAULT_ADMIN, _admin);\n        _setupRole(Role.ADMIN, _admin);\n\n        // Setup the protocol\n        _setupRole(Role.OPERATOR, _kresko);\n        kresko = _kresko;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Read                                    */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControlEnumerableUpgradeable, IERC165) returns (bool) {\n        return (interfaceId != 0xffffffff &&\n            (interfaceId == type(IKreskoAsset).interfaceId ||\n                interfaceId == 0x01ffc9a7 ||\n                interfaceId == 0x36372b07 ||\n                super.supportsInterface(interfaceId)));\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function rebaseInfo() external view override returns (Rebase memory) {\n        return _rebaseInfo;\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function totalSupply() public view override(ERC20Upgradeable, IKreskoAsset) returns (uint256) {\n        return _totalSupply.rebase(_rebaseInfo);\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function balanceOf(address _account) public view override(ERC20Upgradeable, IKreskoAsset) returns (uint256) {\n        uint256 balance = _balances[_account];\n        return balance.rebase(_rebaseInfo);\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function allowance(\n        address _owner,\n        address _account\n    ) public view override(ERC20Upgradeable, IKreskoAsset) returns (uint256) {\n        return _allowances[_owner][_account];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    Write                                   */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IKreskoAsset\n    function reinitializeERC20(\n        string memory _name,\n        string memory _symbol,\n        uint8 _version\n    ) external onlyRole(Role.ADMIN) reinitializer(_version) {\n        __ERC20Upgradeable_init(_name, _symbol, decimals);\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function approve(address spender, uint256 amount) public override(ERC20Upgradeable, IKreskoAsset) returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function transfer(address _to, uint256 _amount) public override(ERC20Upgradeable, IKreskoAsset) returns (bool) {\n        return _transfer(msg.sender, _to, _amount);\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) public override(ERC20Upgradeable, IKreskoAsset) returns (bool) {\n        uint256 allowed = allowance(_from, msg.sender); // Saves gas for unlimited approvals.\n\n        if (allowed != type(uint256).max) {\n            require(_amount <= allowed, Error.NOT_ENOUGH_ALLOWANCE);\n            _allowances[_from][msg.sender] -= _amount;\n        }\n\n        return _transfer(_from, _to, _amount);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Restricted                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IKreskoAsset\n    function rebase(uint256 _denominator, bool _positive, address[] calldata _pools) external onlyRole(Role.ADMIN) {\n        require(_denominator >= 1 ether, Error.REBASING_DENOMINATOR_LOW);\n        if (_denominator == 1 ether) {\n            isRebased = false;\n            _rebaseInfo = Rebase(false, 0);\n        } else {\n            isRebased = true;\n            _rebaseInfo = Rebase(_positive, _denominator);\n        }\n        uint256 length = _pools.length;\n        for (uint256 i; i < length; ) {\n            IUniswapV2Pair(_pools[i]).sync();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function mint(address _to, uint256 _amount) external onlyRole(Role.OPERATOR) {\n        uint256 normalizedAmount = _amount.unrebase(_rebaseInfo);\n        _totalSupply += normalizedAmount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balances[_to] += normalizedAmount;\n        }\n        // Emit user input amount, not the maybe unrebased amount.\n        emit Transfer(address(0), _to, _amount);\n    }\n\n    /// @inheritdoc IKreskoAsset\n    function burn(address _from, uint256 _amount) external onlyRole(Role.OPERATOR) {\n        uint256 normalizedAmount = _amount.unrebase(_rebaseInfo);\n\n        _balances[_from] -= normalizedAmount;\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            _totalSupply -= normalizedAmount;\n        }\n\n        emit Transfer(_from, address(0), _amount);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Internal                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /// @dev Internal balances are always unrebased, events emitted are not.\n    function _transfer(address _from, address _to, uint256 _amount) internal returns (bool) {\n        require(_amount <= balanceOf(_from), Error.NOT_ENOUGH_BALANCE);\n        uint256 normalizedAmount = _amount.unrebase(_rebaseInfo);\n\n        _balances[_from] -= normalizedAmount;\n        unchecked {\n            _balances[_to] += normalizedAmount;\n        }\n\n        // Emit user input amount, not the maybe unrebased amount.\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n}\n"
    },
    "src/contracts/kreskoasset/KreskoAssetAnchor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {AccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\n\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\nimport {Role} from \"../libs/Authorization.sol\";\n\nimport {IKreskoAssetIssuer} from \"./IKreskoAssetIssuer.sol\";\nimport {IKreskoAssetAnchor} from \"./IKreskoAssetAnchor.sol\";\nimport {IERC4626Upgradeable} from \"./IERC4626Upgradeable.sol\";\nimport {ERC4626Upgradeable, IKreskoAsset} from \"./ERC4626Upgradeable.sol\";\nimport {IERC165} from \"../shared/IERC165.sol\";\n\n/* solhint-disable no-empty-blocks */\n\n/**\n * @title Kresko Asset Anchor\n * Pro-rata representation of the underlying kresko asset.\n * Based on ERC-4626 by Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n *\n * @notice Main purpose of this token is to represent a static amount of the possibly rebased underlying KreskoAsset.\n * Main use-cases are normalized book-keeping, bridging and integration with external contracts.\n *\n * @notice Shares means amount of this token.\n * @notice Assets mean amount of KreskoAssets.\n * @author Kresko\n */\ncontract KreskoAssetAnchor is ERC4626Upgradeable, IKreskoAssetAnchor, AccessControlEnumerableUpgradeable {\n    /* -------------------------------------------------------------------------- */\n    /*                                 Immutables                                 */\n    /* -------------------------------------------------------------------------- */\n    constructor(IKreskoAsset _asset) payable ERC4626Upgradeable(_asset) {}\n\n    /// @inheritdoc IKreskoAssetAnchor\n    function initialize(\n        IKreskoAsset _asset,\n        string memory _name,\n        string memory _symbol,\n        address _admin\n    ) external initializer {\n        // ERC4626\n        __ERC4626Upgradeable_init(_asset, _name, _symbol);\n\n        // This does nothing but doesn't hurt to make sure it's called\n        __AccessControlEnumerable_init();\n\n        // Default admin setup\n        _setupRole(Role.DEFAULT_ADMIN, _admin);\n        _setupRole(Role.ADMIN, _admin);\n\n        _setupRole(Role.DEFAULT_ADMIN, msg.sender);\n        _setupRole(Role.ADMIN, msg.sender);\n\n        // Setup the operator, which is the protocol linked to the main asset\n        _setupRole(Role.OPERATOR, asset.kresko());\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControlEnumerableUpgradeable, IERC165) returns (bool) {\n        return\n            interfaceId != 0xffffffff &&\n            (interfaceId == type(IKreskoAssetAnchor).interfaceId ||\n                interfaceId == type(IKreskoAssetIssuer).interfaceId ||\n                interfaceId == 0x01ffc9a7 ||\n                interfaceId == 0x36372b07 ||\n                super.supportsInterface(interfaceId));\n    }\n\n    /// @inheritdoc IKreskoAssetAnchor\n    function reinitializeERC20(\n        string memory _name,\n        string memory _symbol,\n        uint8 _version\n    ) external onlyRole(Role.ADMIN) reinitializer(_version) {\n        __ERC20Upgradeable_init(_name, _symbol, decimals);\n    }\n\n    /// @inheritdoc IKreskoAssetAnchor\n    function totalAssets() public view virtual override(IKreskoAssetAnchor, ERC4626Upgradeable) returns (uint256) {\n        return asset.totalSupply();\n    }\n\n    /// @inheritdoc IKreskoAssetIssuer\n    function convertToAssets(\n        uint256 shares\n    ) public view virtual override(ERC4626Upgradeable, IKreskoAssetIssuer) returns (uint256 assets) {\n        return super.convertToAssets(shares);\n    }\n\n    /// @inheritdoc IKreskoAssetIssuer\n    function convertToShares(\n        uint256 assets\n    ) public view virtual override(ERC4626Upgradeable, IKreskoAssetIssuer) returns (uint256 shares) {\n        return super.convertToShares(assets);\n    }\n\n    /// @inheritdoc IKreskoAssetIssuer\n    function issue(\n        uint256 _assets,\n        address _to\n    ) public virtual override(ERC4626Upgradeable, IKreskoAssetIssuer) onlyRole(Role.OPERATOR) returns (uint256 shares) {\n        shares = super.issue(_assets, _to);\n    }\n\n    /// @inheritdoc IKreskoAssetIssuer\n    function destroy(\n        uint256 _assets,\n        address _from\n    ) public virtual override(ERC4626Upgradeable, IKreskoAssetIssuer) onlyRole(Role.OPERATOR) returns (uint256 shares) {\n        shares = super.destroy(_assets, _from);\n    }\n\n    /// @notice reverting function, kept to maintain compatibility with ERC4626 standard\n    function deposit(uint256, address) public pure override(ERC4626Upgradeable, IERC4626Upgradeable) returns (uint256) {\n        revert(\"NOT_ALLOWED\");\n    }\n\n    /// @notice reverting function, kept to maintain compatibility with ERC4626 standard\n    function withdraw(\n        uint256,\n        address,\n        address\n    ) public pure override(ERC4626Upgradeable, IERC4626Upgradeable) returns (uint256) {\n        revert(\"NOT_ALLOWED\");\n    }\n\n    /// @notice reverting function, kept to maintain compatibility with ERC4626 standard\n    function mint(uint256, address) public pure override(ERC4626Upgradeable, IERC4626Upgradeable) returns (uint256) {\n        revert(\"NOT_ALLOWED\");\n    }\n\n    /// @notice reverting function, kept to maintain compatibility with ERC4626 standard\n    function redeem(\n        uint256,\n        address,\n        address\n    ) public pure override(ERC4626Upgradeable, IERC4626Upgradeable) returns (uint256) {\n        revert(\"NOT_ALLOWED\");\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                            INTERNAL HOOKS LOGIC                            */\n    /* -------------------------------------------------------------------------- */\n\n    function _beforeWithdraw(uint256 assets, uint256 shares) internal virtual override {\n        super._beforeWithdraw(assets, shares);\n    }\n\n    function _afterDeposit(uint256 assets, uint256 shares) internal virtual override {\n        super._afterDeposit(assets, shares);\n    }\n}\n"
    },
    "src/contracts/kreskoasset/Rebase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport {IKreskoAsset} from \"../kreskoasset/IKreskoAsset.sol\";\n\nlibrary RebaseMath {\n    using FixedPointMathLib for uint256;\n\n    /**\n     * @notice Unrebase a value by a given rebase struct.\n     * @param self The value to unrebase.\n     * @param _rebase The rebase struct.\n     * @return The unrebased value.\n     */\n    function unrebase(uint256 self, IKreskoAsset.Rebase memory _rebase) internal pure returns (uint256) {\n        if (_rebase.denominator == 0) return self;\n        return _rebase.positive ? self.divWadDown(_rebase.denominator) : self.mulWadDown(_rebase.denominator);\n    }\n\n    /**\n     * @notice Rebase a value by a given rebase struct.\n     * @param self The value to rebase.\n     * @param _rebase The rebase struct.\n     * @return The rebased value.\n     */\n    function rebase(uint256 self, IKreskoAsset.Rebase memory _rebase) internal pure returns (uint256) {\n        if (_rebase.denominator == 0) return self;\n        return _rebase.positive ? self.mulWadDown(_rebase.denominator) : self.divWadDown(_rebase.denominator);\n    }\n}\n"
    },
    "src/contracts/libs/Arrays.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.19;\n\nimport {Error} from \"./Errors.sol\";\n\n/**\n * @title Library for operations on arrays\n */\nlibrary Arrays {\n    /**\n     * @dev Removes an element by copying the last element to the element to remove's place and removing\n     * the last element.\n     * @param _addresses The address array containing the item to be removed.\n     * @param _elementToRemove The element to be removed.\n     * @param _elementIndex The index of the element to be removed.\n     */\n    function removeAddress(address[] storage _addresses, address _elementToRemove, uint256 _elementIndex) internal {\n        require(_addresses[_elementIndex] == _elementToRemove, Error.INCORRECT_INDEX);\n\n        uint256 lastIndex = _addresses.length - 1;\n        // If the index to remove is not the last one, overwrite the element at the index\n        // with the last element.\n        if (_elementIndex != lastIndex) {\n            _addresses[_elementIndex] = _addresses[lastIndex];\n        }\n        // Remove the last element.\n        _addresses.pop();\n    }\n}\n"
    },
    "src/contracts/libs/Authorization.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {IGnosisSafeL2} from \"../vendor/gnosis/IGnosisSafeL2.sol\";\nimport {Strings} from \"./Strings.sol\";\nimport {AuthEvent} from \"./Events.sol\";\nimport {EnumerableSet} from \"./EnumerableSet.sol\";\nimport {Error} from \"./Errors.sol\";\nimport {Meta} from \"./Meta.sol\";\nimport {ds} from \"../diamond/DiamondStorage.sol\";\n\n/* solhint-disable state-visibility */\n\n/**\n * @title Shared library for access control\n * @author Kresko\n */\n\n/* -------------------------------------------------------------------------- */\n/*                                    Roles                                   */\n/* -------------------------------------------------------------------------- */\n\nlibrary Role {\n    /// @dev role that grants other roles\n    bytes32 constant DEFAULT_ADMIN = 0x00;\n    /// @dev  keccak256(\"kresko.roles.minter.admin\")\n    bytes32 constant ADMIN = 0xb9dacdf02281f2e98ddbadaaf44db270b3d5a916342df47c59f77937a6bcd5d8;\n    /// @dev keccak256(\"kresko.roles.minter.operator\")\n    bytes32 constant OPERATOR = 0x112e48a576fb3a75acc75d9fcf6e0bc670b27b1dbcd2463502e10e68cf57d6fd;\n    /// @dev keccak256(\"kresko.roles.minter.manager\")\n    bytes32 constant MANAGER = 0x46925e0f0cc76e485772167edccb8dc449d43b23b55fc4e756b063f49099e6a0;\n    /// @dev keccak256(\"kresko.roles.minter.safety.council\")\n    bytes32 constant SAFETY_COUNCIL = 0x9c387ecf1663f9144595993e2c602b45de94bf8ba3a110cb30e3652d79b581c0;\n}\n\nlibrary Authorization {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    function hasRole(bytes32 role, address account) internal view returns (bool) {\n        return ds()._roles[role].members[account];\n    }\n\n    function getRoleMemberCount(bytes32 role) internal view returns (uint256) {\n        return ds()._roleMembers[role].length();\n    }\n\n    /**\n     * @dev Revert with a standard message if `Meta.msgSender` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function checkRole(bytes32 role) internal view {\n        _checkRole(role, Meta.msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) internal view returns (bytes32) {\n        return ds()._roles[role].adminRole;\n    }\n\n    function getRoleMember(bytes32 role, uint256 index) internal view returns (address) {\n        return ds()._roleMembers[role].at(index);\n    }\n\n    /**\n     * @notice setups the security council\n     *\n     */\n    function setupSecurityCouncil(address _councilAddress) internal {\n        require(getRoleMemberCount(Role.SAFETY_COUNCIL) == 0, Error.SAFETY_COUNCIL_EXISTS);\n        require(IGnosisSafeL2(_councilAddress).isOwner(msg.sender), Error.ADDRESS_INVALID_SAFETY_COUNCIL);\n\n        ds()._roles[Role.SAFETY_COUNCIL].members[_councilAddress] = true;\n        ds()._roleMembers[Role.SAFETY_COUNCIL].add(_councilAddress);\n\n        emit AuthEvent.RoleGranted(Role.SAFETY_COUNCIL, _councilAddress, Meta.msgSender());\n    }\n\n    function transferSecurityCouncil(address _newCouncil) internal {\n        checkRole(Role.SAFETY_COUNCIL);\n        require(IGnosisSafeL2(_newCouncil).getOwners().length >= 5, Error.MULTISIG_NOT_ENOUGH_OWNERS);\n\n        // As this is called by the multisig - just check that it's not an EOA\n        ds()._roles[Role.SAFETY_COUNCIL].members[msg.sender] = false;\n        ds()._roleMembers[Role.SAFETY_COUNCIL].remove(msg.sender);\n\n        ds()._roles[Role.SAFETY_COUNCIL].members[_newCouncil] = true;\n        ds()._roleMembers[Role.SAFETY_COUNCIL].add(_newCouncil);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) internal {\n        checkRole(getRoleAdmin(role));\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) internal {\n        checkRole(getRoleAdmin(role));\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function _renounceRole(bytes32 role, address account) internal {\n        require(account == Meta.msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        ds()._roles[role].adminRole = adminRole;\n        emit AuthEvent.RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * @notice Cannot grant the role `SAFETY_COUNCIL` - must be done via explicit function.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal ensureNotSafetyCouncil(role) {\n        if (!hasRole(role, account)) {\n            ds()._roles[role].members[account] = true;\n            ds()._roleMembers[role].add(account);\n            emit AuthEvent.RoleGranted(role, account, Meta.msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal {\n        if (hasRole(role, account)) {\n            ds()._roles[role].members[account] = false;\n            ds()._roleMembers[role].remove(account);\n            emit AuthEvent.RoleRevoked(role, account, Meta.msgSender());\n        }\n    }\n\n    /**\n     * @dev Ensure we use the explicit `grantSafetyCouncilRole` function.\n     */\n    modifier ensureNotSafetyCouncil(bytes32 role) {\n        require(role != Role.SAFETY_COUNCIL, Error.ADDRESS_INVALID_SAFETY_COUNCIL);\n        _;\n    }\n}\n"
    },
    "src/contracts/libs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity >=0.8.19;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "src/contracts/libs/Errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity <0.9.0;\n\n/* solhint-disable max-line-length */\n\n/**\n * @author Kresko\n * @title Error codes\n * @notice Kresko-specific revert return values and their explanation\n * @dev First number indicates the domain for the error\n */\nlibrary Error {\n    /* -------------------------------------------------------------------------- */\n    /*                                    Diamond                                 */\n    /* -------------------------------------------------------------------------- */\n\n    // Preserve readability for the diamond proxy\n    string public constant DIAMOND_INVALID_FUNCTION_SIGNATURE = \"krDiamond: function does not exist\";\n    string public constant DIAMOND_INVALID_PENDING_OWNER = \"krDiamond: Must be pending contract owner\";\n    string public constant DIAMOND_INVALID_OWNER = \"krDiamond: Must be diamond owner\";\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   1. General                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant NOT_OWNER = \"100\"; // The sender must be owner\n    string public constant NOT_OPERATOR = \"101\"; // The sender must be operator\n    string public constant ZERO_WITHDRAW = \"102\"; // Withdraw must be greater than 0\n    string public constant ZERO_DEPOSIT = \"103\"; // Deposit must be greater than 0\n    string public constant ZERO_ADDRESS = \"104\"; // Address provided cannot be address(0)\n    string public constant ALREADY_INITIALIZED = \"105\"; // Contract has already been initialized\n    string public constant RE_ENTRANCY = \"106\"; // Function does not allow re-entrant calls\n    string public constant NOT_ENOUGH_BALANCE = \"107\"; // Transfer of rebasing token exceeds value\n    string public constant NOT_ENOUGH_ALLOWANCE = \"108\"; // TransferFrom of rebasing token exceeds allowance\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   2. Minter                                 */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant NOT_LIQUIDATABLE = \"200\"; // Account has collateral deposits exceeding minCollateralValue\n    string public constant ZERO_MINT = \"201\"; // Mint amount must be greater than 0\n    string public constant ZERO_BURN = \"202\"; // Burn amount must be greater than 0\n    string public constant ADDRESS_INVALID_ORACLE = \"203\"; // Oracle address cant be set to address(0)\n    string public constant ADDRESS_INVALID_NRWT = \"204\"; // Underlying rebasing token address cant be set to address(0)\n    string public constant ADDRESS_INVALID_FEERECIPIENT = \"205\"; // Fee recipient address cant be set to address(0)\n    string public constant ADDRESS_INVALID_COLLATERAL = \"206\"; // Collateral address cant be set to address(0)\n    string public constant COLLATERAL_EXISTS = \"207\"; // Collateral has already been added into the protocol\n    string public constant COLLATERAL_INVALID_FACTOR = \"208\"; // cFactor must be greater than 1FP\n    string public constant COLLATERAL_WITHDRAW_OVERFLOW = \"209\"; // Withdraw amount cannot reduce accounts collateral value under minCollateralValue\n    string public constant KRASSET_INVALID_FACTOR = \"210\"; // kFactor must be greater than 1FP\n    string public constant KRASSET_BURN_AMOUNT_OVERFLOW = \"211\"; // Repaying more than account has debt\n    string public constant KRASSET_EXISTS = \"212\"; // KrAsset is already added\n    string public constant PARAM_CLOSE_FEE_TOO_HIGH = \"213\"; // \"Close fee exceeds MAX_CLOSE_FEE\"\n    string public constant PARAM_LIQUIDATION_INCENTIVE_LOW = \"214\"; // \"Liquidation incentive less than MIN_LIQUIDATION_INCENTIVE_MULTIPLIER\"\n    string public constant PARAM_LIQUIDATION_INCENTIVE_HIGH = \"215\"; // \"Liquidation incentive greater than MAX_LIQUIDATION_INCENTIVE_MULTIPLIER\"\n    string public constant PARAM_MIN_COLLATERAL_RATIO_LOW = \"216\"; // Minimum collateral ratio less than MIN_COLLATERALIZATION_RATIO\n    string public constant PARAM_MIN_DEBT_AMOUNT_HIGH = \"217\"; // Minimum debt param argument exceeds MAX_MIN_DEBT_VALUE\n    string public constant COLLATERAL_DOESNT_EXIST = \"218\"; // Collateral does not exist within the protocol\n    string public constant KRASSET_DOESNT_EXIST = \"219\"; // KrAsset does not exist within the protocol\n    string public constant KRASSET_NOT_MINTABLE = \"220\"; // KrAsset is not mintable\n    string public constant KRASSET_SYMBOL_EXISTS = \"221\"; // KrAsset with this symbol is already within the protocl\n    string public constant KRASSET_COLLATERAL_LOW = \"222\"; // Collateral deposits do not cover the amount being minted\n    string public constant KRASSET_MINT_AMOUNT_LOW = \"223\"; // Debt position must be greater than the minimum debt position value\n    string public constant KRASSET_MAX_SUPPLY_REACHED = \"224\"; // KrAsset being minted has reached its current supply limit\n    string public constant SELF_LIQUIDATION = \"225\"; // Account cannot liquidate itself\n    string public constant ZERO_REPAY = \"226\"; // Cannot liquidate zero value\n    string public constant STALE_PRICE = \"227\"; // Price for the asset is stale\n    string public constant LIQUIDATION_OVERFLOW = \"228\"; // Repaying more USD value than allowed\n    string public constant ADDRESS_INVALID_SAFETY_COUNCIL = \"229\"; // Account responsible for the safety council role must be a multisig\n    string public constant SAFETY_COUNCIL_EXISTS = \"230\"; // Only one council role can exist\n    string public constant NOT_SAFETY_COUNCIL = \"231\"; // Sender must have the role `Role.SAFETY_COUNCIL`\n    string public constant ACTION_PAUSED_FOR_ASSET = \"232\"; // This action is currently paused for this asset\n    string public constant INVALID_ASSET_SUPPLIED = \"233\"; // Asset supplied is not a collateral nor a krAsset\n    string public constant KRASSET_NOT_ANCHOR = \"234\"; // Address is not the anchor for the krAsset\n    string public constant INVALID_LT = \"235\"; // Liquidation threshold is greater than minimum collateralization ratio\n    string public constant COLLATERAL_INSUFFICIENT_AMOUNT = \"236\"; // Insufficient amount of collateral to complete the operation\n    string public constant MULTISIG_NOT_ENOUGH_OWNERS = \"237\"; // Multisig has invalid amount of owners\n    string public constant PARAM_OPEN_FEE_TOO_HIGH = \"238\"; // \"Close fee exceeds MAX_OPEN_FEE\"\n    string public constant INVALID_FEE_TYPE = \"239\"; // \"Invalid fee type\n    string public constant KRASSET_INVALID_ANCHOR = \"240\"; // krAsset anchor does not support the correct interfaceId\n    string public constant KRASSET_INVALID_CONTRACT = \"241\"; // krAsset does not support the correct interfaceId\n    string public constant KRASSET_MARKET_CLOSED = \"242\"; // KrAsset's market is currently closed\n    string public constant NO_KRASSETS_MINTED = \"243\"; // Account has no active KreskoAsset positions\n    string public constant NO_COLLATERAL_DEPOSITS = \"244\"; // Account has no active Collateral deposits\n    string public constant INVALID_ORACLE_DECIMALS = \"245\"; // Oracle decimals do not match extOracleDecimals\n    string public constant PARAM_LIQUIDATION_OVERFLOW_LOW = \"246\"; // Liquidation overflow is less than MIN_LIQUIDATION_OVERFLOW\n    string public constant INVALID_ORACLE_DEVIATION_PCT = \"247\"; // Oracle deviation percentage is greater than 100%\n    string public constant SEIZED_COLLATERAL_UNDERFLOW = \"248\"; // Amount of collateral seized is less than the amount calculated.\n    string public constant COLLATERAL_AMOUNT_TOO_LOW = \"249\"; // Amount of krAsset collateral being deposited is less than the minimum amount\n    string public constant PARAM_COLLATERAL_RATIO_LOW_THAN_LT = \"250\"; // Minimum collateral ratio less than LT\n    string public constant ZERO_DEBT = \"251\"; // debt must be greater than 0\n    string public constant ORACLE_PRICE_UNSTABLE = \"252\"; // debt must be greater than 0\n    string public constant NEGATIVE_ORACLE_PRICE = \"253\"; // Oracle price received is negative\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   3. Staking                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant REWARD_PER_BLOCK_MISSING = \"300\"; // Each reward token must have a reward per block value\n    string public constant REWARD_TOKENS_MISSING = \"301\"; // Pool must include an array of reward token addresses\n    string public constant POOL_EXISTS = \"302\"; // Pool with this deposit token already exists\n    string public constant POOL_DOESNT_EXIST = \"303\"; // Pool with this deposit token does not exist\n    string public constant ADDRESS_INVALID_REWARD_RECIPIENT = \"304\"; // Reward recipient cant be address(0)\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   4. Libraries                             */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant ARRAY_OUT_OF_BOUNDS = \"400\"; // Array out of bounds error\n    string public constant PRICEFEEDS_MUST_MATCH_STATUS_FEEDS = \"401\"; // Supplied price feeds must match status feeds in length\n    string public constant INCORRECT_INDEX = \"402\"; // Array index mismatch\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   5. KrAsset                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant REBASING_DENOMINATOR_LOW = \"500\"; // denominator of rebases must be >= 1\n    string public constant ISSUER_NOT_KRESKO = \"501\"; // issue must be done by kresko\n    string public constant REDEEMER_NOT_KRESKO = \"502\"; // redeem must be done by kresko\n    string public constant DESTROY_OVERFLOW = \"503\"; // trying to destroy more than allowed\n    string public constant ISSUE_OVERFLOW = \"504\"; // trying to destroy more than allowed\n    string public constant MINT_OVERFLOW = \"505\"; // trying to destroy more than allowed\n    string public constant DEPOSIT_OVERFLOW = \"506\"; // trying to destroy more than allowed\n    string public constant REDEEM_OVERFLOW = \"507\"; // trying to destroy more than allowed\n    string public constant WITHDRAW_OVERFLOW = \"508\"; // trying to destroy more than allowed\n    string public constant ZERO_SHARES = \"509\"; // amount of shares must be greater than 0\n    string public constant ZERO_ASSETS = \"510\"; // amount of assets must be greater than 0\n    string public constant INVALID_SCALED_AMOUNT = \"511\"; // amount of debt scaled must be greater than 0\n\n    /* -------------------------------------------------------------------------- */\n    /*                              6. STABILITY RATES                            */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant STABILITY_RATES_ALREADY_INITIALIZED = \"601\"; // stability rates for the asset are already initialized\n    string public constant INVALID_OPTIMAL_RATE = \"602\"; // the optimal price rate configured is less than 1e27 for the asset\n    string public constant INVALID_PRICE_RATE_DELTA = \"603\"; // the price rate delta configured is less than 1e27 for the asset\n    string public constant STABILITY_RATES_NOT_INITIALIZED = \"604\"; // the stability rates for the asset are not initialized\n    string public constant STABILITY_RATE_OVERFLOW = \"605\"; // the stability rates is > max uint128\n    string public constant DEBT_INDEX_OVERFLOW = \"606\"; // the debt index is > max uint128\n    string public constant KISS_NOT_SET = \"607\"; // the debt index is > max uint128\n    string public constant STABILITY_RATE_REPAYMENT_AMOUNT_ZERO = \"608\"; // interest being repaid cannot be 0\n    string public constant STABILITY_RATE_INTEREST_IS_ZERO = \"609\"; // account must have accrued interest to repay it\n    string public constant INTEREST_REPAY_NOT_PARTIAL = \"610\"; // account must have accrued interest to repay it\n    string public constant INVALID_STABILITY_RATE_BASE = \"610\"; // the stability base rate is less than 1e27 for the asset\n\n    /* -------------------------------------------------------------------------- */\n    /*                              7. AMM ORACLE                                 */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant PAIR_ADDRESS_IS_ZERO = \"701\"; // Pair address to configure cannot be zero\n    string public constant INVALID_UPDATE_PERIOD = \"702\"; // Update period must be greater than the minimum\n    string public constant PAIR_ALREADY_EXISTS = \"703\"; // Pair with the address is already initialized\n    string public constant PAIR_DOES_NOT_EXIST = \"704\"; // Pair supplied does not exist\n    string public constant INVALID_LIQUIDITY = \"706\"; // Pair initializaition requires that the pair has liquidity\n    string public constant UPDATE_PERIOD_NOT_FINISHED = \"707\"; // Update can only be called once per update period\n    string public constant INVALID_PAIR = \"708\"; // Pair being consulted does not have the token that the price was requested for\n    string public constant CALLER_NOT_ADMIN = \"709\"; // Caller must be the admin\n    string public constant CONSTRUCTOR_INVALID_ADMIN = \"710\"; // Admin cannot be zero address in the constructor\n    string public constant CONSTRUCTOR_INVALID_FACTORY = \"711\"; // Factory cannot be the zero address\n    string public constant NO_INCENTIVES_LEFT = \"712\"; // No incentives left for updating the price\n    string public constant ADMIN_ADDRESS_IS_ZERO = \"713\"; // admin address to configure cannot be zero\n\n    /* -------------------------------------------------------------------------- */\n    /*                              8. KISS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    string public constant OPERATOR_WAIT_PERIOD_NOT_OVER = \"800\"; // Operator role has a cooldown period which has not passed\n    string public constant OPERATOR_LIMIT_REACHED = \"801\"; // More minters cannot be assigned before existing one is removed\n    string public constant CALLER_NOT_CONTRACT = \"802\"; // Caller of the function must be a contract\n    string public constant OPERATOR_NOT_CONTRACT = \"803\"; // Operator role can only be granted to a contract\n    string public constant KRESKO_NOT_CONTRACT = \"804\"; // Operator role can only be granted to a contract\n    string public constant ADMIN_NOT_A_CONTRACT = \"805\"; // Operator role can only be granted to a contract\n    string public constant OPERATOR_WAIT_PERIOD_TOO_SHORT = \"806\"; // Operator assignment cooldown period must be greater than 15 minutes\n}\n"
    },
    "src/contracts/libs/Events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IDiamondCutFacet} from \"../diamond/interfaces/IDiamondCutFacet.sol\";\nimport {Action} from \"../minter/MinterTypes.sol\";\n\n/* solhint-disable var-name-mixedcase */\n\n/**\n * @author Kresko\n * @title Events\n * @notice Event definitions\n */\n\nlibrary GeneralEvent {\n    /**\n     * @dev Triggered when the contract has been deployed\n     */\n    event Deployed(address indexed owner, uint8 version);\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(address indexed operator, uint8 version);\n}\n\nlibrary DiamondEvent {\n    event DiamondCut(IDiamondCutFacet.FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n\nlibrary MinterEvent {\n    /* -------------------------------------------------------------------------- */\n    /*                                 Collateral                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Emitted when a collateral asset is added to the protocol.\n     * @dev Can only be emitted once for a given collateral asset.\n     * @param collateralAsset The address of the collateral asset.\n     * @param factor The collateral factor.\n     * @param oracle The address of the oracle.\n     * @param liquidationIncentive The liquidation incentive\n     */\n    event CollateralAssetAdded(\n        address indexed collateralAsset,\n        uint256 factor,\n        address indexed oracle,\n        address anchor,\n        uint256 liquidationIncentive\n    );\n\n    /**\n     * @notice Emitted when a collateral asset is updated.\n     * @param collateralAsset The address of the collateral asset.\n     * @param factor The collateral factor.\n     * @param oracle The oracle address.\n     * @param liquidationIncentive The liquidation incentive\n     */\n    event CollateralAssetUpdated(\n        address indexed collateralAsset,\n        uint256 factor,\n        address indexed oracle,\n        address anchor,\n        uint256 liquidationIncentive\n    );\n\n    /**\n     * @notice Emitted when an account deposits collateral.\n     * @param account The address of the account depositing collateral.\n     * @param collateralAsset The address of the collateral asset.\n     * @param amount The amount of the collateral asset that was deposited.\n     */\n    event CollateralDeposited(address indexed account, address indexed collateralAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when an account withdraws collateral.\n     * @param account The address of the account withdrawing collateral.\n     * @param collateralAsset The address of the collateral asset.\n     * @param amount The amount of the collateral asset that was withdrawn.\n     */\n    event CollateralWithdrawn(address indexed account, address indexed collateralAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when AMM helper withdraws account collateral without MCR checks.\n     * @param account The address of the account withdrawing collateral.\n     * @param collateralAsset The address of the collateral asset.\n     * @param amount The amount of the collateral asset that was withdrawn.\n     */\n    event UncheckedCollateralWithdrawn(address indexed account, address indexed collateralAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when AMM oracle is set.\n     * @param ammOracle The address of the AMM oracle.\n     */\n    event AMMOracleUpdated(address indexed ammOracle);\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Kresko Assets                               */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Emitted when a KreskoAsset is added to the protocol.\n     * @dev Can only be emitted once for a given Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param anchor anchor token\n     * @param kFactor The k-factor.\n     * @param oracle The address of the oracle.\n     * @param supplyLimit The total supply limit.\n     * @param closeFee The close fee percentage.\n     * @param openFee The open fee percentage.\n     */\n    event KreskoAssetAdded(\n        address indexed kreskoAsset,\n        address anchor,\n        address indexed oracle,\n        uint256 kFactor,\n        uint256 supplyLimit,\n        uint256 closeFee,\n        uint256 openFee\n    );\n\n    /**\n     * @notice Emitted when a Kresko asset's oracle is updated.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param kFactor The k-factor.\n     * @param oracle The address of the oracle.\n     * @param supplyLimit The total supply limit.\n     * @param closeFee The close fee percentage.\n     * @param openFee The open fee percentage.\n     */\n    event KreskoAssetUpdated(\n        address indexed kreskoAsset,\n        address anchor,\n        address indexed oracle,\n        uint256 kFactor,\n        uint256 supplyLimit,\n        uint256 closeFee,\n        uint256 openFee\n    );\n\n    /**\n     * @notice Emitted when an account mints a Kresko asset.\n     * @param account The address of the account minting the Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param amount The amount of the KreskoAsset that was minted.\n     */\n    event KreskoAssetMinted(address indexed account, address indexed kreskoAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when an account burns a Kresko asset.\n     * @param account The address of the account burning the Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param amount The amount of the KreskoAsset that was burned.\n     */\n    event KreskoAssetBurned(address indexed account, address indexed kreskoAsset, uint256 amount);\n\n    /**\n     * @notice Emitted when an account burns a Kresko asset.\n     * @param account The address of the account burning the Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param amount The amount of the KreskoAsset that was burned.\n     * @param interestRepaid The amount of the KISS repaid due to interest accrual\n     */\n    event DebtPositionClosed(\n        address indexed account,\n        address indexed kreskoAsset,\n        uint256 amount,\n        uint256 interestRepaid\n    );\n\n    /**\n     * @notice Emitted when cFactor is updated for a collateral asset.\n     * @param collateralAsset The address of the collateral asset.\n     * @param cFactor The new cFactor\n     */\n    event CFactorUpdated(address indexed collateralAsset, uint256 cFactor);\n    /**\n     * @notice Emitted when kFactor is updated for a KreskoAsset.\n     * @param kreskoAsset The address of the KreskoAsset.\n     * @param kFactor The new kFactor\n     */\n    event KFactorUpdated(address indexed kreskoAsset, uint256 kFactor);\n\n    /**\n     * @notice Emitted when an account pays a close fee with a collateral asset upon burning a KreskoAsset.\n     * @dev This can be emitted multiple times for a single KreskoAsset burn.\n     * @param account The address of the account burning the KreskoAsset.\n     * @param paymentCollateralAsset The address of the collateral asset used to pay the close fee.\n     * @param paymentAmount The amount of the payment collateral asset that was paid.\n     * @param paymentValue The USD value of the payment.\n     */\n    event CloseFeePaid(\n        address indexed account,\n        address indexed paymentCollateralAsset,\n        uint256 paymentAmount,\n        uint256 paymentValue\n    );\n\n    /**\n     * @notice Emitted when an account pays an open fee with a collateral asset upon minting a KreskoAsset.\n     * @dev This can be emitted multiple times for a single KreskoAsset mint.\n     * @param account The address of the account minting the KreskoAsset.\n     * @param paymentCollateralAsset The address of the collateral asset used to pay the open fee.\n     * @param paymentAmount The amount of the payment collateral asset that was paid.\n     * @param paymentValue The USD value of the payment.\n     */\n    event OpenFeePaid(\n        address indexed account,\n        address indexed paymentCollateralAsset,\n        uint256 paymentAmount,\n        uint256 paymentValue\n    );\n\n    /**\n     * @notice Emitted when a liquidation occurs.\n     * @param account The address of the account being liquidated.\n     * @param liquidator The account performing the liquidation.\n     * @param repayKreskoAsset The address of the KreskoAsset being paid back to the protocol by the liquidator.\n     * @param repayAmount The amount of the repay KreskoAsset being paid back to the protocol by the liquidator.\n     * @param seizedCollateralAsset The address of the collateral asset being seized from the account by the liquidator.\n     * @param collateralSent The amount of the seized collateral asset being seized from the account by the liquidator.\n     */\n    event LiquidationOccurred(\n        address indexed account,\n        address indexed liquidator,\n        address indexed repayKreskoAsset,\n        uint256 repayAmount,\n        address seizedCollateralAsset,\n        uint256 collateralSent\n    );\n\n    /**\n     * @notice Emitted when a liquidation of interest occurs.\n     * @param account The address of the account being liquidated.\n     * @param liquidator The account performing the liquidation.\n     * @param repayKreskoAsset The address of the KreskoAsset being paid back to the protocol by the liquidator.\n     * @param repayUSD The value of the repay KreskoAsset being paid back to the protocol by the liquidator.\n     * @param seizedCollateralAsset The address of the collateral asset being seized from the account by the liquidator.\n     * @param collateralSent The amount of the seized collateral asset being seized from the account by the liquidator.\n     */\n    event InterestLiquidationOccurred(\n        address indexed account,\n        address indexed liquidator,\n        address indexed repayKreskoAsset,\n        uint256 repayUSD,\n        address seizedCollateralAsset,\n        uint256 collateralSent\n    );\n    /**\n     * @notice Emitted when a batch liquidation of interest occurs.\n     * @param account The address of the account being liquidated.\n     * @param liquidator The account performing the liquidation.\n     * @param seizedCollateralAsset The address of the collateral asset being seized from the account by the liquidator.\n     * @param repayUSD The value of the repay KreskoAsset being paid back to the protocol by the liquidator.\n     * @param collateralSent The amount of the seized collateral asset being seized from the account by the liquidator.\n     */\n    event BatchInterestLiquidationOccurred(\n        address indexed account,\n        address indexed liquidator,\n        address indexed seizedCollateralAsset,\n        uint256 repayUSD,\n        uint256 collateralSent\n    );\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Parameters                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Emitted when a safety state is triggered for an asset\n     * @param action Target action\n     * @param asset Asset affected\n     * @param description change description\n     */\n    event SafetyStateChange(Action indexed action, address indexed asset, string indexed description);\n\n    /**\n     * @notice Emitted when the fee recipient is updated.\n     * @param feeRecipient The new fee recipient.\n     */\n    event FeeRecipientUpdated(address indexed feeRecipient);\n\n    /**\n     * @notice Emitted when the liquidation incentive multiplier is updated.\n     * @param asset The collateral asset being updated.\n     * @param liquidationIncentiveMultiplier The new liquidation incentive multiplier raw value.\n     */\n    event LiquidationIncentiveMultiplierUpdated(address indexed asset, uint256 liquidationIncentiveMultiplier);\n\n    /**\n     * @notice Emitted when the liquidation overflow multiplier is updated.\n     * @param maxLiquidationMultiplier The new liquidation overflow multiplier value.\n     */\n    event maxLiquidationMultiplierUpdated(uint256 maxLiquidationMultiplier);\n\n    /**\n     * @notice Emitted when the minimum collateralization ratio is updated.\n     * @param minimumCollateralizationRatio The new minimum collateralization ratio raw value.\n     */\n    event MinimumCollateralizationRatioUpdated(uint256 minimumCollateralizationRatio);\n\n    /**\n     * @notice Emitted when the minimum debt value updated.\n     * @param minimumDebtValue The new minimum debt value.\n     */\n    event MinimumDebtValueUpdated(uint256 minimumDebtValue);\n\n    /**\n     * @notice Emitted when the liquidation threshold value is updated\n     * @param liquidationThreshold The new liquidation threshold value.\n     */\n    event LiquidationThresholdUpdated(uint256 liquidationThreshold);\n}\n\nlibrary StakingEvent {\n    event LiquidityAndStakeAdded(address indexed to, uint256 indexed amount, uint256 indexed pid);\n    event LiquidityAndStakeRemoved(address indexed to, uint256 indexed amount, uint256 indexed pid);\n    event Deposit(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event ClaimRewards(address indexed user, address indexed rewardToken, uint256 indexed amount);\n    event ClaimRewardsMulti(address indexed to);\n}\n\nlibrary AuthEvent {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event PendingOwnershipTransfer(address indexed previousOwner, address indexed newOwner);\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n}\n\nlibrary InterestRateEvent {\n    /**\n     * @dev Emitted when @param account repaid their @param asset interest @param value\n     */\n    event StabilityRateConfigured(\n        address indexed asset,\n        uint256 stabilityRateBase,\n        uint256 priceRateDelta,\n        uint256 rateSlope1,\n        uint256 rateSlope2\n    );\n    /**\n     * @dev Emitted when @param account repaid their @param asset interest @param value\n     */\n    event StabilityRateInterestRepaid(address indexed account, address indexed asset, uint256 value);\n    /**\n     * @dev Emitted when @param account repaid all interest @param value\n     */\n    event StabilityRateInterestBatchRepaid(address indexed account, uint256 value);\n\n    /**\n     * @notice Emitted when KISS address is set.\n     * @param KISS The address of KISS.\n     */\n    event KISSUpdated(address indexed KISS);\n}\n"
    },
    "src/contracts/libs/Meta.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable no-inline-assembly */\n\npragma solidity >=0.8.19;\n\nlibrary Meta {\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(bytes(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"));\n\n    function domainSeparator(\n        string memory name,\n        string memory version\n    ) internal view returns (bytes32 domainSeparator_) {\n        domainSeparator_ = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                getChainID(),\n                address(this)\n            )\n        );\n    }\n\n    function getChainID() internal view returns (uint256 id) {\n        assembly {\n            id := chainid()\n        }\n    }\n\n    function msgSender() internal view returns (address sender_) {\n        if (msg.sender == address(this)) {\n            bytes memory array = msg.data;\n            uint256 index = msg.data.length;\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n                sender_ := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n            }\n        } else {\n            sender_ = msg.sender;\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        /// @solidity memory-safe-assembly\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "src/contracts/libs/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity >=0.8.19;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "src/contracts/libs/WadRay.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.10;\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @notice Provides functions to perform calculations with Wad and Ray units\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\n * with 27 digits of precision)\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n **/\nlibrary WadRay {\n    // HALF_WAD and HALF_RAY expressed with extended notation\n    // as constant with operations are not supported in Yul assembly\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant HALF_WAD = 0.5e18;\n\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant HALF_RAY = 0.5e27;\n\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n    /**\n     * @dev Multiplies two wad, rounding half up to the nearest wad\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @param b Wad\n     * @return c = a*b, in wad\n     **/\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\n        assembly {\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, b), HALF_WAD), WAD)\n        }\n    }\n\n    /**\n     * @dev Divides two wad, rounding half up to the nearest wad\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @param b Wad\n     * @return c = a/b, in wad\n     **/\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\n        assembly {\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, WAD), div(b, 2)), b)\n        }\n    }\n\n    /**\n     * @notice Multiplies two ray, rounding half up to the nearest ray\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @param b Ray\n     * @return c = a raymul b\n     **/\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\n        assembly {\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, b), HALF_RAY), RAY)\n        }\n    }\n\n    /**\n     * @notice Divides two ray, rounding half up to the nearest ray\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @param b Ray\n     * @return c = a raydiv b\n     **/\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\n        assembly {\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, RAY), div(b, 2)), b)\n        }\n    }\n\n    /**\n     * @dev Casts ray down to wad\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @return b = a converted to wad, rounded half up to the nearest wad\n     **/\n    function rayToWad(uint256 a) internal pure returns (uint256 b) {\n        assembly {\n            b := div(a, WAD_RAY_RATIO)\n            let remainder := mod(a, WAD_RAY_RATIO)\n            if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\n                b := add(b, 1)\n            }\n        }\n    }\n\n    /**\n     * @dev Converts wad up to ray\n     * @dev assembly optimized for improved gas savings: https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @return b = a converted in ray\n     **/\n    function wadToRay(uint256 a) internal pure returns (uint256 b) {\n        // to avoid overflow, b/WAD_RAY_RATIO == a\n        assembly {\n            b := mul(a, WAD_RAY_RATIO)\n\n            if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/minter/amm-oracle/IUniswapV2OracleCompat.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\nimport {IERC20Minimal} from \"../../vendor/uniswap/v2-core/interfaces/IERC20Minimal.sol\";\nimport {IUniswapV2Factory} from \"../../vendor/uniswap/v2-periphery/libraries/UniswapV2Library.sol\";\n\n/// @notice without UQ values\ninterface IUniswapV2OracleCompat {\n    event NewAdmin(address indexed newAdmin);\n    event NewMinUpdatePeriod(uint256 newMinUpdatePeriod);\n    event NewPair(address indexed pair, address indexed token0, address indexed token1, uint256 updatePeriod);\n    event PairUpdated(address indexed pair, address indexed token0, address indexed token1, uint256 updatePeriod);\n\n    event NewKrAssetPair(address indexed krAsset, address indexed pairAddress);\n\n    /// @notice returns the connected univ2 factory\n    function factory() external view returns (IUniswapV2Factory);\n\n    /// @notice returns the incentive token for the incentivized update\n    function incentiveToken() external view returns (IERC20Minimal);\n\n    /// @notice returns the amount of incentive tokens sent using the incentivized update\n    function incentiveAmount() external view returns (uint256);\n\n    /// @notice returns the current admin of the oracle\n    function admin() external view returns (address);\n\n    /// @notice returns the TWAP time period in seconds\n    function minUpdatePeriod() external view returns (uint256);\n\n    /// @notice returns the pair address for a given krAsset\n    function krAssets(address) external returns (address);\n\n    /**\n     *\n     * @param _newIncentiveToken new incentive token for updater\n     * @param amount amount of incentive tokens\n     */\n    function setIncentiveToken(address _newIncentiveToken, uint256 amount) external;\n\n    /**\n     * @notice Configures existing values of an AMM pair\n     * @param _pairAddress Pair address\n     * @param _updatePeriod Update period (TWAP)\n     */\n    function configurePair(address _pairAddress, uint256 _updatePeriod) external;\n\n    /**\n     * @notice Get the AMM price for an amount of krAsset\n     * @param _kreskoAsset Kresko asset address\n     * @param _amountIn Amount of Kresko Asset to get value for\n     */\n    function consultKrAsset(address _kreskoAsset, uint256 _amountIn) external view returns (uint256 amountOut);\n\n    /**\n     * @notice General consult function, gets a value for `_amountIn` of `_token` in terms of `_tokenOut`\n     * @param _pairAddress Address of the pair that contains the token\n     * @param _token Address of the token to get value for\n     * @param _amountIn Amount of token to get value for\n     * @return amountOut Amount of tokenOut that `_amountIn` of `_token` is worth\n     */\n    function consult(address _pairAddress, address _token, uint256 _amountIn) external view returns (uint256 amountOut);\n\n    /**\n     * @notice Initializes an Uniswap V2 pair to be tracked by this oracle.\n     *\n     * The criteria for a pair to be tracked:\n     * The pair must not already be tracked by this oracle.\n     * The pair must exist.\n     * The pair must have reserves.\n     * The update period must be greater than the minimum update period.\n     * @param _pairAddress Liquidity token address for the pair\n     * @param _krAsset Kresko Asset in the pair we want to add helper functionality for\n     * @param _updatePeriod The update period (TWAP) for this AMM pair\n     *\n     */\n    function initPair(address _pairAddress, address _krAsset, uint256 _updatePeriod) external;\n\n    /**\n     * @notice Updates the oracle values for a pair\n     * @param _pairAddress Pair address\n     */\n    function update(address _pairAddress) external;\n\n    /**\n     * @notice Sets a new admin\n     * @param _newAdmin New admin address\n     */\n    function setAdmin(address _newAdmin) external;\n\n    /**\n     * @notice Set a new min update period\n     * @param _minUpdatePeriod The new minimum period that can be set for a pair\n     */\n    function setMinUpdatePeriod(uint256 _minUpdatePeriod) external;\n\n    /**\n     * @notice Move any missent tokens\n     * @param _erc20 drain any sent tokens\n     * @param _to drain any sent tokens\n     */\n    function drainERC20(address _erc20, address _to) external;\n\n    /**\n     * Update pair data with incentives sent\n     * @param _kreskoAsset Kresko Asset in the pair we want to update pair data for\n     */\n    function updateWithIncentive(address _kreskoAsset) external;\n}\n"
    },
    "src/contracts/minter/facets/AccountStateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IAccountStateFacet} from \"../interfaces/IAccountStateFacet.sol\";\nimport {Fee, KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/**\n * @author Kresko\n * @title AccountStateFacet\n * @notice Views concerning account state\n */\ncontract AccountStateFacet is IAccountStateFacet {\n    using LibDecimals for uint256;\n    using LibDecimals for uint8;\n    using WadRay for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  KrAssets                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IAccountStateFacet\n    function getMintedKreskoAssetsIndex(address _account, address _kreskoAsset) external view returns (uint256) {\n        return ms().getMintedKreskoAssetsIndex(_account, _kreskoAsset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getMintedKreskoAssets(address _account) external view returns (address[] memory) {\n        return ms().mintedKreskoAssets[_account];\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getAccountKrAssetValue(address _account) external view returns (uint256) {\n        return ms().getAccountKrAssetValue(_account);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function kreskoAssetDebt(address _account, address _asset) external view returns (uint256) {\n        return ms().getKreskoAssetDebtScaled(_account, _asset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function kreskoAssetDebtPrincipal(address _account, address _asset) external view returns (uint256) {\n        return ms().getKreskoAssetDebtPrincipal(_account, _asset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function kreskoAssetDebtInterest(\n        address _account,\n        address _asset\n    ) external view returns (uint256 assetAmount, uint256 kissAmount) {\n        return ms().getKreskoAssetDebtInterest(_account, _asset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function kreskoAssetDebtInterestTotal(address _account) external view returns (uint256 kissAmount) {\n        address[] memory mintedKreskoAssets = ms().mintedKreskoAssets[_account];\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            (, uint256 kissAmountForAsset) = ms().getKreskoAssetDebtInterest(_account, mintedKreskoAssets[i]);\n            kissAmount += kissAmountForAsset;\n        }\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Collateral                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IAccountStateFacet\n    function getDepositedCollateralAssets(address _account) external view returns (address[] memory) {\n        return ms().depositedCollateralAssets[_account];\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function collateralDeposits(address _account, address _asset) external view returns (uint256) {\n        return ms().getCollateralDeposits(_account, _asset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getDepositedCollateralAssetIndex(\n        address _account,\n        address _collateralAsset\n    ) external view returns (uint256 i) {\n        return ms().getDepositedCollateralAssetIndex(_account, _collateralAsset);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getAccountCollateralValue(address _account) public view returns (uint256) {\n        return ms().getAccountCollateralValue(_account);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getAccountMinimumCollateralValueAtRatio(address _account, uint256 _ratio) public view returns (uint256) {\n        return ms().getAccountMinimumCollateralValueAtRatio(_account, _ratio);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getAccountCollateralRatio(address _account) public view returns (uint256 ratio) {\n        uint256 collateralValue = ms().getAccountCollateralValue(_account);\n        if (collateralValue == 0) {\n            return 0;\n        }\n        uint256 krAssetValue = ms().getAccountKrAssetValue(_account);\n        if (krAssetValue == 0) {\n            return 0;\n        }\n        ratio = collateralValue.wadDiv(krAssetValue);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getCollateralAdjustedAndRealValue(\n        address _account,\n        address _asset\n    ) external view returns (uint256 adjustedValue, uint256 realValue) {\n        uint256 depositAmount = ms().getCollateralDeposits(_account, _asset);\n        return ms().getCollateralValueAndOraclePrice(_asset, depositAmount, false);\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function getCollateralRatiosFor(address[] calldata _accounts) external view returns (uint256[] memory) {\n        uint256[] memory ratios = new uint256[](_accounts.length);\n        for (uint256 i; i < _accounts.length; i++) {\n            ratios[i] = getAccountCollateralRatio(_accounts[i]);\n        }\n        return ratios;\n    }\n\n    /// @inheritdoc IAccountStateFacet\n    function calcExpectedFee(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kreskoAssetAmount,\n        uint256 _feeType\n    ) external view returns (address[] memory, uint256[] memory) {\n        require(_feeType <= 1, Error.INVALID_FEE_TYPE);\n\n        KrAsset memory krAsset = ms().kreskoAssets[_kreskoAsset];\n\n        // Calculate the value of the fee according to the value of the krAsset\n        uint256 feeValue = krAsset.uintUSD(_kreskoAssetAmount, ms().oracleDeviationPct).wadMul(\n            Fee(_feeType) == Fee.Open ? krAsset.openFee : krAsset.closeFee\n        );\n\n        address[] memory accountCollateralAssets = ms().depositedCollateralAssets[_account];\n\n        ExpectedFeeRuntimeInfo memory info; // Using ExpectedFeeRuntimeInfo struct to avoid StackTooDeep error\n        info.assets = new address[](accountCollateralAssets.length);\n        info.amounts = new uint256[](accountCollateralAssets.length);\n\n        // Return empty arrays if the fee value is 0.\n        if (feeValue == 0) {\n            return (info.assets, info.amounts);\n        }\n\n        for (uint256 i = accountCollateralAssets.length - 1; i >= 0; i--) {\n            address collateralAssetAddress = accountCollateralAssets[i];\n\n            uint256 depositAmount = ms().getCollateralDeposits(_account, collateralAssetAddress);\n\n            // Don't take the collateral asset's collateral factor into consideration.\n            (uint256 depositValue, uint256 oraclePrice) = ms().getCollateralValueAndOraclePrice(\n                collateralAssetAddress,\n                depositAmount,\n                true\n            );\n\n            uint256 feeValuePaid;\n            uint256 transferAmount;\n            // If feeValue < depositValue, the entire fee can be charged for this collateral asset.\n            if (feeValue < depositValue) {\n                transferAmount = ms().collateralAssets[collateralAssetAddress].decimals.fromWad(\n                    feeValue.wadDiv(oraclePrice)\n                );\n                feeValuePaid = feeValue;\n            } else {\n                transferAmount = depositAmount;\n                feeValuePaid = depositValue;\n            }\n\n            if (transferAmount > 0) {\n                info.assets[info.collateralTypeCount] = collateralAssetAddress;\n                info.amounts[info.collateralTypeCount] = transferAmount;\n                info.collateralTypeCount = info.collateralTypeCount++;\n            }\n\n            feeValue = feeValue - feeValuePaid;\n            // If the entire fee has been paid, no more action needed.\n            if (feeValue == 0) {\n                return (info.assets, info.amounts);\n            }\n        }\n        return (info.assets, info.amounts);\n    }\n}\n"
    },
    "src/contracts/minter/facets/BurnFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IBurnFacet} from \"../interfaces/IBurnFacet.sol\";\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {MinterModifiers} from \"../MinterModifiers.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\nimport {Action} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title BurnFacet\n * @notice Main end-user functionality concerning burning of kresko assets\n */\ncontract BurnFacet is DiamondModifiers, MinterModifiers, IBurnFacet {\n    using Arrays for address[];\n\n    /// @inheritdoc IBurnFacet\n    function burnKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _burnAmount,\n        uint256 _mintedKreskoAssetIndex\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        require(_burnAmount > 0, Error.ZERO_BURN);\n        MinterState storage s = ms();\n\n        if (s.safetyStateSet) {\n            ensureNotPaused(_kreskoAsset, Action.Repay);\n        }\n\n        // Get accounts principal debt\n        uint256 debtAmount = s.getKreskoAssetDebtPrincipal(_account, _kreskoAsset);\n        require(debtAmount != 0, Error.ZERO_DEBT);\n\n        if (_burnAmount != type(uint256).max) {\n            require(_burnAmount <= debtAmount, Error.KRASSET_BURN_AMOUNT_OVERFLOW);\n            // Ensure principal left is either 0 or >= minDebtValue\n            _burnAmount = s.ensureNotDustPosition(_kreskoAsset, _burnAmount, debtAmount);\n        } else {\n            // _burnAmount of uint256 max, burn all principal debt\n            _burnAmount = debtAmount;\n        }\n\n        // Charge the burn fee from collateral of _account\n        s.chargeCloseFee(_account, _kreskoAsset, _burnAmount);\n\n        // Record the burn\n        s.burn(_kreskoAsset, s.kreskoAssets[_kreskoAsset].anchor, _burnAmount, _account);\n\n        // If sender repays all scaled debt of asset with no stability rate, remove it from minted assets array.\n        // For assets with stability rate the removal is done when repaying interest\n        if (\n            irs().srAssets[_kreskoAsset].asset == address(0) && s.getKreskoAssetDebtScaled(_account, _kreskoAsset) == 0\n        ) {\n            s.mintedKreskoAssets[_account].removeAddress(_kreskoAsset, _mintedKreskoAssetIndex);\n        }\n\n        // Emit logs\n        emit MinterEvent.KreskoAssetBurned(_account, _kreskoAsset, _burnAmount);\n    }\n}\n"
    },
    "src/contracts/minter/facets/BurnHelperFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {IBurnHelperFacet} from \"../interfaces/IBurnHelperFacet.sol\";\nimport {MinterModifiers} from \"../MinterModifiers.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\nimport {Action} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title BurnHelperFacet\n * @notice Helper functions for reducing positions\n */\ncontract BurnHelperFacet is IBurnHelperFacet, DiamondModifiers, MinterModifiers {\n    using Arrays for address[];\n\n    /// @inheritdoc IBurnHelperFacet\n    function closeKrAssetDebtPosition(\n        address _account,\n        address _kreskoAsset\n    ) public nonReentrant kreskoAssetExists(_kreskoAsset) onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        MinterState storage s = ms();\n        if (s.safetyStateSet) {\n            super.ensureNotPaused(_kreskoAsset, Action.Repay);\n        }\n\n        // Get accounts principal debt\n        uint256 principalDebt = s.getKreskoAssetDebtPrincipal(_account, _kreskoAsset);\n        require(principalDebt != 0, Error.ZERO_BURN);\n\n        // Charge the burn fee from collateral of _account\n        s.chargeCloseFee(_account, _kreskoAsset, principalDebt);\n\n        // Record the burn\n        s.burn(_kreskoAsset, s.kreskoAssets[_kreskoAsset].anchor, principalDebt, _account);\n        uint256 kissRepayAmount = ms().repayFullStabilityRateInterest(_account, _kreskoAsset);\n\n        // If all all principal debt of asset with NO stability rate configured\n        // -> remove it from minted assets array.\n        // For assets with stability rate the revomal is done when repaying interest\n        if (irs().srAssets[_kreskoAsset].asset == address(0)) {\n            s.mintedKreskoAssets[_account].removeAddress(\n                _kreskoAsset,\n                ms().getMintedKreskoAssetsIndex(_account, _kreskoAsset)\n            );\n        }\n\n        emit MinterEvent.DebtPositionClosed(_account, _kreskoAsset, principalDebt, kissRepayAmount);\n    }\n\n    /// @inheritdoc IBurnHelperFacet\n    function batchCloseKrAssetDebtPositions(\n        address _account\n    ) external onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        address[] memory mintedKreskoAssets = ms().getMintedKreskoAssets(_account);\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            closeKrAssetDebtPosition(_account, mintedKreskoAssets[i]);\n        }\n    }\n}\n"
    },
    "src/contracts/minter/facets/ConfigurationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IERC165} from \"../../shared/IERC165.sol\";\nimport {IERC20Permit} from \"../../shared/IERC20Permit.sol\";\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\nimport {IKISS} from \"../../kiss/interfaces/IKISS.sol\";\n\nimport {IConfigurationFacet} from \"../interfaces/IConfigurationFacet.sol\";\n\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent, GeneralEvent} from \"../../libs/Events.sol\";\nimport {Authorization, Role} from \"../../libs/Authorization.sol\";\nimport {Meta} from \"../../libs/Meta.sol\";\n\nimport {MinterModifiers} from \"../MinterModifiers.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\n\nimport {ds} from \"../../diamond/DiamondStorage.sol\";\n\nimport {MinterInitArgs, CollateralAsset, KrAsset, IFluxPriceFeed, AggregatorV3Interface, Constants} from \"../MinterTypes.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/**\n * @author Kresko\n * @title ConfigurationFacet\n * @notice Functionality for `Role.ADMIN` level actions.\n * @notice Can be only initialized by the deployer/owner.\n */\ncontract ConfigurationFacet is DiamondModifiers, MinterModifiers, IConfigurationFacet {\n    /* -------------------------------------------------------------------------- */\n    /*                                 Initialize                                 */\n    /* -------------------------------------------------------------------------- */\n\n    function initialize(MinterInitArgs calldata args) external onlyOwner {\n        require(ms().initializations == 0, Error.ALREADY_INITIALIZED);\n        // Temporarily set ADMIN role for deployer\n        Authorization._grantRole(Role.DEFAULT_ADMIN, msg.sender);\n        Authorization._grantRole(Role.ADMIN, msg.sender);\n\n        // Grant the admin role to admin\n        Authorization._grantRole(Role.DEFAULT_ADMIN, args.admin);\n        Authorization._grantRole(Role.ADMIN, args.admin);\n\n        /**\n         * @notice Council can be set only by this specific function.\n         * Requirements:\n         *\n         * - address `_council` must implement ERC165 and a specific multisig interfaceId.\n         * - reverts if above is not true.\n         */\n        Authorization.setupSecurityCouncil(args.council);\n\n        updateFeeRecipient(args.treasury);\n        updateMinimumCollateralizationRatio(args.minimumCollateralizationRatio);\n        updateMinimumDebtValue(args.minimumDebtValue);\n        updateLiquidationThreshold(args.liquidationThreshold);\n        updateExtOracleDecimals(args.extOracleDecimals);\n        updateMaxLiquidationMultiplier(Constants.MIN_MAX_LIQUIDATION_MULTIPLIER);\n        updateOracleDeviationPct(args.oracleDeviationPct);\n        updateSequencerUptimeFeed(args.sequencerUptimeFeed);\n        updateSequencerGracePeriodTime(args.sequencerGracePeriodTime);\n        updateOracleTimeout(args.oracleTimeout);\n\n        ms().initializations = 1;\n        ms().domainSeparator = Meta.domainSeparator(\"Kresko Minter\", \"V1\");\n        emit GeneralEvent.Initialized(args.admin, 1);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateFeeRecipient(address _feeRecipient) public override onlyRole(Role.ADMIN) {\n        require(_feeRecipient != address(0), Error.ADDRESS_INVALID_FEERECIPIENT);\n        ms().feeRecipient = _feeRecipient;\n        emit MinterEvent.FeeRecipientUpdated(_feeRecipient);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateLiquidationIncentiveMultiplier(\n        address _collateralAsset,\n        uint256 _liquidationIncentiveMultiplier\n    ) public override collateralAssetExists(_collateralAsset) onlyRole(Role.ADMIN) {\n        require(\n            _liquidationIncentiveMultiplier >= Constants.MIN_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_LOW\n        );\n        require(\n            _liquidationIncentiveMultiplier <= Constants.MAX_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_HIGH\n        );\n        ms().collateralAssets[_collateralAsset].liquidationIncentive = _liquidationIncentiveMultiplier;\n        emit MinterEvent.LiquidationIncentiveMultiplierUpdated(_collateralAsset, _liquidationIncentiveMultiplier);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateCFactor(\n        address _collateralAsset,\n        uint256 _cFactor\n    ) public override collateralAssetExists(_collateralAsset) onlyRole(Role.ADMIN) {\n        require(_cFactor <= Constants.ONE_HUNDRED_PERCENT, Error.COLLATERAL_INVALID_FACTOR);\n        ms().collateralAssets[_collateralAsset].factor = _cFactor;\n        emit MinterEvent.CFactorUpdated(_collateralAsset, _cFactor);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateKFactor(\n        address _kreskoAsset,\n        uint256 _kFactor\n    ) public override kreskoAssetExists(_kreskoAsset) onlyRole(Role.ADMIN) {\n        require(_kFactor >= Constants.ONE_HUNDRED_PERCENT, Error.KRASSET_INVALID_FACTOR);\n        ms().kreskoAssets[_kreskoAsset].kFactor = _kFactor;\n        emit MinterEvent.CFactorUpdated(_kreskoAsset, _kFactor);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateMinimumCollateralizationRatio(\n        uint256 _minimumCollateralizationRatio\n    ) public override onlyRole(Role.ADMIN) {\n        require(\n            _minimumCollateralizationRatio >= Constants.MIN_COLLATERALIZATION_RATIO,\n            Error.PARAM_MIN_COLLATERAL_RATIO_LOW\n        );\n        require(_minimumCollateralizationRatio >= ms().liquidationThreshold, Error.PARAM_COLLATERAL_RATIO_LOW_THAN_LT);\n        ms().minimumCollateralizationRatio = _minimumCollateralizationRatio;\n        emit MinterEvent.MinimumCollateralizationRatioUpdated(_minimumCollateralizationRatio);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateMinimumDebtValue(uint256 _minimumDebtValue) public override onlyRole(Role.ADMIN) {\n        require(_minimumDebtValue <= Constants.MAX_MIN_DEBT_VALUE, Error.PARAM_MIN_DEBT_AMOUNT_HIGH);\n        ms().minimumDebtValue = _minimumDebtValue;\n        emit MinterEvent.MinimumDebtValueUpdated(_minimumDebtValue);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateLiquidationThreshold(uint256 _liquidationThreshold) public override onlyRole(Role.ADMIN) {\n        // Liquidation threshold cannot be greater than minimum collateralization ratio\n\n        require(_liquidationThreshold <= ms().minimumCollateralizationRatio, Error.INVALID_LT);\n\n        ms().liquidationThreshold = _liquidationThreshold;\n        emit MinterEvent.LiquidationThresholdUpdated(_liquidationThreshold);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateMaxLiquidationMultiplier(uint256 _maxLiquidationMultiplier) public override onlyRole(Role.ADMIN) {\n        require(\n            _maxLiquidationMultiplier >= Constants.MIN_MAX_LIQUIDATION_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_OVERFLOW_LOW\n        );\n        ms().maxLiquidationMultiplier = _maxLiquidationMultiplier;\n        emit MinterEvent.maxLiquidationMultiplierUpdated(_maxLiquidationMultiplier);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateAMMOracle(address _ammOracle) external onlyRole(Role.ADMIN) {\n        require(_ammOracle != address(0), Error.ADDRESS_INVALID_ORACLE);\n        ms().ammOracle = _ammOracle;\n        emit MinterEvent.AMMOracleUpdated(_ammOracle);\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateExtOracleDecimals(uint8 _decimals) public onlyRole(Role.ADMIN) {\n        ms().extOracleDecimals = _decimals;\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateOracleDeviationPct(uint256 _oracleDeviationPct) public onlyRole(Role.ADMIN) {\n        require(_oracleDeviationPct <= 1 ether, Error.INVALID_ORACLE_DEVIATION_PCT);\n        ms().oracleDeviationPct = _oracleDeviationPct;\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateSequencerUptimeFeed(address _sequencerUptimeFeed) public override onlyRole(Role.ADMIN) {\n        ms().sequencerUptimeFeed = _sequencerUptimeFeed;\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateSequencerGracePeriodTime(uint256 _sequencerGracePeriodTime) public override onlyRole(Role.ADMIN) {\n        ms().sequencerGracePeriodTime = _sequencerGracePeriodTime;\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateOracleTimeout(uint256 _oracleTimeout) public override onlyRole(Role.ADMIN) {\n        ms().oracleTimeout = _oracleTimeout;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 COLLATERAL                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IConfigurationFacet\n    function addCollateralAsset(\n        address _collateralAsset,\n        CollateralAsset memory _config\n    ) external nonReentrant onlyRole(Role.ADMIN) collateralAssetDoesNotExist(_collateralAsset) {\n        require(_collateralAsset != address(0), Error.ADDRESS_INVALID_COLLATERAL);\n        require(_config.oracle.decimals() == ms().extOracleDecimals, Error.INVALID_ORACLE_DECIMALS);\n        require(_config.factor <= Constants.ONE_HUNDRED_PERCENT, Error.COLLATERAL_INVALID_FACTOR);\n        require(\n            _config.liquidationIncentive >= Constants.MIN_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_LOW\n        );\n        require(\n            _config.liquidationIncentive <= Constants.MAX_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_HIGH\n        );\n        bool isKrAsset = ms().kreskoAssets[_collateralAsset].exists;\n        require(\n            !isKrAsset ||\n                (IERC165(_collateralAsset).supportsInterface(type(IKISS).interfaceId)) ||\n                IERC165(_config.anchor).supportsInterface(type(IKreskoAssetIssuer).interfaceId),\n            Error.KRASSET_INVALID_ANCHOR\n        );\n\n        /* ---------------------------------- Save ---------------------------------- */\n        ms().collateralAssets[_collateralAsset] = CollateralAsset({\n            factor: _config.factor,\n            oracle: _config.oracle,\n            liquidationIncentive: _config.liquidationIncentive,\n            anchor: _config.anchor,\n            exists: true,\n            decimals: IERC20Permit(_collateralAsset).decimals(),\n            redstoneId: _config.redstoneId\n        });\n\n        emit MinterEvent.CollateralAssetAdded(\n            _collateralAsset,\n            _config.factor,\n            address(_config.oracle),\n            _config.anchor,\n            _config.liquidationIncentive\n        );\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateCollateralAsset(\n        address _collateralAsset,\n        CollateralAsset memory _config\n    ) external onlyRole(Role.ADMIN) collateralAssetExists(_collateralAsset) {\n        // Setting the factor to 0 effectively sunsets a collateral asset, which is intentionally allowed.\n        require(_config.factor <= Constants.ONE_HUNDRED_PERCENT, Error.COLLATERAL_INVALID_FACTOR);\n        require(\n            _config.liquidationIncentive >= Constants.MIN_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_LOW\n        );\n        require(\n            _config.liquidationIncentive <= Constants.MAX_LIQUIDATION_INCENTIVE_MULTIPLIER,\n            Error.PARAM_LIQUIDATION_INCENTIVE_HIGH\n        );\n\n        CollateralAsset memory collateralAsset = ms().collateralAssets[_collateralAsset];\n\n        /* ------------------------------ Update anchor ----------------------------- */\n        if (_config.anchor != address(0)) {\n            bool krAsset = ms().kreskoAssets[_collateralAsset].exists;\n            require(\n                !krAsset ||\n                    (IERC165(_collateralAsset).supportsInterface(type(IKISS).interfaceId)) ||\n                    IERC165(_config.anchor).supportsInterface(type(IKreskoAssetIssuer).interfaceId),\n                Error.KRASSET_INVALID_ANCHOR\n            );\n            collateralAsset.anchor = _config.anchor;\n        }\n\n        /* ------------------------------- Price feed ------------------------------- */\n        if (address(_config.oracle) != address(0)) {\n            require(_config.oracle.decimals() == ms().extOracleDecimals, Error.INVALID_ORACLE_DECIMALS);\n            collateralAsset.oracle = _config.oracle;\n            require(collateralAsset.uintPrice() != 0, Error.ADDRESS_INVALID_ORACLE);\n        }\n\n        /* --------------------------------- cFactor -------------------------------- */\n        collateralAsset.factor = _config.factor;\n\n        /* ------------------------------ liqIncentive ------------------------------ */\n        collateralAsset.liquidationIncentive = _config.liquidationIncentive;\n\n        ms().collateralAssets[_collateralAsset] = collateralAsset;\n\n        emit MinterEvent.CollateralAssetUpdated(\n            _collateralAsset,\n            collateralAsset.factor,\n            address(collateralAsset.oracle),\n            collateralAsset.anchor,\n            collateralAsset.liquidationIncentive\n        );\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               Kresko Assets                                */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IConfigurationFacet\n    function addKreskoAsset(\n        address _krAsset,\n        KrAsset memory _config\n    ) external onlyRole(Role.ADMIN) kreskoAssetDoesNotExist(_krAsset) {\n        require(_config.kFactor >= Constants.ONE_HUNDRED_PERCENT, Error.KRASSET_INVALID_FACTOR);\n        require(_config.closeFee <= Constants.MAX_CLOSE_FEE, Error.PARAM_CLOSE_FEE_TOO_HIGH);\n        require(_config.openFee <= Constants.MAX_OPEN_FEE, Error.PARAM_OPEN_FEE_TOO_HIGH);\n        require(\n            IERC165(_krAsset).supportsInterface(type(IKISS).interfaceId) ||\n                IERC165(_krAsset).supportsInterface(type(IKreskoAsset).interfaceId),\n            Error.KRASSET_INVALID_CONTRACT\n        );\n        require(\n            IERC165(_config.anchor).supportsInterface(type(IKreskoAssetIssuer).interfaceId),\n            Error.KRASSET_INVALID_ANCHOR\n        );\n        // The diamond needs the operator role\n        require(IKreskoAsset(_krAsset).hasRole(Role.OPERATOR, address(this)), Error.NOT_OPERATOR);\n\n        // Oracle decimals must match the configuration.\n        require(_config.oracle.decimals() == ms().extOracleDecimals, Error.INVALID_ORACLE_DECIMALS);\n\n        /* ---------------------------------- Save ---------------------------------- */\n        ms().kreskoAssets[_krAsset] = KrAsset({\n            kFactor: _config.kFactor,\n            oracle: _config.oracle,\n            anchor: _config.anchor,\n            supplyLimit: _config.supplyLimit,\n            closeFee: _config.closeFee,\n            openFee: _config.openFee,\n            exists: true,\n            redstoneId: _config.redstoneId\n        });\n\n        emit MinterEvent.KreskoAssetAdded(\n            _krAsset,\n            _config.anchor,\n            address(_config.oracle),\n            _config.kFactor,\n            _config.supplyLimit,\n            _config.closeFee,\n            _config.openFee\n        );\n    }\n\n    /// @inheritdoc IConfigurationFacet\n    function updateKreskoAsset(\n        address _krAsset,\n        KrAsset memory _config\n    ) external onlyRole(Role.ADMIN) kreskoAssetExists(_krAsset) {\n        require(_config.kFactor >= Constants.ONE_HUNDRED_PERCENT, Error.KRASSET_INVALID_FACTOR);\n        require(_config.closeFee <= Constants.MAX_CLOSE_FEE, Error.PARAM_CLOSE_FEE_TOO_HIGH);\n        require(_config.openFee <= Constants.MAX_OPEN_FEE, Error.PARAM_OPEN_FEE_TOO_HIGH);\n        require(\n            IERC165(_krAsset).supportsInterface(type(IKISS).interfaceId) ||\n                IERC165(_krAsset).supportsInterface(type(IKreskoAsset).interfaceId),\n            Error.KRASSET_INVALID_CONTRACT\n        );\n\n        KrAsset memory krAsset = ms().kreskoAssets[_krAsset];\n\n        /* --------------------------------- Anchor --------------------------------- */\n        if (_config.anchor != address(0)) {\n            require(\n                IERC165(_config.anchor).supportsInterface(type(IKreskoAssetIssuer).interfaceId),\n                Error.KRASSET_INVALID_ANCHOR\n            );\n            krAsset.anchor = _config.anchor;\n        }\n\n        /* ------------------------------- Price feed ------------------------------- */\n        if (address(_config.oracle) != address(0)) {\n            require(_config.oracle.decimals() == ms().extOracleDecimals, Error.INVALID_ORACLE_DECIMALS);\n            krAsset.oracle = _config.oracle;\n            require(krAsset.uintPrice() != 0, Error.ADDRESS_INVALID_ORACLE);\n        }\n\n        /* -------------------------- Factors, Fees, Limits ------------------------- */\n        krAsset.kFactor = _config.kFactor;\n        krAsset.supplyLimit = _config.supplyLimit;\n        krAsset.closeFee = _config.closeFee;\n        krAsset.openFee = _config.openFee;\n\n        /* ---------------------------------- Save ---------------------------------- */\n        ms().kreskoAssets[_krAsset] = krAsset;\n\n        emit MinterEvent.KreskoAssetUpdated(\n            _krAsset,\n            krAsset.anchor,\n            address(krAsset.oracle),\n            krAsset.kFactor,\n            krAsset.supplyLimit,\n            krAsset.closeFee,\n            krAsset.openFee\n        );\n    }\n}\n"
    },
    "src/contracts/minter/facets/DepositWithdrawFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IDepositWithdrawFacet} from \"../interfaces/IDepositWithdrawFacet.sol\";\n\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\n\nimport {SafeERC20, IERC20Permit} from \"../../shared/SafeERC20.sol\";\nimport {MinterModifiers} from \"../MinterModifiers.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\nimport {Action, KrAsset} from \"../MinterTypes.sol\";\nimport {ms} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {ICollateralReceiver} from \"../interfaces/ICollateralReceiver.sol\";\n\n/**\n * @author Kresko\n * @title DepositWithdrawFacet\n * @notice Main end-user functionality concerning collateral asset deposits and withdrawals within the Kresko protocol\n */\ncontract DepositWithdrawFacet is DiamondModifiers, MinterModifiers, IDepositWithdrawFacet {\n    using SafeERC20 for IERC20Permit;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Collateral                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IDepositWithdrawFacet\n    function depositCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _depositAmount\n    ) external nonReentrant collateralAssetExists(_collateralAsset) {\n        if (ms().safetyStateSet) {\n            super.ensureNotPaused(_collateralAsset, Action.Deposit);\n        }\n\n        // Transfer tokens into this contract prior to any state changes as an extra measure against re-entrancy.\n        IERC20Permit(_collateralAsset).safeTransferFrom(msg.sender, address(this), _depositAmount);\n\n        // Record the collateral deposit.\n        ms().recordCollateralDeposit(_account, _collateralAsset, _depositAmount);\n    }\n\n    /// @inheritdoc IDepositWithdrawFacet\n    function withdrawCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _depositedCollateralAssetIndex\n    ) external nonReentrant collateralAssetExists(_collateralAsset) onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        if (ms().safetyStateSet) {\n            ensureNotPaused(_collateralAsset, Action.Withdraw);\n        }\n\n        uint256 collateralDeposits = ms().getCollateralDeposits(_account, _collateralAsset);\n        _withdrawAmount = (_withdrawAmount > collateralDeposits ? collateralDeposits : _withdrawAmount);\n\n        ms().verifyAndRecordCollateralWithdrawal(\n            _account,\n            _collateralAsset,\n            _withdrawAmount,\n            collateralDeposits,\n            _depositedCollateralAssetIndex\n        );\n\n        IERC20Permit(_collateralAsset).safeTransfer(_account, _withdrawAmount);\n    }\n\n    /// @inheritdoc IDepositWithdrawFacet\n    function withdrawCollateralUnchecked(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _depositedCollateralAssetIndex,\n        bytes memory _userData\n    ) external collateralAssetExists(_collateralAsset) onlyRole(Role.MANAGER) {\n        if (ms().safetyStateSet) {\n            ensureNotPaused(_collateralAsset, Action.Withdraw);\n        }\n\n        uint256 collateralDeposits = ms().getCollateralDeposits(_account, _collateralAsset);\n        _withdrawAmount = (_withdrawAmount > collateralDeposits ? collateralDeposits : _withdrawAmount);\n\n        // perform unchecked withdrawal\n        ms().recordCollateralWithdrawal(\n            _account,\n            _collateralAsset,\n            _withdrawAmount,\n            collateralDeposits,\n            _depositedCollateralAssetIndex\n        );\n\n        // transfer the withdrawn asset to the caller\n        IERC20Permit(_collateralAsset).safeTransfer(msg.sender, _withdrawAmount);\n\n        // Executes the callback on the caller after sending them the withdrawn collateral\n        ICollateralReceiver(msg.sender).onUncheckedCollateralWithdraw(\n            _account,\n            _collateralAsset,\n            _withdrawAmount,\n            _depositedCollateralAssetIndex,\n            _userData\n        );\n\n        /*\n         Perform the MCR check after the callback has been executed\n         Ensures accountCollateralValue remains over accountMinColateralValueAtRatio(MCR)\n         Emits MinterEvent.UncheckedCollateralWithdrawn\n         _withdrawAmount is 0 since deposits reduced in recordCollateralWithdrawal\n        */\n        ms().verifyAccountCollateral(_account, _collateralAsset, 0);\n    }\n}\n"
    },
    "src/contracts/minter/facets/InterestLiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IInterestLiquidationFacet} from \"../interfaces/IInterestLiquidationFacet.sol\";\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {LibCalculation} from \"../libs/LibCalculation.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {MinterEvent, InterestRateEvent} from \"../../libs/Events.sol\";\nimport {SafeERC20, IERC20Permit} from \"../../shared/SafeERC20.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\nimport {KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title InterestLiquidationFacet\n * @notice Main end-user functionality concerning liquidations of accrued KISS interest within the Kresko protocol\n */\ncontract InterestLiquidationFacet is DiamondModifiers, IInterestLiquidationFacet {\n    using Arrays for address[];\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n    using SafeERC20 for IERC20Permit;\n\n    /// @inheritdoc IInterestLiquidationFacet\n    function batchLiquidateInterest(\n        address _account,\n        address _collateralAssetToSeize,\n        bool _allowSeizeUnderflow\n    ) external nonReentrant {\n        // Borrower cannot liquidate themselves\n        require(msg.sender != _account, Error.SELF_LIQUIDATION);\n        // Check that this account is below its minimum collateralization ratio and can be liquidated.\n        require(ms().isAccountLiquidatable(_account), Error.NOT_LIQUIDATABLE);\n        // Collateral exists\n        require(ms().collateralAssets[_collateralAssetToSeize].exists, Error.COLLATERAL_DOESNT_EXIST);\n\n        address[] memory mintedKreskoAssets = ms().getMintedKreskoAssets(_account);\n\n        // Loop all accounts minted assets and sum all accrued kiss interest\n        uint256 kissAmountToRepay;\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            address repayKreskoAsset = mintedKreskoAssets[i];\n            // Repays the full interest of this asset on behalf of the account being liquidated\n            kissAmountToRepay += ms().repayFullStabilityRateInterest(_account, repayKreskoAsset);\n\n            // Check if the status with amount repaid is still underwater, if so no further liquidation is needed\n            if (\n                !ms().isAccountLiquidatable(\n                    _account,\n                    kissAmountToRepay.fromWadPriceToUint().wadMul(\n                        ms().collateralAssets[_collateralAssetToSeize].liquidationIncentive\n                    )\n                )\n            ) break;\n        }\n\n        // Emit a separate event for batch repayment itself\n        emit InterestRateEvent.StabilityRateInterestBatchRepaid(_account, kissAmountToRepay);\n\n        // Seize collateral and send to liquidator according to the repayment made\n        uint256 collateralSeizeAmount = _seizeAndTransferCollateral(\n            _account,\n            _collateralAssetToSeize,\n            ms().getDepositedCollateralAssetIndex(_account, _collateralAssetToSeize),\n            kissAmountToRepay,\n            _allowSeizeUnderflow\n        );\n\n        emit MinterEvent.BatchInterestLiquidationOccurred(\n            _account,\n            msg.sender,\n            _collateralAssetToSeize,\n            kissAmountToRepay,\n            collateralSeizeAmount\n        );\n    }\n\n    /// @inheritdoc IInterestLiquidationFacet\n    function liquidateInterest(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize,\n        bool _allowSeizeUnderflow\n    ) external nonReentrant {\n        // Borrower cannot liquidate themselves\n        require(msg.sender != _account, Error.SELF_LIQUIDATION);\n        // krAsset exists\n        require(ms().kreskoAssets[_repayKreskoAsset].exists, Error.KRASSET_DOESNT_EXIST);\n        // Check that this account is below its minimum collateralization ratio and can be liquidated.\n        require(ms().isAccountLiquidatable(_account), Error.NOT_LIQUIDATABLE);\n        // Collateral exists\n        require(ms().collateralAssets[_collateralAssetToSeize].exists, Error.COLLATERAL_DOESNT_EXIST);\n\n        // Repays the full interest of this asset on behalf of the account being liquidated\n        uint256 kissRepayAmount = ms().repayFullStabilityRateInterest(_account, _repayKreskoAsset);\n\n        uint256 mintedKreskoAssetIndex = ms().getMintedKreskoAssetsIndex(_account, _repayKreskoAsset);\n\n        // Seize collateral and send to liquidator according to the repayment made\n        uint256 collateralAmountSeized = _seizeAndTransferCollateral(\n            _account,\n            _collateralAssetToSeize,\n            ms().getDepositedCollateralAssetIndex(_account, _collateralAssetToSeize),\n            kissRepayAmount,\n            _allowSeizeUnderflow\n        );\n\n        // If the liquidation repays the user's entire Kresko asset balance, remove it from minted assets array.\n        if (ms().kreskoAssetDebt[_account][_repayKreskoAsset] == 0) {\n            ms().mintedKreskoAssets[_account].removeAddress(_repayKreskoAsset, mintedKreskoAssetIndex);\n        }\n\n        emit MinterEvent.InterestLiquidationOccurred(\n            _account,\n            msg.sender,\n            _repayKreskoAsset,\n            kissRepayAmount, // without the liquidation bonus\n            _collateralAssetToSeize,\n            collateralAmountSeized // with the liquidation bonus\n        );\n    }\n\n    /**\n     * @notice Internal function to perform collateral seizing when interest gets liquidated\n     * @dev\n     * @param _account Account being liquidated\n     * @param _collateralAssetToSeize Collateral asset used to liquidate the debt\n     * @param _depositedCollateralAssetIndex Deposit index for the liquidated accounts collateral\n     * @param _kissRepayAmount Accrued KISS interest value being liquidated\n     */\n    function _seizeAndTransferCollateral(\n        address _account,\n        address _collateralAssetToSeize,\n        uint256 _depositedCollateralAssetIndex,\n        uint256 _kissRepayAmount,\n        bool _allowSeizeUnderflow\n    ) internal returns (uint256 seizeAmount) {\n        MinterState storage s = ms();\n\n        seizeAmount = s.collateralAssets[_collateralAssetToSeize].decimals.fromWad(\n            LibCalculation.calculateAmountToSeize(\n                s.collateralAssets[_collateralAssetToSeize].liquidationIncentive,\n                s.collateralAssets[_collateralAssetToSeize].uintPrice(s.oracleDeviationPct),\n                _kissRepayAmount.fromWadPriceToUint()\n            )\n        );\n\n        // Collateral deposits for the seized asset of the account being liquidated\n        uint256 collateralDeposit = s.getCollateralDeposits(_account, _collateralAssetToSeize);\n\n        // Default case where deposits are greater than the seized amount\n        if (collateralDeposit > seizeAmount) {\n            // Convert the value being seized into non-rebasing value\n            s.collateralDeposits[_account][_collateralAssetToSeize] -= ms()\n                .collateralAssets[_collateralAssetToSeize]\n                .toNonRebasingAmount(seizeAmount);\n        } else {\n            if (collateralDeposit < seizeAmount) {\n                require(_allowSeizeUnderflow, Error.SEIZED_COLLATERAL_UNDERFLOW);\n            }\n            // This clause means user either has collateralDeposits equal or less than the _seizeAmount\n            seizeAmount = collateralDeposit;\n            // So we set the collateralDeposits to 0\n            s.collateralDeposits[_account][_collateralAssetToSeize] = 0;\n            // And remove the asset from the deposits array.\n            s.depositedCollateralAssets[_account].removeAddress(\n                _collateralAssetToSeize,\n                _depositedCollateralAssetIndex\n            );\n        }\n\n        // Send liquidator the seized collateral.\n        IERC20Permit(_collateralAssetToSeize).safeTransfer(msg.sender, seizeAmount);\n    }\n}\n"
    },
    "src/contracts/minter/facets/LiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n// solhint-disable not-rely-on-time\n\nimport {ILiquidationFacet} from \"../interfaces/ILiquidationFacet.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {LibCalculation} from \"../libs/LibCalculation.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {SafeERC20, IERC20Permit} from \"../../shared/SafeERC20.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\n\nimport {Constants, KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/**\n * @author Kresko\n * @title LiquidationFacet\n * @notice Main end-user functionality concerning liquidations within the Kresko protocol\n */\ncontract LiquidationFacet is DiamondModifiers, ILiquidationFacet {\n    using Arrays for address[];\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n    using SafeERC20 for IERC20Permit;\n\n    /// @inheritdoc ILiquidationFacet\n    function liquidate(\n        address _account,\n        address _repayAsset,\n        uint256 _repayAmount,\n        address _seizeAsset,\n        uint256 _repayAssetIndex,\n        uint256 _seizeAssetIndex,\n        bool _allowSeizeUnderflow\n    ) external nonReentrant {\n        MinterState storage s = ms();\n\n        CollateralAsset memory collateral = s.collateralAssets[_seizeAsset];\n        KrAsset memory krAsset = s.kreskoAssets[_repayAsset];\n\n        /* ------------------------------ Sanity checks ----------------------------- */\n        {\n            // No zero repays\n            require(_repayAmount != 0, Error.ZERO_REPAY);\n            // Borrower cannot liquidate themselves\n            require(msg.sender != _account, Error.SELF_LIQUIDATION);\n            // krAsset exists\n            require(krAsset.exists, Error.KRASSET_DOESNT_EXIST);\n            // Collateral exists\n            require(collateral.exists, Error.COLLATERAL_DOESNT_EXIST);\n            // Check that this account is below its minimum collateralization ratio and can be liquidated.\n            require(s.isAccountLiquidatable(_account), Error.NOT_LIQUIDATABLE);\n        }\n\n        /* ------------------------------ Amount checks ----------------------------- */\n        // Repay amount USD = repay amount * KR asset USD exchange rate.\n        uint256 repayAmountUSD = krAsset.uintUSD(_repayAmount, s.oracleDeviationPct);\n\n        // Avoid deep stack\n        {\n            // Get the principal debt amount which is unscaled for interest.\n            uint256 krAssetDebt = s.getKreskoAssetDebtPrincipal(_account, _repayAsset);\n            // Cannot liquidate more than the account's debt\n            require(krAssetDebt >= _repayAmount, Error.KRASSET_BURN_AMOUNT_OVERFLOW);\n\n            // We limit liquidations to exactly Liquidation Threshold here.\n            uint256 maxLiquidableUSD = s.getMaxLiquidation(_account, krAsset, _seizeAsset);\n\n            if (repayAmountUSD > maxLiquidableUSD) {\n                _repayAmount = maxLiquidableUSD.wadDiv(krAsset.uintPrice(s.oracleDeviationPct));\n                repayAmountUSD = maxLiquidableUSD;\n            }\n        }\n\n        /* ------------------------------- Charge fee ------------------------------- */\n        s.chargeCloseFee(_account, _repayAsset, _repayAmount);\n\n        /* -------------------------------- Liquidate ------------------------------- */\n        uint256 seizedAmount = _liquidateAssets(\n            ExecutionParams(\n                _account,\n                _repayAmount,\n                collateral.decimals.fromWad(\n                    LibCalculation.calculateAmountToSeize(\n                        collateral.liquidationIncentive,\n                        collateral.uintPrice(s.oracleDeviationPct),\n                        repayAmountUSD\n                    )\n                ),\n                _repayAsset,\n                _repayAssetIndex,\n                _seizeAsset,\n                _seizeAssetIndex,\n                _allowSeizeUnderflow\n            )\n        );\n\n        /* ---------------------------- Balance transfer ---------------------------- */\n        // Send liquidator the seized collateral.\n        IERC20Permit(_seizeAsset).safeTransfer(msg.sender, seizedAmount);\n\n        emit MinterEvent.LiquidationOccurred(\n            _account,\n            // solhint-disable-next-line avoid-tx-origin\n            msg.sender,\n            _repayAsset,\n            _repayAmount,\n            _seizeAsset,\n            seizedAmount\n        );\n    }\n\n    /// @notice Execute the liquidation\n    /// @dev Also updates stability rate and debt index\n    function _liquidateAssets(ExecutionParams memory params) internal returns (uint256 seizedAmount) {\n        MinterState storage s = ms();\n\n        /* -------------------------------------------------------------------------- */\n        /*                                 Reduce debt                                */\n        /* -------------------------------------------------------------------------- */\n        {\n            /* ----------------------------- Destroy assets ----------------------------- */\n            uint256 destroyed = IKreskoAssetIssuer(s.kreskoAssets[params.repayAsset].anchor).destroy(\n                params.repayAmount,\n                msg.sender\n            );\n            s.kreskoAssetDebt[params.account][params.repayAsset] -= destroyed;\n\n            /* ------------------------ Debt index + rate updates ----------------------- */\n\n            uint256 newDebtIndex = irs().srAssets[params.repayAsset].updateDebtIndex();\n            uint256 amountScaled = destroyed.wadToRay().rayDiv(newDebtIndex);\n\n            irs().srUserInfo[params.account][params.repayAsset].debtScaled -= uint128(amountScaled);\n            irs().srUserInfo[params.account][params.repayAsset].lastDebtIndex = uint128(newDebtIndex);\n\n            irs().srAssets[params.repayAsset].updateStabilityRate();\n        }\n\n        // If the liquidation repays entire asset debt, remove from minted assets array.\n        if (s.getKreskoAssetDebtScaled(params.account, params.repayAsset) == 0) {\n            s.mintedKreskoAssets[params.account].removeAddress(params.repayAsset, params.repayAssetIndex);\n        }\n\n        /* -------------------------------------------------------------------------- */\n        /*                              Reduce collateral                             */\n        /* -------------------------------------------------------------------------- */\n\n        uint256 collateralDeposits = s.getCollateralDeposits(params.account, params.seizedAsset);\n\n        /* ------------------------ Above collateral deposits ----------------------- */\n\n        if (collateralDeposits > params.seizeAmount) {\n            uint256 newDepositAmount = collateralDeposits - params.seizeAmount;\n\n            // If the collateral asset is also a kresko asset, ensure that collateral remains over minimum amount required.\n            if (\n                ms().collateralAssets[params.seizedAsset].anchor != address(0) &&\n                newDepositAmount < Constants.MIN_KRASSET_COLLATERAL_AMOUNT\n            ) {\n                params.seizeAmount -= Constants.MIN_KRASSET_COLLATERAL_AMOUNT - newDepositAmount;\n                newDepositAmount = Constants.MIN_KRASSET_COLLATERAL_AMOUNT;\n            }\n\n            s.collateralDeposits[params.account][params.seizedAsset] = ms()\n                .collateralAssets[params.seizedAsset]\n                .toNonRebasingAmount(newDepositAmount);\n\n            return params.seizeAmount;\n        } else if (collateralDeposits < params.seizeAmount) {\n            require(params.allowSeizeUnderflow, Error.SEIZED_COLLATERAL_UNDERFLOW);\n        }\n\n        /* ------------------- Exact or below collateral deposits ------------------- */\n        // Remove the collateral deposits.\n        s.collateralDeposits[params.account][params.seizedAsset] = 0;\n        // Remove from the deposits array.\n        s.depositedCollateralAssets[params.account].removeAddress(params.seizedAsset, params.seizedAssetIndex);\n        // Seized amount is the collateral deposits.\n        return collateralDeposits;\n    }\n\n    /// @inheritdoc ILiquidationFacet\n    function isAccountLiquidatable(address _account) external view returns (bool) {\n        return ms().isAccountLiquidatable(_account);\n    }\n\n    /// @inheritdoc ILiquidationFacet\n    function getMaxLiquidation(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize\n    ) public view returns (uint256 maxLiquidatableUSD) {\n        return ms().getMaxLiquidation(_account, ms().kreskoAssets[_repayKreskoAsset], _collateralAssetToSeize);\n    }\n}\n"
    },
    "src/contracts/minter/facets/MintFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IMintFacet} from \"../interfaces/IMintFacet.sol\";\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {Role} from \"../../libs/Authorization.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\nimport {MinterModifiers} from \"../MinterModifiers.sol\";\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\nimport {Action, KrAsset} from \"../MinterTypes.sol\";\nimport {ms, MinterState} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {LibRedstone} from \"../libs/LibRedstone.sol\";\n\n/**\n * @author Kresko\n * @title MintFacet\n * @notice Main end-user functionality concerning minting kresko assets\n */\ncontract MintFacet is DiamondModifiers, MinterModifiers, IMintFacet {\n    using Arrays for address[];\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  KrAssets                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IMintFacet\n    function mintKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _mintAmount\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) onlyRoleIf(_account != msg.sender, Role.MANAGER) {\n        require(_mintAmount > 0, Error.ZERO_MINT);\n\n        MinterState storage s = ms();\n        if (s.safetyStateSet) {\n            super.ensureNotPaused(_kreskoAsset, Action.Borrow);\n        }\n        // Enforce krAsset's total supply limit\n        KrAsset memory krAsset = s.kreskoAssets[_kreskoAsset];\n        require(krAsset.marketStatus(), Error.KRASSET_MARKET_CLOSED);\n\n        require(\n            IKreskoAsset(_kreskoAsset).totalSupply() + _mintAmount <= krAsset.supplyLimit,\n            Error.KRASSET_MAX_SUPPLY_REACHED\n        );\n\n        if (krAsset.openFee > 0) {\n            s.chargeOpenFee(_account, _kreskoAsset, _mintAmount);\n        }\n        {\n            // Get the account's current minimum collateral value required to maintain current debts.\n            // Calculate additional collateral amount required to back requested additional mint.\n            // Verify that minter has sufficient collateral to back current debt + new requested debt.\n            require(\n                s.getAccountMinimumCollateralValueAtRatio(_account, s.minimumCollateralizationRatio) +\n                    s.getMinimumCollateralValueAtRatio(_kreskoAsset, _mintAmount, s.minimumCollateralizationRatio) <=\n                    s.getAccountCollateralValue(_account),\n                Error.KRASSET_COLLATERAL_LOW\n            );\n        }\n\n        // The synthetic asset debt position must be greater than the minimum debt position value\n        uint256 existingDebt = s.getKreskoAssetDebtScaled(_account, _kreskoAsset);\n        require(\n            krAsset.uintUSD(existingDebt + _mintAmount, s.oracleDeviationPct) >= s.minimumDebtValue,\n            Error.KRASSET_MINT_AMOUNT_LOW\n        );\n\n        // If the account does not have an existing debt for this Kresko Asset,\n        // push it to the list of the account's minted Kresko Assets.\n        if (existingDebt == 0) {\n            bool exists = false;\n            uint256 length = s.mintedKreskoAssets[_account].length;\n            for (uint256 i; i < length; ) {\n                if (s.mintedKreskoAssets[_account][i] == _kreskoAsset) {\n                    exists = true;\n                    break;\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n\n            if (!exists) {\n                s.mintedKreskoAssets[_account].push(_kreskoAsset);\n            }\n        }\n\n        // Record the mint.\n        s.mint(_kreskoAsset, krAsset.anchor, _mintAmount, _account);\n\n        // Emit logs\n        emit MinterEvent.KreskoAssetMinted(_account, _kreskoAsset, _mintAmount);\n    }\n}\n"
    },
    "src/contracts/minter/facets/SafetyCouncilFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {ISafetyCouncilFacet} from \"../interfaces/ISafetyCouncilFacet.sol\";\n\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {Authorization, Role} from \"../../libs/Authorization.sol\";\n\nimport {DiamondModifiers} from \"../../diamond/DiamondModifiers.sol\";\nimport {MinterModifiers} from \"../MinterModifiers.sol\";\n\nimport {Action, SafetyState, Pause} from \"../MinterTypes.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @author Kresko\n * @title SafetyCouncilFacet - protocol safety controls\n * @notice `Role.SAFETY_COUNCIL` must be a multisig.\n */\ncontract SafetyCouncilFacet is MinterModifiers, DiamondModifiers, ISafetyCouncilFacet {\n    /// @inheritdoc ISafetyCouncilFacet\n    function toggleAssetsPaused(\n        address[] calldata _assets,\n        Action _action,\n        bool _withDuration,\n        uint256 _duration\n    ) external override onlyRole(Role.SAFETY_COUNCIL) {\n        bool enabled;\n        /// @dev loop through `_assets` - be it krAsset or collateral\n        for (uint256 i; i < _assets.length; i++) {\n            address asset = _assets[i];\n            // Revert if invalid address is supplied\n            require(\n                ms().collateralAssets[asset].exists || ms().kreskoAssets[asset].exists,\n                Error.INVALID_ASSET_SUPPLIED\n            );\n            // Get the safety state\n            SafetyState memory safetyState = ms().safetyState[asset][_action];\n            // Flip the previous value\n            bool willPause = !safetyState.pause.enabled;\n            // Set a global flag in case any asset gets set to true\n            if (willPause) {\n                enabled = true;\n            }\n            // Update the state for this asset\n            ms().safetyState[asset][_action].pause = Pause(\n                willPause,\n                block.timestamp,\n                _withDuration ? block.timestamp + _duration : 0\n            );\n            // Emit the actions taken\n            emit MinterEvent.SafetyStateChange(_action, asset, willPause ? \"paused\" : \"unpaused\");\n        }\n    }\n\n    /// @inheritdoc ISafetyCouncilFacet\n    function setSafetyStateSet(bool val) external override onlyRole(Role.SAFETY_COUNCIL) {\n        ms().safetyStateSet = val;\n    }\n\n    /// @inheritdoc ISafetyCouncilFacet\n    function safetyStateSet() external view override returns (bool) {\n        return ms().safetyStateSet;\n    }\n\n    /// @inheritdoc ISafetyCouncilFacet\n    function safetyStateFor(address _asset, Action _action) external view override returns (SafetyState memory) {\n        return ms().safetyState[_asset][_action];\n    }\n\n    /// @inheritdoc ISafetyCouncilFacet\n    function assetActionPaused(Action _action, address _asset) external view returns (bool) {\n        return ms().safetyState[_asset][_action].pause.enabled;\n    }\n}\n"
    },
    "src/contracts/minter/facets/StabilityRateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {InterestRateEvent} from \"../../libs/Events.sol\";\nimport {LibStabilityRate} from \"../libs/LibStabilityRate.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {StabilityRateConfig} from \"../InterestRateState.sol\";\nimport {ms} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {IERC20Permit} from \"../../shared/IERC20Permit.sol\";\nimport {IStabilityRateFacet} from \"../interfaces/IStabilityRateFacet.sol\";\nimport {DiamondModifiers, Role} from \"../../diamond/DiamondModifiers.sol\";\nimport {MinterModifiers, Error} from \"../MinterModifiers.sol\";\nimport {SafeERC20, IERC20Permit} from \"../../shared/SafeERC20.sol\";\n\n/* solhint-disable var-name-mixedcase */\n\n// Stability Rate setup params\nstruct StabilityRateParams {\n    uint128 stabilityRateBase;\n    uint128 rateSlope1;\n    uint128 rateSlope2;\n    uint128 optimalPriceRate;\n    uint128 priceRateDelta;\n}\n\n/**\n * @title Stability rate facet\n * @author Kresko\n * @notice Stability rate related views and state operations\n * @dev Uses both MinterState (ms) and InterestRateState (irs)\n */\ncontract StabilityRateFacet is IStabilityRateFacet, MinterModifiers, DiamondModifiers {\n    using Arrays for address[];\n    using SafeERC20 for IERC20Permit;\n    using LibStabilityRate for StabilityRateConfig;\n    using WadRay for uint256;\n    using LibDecimals for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              ASSET STATE WRITES                            */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IStabilityRateFacet\n    function setupStabilityRateParams(address _asset, StabilityRateParams memory _setup) external onlyRole(Role.ADMIN) {\n        require(irs().kiss != address(0), Error.KISS_NOT_SET);\n        require(irs().srAssets[_asset].asset == address(0), Error.STABILITY_RATES_ALREADY_INITIALIZED);\n        require(WadRay.RAY >= _setup.optimalPriceRate, Error.INVALID_OPTIMAL_RATE);\n        require(WadRay.RAY >= _setup.priceRateDelta, Error.INVALID_PRICE_RATE_DELTA);\n\n        irs().srAssets[_asset] = StabilityRateConfig({\n            debtIndex: uint128(WadRay.RAY),\n            stabilityRateBase: _setup.stabilityRateBase,\n            // solhint-disable not-rely-on-time\n            lastUpdateTimestamp: uint40(block.timestamp),\n            asset: _asset,\n            rateSlope1: _setup.rateSlope1,\n            rateSlope2: _setup.rateSlope2,\n            optimalPriceRate: _setup.optimalPriceRate,\n            priceRateDelta: _setup.priceRateDelta,\n            stabilityRate: uint128(WadRay.RAY)\n        });\n\n        emit InterestRateEvent.StabilityRateConfigured(\n            _asset,\n            _setup.stabilityRateBase,\n            _setup.priceRateDelta,\n            _setup.rateSlope1,\n            _setup.rateSlope2\n        );\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function updateStabilityRateParams(\n        address _asset,\n        StabilityRateParams memory _setup\n    ) external onlyRole(Role.ADMIN) {\n        require(irs().srAssets[_asset].asset == _asset, Error.STABILITY_RATES_NOT_INITIALIZED);\n        require(WadRay.RAY >= _setup.optimalPriceRate, Error.INVALID_OPTIMAL_RATE);\n        require(WadRay.RAY >= _setup.priceRateDelta, Error.INVALID_PRICE_RATE_DELTA);\n        require(_setup.stabilityRateBase >= WadRay.RAY, Error.INVALID_STABILITY_RATE_BASE);\n\n        irs().srAssets[_asset].rateSlope1 = _setup.rateSlope1;\n        irs().srAssets[_asset].rateSlope2 = _setup.rateSlope2;\n        irs().srAssets[_asset].optimalPriceRate = _setup.optimalPriceRate;\n        irs().srAssets[_asset].priceRateDelta = _setup.priceRateDelta;\n        irs().srAssets[_asset].stabilityRateBase = _setup.stabilityRateBase;\n\n        emit InterestRateEvent.StabilityRateConfigured(\n            _asset,\n            _setup.stabilityRateBase,\n            _setup.priceRateDelta,\n            _setup.rateSlope1,\n            _setup.rateSlope2\n        );\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function updateStabilityRateAndIndexForAsset(address _asset) external {\n        irs().srAssets[_asset].updateDebtIndex();\n        irs().srAssets[_asset].updateStabilityRate();\n    }\n\n    function updateKiss(address _kiss) external onlyRole(Role.ADMIN) {\n        irs().kiss = _kiss;\n        emit InterestRateEvent.KISSUpdated(_kiss);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                REPAYMENT                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IStabilityRateFacet\n    function repayStabilityRateInterestPartial(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kissRepayAmount\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) {\n        // Update debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n\n        // Get the accrued interest in repayment token\n        (, uint256 maxKissRepayAmount) = ms().getKreskoAssetDebtInterest(_account, _kreskoAsset);\n        require(_kissRepayAmount < maxKissRepayAmount, Error.INTEREST_REPAY_NOT_PARTIAL);\n\n        // If no interest has accrued or 0 amount was supplied as parameter - no further operations needed\n        // Do not revert because we want the preserve new debt index and stability rate\n        // Also removes the need to check if the kresko asset exists as the maxKissAmount will return 0\n        if (_kissRepayAmount == 0 || maxKissRepayAmount == 0) {\n            // Update stability rate for asset\n            irs().srAssets[_kreskoAsset].updateStabilityRate();\n            return;\n        }\n\n        // Transfer the accrued interest\n        IERC20Permit(irs().kiss).safeTransferFrom(msg.sender, ms().feeRecipient, _kissRepayAmount);\n        uint256 assetAmount = _kissRepayAmount.divByPrice(\n            ms().kreskoAssets[_kreskoAsset].uintPrice(ms().oracleDeviationPct)\n        );\n        uint256 amountScaled = assetAmount.wadToRay().rayDiv(newDebtIndex);\n        // Update scaled values for the user\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled -= uint128(amountScaled);\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n        // Update stability rate for asset\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n\n        // Emit event with the account, asset and amount repaid\n        emit InterestRateEvent.StabilityRateInterestRepaid(_account, _kreskoAsset, _kissRepayAmount);\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function repayFullStabilityRateInterest(\n        address _account,\n        address _kreskoAsset\n    ) external nonReentrant kreskoAssetExists(_kreskoAsset) returns (uint256 kissRepayAmount) {\n        return ms().repayFullStabilityRateInterest(_account, _kreskoAsset);\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function batchRepayFullStabilityRateInterest(\n        address _account\n    ) external nonReentrant returns (uint256 kissRepayAmount) {\n        address[] memory mintedKreskoAssets = ms().getMintedKreskoAssets(_account);\n        for (uint256 i; i < mintedKreskoAssets.length; i++) {\n            kissRepayAmount += ms().repayFullStabilityRateInterest(_account, mintedKreskoAssets[i]);\n        }\n        emit InterestRateEvent.StabilityRateInterestBatchRepaid(_account, kissRepayAmount);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   VIEWS                                    */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IStabilityRateFacet\n    function getStabilityRateForAsset(address _asset) external view returns (uint256 stabilityRate) {\n        return irs().srAssets[_asset].calculateStabilityRate();\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function getPriceRateForAsset(address _asset) external view returns (uint256 priceRate) {\n        return irs().srAssets[_asset].getPriceRate();\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function getDebtIndexForAsset(address _asset) external view returns (uint256 debtIndex) {\n        return irs().srAssets[_asset].getNormalizedDebtIndex();\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function getStabilityRateConfigurationForAsset(address _asset) external view returns (StabilityRateConfig memory) {\n        return irs().srAssets[_asset];\n    }\n\n    /// @inheritdoc IStabilityRateFacet\n    function kiss() external view returns (address) {\n        return irs().kiss;\n    }\n\n    function getLastDebtIndexForAccount(\n        address _account,\n        address _asset\n    ) external view returns (uint128 lastDebtIndex) {\n        return irs().srUserInfo[_account][_asset].lastDebtIndex;\n    }\n}\n"
    },
    "src/contracts/minter/facets/StateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IStateFacet} from \"../interfaces/IStateFacet.sol\";\n\nimport {MinterParams, KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {MinterState, ms} from \"../MinterStorage.sol\";\n\n/**\n * @author Kresko\n * @title View functions for protocol parameters and asset values\n * @dev As structs do not create views for members, we must expose most of the state values explicitly.\n */\ncontract StateFacet is IStateFacet {\n    /// @inheritdoc IStateFacet\n    function domainSeparator() external view returns (bytes32) {\n        return ms().domainSeparator;\n    }\n\n    /// @inheritdoc IStateFacet\n    function minterInitializations() external view returns (uint256) {\n        return ms().initializations;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                Configurables                               */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IStateFacet\n    function feeRecipient() external view returns (address) {\n        return ms().feeRecipient;\n    }\n\n    /// @inheritdoc IStateFacet\n    function ammOracle() external view returns (address) {\n        return ms().ammOracle;\n    }\n\n    /// @inheritdoc IStateFacet\n    function extOracleDecimals() external view returns (uint8) {\n        return ms().extOracleDecimals;\n    }\n\n    /// @inheritdoc IStateFacet\n    function minimumCollateralizationRatio() external view returns (uint256) {\n        return ms().minimumCollateralizationRatio;\n    }\n\n    /// @inheritdoc IStateFacet\n    function liquidationIncentiveMultiplier() external view returns (uint256) {\n        return ms().liquidationIncentiveMultiplier;\n    }\n\n    /// @inheritdoc IStateFacet\n    function minimumDebtValue() external view returns (uint256) {\n        return ms().minimumDebtValue;\n    }\n\n    /// @inheritdoc IStateFacet\n    function liquidationThreshold() external view returns (uint256) {\n        return ms().liquidationThreshold;\n    }\n\n    /// @inheritdoc IStateFacet\n    function maxLiquidationMultiplier() external view returns (uint256) {\n        return ms().maxLiquidationMultiplier;\n    }\n\n    /// @inheritdoc IStateFacet\n    function oracleDeviationPct() external view returns (uint256) {\n        return ms().oracleDeviationPct;\n    }\n\n    /// @inheritdoc IStateFacet\n    function getAllParams() external view returns (MinterParams memory) {\n        MinterState storage s = ms();\n        return\n            MinterParams(\n                s.minimumCollateralizationRatio,\n                s.minimumDebtValue,\n                s.liquidationThreshold,\n                s.liquidationIncentiveMultiplier,\n                s.feeRecipient,\n                s.extOracleDecimals,\n                s.oracleDeviationPct\n            );\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   Assets                                   */\n    /* -------------------------------------------------------------------------- */\n    /// @inheritdoc IStateFacet\n    function krAssetExists(address _kreskoAsset) external view returns (bool exists) {\n        return ms().kreskoAssets[_kreskoAsset].exists;\n    }\n\n    /// @inheritdoc IStateFacet\n    function kreskoAsset(address _kreskoAsset) external view returns (KrAsset memory asset) {\n        return ms().kreskoAsset(_kreskoAsset);\n    }\n\n    /// @inheritdoc IStateFacet\n    function collateralExists(address _collateralAsset) external view returns (bool exists) {\n        return ms().collateralAssets[_collateralAsset].exists;\n    }\n\n    /// @inheritdoc IStateFacet\n    function collateralAsset(address _collateralAsset) external view returns (CollateralAsset memory asset) {\n        return ms().collateralAssets[_collateralAsset];\n    }\n\n    /// @inheritdoc IStateFacet\n    function getCollateralValueAndOraclePrice(\n        address _collateralAsset,\n        uint256 _amount,\n        bool _ignoreCollateralFactor\n    ) external view returns (uint256 value, uint256 oraclePrice) {\n        return ms().getCollateralValueAndOraclePrice(_collateralAsset, _amount, _ignoreCollateralFactor);\n    }\n\n    /// @inheritdoc IStateFacet\n    function getKrAssetValue(\n        address _kreskoAsset,\n        uint256 _amount,\n        bool _ignoreKFactor\n    ) external view returns (uint256 value) {\n        return ms().getKrAssetValue(_kreskoAsset, _amount, _ignoreKFactor);\n    }\n}\n"
    },
    "src/contracts/minter/facets/UIDataProviderFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n/* solhint-disable max-line-length */\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable func-name-mixedcase */\n/* solhint-disable contract-name-camelcase */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\nimport {LibUI, IKrStaking, IUniswapV2Pair, IERC20Permit, ms} from \"../libs/LibUI.sol\";\n\n/**\n * @author Kresko\n * @title UIDataProviderFacet\n * @notice UI data aggregation views\n */\ncontract UIDataProviderFacet {\n    function getAccountData(\n        address _account,\n        address[] memory _tokens,\n        address _staking\n    )\n        external\n        view\n        returns (LibUI.KreskoUser memory user, LibUI.Balance[] memory balances, LibUI.StakingData[] memory stakingData)\n    {\n        user = LibUI.kreskoUser(_account);\n        balances = LibUI.getBalances(_tokens, _account);\n        stakingData = LibUI.getStakingData(_account, _staking);\n    }\n\n    function batchOracleValues(\n        address[] memory _assets,\n        address[] memory _oracles,\n        address[] memory _marketStatusOracles\n    ) public view returns (LibUI.Price[] memory result) {\n        return LibUI.batchOracleValues(_assets, _oracles, _marketStatusOracles);\n    }\n\n    function getTokenData(\n        address[] memory _allTokens,\n        address[] memory _assets,\n        address[] memory _priceFeeds,\n        address[] memory _marketStatusOracles\n    ) external view returns (LibUI.TokenMetadata[] memory metadatas, LibUI.Price[] memory prices) {\n        metadatas = new LibUI.TokenMetadata[](_allTokens.length);\n        for (uint256 i; i < _allTokens.length; i++) {\n            metadatas[i] = LibUI.TokenMetadata({\n                decimals: IERC20Permit(_allTokens[i]).decimals(),\n                name: IERC20Permit(_allTokens[i]).name(),\n                symbol: IERC20Permit(_allTokens[i]).symbol(),\n                totalSupply: IERC20Permit(_allTokens[i]).totalSupply()\n            });\n        }\n        prices = LibUI.batchOracleValues(_assets, _priceFeeds, _marketStatusOracles);\n    }\n}\n"
    },
    "src/contracts/minter/facets/UIDataProviderFacet2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n/* solhint-disable max-line-length */\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable func-name-mixedcase */\n/* solhint-disable contract-name-camelcase */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\nimport {LibUI, IKrStaking, IUniswapV2Pair, IERC20Permit, ms} from \"../libs/LibUI.sol\";\n\n/**\n * @author Kresko\n * @title UIDataProviderFacet2\n * @notice UI data aggregation views\n */\ncontract UIDataProviderFacet2 {\n    function getGlobalData(\n        address[] memory _collateralAssets,\n        address[] memory _krAssets\n    )\n        external\n        view\n        returns (\n            LibUI.CollateralAssetInfo[] memory collateralAssets,\n            LibUI.krAssetInfo[] memory krAssets,\n            LibUI.ProtocolParams memory protocolParams\n        )\n    {\n        collateralAssets = LibUI.collateralAssetInfos(_collateralAssets);\n        krAssets = LibUI.krAssetInfos(_krAssets);\n        protocolParams = LibUI.ProtocolParams({\n            minCollateralRatio: ms().minimumCollateralizationRatio,\n            minDebtValue: ms().minimumDebtValue,\n            liquidationThreshold: ms().liquidationThreshold\n        });\n    }\n\n    function getPairsData(address[] memory _pairAddresses) external view returns (LibUI.PairData[] memory result) {\n        result = new LibUI.PairData[](_pairAddresses.length);\n        for (uint256 i; i < _pairAddresses.length; i++) {\n            IUniswapV2Pair pair = IUniswapV2Pair(_pairAddresses[i]);\n            (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\n            result[i] = LibUI.PairData({\n                decimals0: IERC20Permit(pair.token0()).decimals(),\n                decimals1: IERC20Permit(pair.token1()).decimals(),\n                totalSupply: pair.totalSupply(),\n                reserve0: reserve0,\n                reserve1: reserve1\n            });\n        }\n    }\n}\n"
    },
    "src/contracts/minter/initializers/FacetUpgrade16052023.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {ms} from \"../MinterStorage.sol\";\nimport {CollateralAsset} from \"../MinterTypes.sol\";\nimport {IFluxPriceFeed} from \"../../vendor/flux/FluxPriceFeed.sol\";\nimport {AggregatorV3Interface} from \"../../vendor/AggregatorV3Interface.sol\";\n\n/* solhint-disable var-name-mixedcase */\ninterface NewKresko {\n    function collateralAsset(address) external view returns (CollateralAsset memory);\n}\n\ninterface OldKresko {\n    struct CollateralOld {\n        uint256 factor;\n        AggregatorV3Interface oracle;\n        IFluxPriceFeed marketStatusOracle;\n        address anchor;\n        uint8 decimals;\n        bool exists;\n    }\n\n    function collateralAsset(address) external view returns (CollateralOld memory);\n}\n\ncontract FacetUpgrade16052023 {\n    function initialize() external {\n        ms().initializations += 1;\n        address DAI = 0x7ff84e6d3111327ED63eb97691Bf469C7fcE832F;\n        address WETH = 0x4200000000000000000000000000000000000006;\n        address krBTC = 0xf88721B9C87EBc86E3C91E6C98c0f646a75600f4;\n        address krETH = 0xbb37d6016f97Dd369eCB76e2A5036DacD8770f8b;\n        address krTSLA = 0x3502B0329a45011C8FEE033B8eEe6BDA89c03081;\n        address KISS = 0xC0B5aBa9F46bDf4D1bC52a4C3ab05C857aC4Ee80;\n        address[] memory collateralAssets = new address[](6);\n        collateralAssets[0] = DAI;\n        collateralAssets[1] = WETH;\n        collateralAssets[2] = krBTC;\n        collateralAssets[3] = krETH;\n        collateralAssets[4] = krTSLA;\n        collateralAssets[5] = KISS;\n        for (uint i = 0; i < collateralAssets.length; i++) {\n            address asset = collateralAssets[i];\n            ms().collateralAssets[asset].liquidationIncentive = 1.05 ether;\n        }\n\n        require(ms().collateralAssets[DAI].exists, \"!found\");\n        require(ms().collateralAssets[WETH].liquidationIncentive == 1.05 ether, \"!config\");\n\n        uint256 liqIncentive = NewKresko(0x0921a7234a2762aaB3C43d3b1F51dB5D8094a04b)\n            .collateralAsset(krBTC)\n            .liquidationIncentive;\n        require(liqIncentive == 1.05 ether, \"!found-new\");\n    }\n}\n"
    },
    "src/contracts/minter/InterestRateState.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {LibStabilityRate} from \"./libs/LibStabilityRate.sol\";\n\nusing LibStabilityRate for StabilityRateConfig global;\n\n/* solhint-disable var-name-mixedcase */\n\n// Asset data\nstruct StabilityRateConfig {\n    // Interest index for debt\n    uint128 debtIndex;\n    // Represents the optimal price rate between an oracle report and an AMM twap\n    uint128 optimalPriceRate;\n    // Slope of the variable interest curve when rate > 0 and <= optimalPriceRate.\n    // Expressed in ray\n    uint128 rateSlope1;\n    // Slope of the variable interest curve when rate > optimalPriceRate.\n    // Expressed in ray\n    uint128 rateSlope2;\n    /**\n     * Represents the excess price premium in either direction.\n     * Expressed in ray\n     * Eg. 1/20 ray = 5% price premium in either direction is considered excess\n     */\n    uint128 priceRateDelta;\n    // Current accrual rate for debt\n    uint128 stabilityRate;\n    // Base accrual rate for debt\n    uint128 stabilityRateBase;\n    // Asset to configure\n    address asset;\n    // Last update for the asset\n    uint40 lastUpdateTimestamp;\n}\n\n// User data\nstruct StabilityRateUser {\n    uint128 debtScaled;\n    uint128 lastDebtIndex;\n}\n\n// Storage layout\nstruct InterestRateState {\n    // asset address -> asset data\n    mapping(address => StabilityRateConfig) srAssets;\n    // account address -> asset address -> user data\n    mapping(address => mapping(address => StabilityRateUser)) srUserInfo;\n    // interest repayment token is KISS\n    address kiss;\n}\n\n// Storage position\nbytes32 constant INTEREST_RATE_STORAGE_POSITION = keccak256(\"kresko.interest.rate.storage\");\n\n// solhint-disable func-visibility\nfunction irs() pure returns (InterestRateState storage state) {\n    bytes32 position = INTEREST_RATE_STORAGE_POSITION;\n    assembly {\n        state.slot := position\n    }\n}\n"
    },
    "src/contracts/minter/interfaces/IAccountStateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {Action} from \"../MinterTypes.sol\";\n\ninterface IAccountStateFacet {\n    // ExpectedFeeRuntimeInfo is used for stack size optimization\n    struct ExpectedFeeRuntimeInfo {\n        address[] assets;\n        uint256[] amounts;\n        uint256 collateralTypeCount;\n    }\n\n    /**\n     * @notice Gets an array of Kresko assets the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @return An array of addresses of Kresko assets the account has minted.\n     */\n    function getMintedKreskoAssets(address _account) external view returns (address[] memory);\n\n    /**\n     * @notice Gets an index for the Kresko asset the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @param _kreskoAsset The asset lookup address.\n     * @return index of the minted Kresko asset.\n     */\n    function getMintedKreskoAssetsIndex(address _account, address _kreskoAsset) external view returns (uint256);\n\n    /**\n     * @notice Gets the Kresko asset value in USD of a particular account.\n     * @param _account The account to calculate the Kresko asset value for.\n     * @return The Kresko asset value of a particular account.\n     */\n    function getAccountKrAssetValue(address _account) external view returns (uint256);\n\n    /**\n     * @notice Get `_account` debt amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of debt for `_asset`\n     */\n    function kreskoAssetDebt(address _account, address _asset) external view returns (uint256);\n\n    /**\n     * @notice Get `_account` principal debt amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of principal debt for `_asset`\n     */\n    function kreskoAssetDebtPrincipal(address _account, address _asset) external view returns (uint256);\n\n    /**\n     * @notice Get `_account` interest amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return assetAmount the interest denominated in _asset\n     * @return kissAmount the interest denominated in KISS, ignores K-factor\n     */\n    function kreskoAssetDebtInterest(\n        address _account,\n        address _asset\n    ) external view returns (uint256 assetAmount, uint256 kissAmount);\n\n    /**\n     * @notice Get `_account` interest amount for `_asset`\n     * @param _account The account to query amount for\n     * @return kissAmount the interest denominated in KISS, ignores K-factor\n     */\n    function kreskoAssetDebtInterestTotal(address _account) external view returns (uint256 kissAmount);\n\n    /**\n     * @notice Gets the collateral value of a particular account.\n     * @dev O(# of different deposited collateral assets by account) complexity.\n     * @param _account The account to calculate the collateral value for.\n     * @return The collateral value of a particular account.\n     */\n    function getAccountCollateralValue(address _account) external view returns (uint256);\n\n    /**\n     * @notice Get an account's minimum collateral value required\n     * to back a Kresko asset amount at a given collateralization ratio.\n     * @dev Accounts that have their collateral value under the minimum collateral value are considered unhealthy,\n     *      accounts with their collateral value under the liquidation threshold are considered liquidatable.\n     * @param _account The account to calculate the minimum collateral value for.\n     * @param _ratio The collateralization ratio required: higher ratio = more collateral required\n     * @return The minimum collateral value of a particular account.\n     */\n    function getAccountMinimumCollateralValueAtRatio(address _account, uint256 _ratio) external view returns (uint256);\n\n    /**\n     * @notice Get a list of accounts and their collateral ratios\n     * @return ratio for an `_account`\n     */\n    function getAccountCollateralRatio(address _account) external view returns (uint256 ratio);\n\n    /**\n     * @notice Get a list of accounts and their collateral ratios\n     * @return ratios of the accounts\n     */\n    function getCollateralRatiosFor(address[] memory _accounts) external view returns (uint256[] memory);\n\n    /**\n     * @notice Get the adjusted value of collateral and the real value of collateral\n     * @dev The adjusted value of collateral is the value of collateral after adjusting for the cFactor\n     * @param _account The account to get the collateral values for.\n     * @param _asset The asset to get the collateral values for.\n     * @return adjustedValue The adjusted value of the collateral.\n     * @return realValue The real value of the collateral.\n     */\n    function getCollateralAdjustedAndRealValue(\n        address _account,\n        address _asset\n    ) external view returns (uint256 adjustedValue, uint256 realValue);\n\n    /**\n     * @notice Gets an index for the collateral asset the account has deposited.\n     * @param _account The account to get the index for.\n     * @param _collateralAsset The asset lookup address.\n     * @return i = index of the minted collateral asset.\n     */\n    function getDepositedCollateralAssetIndex(\n        address _account,\n        address _collateralAsset\n    ) external view returns (uint256 i);\n\n    /**\n     * @notice Gets an array of collateral assets the account has deposited.\n     * @param _account The account to get the deposited collateral assets for.\n     * @return An array of addresses of collateral assets the account has deposited.\n     */\n    function getDepositedCollateralAssets(address _account) external view returns (address[] memory);\n\n    /**\n     * @notice Get `_account` collateral deposit amount for `_asset`\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of collateral deposited for `_asset`\n     */\n    function collateralDeposits(address _account, address _asset) external view returns (uint256);\n\n    /**\n     * @notice Calculates the expected fee to be taken from a user's deposited collateral assets,\n     *         by imitating calcFee without modifying state.\n     * @param _account The account to charge the open fee from.\n     * @param _kreskoAsset The address of the kresko asset being burned.\n     * @param _kreskoAssetAmount The amount of the kresko asset being minted.\n     * @param _feeType The fee type (open, close, etc).\n     * @return assets The collateral types as an array of addresses.\n     * @return amounts The collateral amounts as an array of uint256.\n     */\n    function calcExpectedFee(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kreskoAssetAmount,\n        uint256 _feeType\n    ) external view returns (address[] memory, uint256[] memory);\n}\n"
    },
    "src/contracts/minter/interfaces/IBurnFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface IBurnFacet {\n    /**\n     * @notice Burns existing Kresko assets.\n     * @param _account The address to burn kresko assets for\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _burnAmount The amount of the Kresko asset to be burned.\n     * @param _mintedKreskoAssetIndex The index of the kresko asset in the user's minted assets array.\n     * @notice Only needed if burning all principal debt of a particular collateral asset.\n     */\n    function burnKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _burnAmount,\n        uint256 _mintedKreskoAssetIndex\n    ) external;\n}\n"
    },
    "src/contracts/minter/interfaces/IBurnHelperFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {MinterEvent} from \"../../libs/Events.sol\";\n\ninterface IBurnHelperFacet {\n    /**\n     * @notice Attempts to close all debt positions and interest\n     * @notice Account must have enough of krAsset balance to burn and enough KISS to cover interest\n     * @param _account The address to close the positions for\n     */\n    function batchCloseKrAssetDebtPositions(address _account) external;\n\n    /**\n     * @notice Burns all Kresko asset debt and repays interest.\n     * @notice Account must have enough of krAsset balance to burn and enough KISS to cover interest\n     * @param _account The address to close the position for\n     * @param _kreskoAsset The address of the Kresko asset.\n     */\n    function closeKrAssetDebtPosition(address _account, address _kreskoAsset) external;\n}\n"
    },
    "src/contracts/minter/interfaces/ICollateralReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface ICollateralReceiver {\n    function onUncheckedCollateralWithdraw(\n        address _account,\n        address _collateralAsset,\n        uint _withdrawalAmount,\n        uint _depositedCollateralAssetIndex,\n        bytes memory _userData\n    ) external returns (bytes memory);\n}\n"
    },
    "src/contracts/minter/interfaces/IConfigurationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {MinterInitArgs, KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\n\ninterface IConfigurationFacet {\n    function initialize(MinterInitArgs calldata args) external;\n\n    /**\n     * @notice Adds a collateral asset to the protocol.\n     * @dev Only callable by the owner and cannot be called more than once for an asset.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _config The configuration for the collateral asset.\n     */\n    function addCollateralAsset(address _collateralAsset, CollateralAsset memory _config) external;\n\n    /**\n     * @notice Adds a KreskoAsset to the protocol.\n     * @dev Only callable by the owner.\n     * @param _krAsset The address of the wrapped KreskoAsset, needs to support IKreskoAsset.\n     * @param _config Configuration for the KreskoAsset.\n     */\n    function addKreskoAsset(address _krAsset, KrAsset memory _config) external;\n\n    /**\n     * @notice Updates a previously added collateral asset.\n     * @dev Only callable by the owner.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _config The configuration for the collateral asset.\n     */\n    function updateCollateralAsset(address _collateralAsset, CollateralAsset memory _config) external;\n\n    /**\n     * @notice Updates a previously added kresko asset.\n     * @dev Only callable by the owner.\n     * @param _krAsset The address of the KreskoAsset.\n     * @param _config Configuration for the KreskoAsset.\n     */\n    function updateKreskoAsset(address _krAsset, KrAsset memory _config) external;\n\n    /**\n     * @notice Updates the fee recipient.\n     * @param _feeRecipient The new fee recipient.\n     */\n    function updateFeeRecipient(address _feeRecipient) external;\n\n    /**\n     * @notice  Updates the cFactor of a KreskoAsset.\n     * @param _collateralAsset The collateral asset.\n     * @param _cFactor The new cFactor.\n     */\n    function updateCFactor(address _collateralAsset, uint256 _cFactor) external;\n\n    /**\n     * @notice Updates the kFactor of a KreskoAsset.\n     * @param _kreskoAsset The KreskoAsset.\n     * @param _kFactor The new kFactor.\n     */\n    function updateKFactor(address _kreskoAsset, uint256 _kFactor) external;\n\n    /**\n     * @notice Updates the liquidation incentive multiplier.\n     * @param _collateralAsset The collateral asset to update it for.\n     * @param _liquidationIncentiveMultiplier The new liquidation incentive multiplie.\n     */\n    function updateLiquidationIncentiveMultiplier(\n        address _collateralAsset,\n        uint256 _liquidationIncentiveMultiplier\n    ) external;\n\n    /**\n     * @notice Updates the max liquidation usd overflow multiplier value.\n     * @param _maxLiquidationMultiplier Overflow value in percent, 18 decimals.\n     */\n    function updateMaxLiquidationMultiplier(uint256 _maxLiquidationMultiplier) external;\n\n    /**\n     * @dev Updates the contract's collateralization ratio.\n     * @param _minimumCollateralizationRatio The new minimum collateralization ratio as wad.\n     */\n    function updateMinimumCollateralizationRatio(uint256 _minimumCollateralizationRatio) external;\n\n    /**\n     * @dev Updates the contract's minimum debt value.\n     * @param _minimumDebtValue The new minimum debt value as a wad.\n     */\n    function updateMinimumDebtValue(uint256 _minimumDebtValue) external;\n\n    /**\n     * @dev Updates the contract's liquidation threshold value\n     * @param _liquidationThreshold The new liquidation threshold value\n     */\n    function updateLiquidationThreshold(uint256 _liquidationThreshold) external;\n\n    /**\n     * @notice Sets the protocol AMM oracle address\n     * @param _ammOracle  The address of the oracle\n     */\n    function updateAMMOracle(address _ammOracle) external;\n\n    /**\n     * @notice Sets the decimal precision of external oracle\n     * @param _decimals Amount of decimals\n     */\n    function updateExtOracleDecimals(uint8 _decimals) external;\n\n    /**\n     * @notice Sets the decimal precision of external oracle\n     * @param _oracleDeviationPct Amount of decimals\n     */\n    function updateOracleDeviationPct(uint256 _oracleDeviationPct) external;\n\n    /**\n     * @notice Sets L2 sequencer uptime feed address\n     * @param _sequencerUptimeFeed sequencer uptime feed address\n     */\n    function updateSequencerUptimeFeed(address _sequencerUptimeFeed) external;\n\n    /**\n     * @notice Sets sequencer grace period time\n     * @param _sequencerGracePeriodTime grace period time\n     */\n    function updateSequencerGracePeriodTime(uint256 _sequencerGracePeriodTime) external;\n\n    /**\n     * @notice Sets oracle timeout\n     * @param _oracleTimeout oracle timeout in seconds\n     */\n    function updateOracleTimeout(uint256 _oracleTimeout) external;\n}\n"
    },
    "src/contracts/minter/interfaces/IDepositWithdrawFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface IDepositWithdrawFacet {\n    /**\n     * @notice Deposits collateral into the protocol.\n     * @param _account The user to deposit collateral for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _depositAmount The amount of the collateral asset to deposit.\n     */\n    function depositCollateral(address _account, address _collateralAsset, uint256 _depositAmount) external;\n\n    /**\n     * @notice Withdraws sender's collateral from the protocol.\n     * @dev Requires that the post-withdrawal collateral value does not violate minimum collateral requirement.\n     * @param _account The address to withdraw assets for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\n     * @param _depositedCollateralAssetIndex The index of the collateral asset in the sender's deposited collateral\n     * assets array. Only needed if withdrawing the entire deposit of a particular collateral asset.\n     */\n    function withdrawCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _depositedCollateralAssetIndex\n    ) external;\n\n    /**\n     * @notice Withdraws sender's collateral from the protocol before checking minimum collateral ratio.\n     * @dev Executes post-withdraw-callback triggering onUncheckedCollateralWithdraw on the caller\n     * @dev Requires that the post-withdraw-callback collateral value does not violate minimum collateral requirement.\n     * @param _account The address to withdraw assets for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\n     * @param _depositedCollateralAssetIndex The index of the collateral asset in the sender's deposited collateral\n     * assets array. Only needed if withdrawing the entire deposit of a particular collateral asset.\n     */\n    function withdrawCollateralUnchecked(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _depositedCollateralAssetIndex,\n        bytes memory _userData\n    ) external;\n}\n"
    },
    "src/contracts/minter/interfaces/IInterestLiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface IInterestLiquidationFacet {\n    /**\n     * @notice Attempts to batch liquidate all KISS interest accrued for an account in a unhealthy position\n     * @notice Liquidator must have the KISS balance required with the Kresko contract approved\n     * @notice Checks liquidatable status on each iteration liquidating only what is necessary\n     * @param _account The account to attempt to liquidate.\n     * @param _collateralAssetToSeize The address of the collateral asset to be seized.\n     * @param _allowSeizeUnderflow Allow the amount of collateral to be seized to be less than the amount calculated.\n     */\n    function batchLiquidateInterest(\n        address _account,\n        address _collateralAssetToSeize,\n        bool _allowSeizeUnderflow\n    ) external;\n\n    /**\n     * @notice Attempts to liquidate all KISS interest accrued for an account in a unhealthy position\n     * @notice Liquidator must have the KISS balance required with the Kresko contract approved\n     * @param _account The account to attempt to liquidate.\n     * @param _repayKreskoAsset The address of the Kresko asset to be repaid.\n     * @param _collateralAssetToSeize The address of the collateral asset to be seized.\n     * @param _allowSeizeUnderflow Allow the amount of collateral to be seized to be less than the amount calculated.\n     */\n    function liquidateInterest(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize,\n        bool _allowSeizeUnderflow\n    ) external;\n}\n"
    },
    "src/contracts/minter/interfaces/ILiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface ILiquidationFacet {\n    /**\n     * @notice Attempts to liquidate an account by repaying the portion of the account's Kresko asset\n     *         princpal debt, receiving in return a portion of the account's collateral at a discounted rate.\n     * @param _account The account to attempt to liquidate.\n     * @param _repayAsset The address of the Kresko asset to be repaid.\n     * @param _repayAmount The amount of the Kresko asset to be repaid.\n     * @param _seizeAsset The address of the collateral asset to be seized.\n     * @param _repayAssetIndex The index of the Kresko asset in the account's minted assets array.\n     * @param _seizeAssetIndex Index of the collateral asset in the account's collateral assets array.\n     * @param _allowSeizeUnderflow Allow the amount of collateral to be seized to be less than the amount calculated.\n     */\n    function liquidate(\n        address _account,\n        address _repayAsset,\n        uint256 _repayAmount,\n        address _seizeAsset,\n        uint256 _repayAssetIndex,\n        uint256 _seizeAssetIndex,\n        bool _allowSeizeUnderflow\n    ) external;\n\n    /**\n     * @notice used execute _liquidateAssets.\n     * @param account The account to attempt to liquidate.\n     * @param repayAmount The amount of the Kresko asset to be repaid.\n     * @param seizeAmount The calculated amount of collateral assets to be seized.\n     * @param repayAsset The address of the Kresko asset to be repaid.\n     * @param repayIndex The index of the Kresko asset in the user's minted assets array.\n     * @param seizeAsset The address of the collateral asset to be seized.\n     * @param seizeAssetIndex The index of the collateral asset in the account's collateral assets array.\n     * @param allowSeizeUnderflow Allow the amount of collateral to be seized to be less than the amount calculated.\n     */\n    struct ExecutionParams {\n        address account;\n        uint256 repayAmount;\n        uint256 seizeAmount;\n        address repayAsset;\n        uint256 repayAssetIndex;\n        address seizedAsset;\n        uint256 seizedAssetIndex;\n        bool allowSeizeUnderflow;\n    }\n\n    /**\n     * @dev Calculates the total value that can be liquidated for a liquidation pair\n     * @param _account address to liquidate\n     * @param _repayKreskoAsset address of the kreskoAsset being repaid on behalf of the liquidatee\n     * @return maxLiquidatableUSD USD value that can be liquidated, 0 if the pair has no liquidatable value\n     */\n    function getMaxLiquidation(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize\n    ) external view returns (uint256 maxLiquidatableUSD);\n\n    /**\n     * @notice Calculates if an account's current collateral value is under its minimum collateral value\n     * @dev Returns true if the account's current collateral value is below the minimum collateral value\n     * required to consider the position healthy.\n     * @param _account The account to check.\n     * @return A boolean indicating if the account can be liquidated.\n     */\n    function isAccountLiquidatable(address _account) external view returns (bool);\n}\n"
    },
    "src/contracts/minter/interfaces/IMintFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\ninterface IMintFacet {\n    /**\n     * @notice Mints new Kresko assets.\n     * @param _account The address to mint assets for.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _mintAmount The amount of the Kresko asset to be minted.\n     */\n    function mintKreskoAsset(address _account, address _kreskoAsset, uint256 _mintAmount) external;\n}\n"
    },
    "src/contracts/minter/interfaces/ISafetyCouncilFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {Action, SafetyState, Pause} from \"../MinterTypes.sol\";\n\ninterface ISafetyCouncilFacet {\n    /**\n     * @dev Toggle paused-state of assets in a per-action basis\n     *\n     * @notice These functions are only callable by a multisig quorum.\n     * @param _assets list of addresses of krAssets and/or collateral assets\n     * @param _action One of possible user actions:\n     *  Deposit = 0\n     *  Withdraw = 1,\n     *  Repay = 2,\n     *  Borrow = 3,\n     *  Liquidate = 4\n     * @param _withDuration Set a duration for this pause - @todo: implement it if required\n     * @param _duration Duration for the pause if `_withDuration` is true\n     */\n    function toggleAssetsPaused(\n        address[] memory _assets,\n        Action _action,\n        bool _withDuration,\n        uint256 _duration\n    ) external;\n\n    /**\n     * @notice set the safetyStateSet flag\n     */\n    function setSafetyStateSet(bool val) external;\n\n    /**\n     * @notice For external checks if a safety state has been set for any asset\n     */\n    function safetyStateSet() external view returns (bool);\n\n    /**\n     * @notice View the state of safety measures for an asset on a per-action basis\n     * @param _asset krAsset / collateral asset\n     * @param _action One of possible user actions:\n     *\n     *  Deposit = 0\n     *  Withdraw = 1,\n     *  Repay = 2,\n     *  Borrow = 3,\n     *  Liquidate = 4\n     */\n    function safetyStateFor(address _asset, Action _action) external view returns (SafetyState memory);\n\n    /**\n     * @notice Check if `_asset` has a pause enabled for `_action`\n     * @param _action enum `Action`\n     *  Deposit = 0\n     *  Withdraw = 1,\n     *  Repay = 2,\n     *  Borrow = 3,\n     *  Liquidate = 4\n     * @return true if `_action` is paused\n     */\n    function assetActionPaused(Action _action, address _asset) external view returns (bool);\n}\n"
    },
    "src/contracts/minter/interfaces/IStabilityRateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {StabilityRateParams} from \"../facets/StabilityRateFacet.sol\";\nimport {StabilityRateConfig} from \"../InterestRateState.sol\";\n\ninterface IStabilityRateFacet {\n    /**\n     * @notice Initialize an asset with stability rate setup values\n     * @param _asset asset to setup\n     * @param _setup setup parameters\n     */\n    function setupStabilityRateParams(address _asset, StabilityRateParams memory _setup) external;\n\n    /**\n     * @notice Configure existing stability rate values\n     * @param _asset asset to configure\n     * @param _setup setup parameters\n     */\n    function updateStabilityRateParams(address _asset, StabilityRateParams memory _setup) external;\n\n    /// @notice Updates the debt index and stability rates for an asset\n    /// @param _asset asset to update rate and index for\n    function updateStabilityRateAndIndexForAsset(address _asset) external;\n\n    /**\n     * @notice Sets the protocol AMM oracle address\n     * @param _kiss  The address of the oracle\n     */\n    function updateKiss(address _kiss) external;\n\n    /**\n     * @notice Repays part of accrued stability rate interest for a single asset\n     * @param _account Account to repay interest for\n     * @param _kreskoAsset Kresko asset to repay interest for\n     * @param _kissRepayAmount USD value to repay (KISS)\n     */\n    function repayStabilityRateInterestPartial(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kissRepayAmount\n    ) external;\n\n    /**\n     * @notice Repays accrued stability rate interest for a single asset\n     * @param _account Account to repay interest for\n     * @param _kreskoAsset Kresko asset to repay interest for\n     * @return kissRepayAmount KISS value repaid\n     */\n    function repayFullStabilityRateInterest(\n        address _account,\n        address _kreskoAsset\n    ) external returns (uint256 kissRepayAmount);\n\n    /**\n     * @notice Repays all accrued stability rate interest for an account\n     * @param _account Account to repay all asset interests for\n     * @return kissRepayAmount KISS value repaid\n     */\n    function batchRepayFullStabilityRateInterest(address _account) external returns (uint256 kissRepayAmount);\n\n    /**\n     * @notice Gets the current stability rate for an asset\n     * @param _asset asset to get the stability rate for\n     * @return stabilityRate the return variables of a contract’s function state variable\n     * @dev expressed in ray\n     */\n    function getStabilityRateForAsset(address _asset) external view returns (uint256 stabilityRate);\n\n    /**\n     * @notice Gets the current price rate (difference between AMM <-> Oracle pricing)\n     * for an asset\n     * @param _asset asset to get the rate for\n     * @return priceRate the current\n     * @dev expressed in ray\n     */\n    function getPriceRateForAsset(address _asset) external view returns (uint256 priceRate);\n\n    /**\n     * @notice Gets the current running debt index\n     * @param _asset asset to get the index for\n     * @return debtIndex current running debt index\n     * @dev expressed in ray\n     */\n    function getDebtIndexForAsset(address _asset) external view returns (uint256 debtIndex);\n\n    /**\n     * @notice View stability rate configuration for an asset\n     * @param _asset asset to view configuration for\n     */\n    function getStabilityRateConfigurationForAsset(address _asset) external view returns (StabilityRateConfig memory);\n\n    /**\n     * @notice The configured address of KISS\n     */\n    function kiss() external view returns (address);\n\n    /**\n     * @notice Get user stability rate data for an asset\n     * @param _account asset to view configuration for\n     * @param _asset asset to view configuration for\n     * @return lastDebtIndex the previous debt index for the user\n     */\n    function getLastDebtIndexForAccount(address _account, address _asset) external view returns (uint128 lastDebtIndex);\n}\n"
    },
    "src/contracts/minter/interfaces/IStateFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {CollateralAsset, KrAsset, MinterParams} from \"../MinterTypes.sol\";\n\ninterface IStateFacet {\n    /// @notice The EIP-712 typehash for the contract's domain.\n    function domainSeparator() external view returns (bytes32);\n\n    /// @notice amount of times the minter has been initialized\n    function minterInitializations() external view returns (uint256);\n\n    /// @notice The recipient of protocol fees.\n    function feeRecipient() external view returns (address);\n\n    /// @notice The AMM oracle address.\n    function ammOracle() external view returns (address);\n\n    /// @notice Offchain oracle decimals\n    function extOracleDecimals() external view returns (uint8);\n\n    /// @notice The collateralization ratio at which positions may be liquidated.\n    function liquidationThreshold() external view returns (uint256);\n\n    /// @notice The factor used to calculate the incentive a liquidator receives in the form of seized collateral.\n    function liquidationIncentiveMultiplier() external view returns (uint256);\n\n    /// @notice Multiplies max liquidatable value, allowing liquidations to go over LT.\n    function maxLiquidationMultiplier() external view returns (uint256);\n\n    /// @notice max deviation between main oracle and fallback oracle\n    function oracleDeviationPct() external view returns (uint256);\n\n    /// @notice The minimum ratio of collateral to debt that can be taken by direct action.\n    function minimumCollateralizationRatio() external view returns (uint256);\n\n    /// @notice The minimum USD value of an individual synthetic asset debt position.\n    function minimumDebtValue() external view returns (uint256);\n\n    /// @notice simple check if kresko asset exists\n    function krAssetExists(address _krAsset) external view returns (bool);\n\n    /**\n     * @notice Get the state of a specific krAsset\n     * @param _asset Address of the asset.\n     * @return State of assets `KrAsset` struct\n     */\n    function kreskoAsset(address _asset) external view returns (KrAsset memory);\n\n    /// @notice Mapping of collateral asset token address to information on the collateral asset.\n    function collateralAsset(address _asset) external view returns (CollateralAsset memory);\n\n    /// @notice simple check if collateral asset exists\n    function collateralExists(address _collateralAsset) external view returns (bool);\n\n    /// @notice get all meaningful protocol parameters\n    function getAllParams() external view returns (MinterParams memory);\n\n    /**\n     * @notice Gets the USD value for a single collateral asset and amount.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _amount The amount of the collateral asset to calculate the value for.\n     * @param _ignoreCollateralFactor Boolean indicating if the asset's collateral factor should be ignored.\n     */\n    function getCollateralValueAndOraclePrice(\n        address _collateralAsset,\n        uint256 _amount,\n        bool _ignoreCollateralFactor\n    ) external view returns (uint256, uint256);\n\n    /**\n     * @notice Gets the USD value for a single Kresko asset and amount.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _amount The amount of the Kresko asset to calculate the value for.\n     * @param _ignoreKFactor Boolean indicating if the asset's k-factor should be ignored.\n     * @return The value for the provided amount of the Kresko asset.\n     */\n    function getKrAssetValue(\n        address _kreskoAsset,\n        uint256 _amount,\n        bool _ignoreKFactor\n    ) external view returns (uint256);\n}\n"
    },
    "src/contracts/minter/libs/LibAccount.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {MinterState} from \"../MinterState.sol\";\nimport {KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {RebaseMath} from \"../../kreskoasset/Rebase.sol\";\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\n\nlibrary LibAccount {\n    using RebaseMath for uint256;\n    using WadRay for uint256;\n    using LibDecimals for uint256;\n\n    /**\n     * @notice Gets an array of Kresko assets the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @return An array of addresses of Kresko assets the account has minted.\n     */\n    function getMintedKreskoAssets(\n        MinterState storage self,\n        address _account\n    ) internal view returns (address[] memory) {\n        return self.mintedKreskoAssets[_account];\n    }\n\n    /**\n     * @notice Gets an array of collateral assets the account has deposited.\n     * @param _account The account to get the deposited collateral assets for.\n     * @return An array of addresses of collateral assets the account has deposited.\n     */\n    function getDepositedCollateralAssets(\n        MinterState storage self,\n        address _account\n    ) internal view returns (address[] memory) {\n        return self.depositedCollateralAssets[_account];\n    }\n\n    /**\n     * @notice Get deposited collateral asset amount for an account\n     * @notice Performs rebasing conversion for KreskoAssets\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return uint256 amount of collateral for `_asset`\n     */\n    function getCollateralDeposits(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256) {\n        return self.collateralAssets[_asset].toRebasingAmount(self.collateralDeposits[_account][_asset]);\n    }\n\n    /**\n     * @notice Checks if accounts collateral value is less than required.\n     * @param _account The account to check.\n     * @return A boolean indicating if the account can be liquidated.\n     */\n    function isAccountLiquidatable(MinterState storage self, address _account) internal view returns (bool) {\n        return\n            self.getAccountCollateralValue(_account) <\n            (self.getAccountMinimumCollateralValueAtRatio(_account, self.liquidationThreshold));\n    }\n\n    /**\n     * @notice Overload for calculating liquidatable status with a future liquidated collateral value\n     * @param _account The account to check.\n     * @param _valueLiquidated Value liquidated, eg. in a batch liquidation\n     * @return bool indicating if the account can be liquidated.\n     */\n    function isAccountLiquidatable(\n        MinterState storage self,\n        address _account,\n        uint256 _valueLiquidated\n    ) internal view returns (bool) {\n        return\n            self.getAccountCollateralValue(_account) - _valueLiquidated <\n            (self.getAccountMinimumCollateralValueAtRatio(_account, self.liquidationThreshold));\n    }\n\n    /**\n     * @notice Gets the collateral value of a particular account.\n     * @dev O(# of different deposited collateral assets by account) complexity.\n     * @param _account The account to calculate the collateral value for.\n     * @return totalCollateralValue The collateral value of a particular account.\n     */\n    function getAccountCollateralValue(\n        MinterState storage self,\n        address _account\n    ) internal view returns (uint256 totalCollateralValue) {\n        address[] memory assets = self.depositedCollateralAssets[_account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            (uint256 collateralValue, ) = self.getCollateralValueAndOraclePrice(\n                asset,\n                self.getCollateralDeposits(_account, asset),\n                false // Take the collateral factor into consideration.\n            );\n            totalCollateralValue += collateralValue;\n        }\n\n        return totalCollateralValue;\n    }\n\n    /**\n     * @notice Gets the collateral value of a particular account including extra return value for specific collateral.\n     * @dev O(# of different deposited collateral assets by account) complexity.\n     * @param _account The account to calculate the collateral value for.\n     * @param _collateralAsset The collateral asset to get the collateral value.\n     * @return totalCollateralValue The collateral value of a particular account.\n     */\n    function getAccountCollateralValue(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset\n    ) internal view returns (uint256 totalCollateralValue, uint256 specificValue) {\n        address[] memory assets = self.depositedCollateralAssets[_account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            (uint256 collateralValue, ) = self.getCollateralValueAndOraclePrice(\n                asset,\n                self.getCollateralDeposits(_account, asset),\n                false // Take the collateral factor into consideration.\n            );\n            totalCollateralValue += collateralValue;\n            if (asset == _collateralAsset) {\n                specificValue = collateralValue;\n            }\n        }\n    }\n\n    /**\n     * @notice Gets accounts min collateral value required to cover debt at a given collateralization ratio.\n     * @dev 1. Account with min collateral value under MCR will not borrow.\n     *      2. Account with min collateral value under LT can be liquidated.\n     * @param _account The account to calculate the minimum collateral value for.\n     * @param _ratio The collateralization ratio to get min collateral value against.\n     * @return The min collateral value at given collateralization ratio for the account.\n     */\n    function getAccountMinimumCollateralValueAtRatio(\n        MinterState storage self,\n        address _account,\n        uint256 _ratio\n    ) internal view returns (uint256) {\n        return self.getAccountKrAssetValue(_account).wadMul(_ratio);\n    }\n\n    /**\n     * @notice Gets the total KreskoAsset value in USD for an account.\n     * @param _account The account to calculate the KreskoAsset value for.\n     * @return value The KreskoAsset value of the account.\n     */\n    function getAccountKrAssetValue(MinterState storage self, address _account) internal view returns (uint256 value) {\n        address[] memory assets = self.mintedKreskoAssets[_account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            value += self.getKrAssetValue(asset, self.getKreskoAssetDebtScaled(_account, asset), false);\n        }\n        return value;\n    }\n\n    /**\n     * @notice Get accounts interested scaled debt amount for a KreskoAsset.\n     * @param _asset The asset address\n     * @param _account The account to get the amount for\n     * @return Amount of scaled debt.\n     */\n    function getKreskoAssetDebtScaled(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256) {\n        uint256 debt = self.kreskoAssets[_asset].toRebasingAmount(irs().srUserInfo[_account][_asset].debtScaled);\n        if (debt == 0) {\n            return 0;\n        }\n\n        return debt.rayMul(irs().srAssets[_asset].getNormalizedDebtIndex()).rayToWad();\n    }\n\n    /**\n     * @notice Get `_account` principal debt amount for `_asset`\n     * @dev Principal debt is rebase adjusted due to possible stock splits/reverse splits\n     * @param _asset The asset address\n     * @param _account The account to query amount for\n     * @return Amount of principal debt for `_asset`\n     */\n    function getKreskoAssetDebtPrincipal(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256) {\n        return self.kreskoAssets[_asset].toRebasingAmount(self.kreskoAssetDebt[_account][_asset]);\n    }\n\n    /**\n     * @notice Get the total interest accrued on top of debt: Scaled Debt - Principal Debt\n     * @return assetAmount Interest denominated in _asset\n     * @return kissAmount Interest denominated in KISS. Ignores K-factor: $1 of interest = 1 KISS\n     **/\n    function getKreskoAssetDebtInterest(\n        MinterState storage self,\n        address _account,\n        address _asset\n    ) internal view returns (uint256 assetAmount, uint256 kissAmount) {\n        assetAmount =\n            self.getKreskoAssetDebtScaled(_account, _asset) -\n            self.getKreskoAssetDebtPrincipal(_account, _asset);\n        kissAmount = self.getKrAssetValue(_asset, assetAmount, true).oraclePriceToWad();\n    }\n\n    /**\n     * @notice Gets an index for the Kresko asset the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @param _kreskoAsset The asset lookup address.\n     * @return i = index of the minted Kresko asset.\n     */\n    function getMintedKreskoAssetsIndex(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset\n    ) internal view returns (uint256 i) {\n        uint256 length = self.mintedKreskoAssets[_account].length;\n        require(length > 0, Error.NO_KRASSETS_MINTED);\n        for (i; i < length; i++) {\n            if (self.mintedKreskoAssets[_account][i] == _kreskoAsset) {\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Gets an index for the collateral asset the account has deposited.\n     * @param _account The account to get the index for.\n     * @param _collateralAsset The asset lookup address.\n     * @return i = index of the minted collateral asset.\n     */\n    function getDepositedCollateralAssetIndex(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset\n    ) internal view returns (uint256 i) {\n        uint256 length = self.depositedCollateralAssets[_account].length;\n        require(length > 0, Error.NO_COLLATERAL_DEPOSITS);\n        for (i; i < length; i++) {\n            if (self.depositedCollateralAssets[_account][i] == _collateralAsset) {\n                break;\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibAssetUtility.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {CollateralAsset, KrAsset} from \"../MinterTypes.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibRedstone} from \"./LibRedstone.sol\";\nimport {ms} from \"../MinterStorage.sol\";\nimport {AggregatorV3Interface} from \"../../vendor/AggregatorV3Interface.sol\";\n\n/**\n * @title LibAssetUtility\n * @author Kresko\n * @notice Utility functions for KrAsset and CollateralAsset structs\n */\nlibrary LibAssetUtility {\n    using WadRay for uint256;\n    using LibDecimals for uint256;\n\n    /**\n     * @notice Amount of non rebasing tokens -> amount of rebasing tokens\n     * @param self the kresko asset struct\n     * @param _nonRebasedAmount the amount to convert\n     */\n    function toRebasingAmount(KrAsset memory self, uint256 _nonRebasedAmount) internal view returns (uint256) {\n        return IKreskoAssetAnchor(self.anchor).convertToAssets(_nonRebasedAmount);\n    }\n\n    /**\n     * @notice Amount of non rebasing tokens -> amount of rebasing tokens\n     * @dev if collateral is not a kresko asset, returns the input\n     * @param self the collateral asset struct\n     * @param _nonRebasedAmount the amount to convert\n     */\n    function toRebasingAmount(CollateralAsset memory self, uint256 _nonRebasedAmount) internal view returns (uint256) {\n        if (self.anchor == address(0)) return _nonRebasedAmount;\n        return IKreskoAssetAnchor(self.anchor).convertToAssets(_nonRebasedAmount);\n    }\n\n    /**\n     * @notice Amount of rebasing tokens -> amount of non rebasing tokens\n     * @param self the kresko asset struct\n     * @param _maybeRebasedAmount the amount to convert\n     */\n    function toNonRebasingAmount(KrAsset memory self, uint256 _maybeRebasedAmount) internal view returns (uint256) {\n        return IKreskoAssetAnchor(self.anchor).convertToShares(_maybeRebasedAmount);\n    }\n\n    /**\n     * @notice Amount of rebasing tokens -> amount of non rebasing tokens\n     * @dev if collateral is not a kresko asset, returns the input\n     * @param self the collateral asset struct\n     * @param _maybeRebasedAmount the amount to convert\n     */\n    function toNonRebasingAmount(\n        CollateralAsset memory self,\n        uint256 _maybeRebasedAmount\n    ) internal view returns (uint256) {\n        if (self.anchor == address(0)) return _maybeRebasedAmount;\n        return IKreskoAssetAnchor(self.anchor).convertToShares(_maybeRebasedAmount);\n    }\n\n    /**\n     * @notice Get the oracle price of a collateral asset in uint256 with extOracleDecimals\n     */\n    function uintPrice(CollateralAsset memory self) internal view returns (uint256) {\n        (, int256 answer, , uint256 updatedAt, ) = self.oracle.latestRoundData();\n        require(answer >= 0, Error.NEGATIVE_ORACLE_PRICE);\n        // returning zero if oracle price is too old so that fallback oracle is used instead.\n        if (block.timestamp - updatedAt > ms().oracleTimeout) {\n            return 0;\n        }\n        return uint256(answer);\n    }\n\n    /**\n     * @notice Get the oracle price of a kresko asset in uint256 with extOracleDecimals\n     */\n    function redstonePrice(CollateralAsset memory self) internal view returns (uint256) {\n        return LibRedstone.getPrice(self.redstoneId);\n    }\n\n    /**\n     * @notice Get the oracle price of a kresko asset in uint256 with extOracleDecimals\n     */\n    function uintPrice(KrAsset memory self) internal view returns (uint256) {\n        (, int256 answer, , uint256 updatedAt, ) = self.oracle.latestRoundData();\n        require(answer >= 0, Error.NEGATIVE_ORACLE_PRICE);\n        // returning zero if oracle price is too old so that fallback oracle is used instead.\n        if (block.timestamp - updatedAt > ms().oracleTimeout) {\n            return 0;\n        }\n        return uint256(answer);\n    }\n\n    /**\n     * @notice Get the oracle price of a kresko asset in uint256 with extOracleDecimals\n     * @param self the kresko asset struct\n     */\n    function redstonePrice(KrAsset memory self) internal view returns (uint256) {\n        return LibRedstone.getPrice(self.redstoneId);\n    }\n\n    /**\n     * @notice Get the oracle price of a collateral asset in uint256 with 18 decimals\n     */\n    function wadPrice(CollateralAsset memory self) internal view returns (uint256) {\n        return self.uintPrice().oraclePriceToWad();\n    }\n\n    /**\n     * @notice Get the oracle price of a kresko asset in uint256 with 18 decimals\n     */\n    function wadPrice(KrAsset memory self) internal view returns (uint256) {\n        return self.uintPrice().oraclePriceToWad();\n    }\n\n    /**\n     * @notice Get value for @param _assetAmount of @param self in uint256\n     */\n    function uintUSD(CollateralAsset memory self, uint256 _assetAmount) internal view returns (uint256) {\n        return self.uintPrice().wadMul(_assetAmount);\n    }\n\n    /**\n     * @notice Get Redstone value for @param _assetAmount of @param self in uint256\n     * @param self the collateral asset struct\n     * @param _assetAmount the amount to convert\n     */\n    function uintUSDRedstone(CollateralAsset memory self, uint256 _assetAmount) internal view returns (uint256) {\n        return self.redstonePrice().wadMul(_assetAmount);\n    }\n\n    /**\n     * @notice Get value for @param _assetAmount of @param self in uint256\n     */\n    function uintUSD(KrAsset memory self, uint256 _assetAmount) internal view returns (uint256) {\n        return self.uintPrice().wadMul(_assetAmount);\n    }\n\n    /**\n     * @notice Get Redstone value for @param _assetAmount of @param self in uint256\n     * @param self the kresko asset struct\n     * @param _assetAmount the amount to convert\n     */\n    function uintUSDRedstone(KrAsset memory self, uint256 _assetAmount) internal view returns (uint256) {\n        return self.redstonePrice().wadMul(_assetAmount);\n    }\n\n    /**\n     * @notice Get Aggregrated price from chainlink oracle and redstone\n     * @param self the collateral asset struct\n     * @param _oracleDeviationPct the deviation percentage to use for the oracle\n     */\n    function uintPrice(CollateralAsset memory self, uint256 _oracleDeviationPct) internal view returns (uint256) {\n        return _getPrice(self.uintPrice(), self.redstonePrice(), _oracleDeviationPct);\n    }\n\n    /**\n     * @notice Get Aggregrated price from chainlink oracle and redstone\n     * @param self the kresko asset struct\n     * @param _oracleDeviationPct the deviation percentage to use for the oracle\n     */\n    function uintPrice(KrAsset memory self, uint256 _oracleDeviationPct) internal view returns (uint256) {\n        return _getPrice(self.uintPrice(), self.redstonePrice(), _oracleDeviationPct);\n    }\n\n    /**\n     * @notice Get Aggregrated price from chainlink oracle and redstone in USD\n     * @param self the collateral asset struct\n     * @param _assetAmount the amount to convert\n     * @param _oracleDeviationPct the deviation percentage to use for the oracle\n     */\n    function uintUSD(\n        CollateralAsset memory self,\n        uint256 _assetAmount,\n        uint256 _oracleDeviationPct\n    ) internal view returns (uint256) {\n        return _getPrice(self.uintUSD(_assetAmount), self.uintUSDRedstone(_assetAmount), _oracleDeviationPct);\n    }\n\n    /**\n     * @notice Get Aggregrated price from chainlink oracle and redstone in USD\n     * @param self the kresko asset struct\n     * @param _assetAmount the amount to convert\n     * @param _oracleDeviationPct the deviation percentage to use for the oracle\n     */\n    function uintUSD(\n        KrAsset memory self,\n        uint256 _assetAmount,\n        uint256 _oracleDeviationPct\n    ) internal view returns (uint256) {\n        return _getPrice(self.uintUSD(_assetAmount), self.uintUSDRedstone(_assetAmount), _oracleDeviationPct);\n    }\n\n    /**\n     * @notice check the price and return it\n     * @notice reverts if the price deviates more than `_oracleDeviationPct`\n     * @param _chainlinkPrice chainlink price\n     * @param _redstonePrice redstone price\n     * @param _oracleDeviationPct the deviation percentage to use for the oracle\n     */\n    function _getPrice(\n        uint256 _chainlinkPrice,\n        uint256 _redstonePrice,\n        uint256 _oracleDeviationPct\n    ) internal view returns (uint256) {\n        if (ms().sequencerUptimeFeed != address(0)) {\n            (, int256 answer, uint256 startedAt, , ) = AggregatorV3Interface(ms().sequencerUptimeFeed)\n                .latestRoundData();\n            bool isSequencerUp = answer == 0;\n            if (!isSequencerUp) {\n                return _redstonePrice;\n            }\n            // Make sure the grace period has passed after the\n            // sequencer is back up.\n            uint256 timeSinceUp = block.timestamp - startedAt;\n            if (timeSinceUp <= ms().sequencerGracePeriodTime) {\n                return _redstonePrice;\n            }\n        }\n        if (_chainlinkPrice == 0) return _redstonePrice;\n        if (_redstonePrice == 0) return _chainlinkPrice;\n        if (\n            (_redstonePrice.wadMul(1 ether - _oracleDeviationPct) <= _chainlinkPrice) &&\n            (_redstonePrice.wadMul(1 ether + _oracleDeviationPct) >= _chainlinkPrice)\n        ) return _chainlinkPrice;\n\n        // Revert if price deviates more than `_oracleDeviationPct`\n        revert(Error.ORACLE_PRICE_UNSTABLE);\n    }\n\n    function marketStatus(KrAsset memory self) internal pure returns (bool) {\n        return true;\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibBurn.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n// solhint-disable not-rely-on-time\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {MinterEvent, InterestRateEvent} from \"../../libs/Events.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {IERC20Permit} from \"../../shared/IERC20Permit.sol\";\nimport {SafeERC20} from \"../../shared/SafeERC20.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\n\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {LibCalculation} from \"./LibCalculation.sol\";\nimport {KrAsset} from \"../MinterTypes.sol\";\nimport {irs} from \"../InterestRateState.sol\";\nimport {MinterState} from \"../MinterState.sol\";\n\nlibrary LibBurn {\n    using Arrays for address[];\n\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n\n    using SafeERC20 for IERC20Permit;\n    using LibCalculation for MinterState;\n\n    /// @notice Repay user kresko asset debt with stability rate updates.\n    /// @dev Updates the principal in MinterState and stability rate adjusted values in InterestRateState\n    /// @param _kreskoAsset the asset being repaid\n    /// @param _anchor the anchor token of the asset being repaid\n    /// @param _burnAmount the asset amount being burned\n    /// @param _account the account the debt is subtracted from\n    function burn(\n        MinterState storage self,\n        address _kreskoAsset,\n        address _anchor,\n        uint256 _burnAmount,\n        address _account\n    ) internal {\n        // Update global debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n        // Get the possibly rebalanced amount of destroyed tokens\n        uint256 destroyed = IKreskoAssetIssuer(_anchor).destroy(_burnAmount, msg.sender);\n        // Calculate the debt index scaled amount\n        uint256 amountScaled = destroyed.wadToRay().rayDiv(newDebtIndex);\n        require(amountScaled != 0, Error.INVALID_SCALED_AMOUNT);\n\n        // Decrease the principal debt\n        self.kreskoAssetDebt[_account][_kreskoAsset] -= destroyed;\n        // Decrease the scaled debt and set user asset's last debt index\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled -= uint128(amountScaled);\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n        // Update the stability rate for the asset\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n    }\n\n    /**\n     * @notice Repays accrued stability rate interest for a single asset\n     * @param _account Account to repay interest for\n     * @param _kreskoAsset Kresko asset to repay interest for\n     * @return kissRepayAmount amount repaid\n     */\n    function repayFullStabilityRateInterest(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset\n    ) internal returns (uint256 kissRepayAmount) {\n        // Update debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n        // Get the accrued interest in repayment token\n        (, kissRepayAmount) = self.getKreskoAssetDebtInterest(_account, _kreskoAsset);\n\n        // If no interest has accrued no further operations needed\n        // Do not revert because we want the preserve new debt index and stability rate\n        if (kissRepayAmount == 0) {\n            // Update stability rate for asset\n            irs().srAssets[_kreskoAsset].updateStabilityRate();\n            return 0;\n        }\n\n        // Transfer the accrued interest\n        IERC20Permit(irs().kiss).safeTransferFrom(msg.sender, self.feeRecipient, kissRepayAmount);\n\n        // Update scaled values for the user\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled = uint128(\n            self.getKreskoAssetDebtPrincipal(_account, _kreskoAsset).wadToRay().rayDiv(newDebtIndex)\n        );\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n\n        // Remove from minted kresko assets if debt is cleared\n        if (self.getKreskoAssetDebtPrincipal(_account, _kreskoAsset) == 0) {\n            self.mintedKreskoAssets[_account].removeAddress(\n                _kreskoAsset,\n                self.getMintedKreskoAssetsIndex(_account, _kreskoAsset)\n            );\n        }\n\n        // Update stability rates\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n        // Emit event with the account, asset and amount repaid\n        emit InterestRateEvent.StabilityRateInterestRepaid(_account, _kreskoAsset, kissRepayAmount);\n    }\n\n    /**\n     * @notice Charges the protocol close fee based off the value of the burned asset.\n     * @dev Takes the fee from the account's collateral assets. Attempts collateral assets\n     *   in reverse order of the account's deposited collateral assets array.\n     * @param _account The account to charge the close fee from.\n     * @param _kreskoAsset The address of the kresko asset being burned.\n     * @param _burnAmount The amount of the kresko asset being burned.\n     */\n    function chargeCloseFee(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset,\n        uint256 _burnAmount\n    ) internal {\n        KrAsset memory krAsset = self.kreskoAssets[_kreskoAsset];\n        // Calculate the value of the fee according to the value of the krAssets being burned.\n        uint256 feeValue = krAsset.uintUSD(_burnAmount, self.oracleDeviationPct).wadMul(krAsset.closeFee);\n\n        // Do nothing if the fee value is 0.\n        if (feeValue == 0) {\n            return;\n        }\n\n        address[] memory accountCollateralAssets = self.depositedCollateralAssets[_account];\n        // Iterate backward through the account's deposited collateral assets to safely\n        // traverse the array while still being able to remove elements if necessary.\n        // This is because removing the last element of the array does not shift around\n        // other elements in the array.\n\n        for (uint256 i = accountCollateralAssets.length - 1; i >= 0; i--) {\n            address collateralAssetAddress = accountCollateralAssets[i];\n\n            (uint256 transferAmount, uint256 feeValuePaid) = self.calcFee(\n                collateralAssetAddress,\n                _account,\n                feeValue,\n                i\n            );\n\n            // Remove the transferAmount from the stored deposit for the account.\n            self.collateralDeposits[_account][collateralAssetAddress] -= self\n                .collateralAssets[collateralAssetAddress]\n                .toNonRebasingAmount(transferAmount);\n\n            // Transfer the fee to the feeRecipient.\n            IERC20Permit(collateralAssetAddress).safeTransfer(self.feeRecipient, transferAmount);\n            emit MinterEvent.CloseFeePaid(_account, collateralAssetAddress, transferAmount, feeValuePaid);\n\n            feeValue = feeValue - feeValuePaid;\n            // If the entire fee has been paid, no more action needed.\n            if (feeValue == 0) {\n                return;\n            }\n        }\n    }\n\n    /**\n     * @notice Check that debt repaid does not leave a dust position, if it does:\n     * return an amount that pays up to minDebtValue\n     * @param _kreskoAsset The address of the kresko asset being burned.\n     * @param _burnAmount The amount being burned\n     * @param _debtAmount The debt amount of `_account`\n     * @return amount == 0 or >= minDebtAmount\n     */\n    function ensureNotDustPosition(\n        MinterState storage self,\n        address _kreskoAsset,\n        uint256 _burnAmount,\n        uint256 _debtAmount\n    ) internal view returns (uint256 amount) {\n        // If the requested burn would put the user's debt position below the minimum\n        // debt value, close up to the minimum debt value instead.\n        uint256 krAssetValue = self.getKrAssetValue(_kreskoAsset, _debtAmount - _burnAmount, true);\n        if (krAssetValue > 0 && krAssetValue < self.minimumDebtValue) {\n            uint256 minDebtValue = self.minimumDebtValue.wadDiv(\n                self.kreskoAssets[_kreskoAsset].uintPrice(self.oracleDeviationPct)\n            );\n            amount = _debtAmount - minDebtValue;\n        } else {\n            amount = _burnAmount;\n        }\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibCalculation.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {MinterState} from \"../MinterState.sol\";\nimport {KrAsset, CollateralAsset, Constants} from \"../MinterTypes.sol\";\n\n/**\n * @title Calculation library for liquidation & fee values\n * @author Kresko\n */\nlibrary LibCalculation {\n    struct MaxLiquidationVars {\n        CollateralAsset collateral;\n        uint256 accountCollateralValue;\n        uint256 minCollateralValue;\n        uint256 seizeCollateralAccountValue;\n        uint256 maxLiquidationMultiplier;\n        uint256 minimumDebtValue;\n        uint256 liquidationThreshold;\n        uint256 debtFactor;\n    }\n\n    using Arrays for address[];\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n\n    /**\n     * @dev Calculates the total value that can be liquidated for a liquidation pair\n     * @param _account address to liquidate\n     * @param _repayKreskoAsset address of the kreskoAsset being repaid on behalf of the liquidatee\n     * @param _seizedCollateral The collateral asset being seized in the liquidation\n     * @return maxLiquidatableUSD USD value that can be liquidated, 0 if the pair has no liquidatable value\n     */\n    function getMaxLiquidation(\n        MinterState storage self,\n        address _account,\n        KrAsset memory _repayKreskoAsset,\n        address _seizedCollateral\n    ) internal view returns (uint256 maxLiquidatableUSD) {\n        MaxLiquidationVars memory vars = _getMaxLiquidationParams(self, _account, _repayKreskoAsset, _seizedCollateral);\n        // Account is not liquidatable\n        if (vars.accountCollateralValue >= (vars.minCollateralValue)) {\n            return 0;\n        }\n\n        maxLiquidatableUSD = _getMaxLiquidatableUSD(vars, _repayKreskoAsset);\n\n        if (vars.seizeCollateralAccountValue < maxLiquidatableUSD) {\n            return vars.seizeCollateralAccountValue;\n        } else if (maxLiquidatableUSD < vars.minimumDebtValue) {\n            return vars.minimumDebtValue;\n        }\n        return maxLiquidatableUSD;\n    }\n\n    /**\n     * @notice Calculate amount of collateral to seize during the liquidation procesself.\n     * @param _liquidationIncentiveMultiplier The liquidation incentive multiplier.\n     * @param _collateralOraclePriceUSD The address of the collateral asset to be seized.\n     * @param _kreskoAssetRepayAmountUSD Kresko asset amount being repaid in exchange for the seized collateral.\n     */\n    function calculateAmountToSeize(\n        uint256 _liquidationIncentiveMultiplier,\n        uint256 _collateralOraclePriceUSD,\n        uint256 _kreskoAssetRepayAmountUSD\n    ) internal pure returns (uint256) {\n        // Seize amount = (repay amount USD * liquidation incentive / collateral price USD).\n        // Denominate seize amount in collateral type\n        // Apply liquidation incentive multiplier\n        return _kreskoAssetRepayAmountUSD.wadMul(_liquidationIncentiveMultiplier).wadDiv(_collateralOraclePriceUSD);\n    }\n\n    /**\n     * @notice Calculates the fee to be taken from a user's deposited collateral asset.\n     * @param _collateralAsset The collateral asset from which to take to the fee.\n     * @param _account The owner of the collateral.\n     * @param _feeValue The original value of the fee.\n     * @param _collateralAssetIndex The collateral asset's index in the user's depositedCollateralAssets array.\n     *\n     * @return transferAmount to be received as a uint256\n     * @return feeValuePaid wad representing the fee value paid.\n     */\n    function calcFee(\n        MinterState storage self,\n        address _collateralAsset,\n        address _account,\n        uint256 _feeValue,\n        uint256 _collateralAssetIndex\n    ) internal returns (uint256 transferAmount, uint256 feeValuePaid) {\n        uint256 depositAmount = self.getCollateralDeposits(_account, _collateralAsset);\n\n        // Don't take the collateral asset's collateral factor into consideration.\n        (uint256 depositValue, uint256 oraclePrice) = self.getCollateralValueAndOraclePrice(\n            _collateralAsset,\n            depositAmount,\n            true\n        );\n\n        // If feeValue < depositValue, the entire fee can be charged for this collateral asset.\n        if (_feeValue < depositValue) {\n            transferAmount = self.collateralAssets[_collateralAsset].decimals.fromWad(_feeValue.wadDiv(oraclePrice));\n            feeValuePaid = _feeValue;\n        } else {\n            // If the feeValue >= depositValue, the entire deposit\n            // should be taken as the fee.\n            transferAmount = depositAmount;\n            feeValuePaid = depositValue;\n        }\n\n        if (transferAmount == depositAmount) {\n            // Because the entire deposit is taken, remove it from the depositCollateralAssets array.\n            self.depositedCollateralAssets[_account].removeAddress(_collateralAsset, _collateralAssetIndex);\n        }\n\n        return (transferAmount, feeValuePaid);\n    }\n\n    /**\n     * @notice Calculates the maximum USD value of a given kreskoAsset that can be liquidated given a liquidation pair\n     *\n     * 1. Calculates the value gained per USD repaid in liquidation for a given kreskoAsset\n     *\n     * debtFactor = debtFactor = k * LT / cFactor;\n     *\n     * valPerUSD = (DebtFactor - Asset closeFee - liquidationIncentive) / DebtFactor\n     *\n     * 2. Calculates the maximum amount of USD value that can be liquidated given the account's collateral value\n     *\n     * maxLiquidatableUSD = (MCV - ACV) / valPerUSD / debtFactor / cFactor * LOM\n     *\n     * @dev This function is used by getMaxLiquidation and is factored out for readability\n     * @param vars liquidation variables struct\n     * @param _repayKreskoAsset The kreskoAsset being repaid in the liquidation\n     */\n    function _getMaxLiquidatableUSD(\n        MaxLiquidationVars memory vars,\n        KrAsset memory _repayKreskoAsset\n    ) private pure returns (uint256) {\n        uint256 valuePerUSDRepaid = (vars.debtFactor -\n            vars.collateral.liquidationIncentive -\n            _repayKreskoAsset.closeFee).wadDiv(vars.debtFactor);\n        return\n            (vars.minCollateralValue - vars.accountCollateralValue)\n                .wadMul(vars.maxLiquidationMultiplier)\n                .wadDiv(valuePerUSDRepaid)\n                .wadDiv(vars.debtFactor)\n                .wadDiv(vars.collateral.factor);\n    }\n\n    function _getMaxLiquidationParams(\n        MinterState storage state,\n        address _account,\n        KrAsset memory _repayKreskoAsset,\n        address _seizedCollateral\n    ) private view returns (MaxLiquidationVars memory) {\n        uint256 liquidationThreshold = state.liquidationThreshold;\n        uint256 minCollateralValue = state.getAccountMinimumCollateralValueAtRatio(_account, liquidationThreshold);\n\n        (uint256 accountCollateralValue, uint256 seizeCollateralAccountValue) = state.getAccountCollateralValue(\n            _account,\n            _seizedCollateral\n        );\n\n        CollateralAsset memory collateral = state.collateralAssets[_seizedCollateral];\n\n        return\n            MaxLiquidationVars({\n                collateral: collateral,\n                accountCollateralValue: accountCollateralValue,\n                debtFactor: _repayKreskoAsset.kFactor.wadMul(liquidationThreshold).wadDiv(collateral.factor),\n                minCollateralValue: minCollateralValue,\n                minimumDebtValue: state.minimumDebtValue,\n                seizeCollateralAccountValue: seizeCollateralAccountValue,\n                liquidationThreshold: liquidationThreshold,\n                maxLiquidationMultiplier: state.maxLiquidationMultiplier\n            });\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibCollateral.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {IKreskoAssetAnchor} from \"../../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {CollateralAsset, Constants} from \"../MinterTypes.sol\";\nimport {MinterState} from \"../MinterState.sol\";\n\n/**\n * @title Library for collateral related operations\n * @author Kresko\n */\nlibrary LibCollateral {\n    using LibDecimals for uint8;\n    using Arrays for address[];\n    using WadRay for uint256;\n\n    /**\n     * In case a collateral asset is also a kresko asset, convert an amount to anchor shares\n     * @param _amount amount to possibly convert\n     * @param _collateralAsset address of the collateral asset\n     */\n    function normalizeCollateralAmount(\n        MinterState storage self,\n        uint256 _amount,\n        address _collateralAsset\n    ) internal view returns (uint256 amount) {\n        CollateralAsset memory asset = self.collateralAssets[_collateralAsset];\n        if (asset.anchor != address(0)) {\n            return IKreskoAssetAnchor(asset.anchor).convertToShares(_amount);\n        }\n        return _amount;\n    }\n\n    /**\n     * @notice Get the state of a specific collateral asset\n     * @param _asset Address of the asset.\n     * @return State of assets `CollateralAsset` struct\n     */\n    function collateralAsset(MinterState storage self, address _asset) internal view returns (CollateralAsset memory) {\n        return self.collateralAssets[_asset];\n    }\n\n    /**\n     * @notice Gets the collateral value for a single collateral asset and amount.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _amount The amount of the collateral asset to calculate the collateral value for.\n     * @param _ignoreCollateralFactor Boolean indicating if the asset's collateral factor should be ignored.\n     * @return The collateral value for the provided amount of the collateral asset.\n     */\n    function getCollateralValueAndOraclePrice(\n        MinterState storage self,\n        address _collateralAsset,\n        uint256 _amount,\n        bool _ignoreCollateralFactor\n    ) internal view returns (uint256, uint256) {\n        CollateralAsset memory asset = self.collateralAssets[_collateralAsset];\n\n        uint256 oraclePrice = asset.uintPrice(self.oracleDeviationPct);\n        uint256 value = asset.decimals.toWad(_amount).wadMul(oraclePrice);\n\n        if (!_ignoreCollateralFactor) {\n            value = value.wadMul(asset.factor);\n        }\n        return (value, oraclePrice);\n    }\n\n    /**\n     * @notice verifies that the account has sufficient collateral for the requested amount and records the collateral\n     * @param _account The address of the account to verify the collateral for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\n     * @param _collateralDeposits Collateral deposits for the account.\n     * @param _depositedCollateralAssetIndex Index of the collateral asset in the account's deposited collateral assets array.\n     */\n    function verifyAndRecordCollateralWithdrawal(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _collateralDeposits,\n        uint256 _depositedCollateralAssetIndex\n    ) internal {\n        require(_withdrawAmount > 0, Error.ZERO_WITHDRAW);\n        require(\n            _depositedCollateralAssetIndex <= self.depositedCollateralAssets[_account].length - 1,\n            Error.ARRAY_OUT_OF_BOUNDS\n        );\n\n        // Ensure that the operation passes checks MCR checks\n        verifyAccountCollateral(self, _account, _collateralAsset, _withdrawAmount);\n\n        uint256 newCollateralAmount = _collateralDeposits - _withdrawAmount;\n\n        // If the collateral asset is also a kresko asset, ensure that the deposit amount is above the minimum.\n        // This is done because kresko assets can be rebased.\n        if (self.collateralAssets[_collateralAsset].anchor != address(0)) {\n            require(\n                newCollateralAmount >= Constants.MIN_KRASSET_COLLATERAL_AMOUNT || newCollateralAmount == 0,\n                Error.COLLATERAL_AMOUNT_TOO_LOW\n            );\n        }\n\n        // If the user is withdrawing all of the collateral asset, remove the collateral asset\n        // from the user's deposited collateral assets array.\n        if (newCollateralAmount == 0) {\n            self.depositedCollateralAssets[_account].removeAddress(_collateralAsset, _depositedCollateralAssetIndex);\n        }\n\n        // Record the withdrawal.\n        self.collateralDeposits[_account][_collateralAsset] = self\n            .collateralAssets[_collateralAsset]\n            .toNonRebasingAmount(newCollateralAmount);\n\n        emit MinterEvent.CollateralWithdrawn(_account, _collateralAsset, _withdrawAmount);\n    }\n\n    /**\n     * @notice Records account as having deposited an amount of a collateral asset.\n     * @dev Token transfers are expected to be done by the caller.\n     * @param _account The address of the collateral asset.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _depositAmount The amount of the collateral asset deposited.\n     */\n    function recordCollateralDeposit(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _depositAmount\n    ) internal {\n        // Because the depositedCollateralAssets[_account] is pushed to if the existing\n        // deposit amount is 0, require the amount to be > 0. Otherwise, the depositedCollateralAssets[_account]\n        // could be filled with duplicates, causing collateral to be double-counted in the collateral value.\n        require(_depositAmount > 0, Error.ZERO_DEPOSIT);\n\n        // If the account does not have an existing deposit for this collateral asset,\n        // push it to the list of the account's deposited collateral assets.\n        uint256 existingCollateralAmount = self.getCollateralDeposits(_account, _collateralAsset);\n\n        if (existingCollateralAmount == 0) {\n            self.depositedCollateralAssets[_account].push(_collateralAsset);\n        }\n\n        uint256 newCollateralAmount = existingCollateralAmount + _depositAmount;\n\n        // If the collateral asset is also a kresko asset, ensure that the deposit amount is above the minimum.\n        // This is done because kresko assets can be rebased.\n        if (self.collateralAssets[_collateralAsset].anchor != address(0)) {\n            require(\n                newCollateralAmount >= Constants.MIN_KRASSET_COLLATERAL_AMOUNT || newCollateralAmount == 0,\n                Error.COLLATERAL_AMOUNT_TOO_LOW\n            );\n        }\n\n        // Record the deposit.\n        unchecked {\n            self.collateralDeposits[_account][_collateralAsset] = self\n                .collateralAssets[_collateralAsset]\n                .toNonRebasingAmount(newCollateralAmount);\n        }\n\n        emit MinterEvent.CollateralDeposited(_account, _collateralAsset, _depositAmount);\n    }\n\n    /**\n     * @notice records the collateral withdrawal\n     * @param _account The address of the account to verify the collateral for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\n     * @param _collateralDeposits Collateral deposits for the account.\n     * @param _depositedCollateralAssetIndex Index of the collateral asset in the account's deposited collateral assets array.\n     */\n    function recordCollateralWithdrawal(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount,\n        uint256 _collateralDeposits,\n        uint256 _depositedCollateralAssetIndex\n    ) internal {\n        require(_withdrawAmount > 0, Error.ZERO_WITHDRAW);\n        require(\n            _depositedCollateralAssetIndex <= self.depositedCollateralAssets[_account].length - 1,\n            Error.ARRAY_OUT_OF_BOUNDS\n        );\n        // ensure that the handler does not attempt to withdraw more collateral than the account has\n        require(_collateralDeposits >= _withdrawAmount, Error.COLLATERAL_INSUFFICIENT_AMOUNT);\n\n        uint256 newCollateralAmount = _collateralDeposits - _withdrawAmount;\n\n        // If the collateral asset is also a kresko asset, ensure that the deposit amount is above the minimum.\n        // This is done because kresko assets can be rebased.\n        if (self.collateralAssets[_collateralAsset].anchor != address(0)) {\n            require(\n                newCollateralAmount >= Constants.MIN_KRASSET_COLLATERAL_AMOUNT || newCollateralAmount == 0,\n                Error.COLLATERAL_AMOUNT_TOO_LOW\n            );\n        }\n\n        // If the user is withdrawing all of the collateral asset, remove the collateral asset\n        // from the user's deposited collateral assets array.\n        if (newCollateralAmount == 0) {\n            self.depositedCollateralAssets[_account].removeAddress(_collateralAsset, _depositedCollateralAssetIndex);\n        }\n\n        // Record the withdrawal.\n        self.collateralDeposits[_account][_collateralAsset] = self\n            .collateralAssets[_collateralAsset]\n            .toNonRebasingAmount(newCollateralAmount);\n\n        emit MinterEvent.UncheckedCollateralWithdrawn(_account, _collateralAsset, _withdrawAmount);\n    }\n\n    /**\n     * @notice verifies that the account collateral\n     * @param _account The address of the account to verify the collateral for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _withdrawAmount The amount of the collateral asset to withdraw.\n     */\n    function verifyAccountCollateral(\n        MinterState storage self,\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawAmount\n    ) internal view {\n        // Ensure the withdrawal does not result in the account having a collateral value\n        // under the minimum collateral amount required to maintain a healthy position.\n        // I.e. the new account's collateral value must still exceed the account's minimum\n        // collateral value.\n        // Get the account's current collateral value.\n        uint256 accountCollateralValue = self.getAccountCollateralValue(_account);\n        // Get the collateral value that the account will lose as a result of this withdrawal.\n        (uint256 withdrawnCollateralValue, ) = self.getCollateralValueAndOraclePrice(\n            _collateralAsset,\n            _withdrawAmount,\n            false // Take the collateral factor into consideration.\n        );\n        // Get the account's minimum collateral value.\n        uint256 accountMinCollateralValue = self.getAccountMinimumCollateralValueAtRatio(\n            _account,\n            self.minimumCollateralizationRatio\n        );\n        // Require accountMinCollateralValue <= accountCollateralValue - withdrawnCollateralValue.\n        require(\n            accountMinCollateralValue <= accountCollateralValue - withdrawnCollateralValue,\n            Error.COLLATERAL_INSUFFICIENT_AMOUNT\n        );\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibDecimals.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\nimport {ms} from \"../MinterStorage.sol\";\n\n/**\n * @title Library for Kresko specific decimals\n */\nlibrary LibDecimals {\n    /**\n     * @notice For a given collateral asset and amount, returns a wad represenatation.\n     * @dev If the collateral asset has decimals other than 18, the amount is scaled appropriately.\n     *   If decimals > 18, there may be a loss of precision.\n     * @param _decimals The collateral asset's number of decimals\n     * @param _amount The amount of the collateral asset.\n     * @return A fp of amount scaled according to the collateral asset's decimals.\n     */\n    function toWad(uint256 _decimals, uint256 _amount) internal pure returns (uint256) {\n        // Initially, use the amount as the raw value for the fixed point.\n        // which internally uses 18 decimals.\n        // Most collateral assets will have 18 decimals.\n\n        // Handle cases where the collateral asset's decimal amount is not 18.\n        if (_decimals < 18) {\n            // If the decimals are less than 18, multiply the amount\n            // to get the correct wad value.\n            // E.g. 1 full token of a 17 decimal token will  cause the\n            // initial setting of amount to be 0.1, so we multiply\n            // by 10 ** (18 - 17) = 10 to get it to 0.1 * 10 = 1.\n            return _amount * (10 ** (18 - _decimals));\n        } else if (_decimals > 18) {\n            // If the decimals are greater than 18, divide the amount\n            // to get the correct fixed point value.\n            // Note because wad numbers are 18 decimals, this results\n            // in loss of precision. E.g. if the collateral asset has 19\n            // decimals and the deposit amount is only 1 uint, this will divide\n            // 1 by 10 ** (19 - 18), resulting in 1 / 10 = 0\n            return _amount / (10 ** (_decimals - 18));\n        }\n        return _amount;\n    }\n\n    /**\n     * @notice For a given collateral asset and wad amount, returns the collateral amount.\n     * @dev If the collateral asset has decimals other than 18, the amount is scaled appropriately.\n     *   If decimals < 18, there may be a loss of precision.\n     * @param _decimals The collateral asset's number of decimals\n     * @param _wadAmount The wad amount of the collateral asset.\n     * @return An amount that is compatible with the collateral asset's decimals.\n     */\n    function fromWad(uint256 _decimals, uint256 _wadAmount) internal pure returns (uint256) {\n        // Initially, use the rawValue, which internally uses 18 decimals.\n        // Most collateral assets will have 18 decimals.\n        // Handle cases where the collateral asset's decimal amount is not 18.\n        if (_decimals < 18) {\n            // If the decimals are less than 18, divide the depositAmount\n            // to get the correct collateral amount.\n            // E.g. 1 full token will result in amount being 1e18 at this point,\n            // so if the token has 17 decimals, divide by 10 ** (18 - 17) = 10\n            // to get a value of 1e17.\n            // This may result in a loss of precision.\n            return _wadAmount / (10 ** (18 - _decimals));\n        } else if (_decimals > 18) {\n            // If the decimals are greater than 18, multiply the depositAmount\n            // to get the correct fixed point value.\n            // E.g. 1 full token will result in amount being 1e18 at this point,\n            // so if the token has 19 decimals, multiply by 10 ** (19 - 18) = 10\n            // to get a value of 1e19.\n            return _wadAmount * (10 ** (_decimals - 18));\n        }\n        return _wadAmount;\n    }\n\n    /**\n     * @notice Divides an uint256 @param _value with @param _priceWithOracleDecimals\n     * @param _value Left side value of the division\n     * @param wadValue result with 18 decimals\n     */\n    function divByPrice(uint256 _value, uint256 _priceWithOracleDecimals) internal view returns (uint256 wadValue) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals >= 18) return _priceWithOracleDecimals;\n        return (_value * 10 ** oracleDecimals) / _priceWithOracleDecimals;\n    }\n\n    /**\n     * @notice Converts an uint256 with extOracleDecimals into a number with 18 decimals\n     * @param _wadPrice value with extOracleDecimals\n     */\n    function fromWadPriceToUint(uint256 _wadPrice) internal view returns (uint256 priceWithOracleDecimals) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals == 18) return _wadPrice;\n        return _wadPrice / 10 ** (18 - oracleDecimals);\n    }\n\n    /**\n     * @notice Converts an uint256 with extOracleDecimals into a number with 18 decimals\n     * @param _priceWithOracleDecimals value with extOracleDecimals\n     * @return wadPrice with 18 decimals\n     */\n    function oraclePriceToWad(uint256 _priceWithOracleDecimals) internal view returns (uint256) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals == 18) {\n            return _priceWithOracleDecimals;\n        }\n        return _priceWithOracleDecimals * 10 ** (18 - oracleDecimals);\n    }\n\n    /**\n     * @notice Converts an int256 with extOracleDecimals into a number with 18 decimals\n     * @param _priceWithOracleDecimals value with extOracleDecimals\n     * @return wadPrice price with 18 decimals\n     */\n    function oraclePriceToWad(int256 _priceWithOracleDecimals) internal view returns (uint256) {\n        uint8 oracleDecimals = ms().extOracleDecimals;\n        if (oracleDecimals >= 18) return uint256(_priceWithOracleDecimals);\n        return uint256(_priceWithOracleDecimals) * 10 ** (18 - oracleDecimals);\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibKrAsset.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {IUniswapV2OracleCompat} from \"../amm-oracle/IUniswapV2OracleCompat.sol\";\nimport {KrAsset} from \"../MinterTypes.sol\";\nimport {MinterState} from \"../MinterState.sol\";\n\nlibrary LibKrAsset {\n    using WadRay for uint256;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Functions                                 */\n    /* -------------------------------------------------------------------------- */\n    /**\n     * @notice Get the state of a specific krAsset\n     * @param _asset Address of the asset.\n     * @return State of assets `KrAsset` struct\n     */\n    function kreskoAsset(MinterState storage self, address _asset) internal view returns (KrAsset memory) {\n        return self.kreskoAssets[_asset];\n    }\n\n    /**\n     * @notice Gets the USD value for a single Kresko asset and amount.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _amount The amount of the Kresko asset to calculate the value for.\n     * @param _ignoreKFactor Boolean indicating if the asset's k-factor should be ignored.\n     * @return The value for the provided amount of the Kresko asset.\n     */\n    function getKrAssetValue(\n        MinterState storage self,\n        address _kreskoAsset,\n        uint256 _amount,\n        bool _ignoreKFactor\n    ) internal view returns (uint256) {\n        KrAsset memory krAsset = self.kreskoAssets[_kreskoAsset];\n        uint256 value = krAsset.uintUSD(_amount, self.oracleDeviationPct);\n\n        if (!_ignoreKFactor) {\n            value = value.wadMul(krAsset.kFactor);\n        }\n\n        return value;\n    }\n\n    /**\n     * @notice Gets the AMM price for a Kresko asset.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _amount The amount of the Kresko asset to calculate the value for.\n     * @return The value for the provided amount of the Kresko asset.\n     */\n    function getKrAssetAMMPrice(\n        MinterState storage self,\n        address _kreskoAsset,\n        uint256 _amount\n    ) internal view returns (uint256) {\n        if (self.ammOracle == address(0)) {\n            return 0;\n        }\n        return IUniswapV2OracleCompat(self.ammOracle).consultKrAsset(_kreskoAsset, _amount);\n    }\n\n    /**\n     * @notice Get the minimum collateral value required to\n     * back a Kresko asset amount at a given collateralization ratio.\n     * @param _krAsset The address of the Kresko asset.\n     * @param _amount The Kresko Asset debt amount.\n     * @return minCollateralValue is the minimum collateral value required for this Kresko Asset amount.\n     * @param _ratio The collateralization ratio required: higher ratio = more collateral required.\n     */\n    function getMinimumCollateralValueAtRatio(\n        MinterState storage self,\n        address _krAsset,\n        uint256 _amount,\n        uint256 _ratio\n    ) internal view returns (uint256 minCollateralValue) {\n        // Calculate the collateral value required to back this Kresko asset amount at the given ratio\n        return self.getKrAssetValue(_krAsset, _amount, false).wadMul(_ratio);\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibMint.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n// solhint-disable not-rely-on-time\n// solhint-disable-next-line\nimport {SafeERC20, IERC20Permit} from \"../../shared/SafeERC20.sol\";\nimport {IKreskoAssetIssuer} from \"../../kreskoasset/IKreskoAssetIssuer.sol\";\nimport {Arrays} from \"../../libs/Arrays.sol\";\nimport {MinterEvent} from \"../../libs/Events.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\n\nimport {LibCalculation} from \"./LibCalculation.sol\";\nimport {KrAsset} from \"../MinterTypes.sol\";\nimport {MinterState} from \"../MinterState.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\nlibrary LibMint {\n    using Arrays for address[];\n\n    using LibDecimals for uint8;\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n\n    using SafeERC20 for IERC20Permit;\n    using LibCalculation for MinterState;\n\n    /// @notice Mint kresko assets with stability rate updates.\n    /// @dev Updates the principal in MinterState and stability rate adjusted values in InterestRateState\n    /// @param _kreskoAsset the asset being repaid\n    /// @param _anchor the anchor token of the asset being repaid\n    /// @param _amount the asset amount being minted\n    /// @param _account the account the debt is subtracted from\n    function mint(\n        MinterState storage self,\n        address _kreskoAsset,\n        address _anchor,\n        uint256 _amount,\n        address _account\n    ) internal {\n        // Update global debt index for the asset\n        uint256 newDebtIndex = irs().srAssets[_kreskoAsset].updateDebtIndex();\n        // Get possibly rebalanced amount of kresko asset\n        uint256 issued = IKreskoAssetIssuer(_anchor).issue(_amount, _account);\n        // Calculate debt index scaled value\n        uint256 amountScaled = issued.wadToRay().rayDiv(newDebtIndex);\n        require(amountScaled != 0, Error.INVALID_SCALED_AMOUNT);\n        // Increase principal debt\n        self.kreskoAssetDebt[_account][_kreskoAsset] += issued;\n        // Update scaled values for the user\n        irs().srUserInfo[_account][_kreskoAsset].debtScaled += uint128(amountScaled);\n        irs().srUserInfo[_account][_kreskoAsset].lastDebtIndex = uint128(newDebtIndex);\n        // Update the global rate for the asset\n        irs().srAssets[_kreskoAsset].updateStabilityRate();\n    }\n\n    /**\n     * @notice Charges the protocol open fee based off the value of the minted asset.\n     * @dev Takes the fee from the account's collateral assets. Attempts collateral assets\n     *   in reverse order of the account's deposited collateral assets array.\n     * @param _account The account to charge the open fee from.\n     * @param _kreskoAsset The address of the kresko asset being minted.\n     * @param _kreskoAssetAmountMinted The amount of the kresko asset being minted.\n     */\n    function chargeOpenFee(\n        MinterState storage self,\n        address _account,\n        address _kreskoAsset,\n        uint256 _kreskoAssetAmountMinted\n    ) internal {\n        KrAsset memory krAsset = self.kreskoAssets[_kreskoAsset];\n        // Calculate the value of the fee according to the value of the krAssets being minted.\n        uint256 feeValue = krAsset.uintUSD(_kreskoAssetAmountMinted, self.oracleDeviationPct).wadMul(krAsset.openFee);\n\n        // Do nothing if the fee value is 0.\n        if (feeValue == 0) {\n            return;\n        }\n\n        address[] memory accountCollateralAssets = self.depositedCollateralAssets[_account];\n        // Iterate backward through the account's deposited collateral assets to safely\n        // traverse the array while still being able to remove elements if necessary.\n        // This is because removing the last element of the array does not shift around\n        // other elements in the array.\n        for (uint256 i = accountCollateralAssets.length - 1; i >= 0; i--) {\n            address collateralAssetAddress = accountCollateralAssets[i];\n\n            (uint256 transferAmount, uint256 feeValuePaid) = self.calcFee(\n                collateralAssetAddress,\n                _account,\n                feeValue,\n                i\n            );\n\n            // Remove the transferAmount from the stored deposit for the account.\n            self.collateralDeposits[_account][collateralAssetAddress] -= self\n                .collateralAssets[collateralAssetAddress]\n                .toNonRebasingAmount(transferAmount);\n\n            // Transfer the fee to the feeRecipient.\n            IERC20Permit(collateralAssetAddress).safeTransfer(self.feeRecipient, transferAmount);\n            emit MinterEvent.OpenFeePaid(_account, collateralAssetAddress, transferAmount, feeValuePaid);\n\n            feeValue = feeValue - feeValuePaid;\n            // If the entire fee has been paid, no more action needed.\n            if (feeValue == 0) {\n                return;\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibRedstone.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {RedstoneDefaultsLib} from \"@redstone-finance/evm-connector/contracts/core/RedstoneDefaultsLib.sol\";\nimport {BitmapLib} from \"@redstone-finance/evm-connector/contracts/libs/BitmapLib.sol\";\nimport {SignatureLib} from \"@redstone-finance/evm-connector/contracts/libs/SignatureLib.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title The base contract with helpful constants\n * @author The Redstone Oracles team\n * @dev It mainly contains redstone-related values, which improve readability\n * of other contracts (e.g. CalldataExtractor and RedstoneConsumerBase)\n */\nlibrary RedstoneError {\n    // Error messages\n    error CalldataOverOrUnderFlow();\n    error IncorrectUnsignedMetadataSize();\n    error InsufficientNumberOfUniqueSigners(uint256 receivedSignersCount, uint256 requiredSignersCount);\n    error EachSignerMustProvideTheSameValue();\n    error EmptyCalldataPointersArr();\n    error InvalidCalldataPointer();\n    error CalldataMustHaveValidPayload();\n    error SignerNotAuthorised(address receivedSigner);\n}\n\n// === Abbreviations ===\n// BS - Bytes size\n// PTR - Pointer (memory location)\n// SIG - Signature\n\n// Solidity and YUL constants\nuint256 constant STANDARD_SLOT_BS = 32;\nuint256 constant FREE_MEMORY_PTR = 0x40;\nuint256 constant BYTES_ARR_LEN_VAR_BS = 32;\nuint256 constant FUNCTION_SIGNATURE_BS = 4;\nuint256 constant REVERT_MSG_OFFSET = 68; // Revert message structure described here: https://ethereum.stackexchange.com/a/66173/106364\nuint256 constant STRING_ERR_MESSAGE_MASK = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n\n// RedStone protocol consts\nuint256 constant SIG_BS = 65;\nuint256 constant TIMESTAMP_BS = 6;\nuint256 constant DATA_PACKAGES_COUNT_BS = 2;\nuint256 constant DATA_POINTS_COUNT_BS = 3;\nuint256 constant DATA_POINT_VALUE_BYTE_SIZE_BS = 4;\nuint256 constant DATA_POINT_SYMBOL_BS = 32;\nuint256 constant DEFAULT_DATA_POINT_VALUE_BS = 32;\nuint256 constant UNSIGNED_METADATA_BYTE_SIZE_BS = 3;\nuint256 constant REDSTONE_MARKER_BS = 9; // byte size of 0x000002ed57011e0000\nuint256 constant REDSTONE_MARKER_MASK = 0x0000000000000000000000000000000000000000000000000002ed57011e0000;\n\n// Derived values (based on consts)\nuint256 constant TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS = 104; // SIG_BS + DATA_POINTS_COUNT_BS + DATA_POINT_VALUE_BYTE_SIZE_BS + STANDARD_SLOT_BS\nuint256 constant DATA_PACKAGE_WITHOUT_DATA_POINTS_BS = 78; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS + SIG_BS\nuint256 constant DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS = 13; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS\nuint256 constant REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS = 41; // REDSTONE_MARKER_BS + STANDARD_SLOT_BS\n\nlibrary LibRedstone {\n    using SafeMath for uint256;\n\n    /**\n     * @dev This function can be used in a consumer contract to securely extract an\n     * oracle value for a given data feed id. Security is achieved by\n     * signatures verification, timestamp validation, and aggregating values\n     * from different authorised signers into a single numeric value. If any of the\n     * required conditions do not match, the function will revert.\n     * Note! This function expects that tx calldata contains redstone payload in the end\n     * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\n     * @param dataFeedId bytes32 value that uniquely identifies the data feed\n     * @return Extracted and verified numeric oracle value for the given data feed id\n     */\n    function getPrice(bytes32 dataFeedId) internal view returns (uint256) {\n        bytes32[] memory dataFeedIds = new bytes32[](1);\n        dataFeedIds[0] = dataFeedId;\n        return _securelyExtractOracleValuesFromTxMsg(dataFeedIds)[0];\n    }\n\n    function getAuthorisedSignerIndex(address signerAddress) internal pure returns (uint8) {\n        if (signerAddress == 0x926E370fD53c23f8B71ad2B3217b227E41A92b12) return 0;\n        if (signerAddress == 0x0C39486f770B26F5527BBBf942726537986Cd7eb) return 1;\n        // For testing hardhat signer 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 is authorised\n        // will be removed in production deployment\n        if (signerAddress == 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266) return 2;\n\n        revert RedstoneError.SignerNotAuthorised(signerAddress);\n    }\n\n    /**\n     * @dev This function can be used in a consumer contract to securely extract several\n     * numeric oracle values for a given array of data feed ids. Security is achieved by\n     * signatures verification, timestamp validation, and aggregating values\n     * from different authorised signers into a single numeric value. If any of the\n     * required conditions do not match, the function will revert.\n     * Note! This function expects that tx calldata contains redstone payload in the end\n     * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\n     * @param dataFeedIds An array of unique data feed identifiers\n     * @return An array of the extracted and verified oracle values in the same order\n     * as they are requested in the dataFeedIds array\n     */\n    function getPrices(bytes32[] memory dataFeedIds) internal view returns (uint256[] memory) {\n        return _securelyExtractOracleValuesFromTxMsg(dataFeedIds);\n    }\n\n    /**\n     * @dev This function may be overridden by the child consumer contract.\n     * It should validate the timestamp against the current time (block.timestamp)\n     * It should revert with a helpful message if the timestamp is not valid\n     * @param receivedTimestampMilliseconds Timestamp extracted from calldata\n     */\n    function validateTimestamp(uint256 receivedTimestampMilliseconds) internal view {\n        // For testing this function is disabled\n        // Uncomment this line to enable timestamp validation in prod\n        // RedstoneDefaultsLib.validateTimestamp(receivedTimestampMilliseconds);\n    }\n\n    /**\n     * @dev This function should be overridden by the child consumer contract.\n     * @return The minimum required value of unique authorised signers\n     */\n    function getUniqueSignersThreshold() internal pure returns (uint8) {\n        return 1;\n    }\n\n    /**\n     * @dev This function may be overridden by the child consumer contract.\n     * It should aggregate values from different signers to a single uint value.\n     * By default, it calculates the median value\n     * @param values An array of uint256 values from different signers\n     * @return Result of the aggregation in the form of a single number\n     */\n    function aggregateValues(uint256[] memory values) internal pure returns (uint256) {\n        return RedstoneDefaultsLib.aggregateValues(values);\n    }\n\n    /**\n     * @dev This is an internal helpful function for secure extraction oracle values\n     * from the tx calldata. Security is achieved by signatures verification, timestamp\n     * validation, and aggregating values from different authorised signers into a\n     * single numeric value. If any of the required conditions (e.g. too old timestamp or\n     * insufficient number of authorised signers) do not match, the function will revert.\n     *\n     * Note! You should not call this function in a consumer contract. You can use\n     * `getOracleNumericValuesFromTxMsg` or `getOracleNumericValueFromTxMsg` instead.\n     *\n     * @param dataFeedIds An array of unique data feed identifiers\n     * @return An array of the extracted and verified oracle values in the same order\n     * as they are requested in dataFeedIds array\n     */\n    function _securelyExtractOracleValuesFromTxMsg(\n        bytes32[] memory dataFeedIds\n    ) private view returns (uint256[] memory) {\n        // Initializing helpful variables and allocating memory\n        uint256[] memory uniqueSignerCountForDataFeedIds = new uint256[](dataFeedIds.length);\n        uint256[] memory signersBitmapForDataFeedIds = new uint256[](dataFeedIds.length);\n        uint256[][] memory valuesForDataFeeds = new uint256[][](dataFeedIds.length);\n        for (uint256 i = 0; i < dataFeedIds.length; i++) {\n            // The line below is commented because newly allocated arrays are filled with zeros\n            // But we left it for better readability\n            // signersBitmapForDataFeedIds[i] = 0; // <- setting to an empty bitmap\n            valuesForDataFeeds[i] = new uint256[](getUniqueSignersThreshold());\n        }\n\n        // Extracting the number of data packages from calldata\n        uint256 calldataNegativeOffset = _extractByteSizeOfUnsignedMetadata();\n        uint256 dataPackagesCount = _extractDataPackagesCountFromCalldata(calldataNegativeOffset);\n        calldataNegativeOffset += DATA_PACKAGES_COUNT_BS;\n\n        // Saving current free memory pointer\n        uint256 freeMemPtr;\n        assembly {\n            freeMemPtr := mload(FREE_MEMORY_PTR)\n        }\n\n        // Data packages extraction in a loop\n        for (uint256 dataPackageIndex = 0; dataPackageIndex < dataPackagesCount; dataPackageIndex++) {\n            // Extract data package details and update calldata offset\n            uint256 dataPackageByteSize = _extractDataPackage(\n                dataFeedIds,\n                uniqueSignerCountForDataFeedIds,\n                signersBitmapForDataFeedIds,\n                valuesForDataFeeds,\n                calldataNegativeOffset\n            );\n            calldataNegativeOffset += dataPackageByteSize;\n\n            // Shifting memory pointer back to the \"safe\" value\n            assembly {\n                mstore(FREE_MEMORY_PTR, freeMemPtr)\n            }\n        }\n\n        // Validating numbers of unique signers and calculating aggregated values for each dataFeedId\n        return _getAggregatedValues(valuesForDataFeeds, uniqueSignerCountForDataFeedIds);\n    }\n\n    /**\n     * @dev This is a private helpful function, which extracts data for a data package based\n     * on the given negative calldata offset, verifies them, and in the case of successful\n     * verification updates the corresponding data package values in memory\n     *\n     * @param dataFeedIds an array of unique data feed identifiers\n     * @param uniqueSignerCountForDataFeedIds an array with the numbers of unique signers\n     * for each data feed\n     * @param signersBitmapForDataFeedIds an array of signer bitmaps for data feeds\n     * @param valuesForDataFeeds 2-dimensional array, valuesForDataFeeds[i][j] contains\n     * j-th value for the i-th data feed\n     * @param calldataNegativeOffset negative calldata offset for the given data package\n     *\n     * @return An array of the aggregated values\n     */\n    function _extractDataPackage(\n        bytes32[] memory dataFeedIds,\n        uint256[] memory uniqueSignerCountForDataFeedIds,\n        uint256[] memory signersBitmapForDataFeedIds,\n        uint256[][] memory valuesForDataFeeds,\n        uint256 calldataNegativeOffset\n    ) private view returns (uint256) {\n        uint256 signerIndex;\n\n        (uint256 dataPointsCount, uint256 eachDataPointValueByteSize) = _extractDataPointsDetailsForDataPackage(\n            calldataNegativeOffset\n        );\n\n        // We use scopes to resolve problem with too deep stack\n        {\n            uint48 extractedTimestamp;\n            address signerAddress;\n            bytes32 signedHash;\n            bytes memory signedMessage;\n            uint256 signedMessageBytesCount;\n\n            signedMessageBytesCount =\n                dataPointsCount.mul(eachDataPointValueByteSize + DATA_POINT_SYMBOL_BS) +\n                DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS; //DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS\n\n            uint256 timestampCalldataOffset = msg.data.length.sub(\n                calldataNegativeOffset + TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS\n            );\n\n            uint256 signedMessageCalldataOffset = msg.data.length.sub(\n                calldataNegativeOffset + SIG_BS + signedMessageBytesCount\n            );\n\n            assembly {\n                // Extracting the signed message\n                signedMessage := extractBytesFromCalldata(signedMessageCalldataOffset, signedMessageBytesCount)\n\n                // Hashing the signed message\n                signedHash := keccak256(add(signedMessage, BYTES_ARR_LEN_VAR_BS), signedMessageBytesCount)\n\n                // Extracting timestamp\n                extractedTimestamp := calldataload(timestampCalldataOffset)\n\n                function initByteArray(bytesCount) -> ptr {\n                    ptr := mload(FREE_MEMORY_PTR)\n                    mstore(ptr, bytesCount)\n                    ptr := add(ptr, BYTES_ARR_LEN_VAR_BS)\n                    mstore(FREE_MEMORY_PTR, add(ptr, bytesCount))\n                }\n\n                function extractBytesFromCalldata(offset, bytesCount) -> extractedBytes {\n                    let extractedBytesStartPtr := initByteArray(bytesCount)\n                    calldatacopy(extractedBytesStartPtr, offset, bytesCount)\n                    extractedBytes := sub(extractedBytesStartPtr, BYTES_ARR_LEN_VAR_BS)\n                }\n            }\n\n            // Validating timestamp\n            validateTimestamp(extractedTimestamp);\n\n            // Verifying the off-chain signature against on-chain hashed data\n            signerAddress = SignatureLib.recoverSignerAddress(signedHash, calldataNegativeOffset + SIG_BS);\n            signerIndex = getAuthorisedSignerIndex(signerAddress);\n        }\n\n        // Updating helpful arrays\n        {\n            bytes32 dataPointDataFeedId;\n            uint256 dataPointValue;\n            for (uint256 dataPointIndex = 0; dataPointIndex < dataPointsCount; dataPointIndex++) {\n                // Extracting data feed id and value for the current data point\n                (dataPointDataFeedId, dataPointValue) = _extractDataPointValueAndDataFeedId(\n                    calldataNegativeOffset,\n                    eachDataPointValueByteSize,\n                    dataPointIndex\n                );\n\n                for (uint256 dataFeedIdIndex = 0; dataFeedIdIndex < dataFeedIds.length; dataFeedIdIndex++) {\n                    if (dataPointDataFeedId == dataFeedIds[dataFeedIdIndex]) {\n                        uint256 bitmapSignersForDataFeedId = signersBitmapForDataFeedIds[dataFeedIdIndex];\n\n                        if (\n                            !BitmapLib.getBitFromBitmap(\n                                bitmapSignersForDataFeedId,\n                                signerIndex\n                            ) /* current signer was not counted for current dataFeedId */ &&\n                            uniqueSignerCountForDataFeedIds[dataFeedIdIndex] < getUniqueSignersThreshold()\n                        ) {\n                            // Increase unique signer counter\n                            uniqueSignerCountForDataFeedIds[dataFeedIdIndex]++;\n\n                            // Add new value\n                            valuesForDataFeeds[dataFeedIdIndex][\n                                uniqueSignerCountForDataFeedIds[dataFeedIdIndex] - 1\n                            ] = dataPointValue;\n\n                            // Update signers bitmap\n                            signersBitmapForDataFeedIds[dataFeedIdIndex] = BitmapLib.setBitInBitmap(\n                                bitmapSignersForDataFeedId,\n                                signerIndex\n                            );\n                        }\n\n                        // Breaking, as there couldn't be several indexes for the same feed ID\n                        break;\n                    }\n                }\n            }\n        }\n\n        // Return total data package byte size\n        return\n            DATA_PACKAGE_WITHOUT_DATA_POINTS_BS + (eachDataPointValueByteSize + DATA_POINT_SYMBOL_BS) * dataPointsCount;\n    }\n\n    /**\n     * @dev This is a private helpful function, which aggregates values from different\n     * authorised signers for the given arrays of values for each data feed\n     *\n     * @param valuesForDataFeeds 2-dimensional array, valuesForDataFeeds[i][j] contains\n     * j-th value for the i-th data feed\n     * @param uniqueSignerCountForDataFeedIds an array with the numbers of unique signers\n     * for each data feed\n     *\n     * @return An array of the aggregated values\n     */\n    function _getAggregatedValues(\n        uint256[][] memory valuesForDataFeeds,\n        uint256[] memory uniqueSignerCountForDataFeedIds\n    ) private pure returns (uint256[] memory) {\n        uint256[] memory aggregatedValues = new uint256[](valuesForDataFeeds.length);\n        uint256 uniqueSignersThreshold = getUniqueSignersThreshold();\n\n        for (uint256 dataFeedIndex = 0; dataFeedIndex < valuesForDataFeeds.length; dataFeedIndex++) {\n            if (uniqueSignerCountForDataFeedIds[dataFeedIndex] < uniqueSignersThreshold) {\n                revert RedstoneError.InsufficientNumberOfUniqueSigners(\n                    uniqueSignerCountForDataFeedIds[dataFeedIndex],\n                    uniqueSignersThreshold\n                );\n            }\n            uint256 aggregatedValueForDataFeedId = aggregateValues(valuesForDataFeeds[dataFeedIndex]);\n            aggregatedValues[dataFeedIndex] = aggregatedValueForDataFeedId;\n        }\n\n        return aggregatedValues;\n    }\n\n    function _extractDataPointsDetailsForDataPackage(\n        uint256 calldataNegativeOffsetForDataPackage\n    ) private pure returns (uint256 dataPointsCount, uint256 eachDataPointValueByteSize) {\n        // Using uint24, because data points count byte size number has 3 bytes\n        uint24 dataPointsCount_;\n\n        // Using uint32, because data point value byte size has 4 bytes\n        uint32 eachDataPointValueByteSize_;\n\n        // Extract data points count\n        uint256 negativeCalldataOffset = calldataNegativeOffsetForDataPackage + SIG_BS;\n        uint256 calldataOffset = msg.data.length.sub(negativeCalldataOffset + STANDARD_SLOT_BS);\n        assembly {\n            dataPointsCount_ := calldataload(calldataOffset)\n        }\n\n        // Extract each data point value size\n        calldataOffset = calldataOffset.sub(DATA_POINTS_COUNT_BS);\n        assembly {\n            eachDataPointValueByteSize_ := calldataload(calldataOffset)\n        }\n\n        // Prepare returned values\n        dataPointsCount = dataPointsCount_;\n        eachDataPointValueByteSize = eachDataPointValueByteSize_;\n    }\n\n    function _extractByteSizeOfUnsignedMetadata() private pure returns (uint256) {\n        // Checking if the calldata ends with the RedStone marker\n        bool hasValidRedstoneMarker;\n        assembly {\n            let calldataLast32Bytes := calldataload(sub(calldatasize(), STANDARD_SLOT_BS))\n            hasValidRedstoneMarker := eq(REDSTONE_MARKER_MASK, and(calldataLast32Bytes, REDSTONE_MARKER_MASK))\n        }\n        if (!hasValidRedstoneMarker) {\n            revert RedstoneError.CalldataMustHaveValidPayload();\n        }\n\n        // Using uint24, because unsigned metadata byte size number has 3 bytes\n        uint24 unsignedMetadataByteSize;\n        if (REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS > msg.data.length) {\n            revert RedstoneError.CalldataOverOrUnderFlow();\n        }\n        assembly {\n            unsignedMetadataByteSize := calldataload(sub(calldatasize(), REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS))\n        }\n        uint256 calldataNegativeOffset = unsignedMetadataByteSize + UNSIGNED_METADATA_BYTE_SIZE_BS + REDSTONE_MARKER_BS;\n        if (calldataNegativeOffset + DATA_PACKAGES_COUNT_BS > msg.data.length) {\n            revert RedstoneError.IncorrectUnsignedMetadataSize();\n        }\n        return calldataNegativeOffset;\n    }\n\n    function _extractDataPackagesCountFromCalldata(\n        uint256 calldataNegativeOffset\n    ) private pure returns (uint16 dataPackagesCount) {\n        uint256 calldataNegativeOffsetWithStandardSlot = calldataNegativeOffset + STANDARD_SLOT_BS;\n        if (calldataNegativeOffsetWithStandardSlot > msg.data.length) {\n            revert RedstoneError.CalldataOverOrUnderFlow();\n        }\n        assembly {\n            dataPackagesCount := calldataload(sub(calldatasize(), calldataNegativeOffsetWithStandardSlot))\n        }\n        return dataPackagesCount;\n    }\n\n    function _extractDataPointValueAndDataFeedId(\n        uint256 calldataNegativeOffsetForDataPackage,\n        uint256 defaultDataPointValueByteSize,\n        uint256 dataPointIndex\n    ) private pure returns (bytes32 dataPointDataFeedId, uint256 dataPointValue) {\n        uint256 negativeOffsetToDataPoints = calldataNegativeOffsetForDataPackage + DATA_PACKAGE_WITHOUT_DATA_POINTS_BS;\n        uint256 dataPointNegativeOffset = negativeOffsetToDataPoints.add(\n            (1 + dataPointIndex).mul((defaultDataPointValueByteSize + DATA_POINT_SYMBOL_BS))\n        );\n        uint256 dataPointCalldataOffset = msg.data.length.sub(dataPointNegativeOffset);\n        assembly {\n            dataPointDataFeedId := calldataload(dataPointCalldataOffset)\n            dataPointValue := calldataload(add(dataPointCalldataOffset, DATA_POINT_SYMBOL_BS))\n        }\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibStabilityRate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IKreskoAsset} from \"../../kreskoasset/IKreskoAsset.sol\";\nimport {IERC20Permit} from \"../../shared/IERC20Permit.sol\";\n\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {LibKrAsset} from \"../libs/LibKrAsset.sol\";\n\nimport {StabilityRateConfig} from \"../InterestRateState.sol\";\nimport {ms} from \"../MinterStorage.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @author Kresko\n * @title AMM price stability rate library, derived from Aave Protocols VariableDebtToken calculations\n * @notice Library for performing stability rate related operations\n */\nlibrary LibStabilityRate {\n    using WadRay for uint256;\n    using WadRay for uint128;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /**\n     * @notice Cumulates the stability rate from previous update and multiplies the debt index with it.\n     * @dev Updates the updated timestamp\n     * @dev New debt index cannot overflow uint128\n     * @param self configuration for the asset\n     * @return newDebtIndex the updated index\n     */\n    function updateDebtIndex(StabilityRateConfig storage self) internal returns (uint256 newDebtIndex) {\n        if (self.asset == address(0)) return WadRay.RAY;\n\n        newDebtIndex = self.debtIndex;\n        // only cumulating if there is any assets minted and rate is over 0\n        if (IERC20Permit(self.asset).totalSupply() != 0) {\n            uint256 cumulatedStabilityRate = self.calculateCompoundedInterest(block.timestamp);\n            newDebtIndex = cumulatedStabilityRate.rayMul(self.debtIndex);\n            require(newDebtIndex <= type(uint128).max, Error.DEBT_INDEX_OVERFLOW);\n            self.debtIndex = uint128(newDebtIndex);\n        }\n\n        self.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /**\n     * @notice Updates the current stability rate for an asset\n     * @dev New stability rate cannot overflow uint128\n     * @param self rate configuration for the asset\n     */\n    function updateStabilityRate(StabilityRateConfig storage self) internal {\n        if (self.asset == address(0)) return;\n\n        uint256 stabilityRate = calculateStabilityRate(self);\n        require(stabilityRate <= type(uint128).max, Error.STABILITY_RATE_OVERFLOW);\n        self.stabilityRate = uint128(stabilityRate);\n    }\n\n    /**\n     * @notice Get the current price rate between AMM and oracle pricing\n     * @dev Raw return value of ammPrice == 0 when no AMM pair exists OR liquidity of the pair does not qualify\n     * @param self rate configuration for the asset\n     * @return priceRate the current price rate\n     */\n    function getPriceRate(StabilityRateConfig storage self) internal view returns (uint256 priceRate) {\n        uint256 oraclePrice = ms().getKrAssetValue(self.asset, 1 ether, true);\n        uint256 ammPrice = ms().getKrAssetAMMPrice(self.asset, 1 ether);\n        // no pair, no effect\n        if (ammPrice == 0) {\n            return 0;\n        }\n        return ammPrice.wadDiv(oraclePrice) / 10;\n    }\n\n    /**\n     * @notice Calculate new stability rate from the current price rate\n     * @dev Separate calculations exist for following cases:\n     * case 1: AMM premium < optimal\n     * case 2: AMM premium > optimal\n     * @param self rate configuration for the asset\n     * @return stabilityRate the current stability rate\n     */\n    function calculateStabilityRate(StabilityRateConfig storage self) internal view returns (uint256 stabilityRate) {\n        uint256 priceRate = self.getPriceRate(); // 0.95 RAY = -5% PREMIUM, 1.05 RAY = +5% PREMIUM\n        // Return base rate if no AMM price exists\n        if (priceRate == 0) {\n            return self.stabilityRateBase;\n        }\n        bool rateIsGTOptimal = priceRate > self.optimalPriceRate;\n\n        uint256 rateDiff = rateIsGTOptimal ? priceRate - self.optimalPriceRate : self.optimalPriceRate - priceRate;\n        uint256 rateDiffAdjusted = rateDiff.rayMul(self.rateSlope2.rayDiv(self.rateSlope1 + self.priceRateDelta));\n\n        if (!rateIsGTOptimal) {\n            // Case: AMM price is lower than priceRate\n            return self.stabilityRateBase + rateDiffAdjusted;\n        } else {\n            // Case: AMM price is higher than priceRate\n            return self.stabilityRateBase.rayDiv(WadRay.RAY + rateDiffAdjusted);\n        }\n    }\n\n    /**\n     * @dev Function to calculate the interest using a compounded interest rate formula\n     * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\n     *\n     *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n     *\n     * The approximation slightly underpays liquidity providers and undercharges borrowers\n     * with the advantage of great gas cost reductions\n     * The Aave whitepaper contains reference to the approximation\n     * with a table showing the margin of error per different time periods\n     *\n     * @param self rate configuration for the asset\n     * @param _currentTimestamp The timestamp of the last update of the interest\n     * @return The interest rate compounded during the timeDelta, in ray\n     **/\n    function calculateCompoundedInterest(\n        StabilityRateConfig storage self,\n        uint256 _currentTimestamp\n    ) internal view returns (uint256) {\n        //solium-disable-next-line\n        uint256 exp = _currentTimestamp - uint256(self.lastUpdateTimestamp);\n\n        if (exp == 0) {\n            return WadRay.RAY;\n        }\n\n        uint256 expMinusOne;\n        uint256 expMinusTwo;\n        uint256 basePowerTwo;\n        uint256 basePowerThree;\n        unchecked {\n            expMinusOne = exp - 1;\n\n            expMinusTwo = exp > 2 ? exp - 2 : 0;\n\n            basePowerTwo = self.stabilityRate.rayMul(self.stabilityRate) / (SECONDS_PER_YEAR * SECONDS_PER_YEAR);\n            basePowerThree = basePowerTwo.rayMul(self.stabilityRate) / SECONDS_PER_YEAR;\n        }\n\n        uint256 secondTerm = exp * expMinusOne * basePowerTwo;\n        unchecked {\n            secondTerm /= 2;\n        }\n        uint256 thirdTerm = exp * expMinusOne * expMinusTwo * basePowerThree;\n        unchecked {\n            thirdTerm /= 6;\n        }\n\n        return WadRay.RAY + (self.stabilityRate * exp) / SECONDS_PER_YEAR + secondTerm + thirdTerm;\n    }\n\n    /**\n     * @dev Returns the ongoing normalized debt index for the borrowers\n     * A value of 1e27 means there is no interest. As time passes, the interest is accrued\n     * A value of 2*1e27 means that for each unit of debt, one unit worth of interest has been accumulated\n     * @param self rate configuration for the asset\n     * @return The normalized debt index. expressed in ray\n     **/\n    function getNormalizedDebtIndex(StabilityRateConfig storage self) internal view returns (uint256) {\n        if (self.asset == address(0)) return WadRay.RAY;\n        //solium-disable-next-line\n        if (self.lastUpdateTimestamp == uint40(block.timestamp)) {\n            //if the index was updated in the same block, no need to perform any calculation\n            return self.debtIndex;\n        }\n\n        return self.calculateCompoundedInterest(block.timestamp).rayMul(self.debtIndex);\n    }\n}\n"
    },
    "src/contracts/minter/libs/LibUI.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\n// solhint-disable-next-line\nimport {IERC20Permit} from \"../../shared/IERC20Permit.sol\";\nimport {IFluxPriceFeed} from \"../../vendor/flux/interfaces/IFluxPriceFeed.sol\";\nimport {AggregatorV3Interface} from \"../../vendor/AggregatorV3Interface.sol\";\nimport {IUniswapV2Pair} from \"../../vendor/uniswap/v2-core/interfaces/IUniswapV2Pair.sol\";\nimport {IKrStaking} from \"../../staking/interfaces/IKrStaking.sol\";\nimport {LibDecimals} from \"../libs/LibDecimals.sol\";\nimport {WadRay} from \"../../libs/WadRay.sol\";\nimport {Error} from \"../../libs/Errors.sol\";\nimport {IUniswapV2OracleCompat} from \"../amm-oracle/IUniswapV2OracleCompat.sol\";\nimport {KrAsset, CollateralAsset} from \"../MinterTypes.sol\";\nimport {MinterState, ms} from \"../MinterStorage.sol\";\nimport {irs} from \"../InterestRateState.sol\";\n\n/* solhint-disable contract-name-camelcase */\n/* solhint-disable var-name-mixedcase */\n\n/**\n * @title Library for UI related views\n * @author Kresko\n */\nlibrary LibUI {\n    using LibDecimals for uint256;\n    using WadRay for uint256;\n\n    struct CollateralAssetInfoUser {\n        address assetAddress;\n        address oracleAddress;\n        address anchorAddress;\n        uint256 amount;\n        uint256 amountUSD;\n        uint256 cFactor;\n        uint256 liquidationIncentive;\n        uint8 decimals;\n        uint256 index;\n        uint256 price;\n        string symbol;\n        string name;\n    }\n\n    struct CollateralAssetInfo {\n        address assetAddress;\n        address oracleAddress;\n        address anchorAddress;\n        uint256 price;\n        uint256 value;\n        uint256 liquidationIncentive;\n        uint256 cFactor;\n        uint8 decimals;\n        string symbol;\n        string name;\n        bool marketOpen;\n    }\n\n    struct ProtocolParams {\n        uint256 minDebtValue;\n        uint256 minCollateralRatio;\n        uint256 liquidationThreshold;\n    }\n\n    struct krAssetInfo {\n        address oracleAddress;\n        address assetAddress;\n        address anchorAddress;\n        uint256 price;\n        uint256 ammPrice;\n        uint256 priceRate;\n        uint256 stabilityRate;\n        uint256 value;\n        uint256 openFee;\n        uint256 closeFee;\n        uint256 kFactor;\n        string symbol;\n        string name;\n        bool marketOpen;\n    }\n\n    struct KreskoUser {\n        krAssetInfoUser[] krAssets;\n        CollateralAssetInfoUser[] collateralAssets;\n        uint256 healthFactor;\n        uint256 debtActualUSD;\n        uint256 debtUSD;\n        uint256 collateralActualUSD;\n        uint256 collateralUSD;\n        uint256 minCollateralUSD;\n        uint256 borrowingPowerUSD;\n    }\n\n    struct PairData {\n        uint8 decimals0;\n        uint8 decimals1;\n        uint256 reserve0;\n        uint256 reserve1;\n        uint256 totalSupply;\n    }\n\n    struct GenericInfo {\n        address assetAddress;\n        uint256 kFactor;\n        uint256 cFactor;\n        uint256 price;\n        bool isKrAsset;\n        bool isCollateral;\n        uint256 debtAmount;\n        uint256 depositAmount;\n        uint256 walletBalance;\n    }\n\n    struct Price {\n        uint256 price;\n        uint256 timestamp;\n        address assetAddress;\n        uint80 roundId;\n        bool marketOpen;\n    }\n\n    struct Allowance {\n        address owner;\n        address spender;\n        uint256 allowance;\n    }\n\n    struct Balance {\n        address token;\n        uint256 balance;\n    }\n\n    struct TokenMetadata {\n        uint8 decimals;\n        string symbol;\n        string name;\n        uint256 totalSupply;\n    }\n\n    struct StakingData {\n        uint256 pid;\n        address depositToken;\n        uint256 totalDeposits;\n        uint256 allocPoint;\n        uint256 rewardPerBlocks;\n        uint256 lastRewardBlock;\n        uint256 depositAmount;\n        address[] rewardTokens;\n        uint256[] rewardAmounts;\n    }\n\n    struct krAssetInfoUser {\n        address assetAddress;\n        address oracleAddress;\n        address anchorAddress;\n        uint256 amount;\n        uint256 amountScaled;\n        uint256 priceRate;\n        uint256 stabilityRate;\n        uint256 amountUSD;\n        uint256 index;\n        uint256 kFactor;\n        uint256 price;\n        uint256 ammPrice;\n        string symbol;\n        string name;\n        uint256 openFee;\n        uint256 closeFee;\n    }\n\n    function getBalances(address[] memory _tokens, address account) internal view returns (Balance[] memory balances) {\n        balances = new Balance[](_tokens.length);\n        for (uint256 i; i < _tokens.length; i++) {\n            balances[i] = Balance({token: address(_tokens[i]), balance: IERC20Permit(_tokens[i]).balanceOf(account)});\n        }\n    }\n\n    function getAllowances(\n        address[] memory _tokens,\n        address owner,\n        address spender\n    ) internal view returns (Allowance[] memory allowances) {\n        allowances = new Allowance[](_tokens.length);\n        for (uint256 i; i < _tokens.length; i++) {\n            allowances[i] = Allowance({\n                allowance: IERC20Permit(_tokens[i]).allowance(owner, spender),\n                spender: spender,\n                owner: owner\n            });\n        }\n    }\n\n    function getStakingData(address _account, address _staking) internal view returns (StakingData[] memory result) {\n        IKrStaking staking = IKrStaking(_staking);\n        IKrStaking.Reward[] memory rewards = staking.allPendingRewards(_account);\n        result = new StakingData[](rewards.length);\n\n        for (uint256 i; i < rewards.length; i++) {\n            IKrStaking.PoolInfo memory poolInfo = staking.poolInfo(rewards[i].pid);\n            address depositTokenAddress = address(poolInfo.depositToken);\n            result[i] = StakingData({\n                pid: rewards[i].pid,\n                totalDeposits: poolInfo.depositToken.balanceOf(_staking),\n                allocPoint: poolInfo.allocPoint,\n                depositToken: depositTokenAddress,\n                depositAmount: staking.userInfo(rewards[i].pid, _account).amount,\n                rewardTokens: rewards[i].tokens,\n                rewardAmounts: rewards[i].amounts,\n                rewardPerBlocks: staking.rewardPerBlockFor(depositTokenAddress),\n                lastRewardBlock: poolInfo.lastRewardBlock\n            });\n        }\n    }\n\n    function borrowingPowerUSD(address _account) internal view returns (uint256) {\n        uint256 minCollateral = ms().getAccountMinimumCollateralValueAtRatio(\n            _account,\n            ms().minimumCollateralizationRatio\n        );\n        uint256 collateral = ms().getAccountCollateralValue(_account);\n\n        if (collateral < minCollateral) {\n            return 0;\n        } else {\n            return collateral - minCollateral;\n        }\n    }\n\n    function batchOracleValues(\n        address[] memory _assets,\n        address[] memory _priceFeeds,\n        address[] memory _marketStatusFeeds\n    ) internal view returns (Price[] memory result) {\n        require(_marketStatusFeeds.length == _priceFeeds.length, Error.PRICEFEEDS_MUST_MATCH_STATUS_FEEDS);\n        result = new Price[](_assets.length);\n\n        for (uint256 i; i < _assets.length; i++) {\n            (uint80 roundId, int256 answer, , uint256 timestamp, ) = AggregatorV3Interface(_priceFeeds[i])\n                .latestRoundData();\n            result[i] = Price({\n                price: uint256(answer),\n                timestamp: timestamp,\n                assetAddress: _assets[i],\n                roundId: roundId,\n                marketOpen: true\n            });\n        }\n    }\n\n    function krAssetInfos(address[] memory assetAddresses) internal view returns (krAssetInfo[] memory result) {\n        result = new krAssetInfo[](assetAddresses.length);\n        for (uint256 i; i < assetAddresses.length; i++) {\n            address assetAddress = assetAddresses[i];\n            KrAsset memory krAsset = ms().kreskoAssets[assetAddress];\n            uint256 ammPrice;\n            uint256 stabilityRate;\n            uint256 priceRate;\n            if (irs().srAssets[assetAddress].asset != address(0)) {\n                ammPrice = IUniswapV2OracleCompat(ms().ammOracle).consultKrAsset(assetAddress, 1 ether);\n                stabilityRate = irs().srAssets[assetAddress].calculateStabilityRate();\n                priceRate = irs().srAssets[assetAddress].getPriceRate();\n            }\n            (, int256 answer, , , ) = krAsset.oracle.latestRoundData();\n            result[i] = krAssetInfo({\n                value: ms().getKrAssetValue(assetAddress, 1 ether, false),\n                oracleAddress: address(krAsset.oracle),\n                anchorAddress: krAsset.anchor,\n                assetAddress: assetAddress,\n                closeFee: krAsset.closeFee,\n                openFee: krAsset.openFee,\n                kFactor: krAsset.kFactor,\n                price: uint256(answer),\n                stabilityRate: stabilityRate,\n                priceRate: priceRate,\n                ammPrice: ammPrice,\n                marketOpen: true,\n                symbol: IERC20Permit(assetAddress).symbol(),\n                name: IERC20Permit(assetAddress).name()\n            });\n        }\n    }\n\n    function collateralAssetInfos(\n        address[] memory assetAddresses\n    ) internal view returns (CollateralAssetInfo[] memory result) {\n        result = new CollateralAssetInfo[](assetAddresses.length);\n        for (uint256 i; i < assetAddresses.length; i++) {\n            address assetAddress = assetAddresses[i];\n            CollateralAsset memory collateralAsset = ms().collateralAssets[assetAddress];\n            uint8 decimals = IERC20Permit(assetAddress).decimals();\n\n            (uint256 value, uint256 price) = ms().getCollateralValueAndOraclePrice(\n                assetAddress,\n                1 * 10 ** decimals,\n                false\n            );\n\n            result[i] = CollateralAssetInfo({\n                value: value,\n                oracleAddress: address(collateralAsset.oracle),\n                anchorAddress: collateralAsset.anchor,\n                assetAddress: assetAddress,\n                liquidationIncentive: collateralAsset.liquidationIncentive,\n                cFactor: collateralAsset.factor,\n                decimals: decimals,\n                price: price,\n                marketOpen: true,\n                symbol: IERC20Permit(assetAddress).symbol(),\n                name: IERC20Permit(assetAddress).name()\n            });\n        }\n    }\n\n    function collateralAssetInfoFor(\n        address _account\n    ) internal view returns (CollateralAssetInfoUser[] memory result, uint256 totalCollateralUSD) {\n        address[] memory collateralAssetAddresses = ms().getDepositedCollateralAssets(_account);\n        if (collateralAssetAddresses.length > 0) {\n            result = new CollateralAssetInfoUser[](collateralAssetAddresses.length);\n            for (uint256 i; i < collateralAssetAddresses.length; i++) {\n                address assetAddress = collateralAssetAddresses[i];\n                uint8 decimals = IERC20Permit(assetAddress).decimals();\n\n                uint256 amount = ms().getCollateralDeposits(_account, assetAddress);\n\n                (uint256 amountUSD, uint256 price) = ms().getCollateralValueAndOraclePrice(assetAddress, amount, true);\n\n                totalCollateralUSD + amountUSD;\n                result[i] = CollateralAssetInfoUser({\n                    amount: amount,\n                    amountUSD: amountUSD,\n                    liquidationIncentive: ms().collateralAssets[assetAddress].liquidationIncentive,\n                    anchorAddress: ms().collateralAssets[assetAddress].anchor,\n                    oracleAddress: address(ms().collateralAssets[assetAddress].oracle),\n                    assetAddress: assetAddress,\n                    cFactor: ms().collateralAssets[assetAddress].factor,\n                    decimals: decimals,\n                    index: i,\n                    price: price,\n                    symbol: IERC20Permit(assetAddress).symbol(),\n                    name: IERC20Permit(assetAddress).name()\n                });\n            }\n        }\n    }\n\n    function krAssetInfoFor(\n        address _account\n    ) internal view returns (krAssetInfoUser[] memory result, uint256 totalDebtUSD) {\n        address[] memory krAssetAddresses = ms().mintedKreskoAssets[_account];\n        if (krAssetAddresses.length > 0) {\n            result = new krAssetInfoUser[](krAssetAddresses.length);\n            for (uint256 i; i < krAssetAddresses.length; i++) {\n                address assetAddress = krAssetAddresses[i];\n                KrAsset memory krAsset = ms().kreskoAssets[assetAddress];\n                uint256 amount = ms().getKreskoAssetDebtPrincipal(_account, assetAddress);\n                uint256 amountScaled = ms().getKreskoAssetDebtScaled(_account, assetAddress);\n\n                uint256 amountUSD = ms().getKrAssetValue(assetAddress, amount, true);\n                uint256 ammPrice;\n                uint256 stabilityRate;\n                uint256 priceRate;\n                if (irs().srAssets[assetAddress].asset != address(0)) {\n                    stabilityRate = irs().srAssets[assetAddress].calculateStabilityRate();\n                    priceRate = irs().srAssets[assetAddress].getPriceRate();\n                    ammPrice = IUniswapV2OracleCompat(ms().ammOracle).consultKrAsset(assetAddress, 1 ether);\n                }\n                totalDebtUSD + amountUSD;\n                (, int256 answer, , , ) = krAsset.oracle.latestRoundData();\n                result[i] = krAssetInfoUser({\n                    assetAddress: assetAddress,\n                    oracleAddress: address(krAsset.oracle),\n                    anchorAddress: krAsset.anchor,\n                    openFee: krAsset.openFee,\n                    closeFee: krAsset.closeFee,\n                    amount: amount,\n                    amountScaled: amountScaled,\n                    amountUSD: amountUSD,\n                    stabilityRate: stabilityRate,\n                    priceRate: priceRate,\n                    index: i,\n                    kFactor: krAsset.kFactor,\n                    price: uint256(answer),\n                    ammPrice: ammPrice,\n                    symbol: IERC20Permit(assetAddress).symbol(),\n                    name: IERC20Permit(assetAddress).name()\n                });\n            }\n        }\n    }\n\n    function healthFactorFor(address _account) internal view returns (uint256) {\n        uint256 userDebt = ms().getAccountKrAssetValue(_account);\n        uint256 userCollateral = ms().getAccountCollateralValue(_account);\n\n        if (userDebt > 0) {\n            return userCollateral.wadDiv(userDebt);\n        } else {\n            return 0;\n        }\n    }\n\n    function kreskoUser(address _account) internal view returns (KreskoUser memory user) {\n        (krAssetInfoUser[] memory krInfos, uint256 totalDebtUSD) = krAssetInfoFor(_account);\n        (CollateralAssetInfoUser[] memory collateralInfos, uint256 totalCollateralUSD) = collateralAssetInfoFor(\n            _account\n        );\n\n        if (krInfos.length > 0 || collateralInfos.length > 0) {\n            user = KreskoUser({\n                collateralAssets: collateralInfos,\n                krAssets: krInfos,\n                borrowingPowerUSD: borrowingPowerUSD(_account),\n                healthFactor: healthFactorFor(_account),\n                debtActualUSD: totalDebtUSD,\n                debtUSD: ms().getAccountKrAssetValue(_account),\n                collateralActualUSD: totalCollateralUSD,\n                collateralUSD: ms().getAccountCollateralValue(_account),\n                minCollateralUSD: ms().getAccountMinimumCollateralValueAtRatio(\n                    _account,\n                    ms().minimumCollateralizationRatio\n                )\n            });\n        }\n    }\n}\n"
    },
    "src/contracts/minter/MinterModifiers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {ms} from \"./MinterStorage.sol\";\nimport {Action} from \"./MinterTypes.sol\";\nimport {Error} from \"../libs/Errors.sol\";\n\nabstract contract MinterModifiers {\n    /**\n     * @notice Reverts if a collateral asset does not exist within the protocol.\n     * @param _collateralAsset The address of the collateral asset.\n     */\n    modifier collateralAssetExists(address _collateralAsset) {\n        require(ms().collateralAssets[_collateralAsset].exists, Error.COLLATERAL_DOESNT_EXIST);\n        _;\n    }\n\n    /**\n     * @notice Reverts if a collateral asset already exists within the protocol.\n     * @param _collateralAsset The address of the collateral asset.\n     */\n    modifier collateralAssetDoesNotExist(address _collateralAsset) {\n        require(!ms().collateralAssets[_collateralAsset].exists, Error.COLLATERAL_EXISTS);\n        _;\n    }\n\n    /**\n     * @notice Reverts if a Kresko asset does not exist within the protocol. Does not revert if\n     * the Kresko asset is not mintable.\n     * @param _kreskoAsset The address of the Kresko asset.\n     */\n    modifier kreskoAssetExists(address _kreskoAsset) {\n        require(ms().kreskoAssets[_kreskoAsset].exists, Error.KRASSET_DOESNT_EXIST);\n        _;\n    }\n\n    /**\n     * @notice Reverts if the symbol of a Kresko asset already exists within the protocol.\n     * @param _kreskoAsset The address of the Kresko asset.\n     */\n    modifier kreskoAssetDoesNotExist(address _kreskoAsset) {\n        require(!ms().kreskoAssets[_kreskoAsset].exists, Error.KRASSET_EXISTS);\n        _;\n    }\n\n    /// @dev Simple check for the enabled flag\n    function ensureNotPaused(address _asset, Action _action) internal view virtual {\n        require(!ms().safetyState[_asset][_action].pause.enabled, Error.ACTION_PAUSED_FOR_ASSET);\n    }\n}\n"
    },
    "src/contracts/minter/MinterState.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {LibKrAsset} from \"./libs/LibKrAsset.sol\";\nimport {LibAccount} from \"./libs/LibAccount.sol\";\nimport {LibCollateral} from \"./libs/LibCollateral.sol\";\nimport {LibCalculation} from \"./libs/LibCalculation.sol\";\nimport {LibBurn} from \"./libs/LibBurn.sol\";\nimport {LibMint} from \"./libs/LibMint.sol\";\nimport {Action, SafetyState, CollateralAsset, KrAsset} from \"./MinterTypes.sol\";\n\n/* solhint-disable state-visibility */\nusing LibCalculation for MinterState global;\nusing LibKrAsset for MinterState global;\nusing LibCollateral for MinterState global;\nusing LibAccount for MinterState global;\nusing LibBurn for MinterState global;\nusing LibMint for MinterState global;\n\n/**\n * @title Storage layout for the minter state\n * @author Kresko\n */\nstruct MinterState {\n    /* -------------------------------------------------------------------------- */\n    /*                               Initialization                               */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Initialization version\n    uint256 initializations;\n    bytes32 domainSeparator;\n    /* -------------------------------------------------------------------------- */\n    /*                           Configurable Parameters                          */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice The recipient of protocol fees.\n    address feeRecipient;\n    /// @notice The factor used to calculate the incentive a liquidator receives in the form of seized collateral.\n    uint256 liquidationIncentiveMultiplier;\n    /// @notice The minimum ratio of collateral to debt that can be taken by direct action.\n    uint256 minimumCollateralizationRatio;\n    /// @notice The minimum USD value of an individual synthetic asset debt position.\n    uint256 minimumDebtValue;\n    /// @notice The collateralization ratio at which positions may be liquidated.\n    uint256 liquidationThreshold;\n    /// @notice Flag tells if there is a need to perform safety checks on user actions\n    bool safetyStateSet;\n    /// @notice asset -> action -> state\n    mapping(address => mapping(Action => SafetyState)) safetyState;\n    /* -------------------------------------------------------------------------- */\n    /*                              Collateral Assets                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Mapping of collateral asset token address to information on the collateral asset.\n    mapping(address => CollateralAsset) collateralAssets;\n    /**\n     * @notice Mapping of account -> asset -> deposit amount\n     */\n    mapping(address => mapping(address => uint256)) collateralDeposits;\n    /// @notice Mapping of account -> collateral asset addresses deposited\n    mapping(address => address[]) depositedCollateralAssets;\n    /* -------------------------------------------------------------------------- */\n    /*                                Kresko Assets                               */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Mapping of kresko asset token address to information on the Kresko asset.\n    mapping(address => KrAsset) kreskoAssets;\n    /// @notice Mapping of account -> krAsset -> debt amount owed to the protocol\n    mapping(address => mapping(address => uint256)) kreskoAssetDebt;\n    /// @notice Mapping of account -> addresses of borrowed krAssets\n    mapping(address => address[]) mintedKreskoAssets;\n    /// @notice The AMM oracle address.\n    address ammOracle;\n    /// @notice Offchain oracle decimals\n    uint8 extOracleDecimals;\n    /// @notice Liquidation Overflow Multiplier, multiplies max liquidatable value.\n    uint256 maxLiquidationMultiplier;\n    /* -------------------------------------------------------------------------- */\n    /*                                  ORACLE                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice The oracle deviation percentage between the main oracle and fallback oracle.\n    uint256 oracleDeviationPct;\n    /// @notice L2 sequencer feed address\n    address sequencerUptimeFeed;\n    /// @notice grace period of sequencer in seconds\n    uint256 sequencerGracePeriodTime;\n    /// @notice timeout for oracle in seconds\n    uint256 oracleTimeout;\n}\n"
    },
    "src/contracts/minter/MinterStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable func-visibility */\n\npragma solidity >=0.8.19;\n\nimport {MinterState} from \"./MinterState.sol\";\n\n// Storage position\nbytes32 constant MINTER_STORAGE_POSITION = keccak256(\"kresko.minter.storage\");\n\nfunction ms() pure returns (MinterState storage state) {\n    bytes32 position = MINTER_STORAGE_POSITION;\n    assembly {\n        state.slot := position\n    }\n}\n"
    },
    "src/contracts/minter/MinterTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IFluxPriceFeed} from \"../vendor/flux/interfaces/IFluxPriceFeed.sol\";\nimport {AggregatorV3Interface} from \"../vendor/AggregatorV3Interface.sol\";\nimport {IKreskoAssetAnchor} from \"../kreskoasset/IKreskoAssetAnchor.sol\";\nimport {LibAssetUtility} from \"./libs/LibAssetUtility.sol\";\n\n/* solhint-disable state-visibility */\n\n/* -------------------------------------------------------------------------- */\n/*                                  CONSTANTS                                 */\n/* -------------------------------------------------------------------------- */\n\nlibrary Constants {\n    uint256 constant FP_DECIMALS = 18;\n\n    uint256 constant FP_SCALING_FACTOR = 10 ** FP_DECIMALS;\n\n    uint256 constant ONE_HUNDRED_PERCENT = 1 ether;\n\n    uint256 constant BASIS_POINT = 1e14;\n\n    /// @dev The maximum configurable close fee.\n    uint256 constant MAX_CLOSE_FEE = 0.1 ether; // 10%\n\n    /// @dev The maximum configurable open fee.\n    uint256 constant MAX_OPEN_FEE = 0.1 ether; // 10%\n\n    /// @dev Overflow over maximum liquidatable value to allow leeway for users after one happens.\n    uint256 constant MIN_MAX_LIQUIDATION_MULTIPLIER = ONE_HUNDRED_PERCENT + BASIS_POINT; // 100.01% or .01% over\n\n    /// @dev The minimum configurable minimum collateralization ratio.\n    uint256 constant MIN_COLLATERALIZATION_RATIO = ONE_HUNDRED_PERCENT;\n\n    /// @dev The minimum configurable liquidation incentive multiplier.\n    /// This means liquidator only receives equal amount of collateral to debt repaid.\n    uint256 constant MIN_LIQUIDATION_INCENTIVE_MULTIPLIER = ONE_HUNDRED_PERCENT;\n\n    /// @dev The maximum configurable liquidation incentive multiplier.\n    /// This means liquidator receives 25% bonus collateral compared to the debt repaid.\n    uint256 constant MAX_LIQUIDATION_INCENTIVE_MULTIPLIER = 1.25 ether; // 125%\n\n    /// @dev The minimum collateral amount for a kresko asset.\n    uint256 constant MIN_KRASSET_COLLATERAL_AMOUNT = 1e12;\n\n    /// @dev The maximum configurable minimum debt USD value. 8 decimals.\n    uint256 constant MAX_MIN_DEBT_VALUE = 1_000 * 1e8; // $1,000\n}\n\n/* -------------------------------------------------------------------------- */\n/*                                    ENUM                                    */\n/* -------------------------------------------------------------------------- */\n\n/**\n * @dev Protocol user facing actions\n *\n * Deposit = 0\n * Withdraw = 1,\n * Repay = 2,\n * Borrow = 3,\n * Liquidate = 4\n */\nenum Action {\n    Deposit,\n    Withdraw,\n    Repay,\n    Borrow,\n    Liquidation\n}\n/**\n * @dev Fee types\n *\n * Open = 0\n * Close = 1\n */\nenum Fee {\n    Open,\n    Close\n}\n\n/* ========================================================================== */\n/*                                   STRUCTS                                  */\n/* ========================================================================== */\n\n/**\n * @notice Initialization arguments for the protocol\n */\nstruct MinterInitArgs {\n    address admin;\n    address council;\n    address treasury;\n    uint8 extOracleDecimals;\n    uint256 minimumCollateralizationRatio;\n    uint256 minimumDebtValue;\n    uint256 liquidationThreshold;\n    uint256 oracleDeviationPct;\n    address sequencerUptimeFeed;\n    uint256 sequencerGracePeriodTime;\n    uint256 oracleTimeout;\n}\n\n/**\n * @notice Configurable parameters within the protocol\n */\n\nstruct MinterParams {\n    uint256 minimumCollateralizationRatio;\n    uint256 minimumDebtValue;\n    uint256 liquidationThreshold;\n    uint256 liquidationOverflowPercentage;\n    address feeRecipient;\n    uint8 extOracleDecimals;\n    uint256 oracleDeviationPct;\n}\n\n/**\n * @notice Information on a token that is a KreskoAsset.\n * @dev Each KreskoAsset has 18 decimals.\n * @param kFactor The k-factor used for calculating the required collateral value for KreskoAsset debt.\n * @param oracle The oracle that provides the USD price of one KreskoAsset.\n * @param supplyLimit The total supply limit of the KreskoAsset.\n * @param anchor The anchor address\n * @param closeFee The percentage paid in fees when closing a debt position of this type.\n * @param openFee The percentage paid in fees when opening a debt position of this type.\n * @param exists Whether the KreskoAsset exists within the protocol.\n */\nstruct KrAsset {\n    uint256 kFactor;\n    AggregatorV3Interface oracle;\n    uint256 supplyLimit;\n    address anchor;\n    uint256 closeFee;\n    uint256 openFee;\n    bool exists;\n    bytes32 redstoneId;\n}\n\nusing LibAssetUtility for KrAsset global;\n\n/**\n * @notice Information on a token that can be used as collateral.\n * @dev Setting the factor to zero effectively makes the asset useless as collateral while still allowing\n * it to be deposited and withdrawn.\n * @param factor The collateral factor used for calculating the value of the collateral.\n * @param oracle The oracle that provides the USD price of one collateral asset.\n * @param anchor If the collateral is a KreskoAsset, the anchor address\n * @param decimals The decimals for the token, stored here to avoid repetitive external calls.\n * @param exists Whether the collateral asset exists within the protocol.\n * @param liquidationIncentive The liquidation incentive for the asset\n */\nstruct CollateralAsset {\n    uint256 factor;\n    AggregatorV3Interface oracle;\n    address anchor;\n    uint8 decimals;\n    bool exists;\n    uint256 liquidationIncentive;\n    bytes32 redstoneId;\n}\nusing LibAssetUtility for CollateralAsset global;\n\n/// @notice Configuration for pausing `Action`\nstruct Pause {\n    bool enabled;\n    uint256 timestamp0;\n    uint256 timestamp1;\n}\n\n/// @notice Safety configuration for assets\nstruct SafetyState {\n    Pause pause;\n}\n"
    },
    "src/contracts/shared/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.19;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\n\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable not-rely-on-time */\n/* solhint-disable func-name-mixedcase */\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @author Kresko: modified to an upgradeable\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\n\ncontract ERC20Upgradeable is Initializable, IERC20Permit {\n    /* -------------------------------------------------------------------------- */\n    /*                                   Events                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /* -------------------------------------------------------------------------- */\n    /*                                ERC20 Storage                               */\n    /* -------------------------------------------------------------------------- */\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  EIP-2612                                  */\n    /* -------------------------------------------------------------------------- */\n\n    mapping(address => uint256) public nonces;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 Immutables                                 */\n    /* -------------------------------------------------------------------------- */\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    constructor() payable initializer {\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20Upgradeable_init(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) internal onlyInitializing {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    READ                                    */\n    /* -------------------------------------------------------------------------- */\n\n    function balanceOf(address _account) public view virtual returns (uint256) {\n        return _balances[_account];\n    }\n\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    function allowance(address _owner, address _spender) public view virtual returns (uint256) {\n        return _allowances[_owner][_spender];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 ERC20 Logic                                */\n    /* -------------------------------------------------------------------------- */\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(msg.sender, to, amount);\n\n        _balances[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balances[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 allowed = _allowances[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) _allowances[from][msg.sender] = allowed - amount;\n\n        _balances[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               EIP-2612 Logic                               */\n    /* -------------------------------------------------------------------------- */\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            _allowances[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Internals                                 */\n    /* -------------------------------------------------------------------------- */\n\n    function _mint(address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), to, amount);\n\n        _totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balances[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, address(0), amount);\n\n        _balances[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {\n        // Silence state mutability warning without generating bytecode.\n    }\n}\n"
    },
    "src/contracts/shared/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/contracts/shared/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n/* solhint-disable func-name-mixedcase */\n\ninterface IERC20Permit {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function allowance(address, address) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function name() external view returns (string memory);\n\n    function nonces(address) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "src/contracts/shared/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(IERC20Permit token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20Permit token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Permit token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20Permit token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20Permit token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Permit token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "src/contracts/staking/interfaces/IKrStaking.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IKrStaking {\n    struct UserInfo {\n        uint256 amount;\n        uint256[] rewardDebts;\n    }\n\n    struct PoolInfo {\n        IERC20 depositToken; // Address of LP token contract.\n        uint128 allocPoint; // How many allocation points assigned to this pool.\n        uint128 lastRewardBlock; // Last block number that rewards distribution occurs.\n        uint256[] accRewardPerShares; // Accumulated rewards per share, times 1e12.\n        address[] rewardTokens; // Reward tokens for this pool.\n    }\n\n    struct Reward {\n        uint256 pid;\n        address[] tokens;\n        uint256[] amounts;\n    }\n\n    /**\n     * @notice Get id for a token\n     * @notice Useful for external contracts\n     * @param _depositToken depositToken in `_poolInfo`\n     * @return pid of pool with `_depositToken`\n     * @return found ensure 0 index\n     */\n    function getPidFor(address _depositToken) external view returns (uint256 pid, bool found);\n\n    /**\n     * @notice Amount of pools\n     */\n    function poolLength() external view returns (uint256);\n\n    /**\n     * @notice Deposits tokens for @param _to\n     * @param _to address that msg.sender deposits tokens for\n     * @param _pid in `_poolInfo`\n     * @param _amount amount of tokens to deposit\n     */\n    function deposit(address _to, uint256 _pid, uint256 _amount) external payable;\n\n    /**\n     * @notice Trusted helper contract can withdraw rewards and deposits on behalf of an account\n     * @notice For eg. withdraw + remove liquidity\n     * @param _for account to withdraw from\n     * @param _pid id in `_poolInfo`\n     * @param _amount amount to withdraw\n     * @param _rewardRecipient reward recipient\n     */\n    function withdrawFor(address _for, uint256 _pid, uint256 _amount, address _rewardRecipient) external payable;\n\n    /**\n     * @notice Trusted helper contract can claim rewards on behalf of an account\n     * @param _for account to claim for\n     * @param _pid id in `_poolInfo`\n     * @param _rewardRecipient address that receives rewards\n     */\n    function claimFor(address _for, uint256 _pid, address _rewardRecipient) external payable;\n\n    /**\n     * @notice Get all pending rewards for an account\n     * @param _account to get rewards for\n     * @return all pending rewards\n     */\n    function allPendingRewards(address _account) external view returns (Reward[] memory);\n\n    /**\n     * @notice Get account information on a pool\n     * @param _pid in `_poolInfo`\n     * @param _account to get information for\n     * @return information on the account\n     */\n    function userInfo(uint256 _pid, address _account) external view returns (UserInfo memory);\n\n    /**\n     * @notice Get pool information\n     * @param _pid in `_poolInfo`\n     * @return pool information\n     */\n    function poolInfo(uint256 _pid) external view returns (PoolInfo memory);\n\n    function rewardPerBlockFor(address depositTokenAddress) external view returns (uint256 rewardPerBlocks);\n\n    /**\n     * @notice A rescue function for missent msg.value\n     * @notice Since we are using payable functions to save gas on calls\n     */\n    function rescueNative() external payable;\n\n    /**\n     * @notice A rescue function for missent tokens / airdrops\n     * @notice This cannot withdraw any deposits due `ensurePoolDoesNotExist` modifier.\n     */\n    function rescueNonPoolToken(IERC20 _tokenToRescue, uint256 _amount) external payable;\n\n    /**\n     * @notice Set new allocations for a pool\n     * @notice Set `_newAllocPoint` to 0 to retire a pool\n     * @param _pid pool to modify\n     * @param _newAllocPoint new allocation (weight) for rewards\n     */\n    function setPool(uint256 _pid, uint128 _newAllocPoint) external payable;\n\n    /**\n     * @notice Adds a new reward pool\n     * @notice Updates reward token count in case of adding extra tokens\n     * @param _rewardTokens tokens to reward from this pool\n     * @param _depositToken token to deposit for rewards\n     * @param _allocPoint weight of rewards this pool receives\n     * @param _startBlock block when rewards start\n     */\n    function addPool(\n        address[] calldata _rewardTokens,\n        IERC20 _depositToken,\n        uint128 _allocPoint,\n        uint128 _startBlock\n    ) external payable;\n\n    /**\n     * @notice Adjust/Set reward per block for a particular reward token\n     * @param _rewardToken token to adjust the drip for\n     * @param _rewardPerBlock tokens to drip per block\n     */\n    function setRewardPerBlockFor(address _rewardToken, uint256 _rewardPerBlock) external payable;\n\n    /**\n     * @notice Emergency function, withdraws deposits from a pool\n     * @notice This will forfeit your rewards.\n     * @param _pid pool id to withdraw tokens from\n     */\n    function emergencyWithdraw(uint256 _pid) external payable;\n\n    /**\n     * @notice Claim rewards only\n     * @param _pid id in `_poolInfo`\n     * @param _rewardRecipient address to send rewards to\n     */\n    function claim(uint256 _pid, address _rewardRecipient) external payable;\n\n    /**\n     * @notice Withdraw deposited tokens and rewards.\n     * @param _pid id in `_poolInfo`\n     * @param _amount amount to withdraw\n     * @param _rewardRecipient address to send rewards to\n     */\n    function withdraw(uint256 _pid, uint256 _amount, address _rewardRecipient) external payable;\n\n    /**\n     * @notice Updates all pools to be up-to date\n     */\n    function massUpdatePools() external payable;\n\n    /**\n     * @notice Updates a pools reward variables to be up-to date\n     * @param _pid pool to update\n     */\n    function updatePool(uint256 _pid) external payable returns (PoolInfo memory pool);\n\n    /**\n     * @notice Get pending rewards from a certain pool\n     * @param _pid id in `_poolInfo`\n     * @param _user id in `_userInfo[_pid]`\n     * @return rewards pending rewards\n     */\n    function pendingRewards(uint256 _pid, address _user) external view returns (Reward memory rewards);\n}\n"
    },
    "src/contracts/staking/KrStaking.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IKrStaking} from \"./interfaces/IKrStaking.sol\";\n\ncontract KrStaking is AccessControlUpgradeable, ReentrancyGuardUpgradeable, IKrStaking {\n    using SafeERC20 for IERC20;\n\n    // keccak256(\"kresko.operator.role\")\n    bytes32 public constant OPERATOR_ROLE = 0x8952ae23cc3fea91b9dba0cefa16d18a26ca2bf124b54f42b5d04bce3aacecd2;\n\n    /**\n     * ==================================================\n     * =============== Storage ==========================\n     * ==================================================\n     */\n\n    // Info of each staked user.\n    mapping(uint256 => mapping(address => UserInfo)) private _userInfo;\n\n    // Reward token drip per block\n    mapping(address => uint256) public rewardPerBlockFor;\n\n    // Info of each pool.\n    PoolInfo[] private _poolInfo;\n\n    // Total allocation points.\n    uint128 public totalAllocPoint;\n\n    /**\n     * ==================================================\n     * ============== Events ============================\n     * ==================================================\n     */\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event ClaimRewards(address indexed user, address indexed rewardToken, uint256 indexed amount);\n    event LogSetPool(uint256 indexed pid, uint256 indexed allocPoint);\n\n    /**\n     * ==================================================\n     * ============== Initializer =======================\n     * ==================================================\n     */\n\n    /**\n     * @notice Initialize the contract with a single pool\n     * @notice Sets initial reward token and rates\n     * @notice Sets the caller as DEFAULT_ADMIN\n     */\n    function initialize(\n        address[] calldata _rewardTokens,\n        uint256[] calldata _rewardPerBlocks,\n        IERC20 _depositToken,\n        uint128 _allocPoint,\n        uint128 _startBlock,\n        address _admin,\n        address _operator\n    ) external initializer {\n        require(_rewardPerBlocks.length == _rewardTokens.length, \"Reward tokens must have a rewardPerBlock value\");\n\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n        _setupRole(OPERATOR_ROLE, _operator);\n        _setupRole(OPERATOR_ROLE, msg.sender);\n\n        // Set initial reward tokens and allocations\n        for (uint256 i; i < _rewardTokens.length; i++) {\n            rewardPerBlockFor[_rewardTokens[i]] = _rewardPerBlocks[i];\n        }\n\n        // Push the initial pool in.\n        _poolInfo.push(\n            PoolInfo({\n                depositToken: _depositToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: _startBlock,\n                accRewardPerShares: new uint256[](_rewardTokens.length),\n                rewardTokens: _rewardTokens\n            })\n        );\n\n        totalAllocPoint += _allocPoint;\n    }\n\n    /**\n     * ==================================================\n     * =============== Modifiers ========================\n     * ==================================================\n     */\n\n    /**\n     * @notice Ensures no pool exists with this depositToken\n     * @param _depositToken to check\n     */\n    modifier ensurePoolDoesNotExist(IERC20 _depositToken) {\n        for (uint256 i; i < _poolInfo.length; i++) {\n            require(address(_poolInfo[i].depositToken) != address(_depositToken), \"KR: poolExists\");\n        }\n        _;\n    }\n\n    /**\n     * @notice Ensures this pool exists\n     * @param _pid to check\n     */\n    modifier ensurePoolExists(uint256 _pid) {\n        require(address(_poolInfo[_pid].depositToken) != address(0), \"KR: !poolExists\");\n        _;\n    }\n\n    /**\n     * ==================================================\n     * ================== Views =========================\n     * ==================================================\n     */\n\n    /// @inheritdoc IKrStaking\n    function pendingRewards(uint256 _pid, address _user) public view returns (Reward memory rewards) {\n        PoolInfo memory pool = _poolInfo[_pid];\n        UserInfo memory user = _userInfo[_pid][_user];\n        uint256 depositTokenSupply = pool.depositToken.balanceOf(address(this));\n        uint256 rewardTokensLength = pool.rewardTokens.length;\n\n        rewards = Reward({pid: _pid, tokens: pool.rewardTokens, amounts: new uint256[](rewardTokensLength)});\n\n        if (depositTokenSupply != 0 && user.amount > 0) {\n            for (uint256 rewardIndex; rewardIndex < rewardTokensLength; rewardIndex++) {\n                uint256 accRewardPerShare = pool.accRewardPerShares[rewardIndex];\n\n                uint256 rewardPerBlock = rewardPerBlockFor[pool.rewardTokens[rewardIndex]];\n                uint256 blocks = block.number - pool.lastRewardBlock;\n                uint256 reward = (rewardPerBlock * blocks * pool.allocPoint) / totalAllocPoint;\n\n                accRewardPerShare += (reward * 1e12) / depositTokenSupply;\n\n                rewards.amounts[rewardIndex] = (user.amount * accRewardPerShare) / 1e12 - user.rewardDebts[rewardIndex];\n            }\n        }\n    }\n\n    /// @inheritdoc IKrStaking\n    function allPendingRewards(address _account) external view returns (Reward[] memory allRewards) {\n        allRewards = new Reward[](_poolInfo.length);\n        for (uint256 pid; pid < _poolInfo.length; pid++) {\n            Reward memory poolReward = pendingRewards(pid, _account);\n            allRewards[pid] = poolReward;\n        }\n    }\n\n    /// @inheritdoc IKrStaking\n    function poolLength() external view returns (uint256) {\n        return _poolInfo.length;\n    }\n\n    /// @inheritdoc IKrStaking\n    function poolInfo(uint256 _pid) external view returns (PoolInfo memory) {\n        return _poolInfo[_pid];\n    }\n\n    /// @inheritdoc IKrStaking\n    function getPidFor(address _depositToken) external view returns (uint256 pid, bool found) {\n        for (pid; pid < _poolInfo.length; pid++) {\n            if (address(_poolInfo[pid].depositToken) == _depositToken) {\n                found = true;\n                break;\n            }\n        }\n    }\n\n    /// @inheritdoc IKrStaking\n    function userInfo(uint256 _pid, address _account) external view returns (UserInfo memory) {\n        return _userInfo[_pid][_account];\n    }\n\n    /**\n     * ==================================================\n     * =========== Core public functions ================\n     * ==================================================\n     */\n\n    /// @inheritdoc IKrStaking\n    function massUpdatePools() public payable {\n        for (uint256 pid; pid < _poolInfo.length; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n    /// @inheritdoc IKrStaking\n    function updatePool(uint256 _pid) public payable returns (PoolInfo memory pool) {\n        pool = _poolInfo[_pid];\n        // Updates once per block\n        if (block.number > pool.lastRewardBlock) {\n            uint256 deposits = pool.depositToken.balanceOf(address(this));\n            // No rewards for 0 deposits\n            if (deposits > 0) {\n                for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n                    // Reward per block for a particular reward token\n                    uint256 rewardPerBlock = rewardPerBlockFor[pool.rewardTokens[rewardIndex]];\n                    // Blocks advanced since last update\n                    uint256 blocks = block.number - pool.lastRewardBlock;\n                    // Allocation for this particular pool\n                    uint256 reward = (rewardPerBlock * blocks * pool.allocPoint) / totalAllocPoint;\n                    // Increment accumulated rewards for new block height\n                    pool.accRewardPerShares[rewardIndex] += (reward * 1e12) / deposits;\n                }\n            }\n            // No further updates within same block height\n            pool.lastRewardBlock = uint128(block.number);\n            // storage\n            _poolInfo[_pid] = pool;\n        }\n    }\n\n    /// @inheritdoc IKrStaking\n    function deposit(address _to, uint256 _pid, uint256 _amount) external payable nonReentrant ensurePoolExists(_pid) {\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][_to];\n\n        // Initialize rewardDebts\n        if (user.rewardDebts.length == 0) {\n            user.rewardDebts = new uint256[](pool.rewardTokens.length);\n        }\n\n        pool.depositToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n        user.amount += _amount;\n\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] += (_amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n        }\n\n        emit Deposit(_to, _pid, _amount);\n    }\n\n    /// @inheritdoc IKrStaking\n    function withdraw(uint256 _pid, uint256 _amount, address _rewardRecipient) external payable nonReentrant {\n        _withdraw(msg.sender, _pid, _amount, _rewardRecipient, true);\n    }\n\n    /// @inheritdoc IKrStaking\n    function claim(uint256 _pid, address _rewardRecipient) external payable nonReentrant {\n        _claim(msg.sender, _pid, _rewardRecipient);\n    }\n\n    /// @inheritdoc IKrStaking\n    function emergencyWithdraw(uint256 _pid) external payable nonReentrant {\n        PoolInfo memory pool = _poolInfo[_pid];\n        UserInfo storage user = _userInfo[_pid][msg.sender];\n        pool.depositToken.safeTransfer(address(msg.sender), user.amount);\n        user.amount = 0;\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] = 0;\n        }\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n    }\n\n    /**\n     * ==================================================\n     * ============= Admin functions ====================\n     * ==================================================\n     */\n\n    /// @inheritdoc IKrStaking\n    function setRewardPerBlockFor(\n        address _rewardToken,\n        uint256 _rewardPerBlock\n    ) external payable onlyRole(OPERATOR_ROLE) {\n        rewardPerBlockFor[_rewardToken] = _rewardPerBlock;\n    }\n\n    /// @inheritdoc IKrStaking\n    function addPool(\n        address[] calldata _rewardTokens,\n        IERC20 _depositToken,\n        uint128 _allocPoint,\n        uint128 _startBlock\n    ) external payable onlyRole(OPERATOR_ROLE) ensurePoolDoesNotExist(_depositToken) {\n        require(_rewardTokens.length > 0, \"KR: !rewardTokens\");\n\n        totalAllocPoint += _allocPoint;\n\n        _poolInfo.push(\n            PoolInfo({\n                depositToken: _depositToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: _startBlock != 0 ? _startBlock : uint128(block.number),\n                accRewardPerShares: new uint256[](_rewardTokens.length),\n                rewardTokens: _rewardTokens\n            })\n        );\n    }\n\n    /// @inheritdoc IKrStaking\n    function setPool(\n        uint256 _pid,\n        uint128 _newAllocPoint\n    ) external payable onlyRole(OPERATOR_ROLE) ensurePoolExists(_pid) {\n        totalAllocPoint = totalAllocPoint - _poolInfo[_pid].allocPoint + _newAllocPoint;\n        _poolInfo[_pid].allocPoint = _newAllocPoint;\n\n        emit LogSetPool(_pid, _newAllocPoint);\n    }\n\n    /**\n     * ==================================================\n     * ============ Protected functions =================\n     * ==================================================\n     */\n\n    /// @inheritdoc IKrStaking\n    function withdrawFor(\n        address _for,\n        uint256 _pid,\n        uint256 _amount,\n        address _rewardRecipient\n    ) external payable nonReentrant onlyRole(OPERATOR_ROLE) {\n        _withdraw(_for, _pid, _amount, _rewardRecipient, false);\n    }\n\n    /// @inheritdoc IKrStaking\n    function claimFor(\n        address _for,\n        uint256 _pid,\n        address _rewardRecipient\n    ) external payable nonReentrant onlyRole(OPERATOR_ROLE) {\n        _claim(_for, _pid, _rewardRecipient);\n    }\n\n    /// @inheritdoc IKrStaking\n    function rescueNative() external payable onlyRole(OPERATOR_ROLE) {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    /// @inheritdoc IKrStaking\n    function rescueNonPoolToken(\n        IERC20 _tokenToRescue,\n        uint256 _amount\n    ) external payable onlyRole(OPERATOR_ROLE) ensurePoolDoesNotExist(_tokenToRescue) {\n        _tokenToRescue.safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * ==================================================\n     * ============= Internal functions =================\n     * ==================================================\n     */\n\n    /**\n     * @notice Loops over pools reward tokens and sends them to the user\n     * @param pool pool to send rewards from in `_poolInfo`\n     * @param user users info in the @param pool\n     * @param recipient user to send rewards to\n     */\n    function sendRewards(PoolInfo memory pool, UserInfo memory user, address recipient) internal {\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            uint256 rewardDebt = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n            uint256 pending = rewardDebt - user.rewardDebts[rewardIndex];\n\n            if (pending > 0) {\n                IERC20(pool.rewardTokens[rewardIndex]).safeTransfer(recipient, pending);\n                emit ClaimRewards(recipient, pool.rewardTokens[rewardIndex], pending);\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraw deposited tokens and rewards.\n     * @param _user user to withdraw for\n     * @param _pid id in `_poolInfo`\n     * @param _amount amount to withdraw\n     * @param _rewardRecipient address to send rewards to\n     * @param _transferToUser if true, withdraws to `_user` instead of `msg.sender`\n     */\n    function _withdraw(\n        address _user,\n        uint256 _pid,\n        uint256 _amount,\n        address _rewardRecipient,\n        bool _transferToUser\n    ) internal {\n        require(_amount > 0, \"KR: 0-withdraw\");\n        require(_rewardRecipient != address(0), \"KR: !rewardRecipient\");\n\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][_user];\n\n        sendRewards(pool, user, _rewardRecipient);\n\n        // Send whole balance in case of amount exceeds deposits\n        if (_amount > user.amount) {\n            _amount = user.amount;\n            user.amount = 0;\n        } else {\n            user.amount -= _amount;\n        }\n\n        pool.depositToken.safeTransfer(_transferToUser ? _user : address(msg.sender), _amount);\n\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n        }\n\n        emit Withdraw(_user, _pid, _amount);\n    }\n\n    /**\n     * @notice Claim rewards\n     * @param _user user to claim for\n     * @param _pid id in `_poolInfo`\n     * @param _rewardRecipient address to send rewards to\n     */\n    function _claim(address _user, uint256 _pid, address _rewardRecipient) internal {\n        require(_rewardRecipient != address(0), \"KR: !rewardRecipient\");\n\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][_user];\n\n        if (user.amount > 0) {\n            sendRewards(pool, user, _rewardRecipient);\n\n            for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n                user.rewardDebts[rewardIndex] = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/staking/KrStakingHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IUniswapV2Factory} from \"../vendor/uniswap/v2-core/interfaces/IUniswapV2Factory.sol\";\nimport {IUniswapV2Router02} from \"../vendor/uniswap/v2-periphery/interfaces/IUniswapV2Router02.sol\";\nimport {IKrStaking, IERC20} from \"./interfaces/IKrStaking.sol\";\n\ncontract KrStakingHelper {\n    using SafeERC20 for IERC20;\n\n    IUniswapV2Router02 public immutable router;\n    IUniswapV2Factory public immutable factory;\n    IKrStaking public immutable staking;\n\n    constructor(IUniswapV2Router02 _router, IUniswapV2Factory _factory, IKrStaking _staking) {\n        router = _router;\n        factory = _factory;\n        staking = _staking;\n    }\n\n    /**\n     * ==================================================\n     * ============ Events ==============================\n     * ==================================================\n     */\n\n    event LiquidityAndStakeAdded(address indexed to, uint256 indexed amount, uint256 indexed pid);\n    event LiquidityAndStakeRemoved(address indexed to, uint256 indexed amount, uint256 indexed pid);\n    event ClaimRewardsMulti(address indexed to);\n\n    /**\n     * ==================================================\n     * ============ Public functions ====================\n     * ==================================================\n     */\n\n    /**\n     * @notice Add liquidity to a pair, deposit liquidity tokens to staking\n     * @param tokenA address of tokenA\n     * @param tokenB address of tokenB\n     * @param amountADesired optimal amount of token A\n     * @param amountBDesired optimal amount of token B\n     * @param amountAMin min amountA (slippage)\n     * @param amountBMin min amountB (slippage)\n     * @param to address to deposit for\n     * @param deadline transaction deadline (used by router)\n     */\n    function addLiquidityAndStake(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256) {\n        require(to != address(0), \"KR: !address\");\n        address pair = factory.getPair(tokenA, tokenB);\n        (uint256 pid, bool found) = staking.getPidFor(pair);\n\n        require(found, \"KR: !poolExists\");\n\n        IERC20(tokenA).safeTransferFrom(msg.sender, address(this), amountADesired);\n        IERC20(tokenB).safeTransferFrom(msg.sender, address(this), amountBDesired);\n\n        IERC20(tokenA).approve(address(router), amountADesired);\n        IERC20(tokenB).approve(address(router), amountBDesired);\n\n        (, , uint256 liquidity) = router.addLiquidity(\n            tokenA,\n            tokenB,\n            amountADesired,\n            amountBDesired,\n            amountAMin,\n            amountBMin,\n            address(this),\n            deadline\n        );\n\n        IERC20(pair).approve(address(staking), liquidity);\n        staking.deposit(to, pid, liquidity);\n\n        emit LiquidityAndStakeAdded(to, liquidity, pid);\n        return liquidity;\n    }\n\n    /**\n     * @notice Withdraw liquidity tokens from staking, remove the underlying\n     * @param tokenA address of tokenA\n     * @param tokenB address of tokenB\n     * @param liquidity liquidity token amount to remove\n     * @param amountAMin min amountA to receive (slippage)\n     * @param amountBMin min amountB to receive (slippage)\n     * @param to address that receives the underlying\n     * @param deadline transaction deadline (used by router)\n     */\n    function withdrawAndRemoveLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external {\n        require(to != address(0), \"KR: !address\");\n        address pair = factory.getPair(tokenA, tokenB);\n        (uint256 pid, bool found) = staking.getPidFor(pair);\n\n        require(found, \"KR: !poolExists\");\n\n        staking.withdrawFor(msg.sender, pid, liquidity, to);\n\n        IERC20(pair).approve(address(router), liquidity);\n        router.removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n\n        emit LiquidityAndStakeRemoved(to, liquidity, pid);\n    }\n\n    /**\n     * @notice Claim rewards from each pool\n     * @param to address that receives the rewards\n     */\n    function claimRewardsMulti(address to) external {\n        require(to != address(0), \"KR: !address\");\n\n        uint256 length = staking.poolLength();\n\n        for (uint256 i; i < length; i++) {\n            staking.claimFor(msg.sender, i, to);\n        }\n\n        emit ClaimRewardsMulti(to);\n    }\n}\n"
    },
    "src/contracts/test/Funder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {IERC20Permit} from \"../shared/IERC20Permit.sol\";\nimport {WETH} from \"./WETH.sol\";\nimport {IAccountStateFacet} from \"../minter/interfaces/IAccountStateFacet.sol\";\n\n/* solhint-disable no-empty-blocks */\n\nstruct Token {\n    uint256 amount;\n    address token;\n}\n\ncontract Funder {\n    mapping(address => bool) public owners;\n    mapping(address => bool) public funded;\n    IAccountStateFacet public kresko;\n\n    event Funded(address indexed account);\n\n    constructor(address _kresko) {\n        owners[msg.sender] = true;\n        kresko = IAccountStateFacet(_kresko);\n    }\n\n    function toggleOwners(address[] calldata accounts) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < accounts.length; i++) {\n            owners[accounts[i]] = !owners[accounts[i]];\n        }\n    }\n\n    function isEligible(address account) public view returns (bool) {\n        return account.balance < 0.001 ether && kresko.getAccountKrAssetValue(account) > 0 && !funded[account];\n    }\n\n    function distribute(address[] calldata accounts, uint256 ethAmount) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < accounts.length; i++) {\n            if (!isEligible(accounts[i])) continue;\n\n            funded[accounts[i]] = true;\n            payable(accounts[i]).transfer(ethAmount);\n            emit Funded(accounts[i]);\n        }\n    }\n\n    function drain() external {\n        require(owners[msg.sender], \"!o\");\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}\n"
    },
    "src/contracts/test/FunderTestnetExtended.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {MockERC20} from \"./MockERC20.sol\";\nimport {WETH} from \"./WETH.sol\";\nimport {IAccountStateFacet} from \"../minter/interfaces/IAccountStateFacet.sol\";\n\n/* solhint-disable no-empty-blocks */\n\nstruct Token {\n    uint256 amount;\n    address token;\n}\n\ncontract FunderTestnetExtended {\n    mapping(address => bool) public owners;\n    mapping(address => bool) public funded;\n    IAccountStateFacet public kresko;\n    MockERC20 public tokenToFund;\n    uint256 public fundAmount = 10000 ether;\n    event Funded(address indexed account);\n\n    constructor(address _kresko, address _tokenToFund) {\n        owners[msg.sender] = true;\n        kresko = IAccountStateFacet(_kresko);\n        tokenToFund = MockERC20(_tokenToFund);\n    }\n\n    function toggleOwners(address[] calldata accounts) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < accounts.length; i++) {\n            owners[accounts[i]] = !owners[accounts[i]];\n        }\n    }\n\n    function isEligible(address account) public view returns (bool) {\n        return !funded[account];\n    }\n\n    function setFundAmount(uint256 amount) external {\n        require(owners[msg.sender], \"!o\");\n        fundAmount = amount;\n    }\n\n    function distribute() external {\n        if (!isEligible(msg.sender)) return;\n        tokenToFund.mint(msg.sender, fundAmount);\n        funded[msg.sender] = true;\n        emit Funded(msg.sender);\n    }\n\n    function drain() external {\n        require(owners[msg.sender], \"!o\");\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}\n"
    },
    "src/contracts/test/interfaces/ISmockFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\ninterface ISmockFacet {\n    event NewMessage(address indexed caller, string message);\n\n    function activate() external;\n\n    function disable() external;\n\n    function setMessage(string memory message) external;\n}\n"
    },
    "src/contracts/test/markets/UniswapMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.6.6;\n\nimport {IUniswapV2Router02} from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport {TransferHelper} from \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport {UniswapV2LiquidityMathLibrary, SafeMath, Babylonian, UniswapV2Library} from \"./UniswapV2LiquidityMathLibrary.sol\";\n\ncontract UniswapMath {\n    using SafeMath for uint256;\n    IUniswapV2Router02 public immutable router;\n    address public immutable factory;\n\n    constructor(address factory_, IUniswapV2Router02 router_) {\n        factory = factory_;\n        router = router_;\n    }\n\n    // computes the direction and magnitude of the profit-maximizing trade\n    function computeProfitMaximizingTrade(\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 reserveA,\n        uint256 reserveB\n    ) public pure returns (bool aToB, uint256 amountIn) {\n        aToB = reserveA.mul(truePriceTokenB) / reserveB < truePriceTokenA;\n\n        uint256 invariant = reserveA.mul(reserveB);\n\n        uint256 leftSide = Babylonian.sqrt(\n            invariant.mul(aToB ? truePriceTokenA : truePriceTokenB).mul(1000) /\n                uint256(aToB ? truePriceTokenB : truePriceTokenA).mul(997)\n        );\n        uint256 rightSide = (aToB ? reserveA.mul(1000) : reserveB.mul(1000)) / 997;\n\n        // compute the amount that must be sent to move the price to the profit-maximizing price\n        amountIn = leftSide.sub(rightSide);\n    }\n\n    // swaps an amount of either token such that the trade is profit-maximizing, given an external true price\n    // true price is expressed in the ratio of token A to token B\n    // caller must approve this contract to spend whichever token is intended to be swapped\n    function swapToPrice(\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 maxSpendTokenA,\n        uint256 maxSpendTokenB,\n        address to,\n        uint256 deadline\n    ) public {\n        // true price is expressed as a ratio, so both values must be non-zero\n        require(truePriceTokenA != 0 && truePriceTokenB != 0, \"ExampleSwapToPrice: ZERO_PRICE\");\n        // caller can specify 0 for either if they wish to swap in only one direction, but not both\n        require(maxSpendTokenA != 0 || maxSpendTokenB != 0, \"ExampleSwapToPrice: ZERO_SPEND\");\n\n        bool aToB;\n        uint256 amountIn;\n        {\n            (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n            (aToB, amountIn) = computeProfitMaximizingTrade(truePriceTokenA, truePriceTokenB, reserveA, reserveB);\n        }\n\n        // spend up to the allowance of the token in\n        uint256 maxSpend = aToB ? maxSpendTokenA : maxSpendTokenB;\n        if (amountIn > maxSpend) {\n            amountIn = maxSpend;\n        }\n\n        address tokenIn = aToB ? tokenA : tokenB;\n        address tokenOut = aToB ? tokenB : tokenA;\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, address(this), amountIn);\n        TransferHelper.safeApprove(tokenIn, address(router), amountIn);\n\n        address[] memory path = new address[](2);\n        path[0] = tokenIn;\n        path[1] = tokenOut;\n\n        router.swapExactTokensForTokens(\n            amountIn,\n            0, // amountOutMin: we can skip computing this number because the math is tested\n            path,\n            to,\n            deadline\n        );\n    }\n\n    function profitMaximizingTrade(\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB\n    ) external view returns (uint256 amountIn, bool aToB) {\n        (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n        (aToB, amountIn) = computeProfitMaximizingTrade(truePriceTokenA, truePriceTokenB, reserveA, reserveB);\n    }\n\n    function getReservesAfterArbitrage(\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB\n    ) external view returns (uint256 reserveA, uint256 reserveB) {\n        return\n            UniswapV2LiquidityMathLibrary.getReservesAfterArbitrage(\n                factory,\n                tokenA,\n                tokenB,\n                truePriceTokenA,\n                truePriceTokenB\n            );\n    }\n\n    function getLiquidityValue(\n        address tokenA,\n        address tokenB,\n        uint256 liquidityAmount\n    ) external view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n        return UniswapV2LiquidityMathLibrary.getLiquidityValue(factory, tokenA, tokenB, liquidityAmount);\n    }\n\n    function getLiquidityValueAfterArbitrageToPrice(\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 liquidityAmount\n    ) external view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n        return\n            UniswapV2LiquidityMathLibrary.getLiquidityValueAfterArbitrageToPrice(\n                factory,\n                tokenA,\n                tokenB,\n                truePriceTokenA,\n                truePriceTokenB,\n                liquidityAmount\n            );\n    }\n\n    function getGasCostOfGetLiquidityValueAfterArbitrageToPrice(\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 liquidityAmount\n    ) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        UniswapV2LiquidityMathLibrary.getLiquidityValueAfterArbitrageToPrice(\n            factory,\n            tokenA,\n            tokenB,\n            truePriceTokenA,\n            truePriceTokenB,\n            liquidityAmount\n        );\n        uint256 gasAfter = gasleft();\n        return gasBefore - gasAfter;\n    }\n}\n"
    },
    "src/contracts/test/markets/UniswapV2LiquidityMathLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nimport {Babylonian} from \"@uniswap/lib/contracts/libraries/Babylonian.sol\";\nimport {UniswapV2Library, SafeMath, IUniswapV2Pair, IUniswapV2Factory} from \"../../vendor/uniswap/v2-periphery/libraries/UniswapV2Library.sol\";\n\n// library containing some math for dealing with the liquidity shares of a pair, e.g. computing their exact value\n// in terms of the underlying tokens\nlibrary UniswapV2LiquidityMathLibrary {\n    using SafeMath for uint256;\n\n    // computes the direction and magnitude of the profit-maximizing trade\n    function computeProfitMaximizingTrade(\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 reserveA,\n        uint256 reserveB\n    ) public pure returns (bool aToB, uint256 amountIn) {\n        aToB = reserveA.mul(truePriceTokenB) / reserveB < truePriceTokenA;\n\n        uint256 invariant = reserveA.mul(reserveB);\n\n        uint256 leftSide = Babylonian.sqrt(\n            invariant.mul(aToB ? truePriceTokenA : truePriceTokenB).mul(1000) /\n                uint256(aToB ? truePriceTokenB : truePriceTokenA).mul(997)\n        );\n        uint256 rightSide = (aToB ? reserveA.mul(1000) : reserveB.mul(1000)) / 997;\n\n        // compute the amount that must be sent to move the price to the profit-maximizing price\n        amountIn = leftSide.sub(rightSide);\n    }\n\n    // gets the reserves after an arbitrage moves the price to\n    // the profit-maximizing ratio given an externally observed true price\n    function getReservesAfterArbitrage(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        // first get reserves before the swap\n        (reserveA, reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n\n        require(reserveA > 0 && reserveB > 0, \"UniswapV2ArbitrageLibrary: ZERO_PAIR_RESERVES\");\n\n        // then compute how much to swap to arb to the true price\n        (bool aToB, uint256 amountIn) = computeProfitMaximizingTrade(\n            truePriceTokenA,\n            truePriceTokenB,\n            reserveA,\n            reserveB\n        );\n\n        if (amountIn == 0) {\n            return (reserveA, reserveB);\n        }\n\n        // now affect the trade to the reserves\n        if (aToB) {\n            uint256 amountOut = UniswapV2Library.getAmountOut(amountIn, reserveA, reserveB);\n            reserveA += amountIn;\n            reserveB -= amountOut;\n        } else {\n            uint256 amountOut = UniswapV2Library.getAmountOut(amountIn, reserveB, reserveA);\n            reserveB += amountIn;\n            reserveA -= amountOut;\n        }\n    }\n\n    // computes liquidity value given all the parameters of the pair\n    function computeLiquidityValue(\n        uint256 reservesA,\n        uint256 reservesB,\n        uint256 totalSupply,\n        uint256 liquidityAmount,\n        bool feeOn,\n        uint256 kLast\n    ) internal pure returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n        if (feeOn && kLast > 0) {\n            uint256 rootK = Babylonian.sqrt(reservesA.mul(reservesB));\n            uint256 rootKLast = Babylonian.sqrt(kLast);\n            if (rootK > rootKLast) {\n                uint256 numerator1 = totalSupply;\n                uint256 numerator2 = rootK.sub(rootKLast);\n                uint256 denominator = rootK.mul(5).add(rootKLast);\n                uint256 feeLiquidity = numerator1.mul(numerator2) / denominator;\n                totalSupply = totalSupply.add(feeLiquidity);\n            }\n        }\n        return (reservesA.mul(liquidityAmount) / totalSupply, reservesB.mul(liquidityAmount) / totalSupply);\n    }\n\n    // get all current parameters from the pair and compute value of a liquidity amount\n    // **note this is subject to manipulation, e.g. sandwich attacks**. prefer passing a manipulation resistant price to\n    // #getLiquidityValueAfterArbitrageToPrice\n    function getLiquidityValue(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint256 liquidityAmount\n    ) internal view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n        (uint256 reservesA, uint256 reservesB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n        IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, tokenA, tokenB));\n        bool feeOn = IUniswapV2Factory(factory).feeTo() != address(0);\n        uint256 kLast = feeOn ? pair.kLast() : 0;\n        uint256 totalSupply = pair.totalSupply();\n        return computeLiquidityValue(reservesA, reservesB, totalSupply, liquidityAmount, feeOn, kLast);\n    }\n\n    // Given two tokens, tokenA and tokenB, and their \"true price\",\n    // i.e. the observed ratio of value of token A to token B,\n    // and a liquidity amount, returns the value of the liquidity in terms of tokenA and tokenB\n    function getLiquidityValueAfterArbitrageToPrice(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 liquidityAmount\n    ) internal view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n        bool feeOn = IUniswapV2Factory(factory).feeTo() != address(0);\n        IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, tokenA, tokenB));\n        uint256 kLast = feeOn ? pair.kLast() : 0;\n        uint256 totalSupply = pair.totalSupply();\n\n        // this also checks that totalSupply > 0\n        require(totalSupply >= liquidityAmount && liquidityAmount > 0, \"ComputeLiquidityValue: LIQUIDITY_AMOUNT\");\n\n        (uint256 reservesA, uint256 reservesB) = getReservesAfterArbitrage(\n            factory,\n            tokenA,\n            tokenB,\n            truePriceTokenA,\n            truePriceTokenB\n        );\n\n        return computeLiquidityValue(reservesA, reservesB, totalSupply, liquidityAmount, feeOn, kLast);\n    }\n}\n"
    },
    "src/contracts/test/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.19;\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    mapping(address => bool) public minters;\n    address public owner;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _initialSupply\n    ) ERC20(_name, _symbol, _decimals) {\n        _mint(msg.sender, _initialSupply);\n        minters[msg.sender] = true;\n    }\n\n    function reinitializeERC20(string memory _name, string memory _symbol) external {\n        require(msg.sender == owner, \"!owner\");\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function toggleMinters(address[] calldata _minters) external {\n        require(minters[msg.sender], \"!minter\");\n        for (uint256 i; i < _minters.length; i++) {\n            minters[_minters[i]] = !minters[_minters[i]];\n        }\n    }\n\n    function mint(address to, uint256 value) public virtual {\n        require(minters[msg.sender], \"!minter\");\n        _mint(to, value);\n    }\n\n    function burn(address from, uint256 value) public virtual {\n        require(minters[msg.sender], \"!minter\");\n        _burn(from, value);\n    }\n}\n"
    },
    "src/contracts/test/Multisender.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport {MockERC20} from \"./MockERC20.sol\";\nimport {WETH} from \"./WETH.sol\";\n\n/* solhint-disable no-empty-blocks */\n\nstruct Token {\n    uint256 amount;\n    address token;\n}\n\ncontract Multisender {\n    mapping(address => bool) public owners;\n    mapping(address => bool) public funded;\n\n    Token[] internal tokens;\n    WETH internal weth;\n    address internal kiss;\n\n    event Funded(address indexed account);\n\n    constructor(Token[] memory _tokens, address _weth, address _kiss) {\n        owners[msg.sender] = true;\n\n        for (uint256 i; i < _tokens.length; i++) {\n            tokens.push(_tokens[i]);\n        }\n        weth = WETH(_weth);\n        kiss = _kiss;\n    }\n\n    function addToken(Token memory _token) external {\n        require(owners[msg.sender], \"!o\");\n        tokens.push(_token);\n    }\n\n    function setTokens(Token[] memory _tokens) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < _tokens.length; i++) {\n            tokens[i].amount = _tokens[i].amount;\n            tokens[i].token = _tokens[i].token;\n        }\n    }\n\n    function toggleOwners(address[] calldata accounts) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < accounts.length; i++) {\n            owners[accounts[i]] = !owners[accounts[i]];\n        }\n    }\n\n    function distribute(\n        address[] calldata accounts,\n        uint256 wethAmount,\n        uint256 ethAmount,\n        uint256 kissAmount\n    ) external {\n        require(owners[msg.sender], \"!o\");\n        for (uint256 i; i < accounts.length; i++) {\n            if (funded[accounts[i]]) continue;\n\n            funded[accounts[i]] = true;\n            for (uint256 j; j < tokens.length; j++) {\n                MockERC20(tokens[j].token).mint(accounts[i], tokens[j].amount);\n            }\n\n            weth.deposit(wethAmount);\n            weth.transfer(accounts[i], wethAmount);\n            MockERC20(kiss).transfer(accounts[i], kissAmount);\n\n            payable(accounts[i]).transfer(ethAmount);\n\n            emit Funded(accounts[i]);\n        }\n    }\n\n    function drain() external {\n        require(owners[msg.sender], \"!o\");\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function drainERC20() external {\n        require(owners[msg.sender], \"!o\");\n        MockERC20(kiss).transfer(msg.sender, MockERC20(kiss).balanceOf(address(this)));\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}\n"
    },
    "src/contracts/test/SmockCollateralReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\nimport {IDepositWithdrawFacet} from \"../minter/interfaces/IDepositWithdrawFacet.sol\";\nimport {ICollateralReceiver} from \"../minter/interfaces/ICollateralReceiver.sol\";\nimport {IERC20Permit} from \"../shared/IERC20Permit.sol\";\nimport {ProxyConnector} from \"@redstone-finance/evm-connector/contracts/core/ProxyConnector.sol\";\n\ncontract SmockCollateralReceiver is ICollateralReceiver, ProxyConnector {\n    IDepositWithdrawFacet public kresko;\n    function(address, address, uint256, bytes memory) internal callbackLogic;\n\n    address public account;\n    address public collateralAsset;\n    uint256 public withdrawalAmountRequested;\n    uint256 public withdrawalAmountReceived;\n    Params public userData;\n\n    struct Params {\n        uint256 val;\n        uint256 val1;\n        address addr;\n    }\n\n    constructor(address _kresko) {\n        kresko = IDepositWithdrawFacet(_kresko);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  Callback                                  */\n    /* -------------------------------------------------------------------------- */\n\n    function onUncheckedCollateralWithdraw(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawalAmount,\n        uint256 _depositedCollateralAssetIndex,\n        bytes memory _userData\n    ) external returns (bytes memory) {\n        _depositedCollateralAssetIndex;\n        callbackLogic(_account, _collateralAsset, _withdrawalAmount, _userData);\n        return \"\";\n    }\n\n    function execute(\n        address _collateralAsset,\n        uint256 _amount,\n        function(address, address, uint256, bytes memory) internal logic\n    ) internal {\n        bytes memory data = abi.encode(_amount, 0, address(0));\n        execute(_collateralAsset, _amount, data, logic);\n    }\n\n    function execute(\n        address _collateralAsset,\n        uint256 _amount,\n        bytes memory data,\n        function(address, address, uint256, bytes memory) internal logic\n    ) internal {\n        callbackLogic = logic;\n        withdrawalAmountRequested = _amount;\n        bytes memory encodedFunction = abi.encodeWithSelector(\n            kresko.withdrawCollateralUnchecked.selector,\n            msg.sender,\n            _collateralAsset,\n            _amount,\n            0,\n            data\n        );\n        proxyCalldata(address(kresko), encodedFunction, false);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               Test functions                               */\n    /* -------------------------------------------------------------------------- */\n\n    // should send correct values to the callback\n    function test(address _collateralAsset, uint256 _amount) external {\n        execute(_collateralAsset, _amount, logicBase);\n    }\n\n    function testWithdrawalAmount(address _collateralAsset, uint256 _amount) external {\n        execute(_collateralAsset, _amount, logicTestWithdrawalAmount);\n    }\n\n    // should be able to redeposit\n    function testRedeposit(address _collateralAsset, uint256 _amount) external {\n        execute(_collateralAsset, _amount, logicRedeposit);\n    }\n\n    // should be able to redeposit\n    function testInsufficientRedeposit(address _collateralAsset, uint256 _amount) external {\n        execute(_collateralAsset, _amount, logicInsufficientRedeposit);\n    }\n\n    function testDepositAlternate(address _collateralWithdraw, uint _amount, address _collateralDeposit) external {\n        bytes memory data = abi.encode(_amount, 0, _collateralDeposit);\n        execute(_collateralWithdraw, _amount, data, logicDepositAlternate);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             Callback Execution                             */\n    /* -------------------------------------------------------------------------- */\n\n    function logicDepositAlternate(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawalAmount,\n        bytes memory _userData\n    ) internal {\n        _collateralAsset;\n        userData = abi.decode(_userData, (Params));\n        withdrawalAmountReceived = _withdrawalAmount;\n        IERC20Permit(userData.addr).transferFrom(_account, address(this), userData.val);\n        IERC20Permit(userData.addr).approve(address(kresko), userData.val);\n        // redeposit all\n        kresko.depositCollateral(_account, userData.addr, userData.val);\n    }\n\n    function logicBase(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawalAmount,\n        bytes memory _userData\n    ) internal {\n        // just set data\n        account = _account;\n        collateralAsset = _collateralAsset;\n        withdrawalAmountReceived = _withdrawalAmount;\n        userData = abi.decode(_userData, (Params));\n    }\n\n    function logicTestWithdrawalAmount(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawalAmount,\n        bytes memory _userData\n    ) internal {\n        _userData;\n        account = _account;\n        require(IERC20Permit(_collateralAsset).balanceOf(address(this)) == _withdrawalAmount, \"wrong amount received\");\n    }\n\n    function logicRedeposit(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawalAmount,\n        bytes memory _userData\n    ) internal {\n        _userData;\n        withdrawalAmountReceived = _withdrawalAmount;\n        IERC20Permit(_collateralAsset).approve(address(kresko), _withdrawalAmount);\n        // redeposit all\n        kresko.depositCollateral(_account, _collateralAsset, _withdrawalAmount);\n    }\n\n    function logicInsufficientRedeposit(\n        address _account,\n        address _collateralAsset,\n        uint256 _withdrawalAmount,\n        bytes memory _userData\n    ) internal {\n        _userData;\n        withdrawalAmountReceived = _withdrawalAmount;\n        IERC20Permit(_collateralAsset).approve(address(kresko), 1);\n        // bare minimum redeposit\n        kresko.depositCollateral(_account, _collateralAsset, 1);\n    }\n}\n"
    },
    "src/contracts/test/SmockFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {ISmockFacet} from \"./interfaces/ISmockFacet.sol\";\nimport {DiamondModifiers} from \"../diamond/DiamondModifiers.sol\";\nimport {SmockStorage, Errors} from \"./SmockStorage.sol\";\n\nbytes32 constant TEST_OPERATOR_ROLE = keccak256(\"kresko.test.operator\");\n\n/**\n * @dev Use for Smock fakes / mocks.\n */\ncontract SmockFacet is DiamondModifiers, ISmockFacet {\n    uint256 public constant MESSAGE_THROTTLE = 2;\n\n    function operator() external view returns (address) {\n        return SmockStorage.state().operator;\n    }\n\n    function activate() external override onlyRole(TEST_OPERATOR_ROLE) onlyDisabled {\n        SmockStorage.activate();\n    }\n\n    function disable() external override onlyRole(TEST_OPERATOR_ROLE) onlyActive {\n        SmockStorage.disable();\n    }\n\n    function smockInitialized() external view returns (bool) {\n        return SmockStorage.state().initialized;\n    }\n\n    function setMessage(string memory message) external override onlyActive {\n        require(block.number >= SmockStorage.state().lastMessageBlock + MESSAGE_THROTTLE, \"Cant set message yet\");\n\n        SmockStorage.state().message = message;\n        SmockStorage.state().callers[msg.sender] = true;\n\n        emit SmockStorage.Call(msg.sender);\n        emit NewMessage(msg.sender, message);\n    }\n\n    modifier onlyActive() {\n        require(SmockStorage.state().isActive, Errors.ACTIVE);\n        _;\n    }\n    modifier onlyDisabled() {\n        require(!SmockStorage.state().isActive, Errors.NOT_ACTIVE);\n        _;\n    }\n}\n"
    },
    "src/contracts/test/SmockFacet2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {GeneralEvent} from \"../libs/Events.sol\";\nimport {ISmockFacet} from \"./interfaces/ISmockFacet.sol\";\nimport {TEST_OPERATOR_ROLE} from \"./SmockFacet.sol\";\nimport {SmockStorage} from \"./SmockStorage.sol\";\n\ncontract SmockFacet2 {\n    function initialize() external {\n        SmockStorage.stateExtended().extended = true;\n    }\n\n    function getOldStructValueFromExtended() external view returns (bool) {\n        return SmockStorage.stateExtended().initialized;\n    }\n\n    function getNewStructValueFromExtended() external view returns (bool) {\n        return SmockStorage.stateExtended().extended;\n    }\n}\n"
    },
    "src/contracts/test/SmockInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {GeneralEvent} from \"../libs/Events.sol\";\nimport {Authorization, ds, Role, DiamondModifiers} from \"../diamond/DiamondModifiers.sol\";\n\nimport {ISmockFacet} from \"./interfaces/ISmockFacet.sol\";\nimport {TEST_OPERATOR_ROLE} from \"./SmockFacet.sol\";\nimport {SmockStorage} from \"./SmockStorage.sol\";\n\ncontract SmockInit is DiamondModifiers {\n    function initialize(address _operator) external onlyOwner onlyRole(Role.ADMIN) {\n        require(msg.sender == ds().contractOwner, \"WithStorage: Not owner\");\n        SmockStorage.initialize(_operator);\n\n        Authorization.grantRole(TEST_OPERATOR_ROLE, _operator);\n\n        ds().supportedInterfaces[type(ISmockFacet).interfaceId] = true;\n        emit GeneralEvent.Initialized(msg.sender, 1);\n    }\n\n    function getNumber() public pure returns (uint8) {\n        return 1;\n    }\n\n    function getBool() public pure returns (bool) {\n        return false;\n    }\n\n    function upgradeState() external {\n        ds().initialized = getBool();\n    }\n}\n"
    },
    "src/contracts/test/SmockStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nlibrary Errors {\n    string public constant INITIALIZED = \"Already initialized\";\n    string public constant NOT_ACTIVE = \"SmockFacet: Not active\";\n    string public constant ACTIVE = \"SmockFacet: Active\";\n}\n\nstruct SmockState {\n    bool initialized;\n    bool isActive;\n    address operator;\n    mapping(address => bool) callers;\n    string message;\n    uint256 lastMessageBlock;\n}\n// This is not how it has to be done in reality\n// We can just extend the original\nstruct SmockState2 {\n    bool initialized;\n    bool isActive;\n    address operator;\n    mapping(address => bool) callers;\n    string message;\n    uint256 lastMessageBlock;\n    bool extended;\n}\n\nlibrary SmockStorage {\n    event Call(address indexed caller);\n\n    bytes32 public constant SMOCK_STORAGE_POSITION = keccak256(\"kresko.smock.storage\");\n\n    function initialize(address _operator) internal {\n        SmockState storage ss = state();\n        require(!ss.initialized, Errors.INITIALIZED);\n        ss.initialized = true;\n        ss.operator = _operator;\n        emit Call(msg.sender);\n    }\n\n    function state() internal pure returns (SmockState storage ss) {\n        bytes32 position = SMOCK_STORAGE_POSITION;\n        assembly {\n            ss.slot := position\n        }\n    }\n\n    // This is not how it has to be done in reality\n    function stateExtended() internal pure returns (SmockState2 storage ss) {\n        bytes32 position = SMOCK_STORAGE_POSITION;\n        assembly {\n            ss.slot := position\n        }\n    }\n\n    function activate() internal {\n        state().isActive = true;\n        state().callers[msg.sender] = true;\n        emit Call(msg.sender);\n    }\n\n    function disable() internal {\n        state().isActive = false;\n        state().callers[msg.sender] = true;\n        emit Call(msg.sender);\n    }\n}\n"
    },
    "src/contracts/test/WBTC.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {WETH9} from \"../vendor/WETH9.sol\";\n\ncontract WBTC is WETH9 {\n    mapping(address => bool) public minters;\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\n        minters[msg.sender] = true;\n        symbol = _symbol;\n        name = _name;\n        decimals = _decimals;\n    }\n\n    function toggleMinter(address minter) public {\n        require(minters[msg.sender], \"Not a minter\");\n        minters[minter] = !minters[minter];\n    }\n\n    function deposit() public payable override {\n        revert(\"Use deposit(uint256 amount) instead\");\n    }\n\n    function deposit(uint256 amount) public {\n        require(minters[msg.sender], \"Not a minter\");\n        balanceOf[msg.sender] += amount;\n        emit Deposit(msg.sender, amount);\n    }\n}\n"
    },
    "src/contracts/test/WETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {WETH9} from \"../vendor/WETH9.sol\";\n\ncontract WETH is WETH9 {\n    mapping(address => bool) public minters;\n\n    constructor() {\n        minters[msg.sender] = true;\n    }\n\n    function deposit(uint256 amount) public {\n        require(minters[msg.sender], \"Not a minter\");\n        balanceOf[msg.sender] += amount;\n        emit Deposit(msg.sender, amount);\n    }\n}\n"
    },
    "src/contracts/vendor/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}"
    },
    "src/contracts/vendor/flux/FluxPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IFluxPriceFeed} from \"./interfaces/IFluxPriceFeed.sol\";\n\n/** solhint-disable var-name-mixedcase */\n/**\n * @notice Simple data posting on chain of a scalar value, compatible with Chainlink V2 and V3 aggregator interface\n */\ncontract FluxPriceFeed is AccessControl, IFluxPriceFeed {\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant VALIDATOR_ROLE = keccak256(\"VALIDATOR_ROLE\");\n    uint32 public latestAggregatorRoundId;\n\n    // Transmission records the answer from the transmit transaction at\n    // time timestamp\n    struct Transmission {\n        int192 answer; // 192 bits ought to be enough for anyone\n        uint64 timestamp;\n        bool marketOpen;\n    }\n    mapping(uint32 => Transmission) internal s_transmissions; /* aggregator round ID */\n       \n\n    /**\n     * @param _validator the initial validator that can post data to this contract\n     * @param _decimals answers are stored in fixed-point format, with this many digits of precision\n     * @param _description short human-readable description of observable this contract's answers pertain to\n     */\n    constructor(\n        address _validator,\n        uint8 _decimals,\n        string memory _description\n    ) {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setupRole(VALIDATOR_ROLE, _validator);\n        decimals = _decimals;\n        s_description = _description;\n    }\n\n    /*\n     * Versioning\n     */\n    function typeAndVersion() external pure virtual returns (string memory) {\n        return \"FluxPriceFeed 1.0.0\";\n    }\n\n    /*\n     * Transmission logic\n     */\n\n    /**\n     * @notice indicates that a new report was transmitted\n     * @param aggregatorRoundId the round to which this report was assigned\n     * @param answer value posted by validator\n     * @param marketOpen bool indicating if the market is open\n     * @param transmitter address from which the report was transmitted\n     */\n    event NewTransmission(uint32 indexed aggregatorRoundId, int192 answer, bool marketOpen, address transmitter);\n        \n    /**\n     * @notice details about the most recent report\n     * @return _latestAnswer value from latest report\n     * @return _latestTimestamp when the latest report was transmitted\n     * @return _marketOpen value from latest report\n     */\n    function latestTransmissionDetails() external view returns (int192 _latestAnswer, uint64 _latestTimestamp, bool _marketOpen) {\n        // solhint-disable-next-line avoid-tx-origin\n        require(msg.sender == tx.origin, \"Only callable by EOA\");\n        return (\n            s_transmissions[latestAggregatorRoundId].answer,\n            s_transmissions[latestAggregatorRoundId].timestamp,\n            s_transmissions[latestAggregatorRoundId].marketOpen\n        );\n    }\n\n    /**\n     * @notice transmit is called to post a new report to the contract\n     * @param _answer latest answer\n     */\n    function transmit(int192 _answer, bool _marketOpen) external {\n        require(hasRole(VALIDATOR_ROLE, msg.sender), \"Caller is not a validator\");\n\n        // Check the report contents, and record the result\n        latestAggregatorRoundId++;\n        // solhint-disable-next-line not-rely-on-time\n        s_transmissions[latestAggregatorRoundId] = Transmission(_answer, uint64(block.timestamp), true);\n\n        emit NewTransmission(latestAggregatorRoundId, _answer, true, msg.sender);\n    }\n\n    /*\n     * v2 Aggregator interface\n     */\n\n    /**\n     * @notice answer from the most recent report\n     */\n    function latestAnswer() public view virtual override returns (int256) {\n        return s_transmissions[latestAggregatorRoundId].answer;\n    }\n\n    /**\n     * @notice timestamp of block in which last report was transmitted\n     */\n    function latestTimestamp() public view virtual override returns (uint256) {\n        return s_transmissions[latestAggregatorRoundId].timestamp;\n    }\n\n     /**\n     * @notice market open indicator from the most recent report\n     */\n    function latestMarketOpen() public view virtual override returns (bool) {\n        return s_transmissions[latestAggregatorRoundId].marketOpen;\n    }\n\n    /**\n     * @notice Aggregator round in which last report was transmitted\n     */\n    function latestRound() public view virtual override returns (uint256) {\n        return latestAggregatorRoundId;\n    }\n\n    /**\n     * @notice answer of report from given aggregator round\n     * @param _roundId the aggregator round of the target report\n     */\n    function getAnswer(uint256 _roundId) public view virtual override returns (int256) {\n        if (_roundId > 0xFFFFFFFF) {\n            return 0;\n        }\n        return s_transmissions[uint32(_roundId)].answer;\n    }\n\n    /**\n     * @notice timestamp of block in which report from given aggregator round was transmitted\n     * @param _roundId aggregator round of target report\n     */\n    function getTimestamp(uint256 _roundId) public view virtual override returns (uint256) {\n        if (_roundId > 0xFFFFFFFF) {\n            return 0;\n        }\n        return s_transmissions[uint32(_roundId)].timestamp;\n    }\n\n    /**\n     * @notice market open of report from given aggregator round\n     * @param _roundId the aggregator round of the target report\n     */\n    function getMarketOpen(uint256 _roundId) public view virtual override returns (bool) {\n        require(_roundId <= 0xFFFFFFFF, \"FluxPriceFeed: round ID\");\n        return s_transmissions[uint32(_roundId)].marketOpen;\n    }\n\n    /*\n     * v3 Aggregator interface\n     */\n\n    string private constant V3_NO_DATA_ERROR = \"No data present\";\n\n    /**\n     * @return answers are stored in fixed-point format, with this many digits of precision\n     */\n    uint8 public immutable override decimals;\n\n    /**\n     * @notice aggregator contract version\n     */\n    uint256 public constant override version = 1;\n\n    string internal s_description;\n\n    /**\n     * @notice human-readable description of observable this contract is reporting on\n     */\n    function description() public view virtual override returns (string memory) {\n        return s_description;\n    }\n\n    /**\n     * @notice details for the given aggregator round\n     * @param _roundId target aggregator round. Must fit in uint32\n     * @return roundId _roundId\n     * @return answer answer of report from given _roundId\n     * @return marketOpen of report from given _roundId\n     * @return startedAt timestamp of block in which report from given _roundId was transmitted\n     * @return updatedAt timestamp of block in which report from given _roundId was transmitted\n     * @return answeredInRound _roundId\n     */\n    function getRoundData(uint80 _roundId)\n        public\n        view\n        virtual\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            bool marketOpen,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        require(_roundId <= 0xFFFFFFFF, V3_NO_DATA_ERROR);\n        Transmission memory transmission = s_transmissions[uint32(_roundId)];\n        return (_roundId, transmission.answer, transmission.marketOpen, transmission.timestamp, transmission.timestamp, _roundId);\n    }\n\n    /**\n     * @notice aggregator details for the most recently transmitted report\n     * @return roundId aggregator round of latest report\n     * @return answer answer of latest report\n     * @return marketOpen of latest report\n     * @return startedAt timestamp of block containing latest report\n     * @return updatedAt timestamp of block containing latest report\n     * @return answeredInRound aggregator round of latest report\n     */\n    function latestRoundData()\n        public\n        view\n        virtual\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            bool marketOpen,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        roundId = latestAggregatorRoundId;\n\n        // Skipped for compatability with existing FluxAggregator in which latestRoundData never reverts.\n        // require(roundId != 0, V3_NO_DATA_ERROR);\n\n        Transmission memory transmission = s_transmissions[uint32(roundId)];\n        return (roundId, transmission.answer, transmission.marketOpen, transmission.timestamp, transmission.timestamp, roundId);\n    }\n}\n"
    },
    "src/contracts/vendor/flux/FluxPriceFeedFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"./FluxPriceFeed.sol\";\n\n/**\n * @title Flux first-party price feed factory\n * @author fluxprotocol.org\n */\ncontract FluxPriceFeedFactory {\n    address public owner;\n    // roles\n    bytes32 public constant VALIDATOR_ROLE = keccak256(\"VALIDATOR_ROLE\");\n\n    // mapping of id to FluxPriceFeed\n    mapping(bytes32 => FluxPriceFeed) public fluxPriceFeeds;\n\n    /**\n     * @notice indicates that a new oracle was created\n     * @param id hash of the price pair of the deployed oracle\n     * @param oracle address of the deployed oracle\n     */\n    event FluxPriceFeedCreated(bytes32 indexed id, address indexed oracle);\n\n    /**\n     * @notice to log error messages\n     * @param message the logged message\n     */\n    event Log(string message);\n\n    constructor () {\n        owner = msg.sender;\n    }\n\n    function transferOwnership(address newOwner) external {\n        require(msg.sender == owner, \"!owner\");\n        owner = newOwner;\n    }\n\n    /**\n     * @notice transmit submits an answer to a price feed or creates a new one if it does not exist\n     * @param _pricePairs array of price pairs strings (e.g. ETH/USD)\n     * @param _decimals array of decimals for associated price pairs (e.g. 3)\n     * @param _answers array of prices for associated price pairs\n     * @param _marketStatusAnswers array of market open/closed statuses\n     * @param _provider optional address of the provider, if different from msg.sender\n     */\n    function transmit(\n        string[] calldata _pricePairs,\n        uint8[] calldata _decimals,\n        int192[] calldata _answers,\n        bool[] calldata _marketStatusAnswers,\n        address _provider\n    ) external {\n        require(\n            (_pricePairs.length == _decimals.length) && (_pricePairs.length == _answers.length) && (_pricePairs.length == _marketStatusAnswers.length),\n            \"Transmitted arrays must be equal\"\n        );\n        // if no provider is provided, use the msg.sender\n        address provider = (_provider == address(0)) ? msg.sender : _provider;\n\n        // Iterate through each transmitted price pair\n        for (uint256 i = 0; i < _pricePairs.length; i++) {\n            string memory str = string(\n                abi.encodePacked(\"Price-\", _pricePairs[i], \"-\", Strings.toString(_decimals[i]), \"-\", provider)\n            );\n            bytes32 id = keccak256(bytes(str));\n\n            // deploy a new oracle if there's none previously deployed and this is the original provider\n            if (address(fluxPriceFeeds[id]) == address(0x0)) { \n                _deployOracle(id, _pricePairs[i], _decimals[i], _provider);\n            }\n\n            require(address(fluxPriceFeeds[id]) != address(0x0), \"Provider doesn't exist\");\n\n            require(fluxPriceFeeds[id].hasRole(VALIDATOR_ROLE, msg.sender), \"Only validators can transmit\");\n\n            // try transmitting values to the oracle\n            /* solhint-disable-next-line no-empty-blocks */\n            try fluxPriceFeeds[id].transmit(_answers[i], _marketStatusAnswers[i]) {\n                // transmission is successful, nothing to do\n            } catch Error(string memory reason) {\n                // catch failing revert() and require()\n                emit Log(reason);\n            }\n        }\n    }\n\n    /**\n     * @notice internal function to create a new FluxPriceFeed\n     * @dev only a validator should be able to call this function\n     */\n    function _deployOracle(\n        bytes32 _id,\n        string calldata _pricePair,\n        uint8 _decimals,\n        address _provider\n    ) internal {\n        require(msg.sender == owner, \"!owner\");\n        // deploy the new contract and store it in the mapping\n        FluxPriceFeed newPriceFeed = new FluxPriceFeed(address(this), _decimals, _pricePair);\n\n        fluxPriceFeeds[_id] = newPriceFeed;\n\n        // grant the provider DEFAULT_ADMIN_ROLE and VALIDATOR_ROLE on the new FluxPriceFeed\n        newPriceFeed.grantRole(0x00, msg.sender);\n        newPriceFeed.grantRole(VALIDATOR_ROLE, msg.sender);\n        newPriceFeed.grantRole(VALIDATOR_ROLE, _provider);\n\n        emit FluxPriceFeedCreated(_id, address(newPriceFeed));\n    }\n\n    /**\n     * @notice answer from the most recent report of a certain price pair from factory\n     * @param _id hash of the price pair string to query\n     */\n    function valueFor(bytes32 _id)\n        external\n        view\n        returns (\n            int256,\n            bool,\n            uint256,\n            uint256\n        )\n    {\n        // if oracle exists then fetch values\n        if (address(fluxPriceFeeds[_id]) != address(0x0)) {\n            // fetch the price feed contract and read its latest answer and timestamp\n            try fluxPriceFeeds[_id].latestRoundData() returns (\n                uint80,\n                int256 answer,\n                bool marketOpen,\n                uint256,\n                uint256 updatedAt,\n                uint80\n            ) {\n                return (answer,marketOpen, updatedAt, 200);\n            } catch {\n                // catch failing revert() and require()\n                return (0, false, 0, 404);\n            }\n\n            // else return not found\n        } else {\n            return (0, false, 0, 404);\n        }\n    }\n\n    /**\n     * @notice returns address of a price feed id\n     * @param _id hash of the price pair string to query\n     */\n    function addressOfPricePairId(bytes32 _id) external view returns (address) {\n        return address(fluxPriceFeeds[_id]);\n    }\n\n    /**\n     * @notice returns the hash of a price pair\n     * @param _pricePair ETH/USD\n     * @param _decimals decimal of the price pair\n     * @param _provider original provider of the price pair\n     */\n    function getId(\n        string calldata _pricePair,\n        uint8 _decimals,\n        address _provider\n    ) external pure returns (bytes32) {\n        string memory str = string(\n            abi.encodePacked(\"Price-\", _pricePair, \"-\", Strings.toString(_decimals), \"-\", _provider)\n        );\n        bytes32 id = keccak256(bytes(str));\n        return id;\n    }\n\n    /**\n     * @notice returns address of a price feed id\n     * @param _pricePair ETH/USD\n     * @param _decimals decimal of the price pair\n     * @param _provider original provider of the price pair\n     */\n    function addressOfPricePair(\n        string calldata _pricePair,\n        uint8 _decimals,\n        address _provider\n    ) external view returns (address) {\n        bytes32 id = this.getId(_pricePair, _decimals, _provider);\n        return address(fluxPriceFeeds[id]);\n    }\n\n    /**\n     * @notice returns factory's type and version\n     */\n    function typeAndVersion() external pure virtual returns (string memory) {\n        return \"FluxPriceFeedFactory 2.0.0\";\n    }\n}\n"
    },
    "src/contracts/vendor/flux/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\ninterface AggregatorInterface {\n    function latestAnswer() external view returns (int256);\n\n    function latestTimestamp() external view returns (uint256);\n\n    function latestMarketOpen() external view returns (bool);\n\n    function latestRound() external view returns (uint256);\n\n    function getAnswer(uint256 roundId) external view returns (int256);\n\n    function getTimestamp(uint256 roundId) external view returns (uint256);\n\n    function getMarketOpen(uint256 roundId) external view returns (bool);\n\n    event AnswerUpdated(int256 indexed current, bool marketOpen, uint256 indexed roundId, uint256 updatedAt);\n    event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "src/contracts/vendor/flux/interfaces/FluxAggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\ninterface FluxAggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n    \n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            bool marketOpen,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            bool marketOpen,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "src/contracts/vendor/flux/interfaces/IERC2362.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n/**\n * @dev EIP2362 Interface for pull oracles\n * https://github.com/tellor-io/EIP-2362\n */\ninterface IERC2362 {\n    /**\n     * @dev Exposed function pertaining to EIP standards\n     * @param _id bytes32 ID of the query\n     * @return int,uint,uint returns the value, timestamp, and status code of query\n     */\n    function valueFor(bytes32 _id)\n        external\n        view\n        returns (\n            int256,\n            uint256,\n            uint256\n        );\n}\n"
    },
    "src/contracts/vendor/flux/interfaces/IFluxPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n/* solhint-disable no-global-import */\n/* solhint-disable no-empty-blocks */\nimport \"./AggregatorInterface.sol\";\nimport \"./FluxAggregatorV3Interface.sol\";\n\ninterface IFluxPriceFeed is AggregatorInterface, FluxAggregatorV3Interface {}\n"
    },
    "src/contracts/vendor/flux/SimpleFeed.sol": {
      "content": "pragma solidity >=0.8.19;\nimport {AggregatorV3Interface} from \"../AggregatorV3Interface.sol\";\n\ncontract SimpleFeed is AggregatorV3Interface {\n\n    uint8 public override decimals = 8;\n    string public override description;\n    uint256 public override version = 1;\n    int256 public  initialAnswer;\n\n    constructor(string memory _description, int256 _initialAnswer) {\n        description = _description;\n        initialAnswer = _initialAnswer;\n    }\n    \n    function getRoundData(uint80 _roundId)\n        external\n        view\n        override\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n    {\n        return (1, initialAnswer,  block.timestamp, block.timestamp, roundId);\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n    {\n        return (1, initialAnswer, block.timestamp, block.timestamp, roundId);\n    }\n}\n"
    },
    "src/contracts/vendor/gnosis/GnosisSafe.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity <=0.8.19;\n\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/base/ModuleManager.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/base/OwnerManager.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/base/FallbackManager.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/base/GuardManager.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/common/EtherPaymentFallback.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/common/Singleton.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/common/SignatureDecoder.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/common/SecuredTokenTransfer.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/common/StorageAccessible.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/interfaces/ISignatureValidator.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/external/GnosisSafeMath.sol\";\n\n/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract GnosisSafe is\n    EtherPaymentFallback,\n    Singleton,\n    ModuleManager,\n    OwnerManager,\n    SignatureDecoder,\n    SecuredTokenTransfer,\n    ISignatureValidatorConstants,\n    FallbackManager,\n    StorageAccessible,\n    GuardManager\n{\n    using GnosisSafeMath for uint256;\n\n    string public constant VERSION = \"1.3.0\";\n\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n        0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // keccak256(\n    //     \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    event SafeSetup(\n        address indexed initiator,\n        address[] owners,\n        uint256 threshold,\n        address initializer,\n        address fallbackHandler\n    );\n    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);\n    event SignMsg(bytes32 indexed msgHash);\n    event ExecutionFailure(bytes32 txHash, uint256 payment);\n    event ExecutionSuccess(bytes32 txHash, uint256 payment);\n\n    uint256 public nonce;\n    bytes32 private _deprecatedDomainSeparator;\n    // Mapping to keep track of all message hashes that have been approved by ALL REQUIRED owners\n    mapping(bytes32 => uint256) public signedMessages;\n    // Mapping to keep track of all hashes (message or transaction) that have been approved by ANY owners\n    mapping(address => mapping(bytes32 => uint256)) public approvedHashes;\n\n    // This constructor ensures that this contract can only be used as a master copy for Proxy contracts\n    constructor() {\n        // By setting the threshold it is not possible to call setup anymore,\n        // so we create a Safe with 0 owners and threshold 1.\n        // This is an unusable Safe, perfect for the singleton\n        threshold = 1;\n    }\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    /// @param to Contract address for optional delegate call.\n    /// @param data Data payload for optional delegate call.\n    /// @param fallbackHandler Handler for fallback calls to this contract\n    /// @param paymentToken Token that should be used for the payment (0 is ETH)\n    /// @param payment Value that should be paid\n    /// @param paymentReceiver Address that should receive the payment (or 0 if tx.origin)\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external {\n        // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n        emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);\n    }\n\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    ///      Note: The fees are always transferred, even if the user transaction fails.\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\n    /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Gas price that should be used for the payment calculation.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable virtual returns (bool success) {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData = encodeTransactionData(\n                // Transaction info\n                to,\n                value,\n                data,\n                operation,\n                safeTxGas,\n                // Payment info\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                // Signature info\n                nonce\n            );\n            // Increase nonce and execute transaction.\n            nonce++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n        address guard = getGuard();\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkTransaction(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    signatures,\n                    msg.sender\n                );\n            }\n        }\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500, \"GS010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas\n            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || safeTxGas != 0 || gasPrice != 0, \"GS013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkAfterExecution(txHash, success);\n            }\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    ) private returns (uint256 payment) {\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            require(receiver.send(payment), \"GS011\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            require(transferToken(gasToken, receiver, payment), \"GS012\");\n        }\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) public view {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        require(_threshold > 0, \"GS001\");\n        checkNSignatures(dataHash, data, signatures, _threshold);\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     * @param requiredSignatures Amount of required valid signatures.\n     */\n    function checkNSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures,\n        uint256 requiredSignatures\n    ) public view {\n        // Check that the provided signature data is not too short\n        require(signatures.length >= requiredSignatures.mul(65), \"GS020\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < requiredSignatures; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= requiredSignatures.mul(65), \"GS021\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s).add(32) <= signatures.length, \"GS022\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"GS023\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(\n                    ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE,\n                    \"GS024\"\n                );\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"GS025\");\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(\n                    keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)),\n                    v - 4,\n                    r,\n                    s\n                );\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n            require(\n                currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS,\n                \"GS026\"\n            );\n            lastOwner = currentOwner;\n        }\n    }\n\n    /// @dev Allows to estimate a Safe transaction.\n    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    /// @notice Deprecated in favor of common/StorageAccessible.sol and will be removed in next version.\n    function requiredTxGas(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (uint256) {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n     * @dev Marks a hash as approved. This can be used to validate a hash that is used by a signature.\n     * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.\n     */\n    function approveHash(bytes32 hashToApprove) external {\n        require(owners[msg.sender] != address(0), \"GS030\");\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(hashToApprove, msg.sender);\n    }\n\n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Gas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash = keccak256(\n            abi.encode(\n                SAFE_TX_TYPEHASH,\n                to,\n                value,\n                keccak256(data),\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                _nonce\n            )\n        );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    /// @dev Returns hash to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        return\n            keccak256(\n                encodeTransactionData(\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    _nonce\n                )\n            );\n    }\n}\n"
    },
    "src/contracts/vendor/gnosis/GnosisSafeL2.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./GnosisSafe.sol\";\n\n/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract GnosisSafeL2 is GnosisSafe {\n    event SafeMultiSigTransaction(\n        address to,\n        uint256 value,\n        bytes data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes signatures,\n        // We combine nonce, sender and threshold into one to avoid stack too deep\n        // Dev note: additionalInfo should not contain `bytes`, as this complicates decoding\n        bytes additionalInfo\n    );\n\n    event SafeModuleTransaction(address module, address to, uint256 value, bytes data, Enum.Operation operation);\n\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    ///      Note: The fees are always transferred, even if the user transaction fails.\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\n    /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Gas price that should be used for the payment calculation.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable override returns (bool) {\n        bytes memory additionalInfo;\n        {\n            additionalInfo = abi.encode(nonce, msg.sender, threshold);\n        }\n        emit SafeMultiSigTransaction(\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver,\n            signatures,\n            additionalInfo\n        );\n        return\n            super.execTransaction(\n                to,\n                value,\n                data,\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                signatures\n            );\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public override returns (bool success) {\n        emit SafeModuleTransaction(msg.sender, to, value, data, operation);\n        success = super.execTransactionFromModule(to, value, data, operation);\n    }\n}\n"
    },
    "src/contracts/vendor/gnosis/GnosisSafeProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/proxies/IProxyCreationCallback.sol\";\nimport \"@kreskolabs/gnosis-safe-contracts/contracts/proxies/GnosisSafeProxy.sol\";\n\n/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n/// @author Stefan George - <stefan@gnosis.pm>\ncontract GnosisSafeProxyFactory {\n    event ProxyCreation(GnosisSafeProxy proxy, address singleton);\n\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n    /// @param singleton Address of singleton contract.\n    /// @param data Payload for message call sent to new proxy contract.\n    function createProxy(address singleton, bytes memory data) public returns (GnosisSafeProxy proxy) {\n        proxy = new GnosisSafeProxy(singleton);\n        if (data.length > 0)\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                if eq(call(gas(), proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) {\n                    revert(0, 0)\n                }\n            }\n        emit ProxyCreation(proxy, singleton);\n    }\n\n    /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\n    function proxyRuntimeCode() public pure returns (bytes memory) {\n        return type(GnosisSafeProxy).runtimeCode;\n    }\n\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\n    function proxyCreationCode() public pure returns (bytes memory) {\n        return type(GnosisSafeProxy).creationCode;\n    }\n\n    /// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\n    ///      This method is only meant as an utility to be called from other methods\n    /// @param _singleton Address of singleton contract.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function deployProxyWithNonce(\n        address _singleton,\n        bytes memory initializer,\n        uint256 saltNonce\n    ) internal returns (GnosisSafeProxy proxy) {\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\n        bytes memory deploymentData = abi.encodePacked(\n            type(GnosisSafeProxy).creationCode,\n            uint256(uint160(_singleton))\n        );\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        require(address(proxy) != address(0), \"Create2 call failed\");\n    }\n\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n    /// @param _singleton Address of singleton contract.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function createProxyWithNonce(\n        address _singleton,\n        bytes memory initializer,\n        uint256 saltNonce\n    ) public returns (GnosisSafeProxy proxy) {\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\n        if (initializer.length > 0)\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) {\n                    revert(0, 0)\n                }\n            }\n        emit ProxyCreation(proxy, _singleton);\n    }\n\n    /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction\n    /// @param _singleton Address of singleton contract.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    /// @param callback Callback that will be invoked after the new proxy contract has been successfully deployed and initialized.\n    function createProxyWithCallback(\n        address _singleton,\n        bytes memory initializer,\n        uint256 saltNonce,\n        IProxyCreationCallback callback\n    ) public returns (GnosisSafeProxy proxy) {\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\n        proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback);\n        if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce);\n    }\n\n    /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce`\n    ///      This method is only meant for address calculation purpose when you use an initializer that would revert,\n    ///      therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory.\n    /// @param _singleton Address of singleton contract.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function calculateCreateProxyWithNonceAddress(\n        address _singleton,\n        bytes calldata initializer,\n        uint256 saltNonce\n    ) external returns (GnosisSafeProxy proxy) {\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\n        revert(string(abi.encodePacked(proxy)));\n    }\n}\n"
    },
    "src/contracts/vendor/gnosis/IGnosisSafeL2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\ninterface IGnosisSafeL2 {\n    function isOwner(address owner) external view returns (bool);\n\n    function getOwners() external view returns (address[] memory);\n}\n"
    },
    "src/contracts/vendor/MockAggregatorV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport {AggregatorV3Interface} from \"./AggregatorV3Interface.sol\";\n\ncontract MockAggregatorV3 is AggregatorV3Interface {\n      // Transmission records the answer from the transmit transaction at\n    // time timestamp\n    struct Transmission {\n        int192 answer; // 192 bits ought to be enough for anyone\n        uint64 timestamp;\n    }\n\n    mapping(uint32 => Transmission) internal s_transmissions; /* aggregator round ID */\n    uint32 public latestAggregatorRoundId;\n        /**\n     * @return answers are stored in fixed-point format, with this many digits of precision\n     */\n    uint8 public immutable decimals = 8;\n\n    /**\n     * @notice aggregator contract version\n     */\n    uint256 public constant version = 1;\n\n    string internal s_description;\n\n    /**\n     * @notice indicates that a new report was transmitted\n     * @param aggregatorRoundId the round to which this report was assigned\n     * @param answer value posted by validator\n     * @param marketOpen bool indicating if the market is open\n     * @param transmitter address from which the report was transmitted\n     */\n    event NewTransmission(uint32 indexed aggregatorRoundId, int192 answer, bool marketOpen, address transmitter);\n    /**\n     * @notice human-readable description of observable this contract is reporting on\n     */\n    function description() public view virtual  returns (string memory) {\n        return s_description;\n    }\n\n     /**\n     * @notice details for the given aggregator round\n     * @param _roundId target aggregator round. Must fit in uint32\n     * @return roundId _roundId\n     * @return answer answer of report from given _roundId\n     * @return startedAt timestamp of block in which report from given _roundId was transmitted\n     * @return updatedAt timestamp of block in which report from given _roundId was transmitted\n     * @return answeredInRound _roundId\n     */\n    function getRoundData(uint80 _roundId)\n        public\n        view\n        virtual\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        require(_roundId <= 0xFFFFFFFF, \"no data\");\n        Transmission memory transmission = s_transmissions[uint32(_roundId)];\n        return (_roundId, transmission.answer, transmission.timestamp, transmission.timestamp, _roundId);\n    }\n\n    /**\n     * @notice aggregator details for the most recently transmitted report\n     * @return roundId aggregator round of latest report\n     * @return answer answer of latest report\n     * @return startedAt timestamp of block containing latest report\n     * @return updatedAt timestamp of block containing latest report\n     * @return answeredInRound aggregator round of latest report\n     */\n    function latestRoundData()\n        public\n        view\n        virtual\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        roundId = latestAggregatorRoundId;\n\n        // Skipped for compatability with existing FluxAggregator in which latestRoundData never reverts.\n        // require(roundId != 0, V3_NO_DATA_ERROR);\n\n        Transmission memory transmission = s_transmissions[uint32(roundId)];\n        return (roundId, transmission.answer, transmission.timestamp, transmission.timestamp, roundId);\n    }\n}\n"
    },
    "src/contracts/vendor/MockSequencerUptimeFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\ncontract MockSequencerUptimeFeed {\n    function latestRoundData()\n        public\n        view\n        virtual\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n    {\n        return (0, 0, block.timestamp, block.timestamp, 0);\n    }\n}\n"
    },
    "src/contracts/vendor/Multicall3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n/// @title Multicall3\n/// @notice Aggregate results from multiple function calls\n/// @dev Multicall & Multicall2 backwards-compatible\n/// @dev Aggregate methods are marked `payable` to save 24 gas per call\n/// @author Michael Elliot <mike@makerdao.com>\n/// @author Joshua Levine <joshua@makerdao.com>\n/// @author Nick Johnson <arachnid@notdot.net>\n/// @author Andreas Bigger <andreas@nascent.xyz>\n/// @author Matt Solomon <matt@mattsolomon.dev>\ncontract Multicall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    /// @notice Backwards-compatible call aggregation with Multicall\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return returnData An array of bytes containing the responses\n    function aggregate(Call[] calldata calls) public payable returns (uint256 blockNumber, bytes[] memory returnData) {\n        blockNumber = block.number;\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n        Call calldata call;\n        for (uint256 i = 0; i < length;) {\n            bool success;\n            call = calls[i];\n            (success, returnData[i]) = call.target.call(call.callData);\n            require(success, \"Multicall3: call failed\");\n            unchecked { ++i; }\n        }\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls without requiring success\n    /// @param requireSuccess If true, require all calls to succeed\n    /// @param calls An array of Call structs\n    /// @return returnData An array of Result structs\n    function tryAggregate(bool requireSuccess, Call[] calldata calls) public payable returns (Result[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call calldata call;\n        for (uint256 i = 0; i < length;) {\n            Result memory result = returnData[i];\n            call = calls[i];\n            (result.success, result.returnData) = call.target.call(call.callData);\n            if (requireSuccess) require(result.success, \"Multicall3: call failed\");\n            unchecked { ++i; }\n        }\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls and allow failures using tryAggregate\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return blockHash The hash of the block where the calls were executed\n    /// @return returnData An array of Result structs\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls) public payable returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {\n        blockNumber = block.number;\n        blockHash = blockhash(block.number);\n        returnData = tryAggregate(requireSuccess, calls);\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls and allow failures using tryAggregate\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return blockHash The hash of the block where the calls were executed\n    /// @return returnData An array of Result structs\n    function blockAndAggregate(Call[] calldata calls) public payable returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {\n        (blockNumber, blockHash, returnData) = tryBlockAndAggregate(true, calls);\n    }\n\n    /// @notice Aggregate calls, ensuring each returns success if required\n    /// @param calls An array of Call3 structs\n    /// @return returnData An array of Result structs\n    function aggregate3(Call3[] calldata calls) public payable returns (Result[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call3 calldata calli;\n        for (uint256 i = 0; i < length;) {\n            Result memory result = returnData[i];\n            calli = calls[i];\n            (result.success, result.returnData) = calli.target.call(calli.callData);\n            assembly {\n                // Revert if the call fails and failure is not allowed\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                    // set data offset\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n                    // set length of revert string\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\n                    revert(0x00, 0x64)\n                }\n            }\n            unchecked { ++i; }\n        }\n    }\n\n    /// @notice Aggregate calls with a msg value\n    /// @notice Reverts if msg.value is less than the sum of the call values\n    /// @param calls An array of Call3Value structs\n    /// @return returnData An array of Result structs\n    function aggregate3Value(Call3Value[] calldata calls) public payable returns (Result[] memory returnData) {\n        uint256 valAccumulator;\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call3Value calldata calli;\n        for (uint256 i = 0; i < length;) {\n            Result memory result = returnData[i];\n            calli = calls[i];\n            uint256 val = calli.value;\n            // Humanity will be a Type V Kardashev Civilization before this overflows - andreas\n            // ~ 10^25 Wei in existence << ~ 10^76 size uint fits in a uint256\n            unchecked { valAccumulator += val; }\n            (result.success, result.returnData) = calli.target.call{value: val}(calli.callData);\n            assembly {\n                // Revert if the call fails and failure is not allowed\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                    // set data offset\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n                    // set length of revert string\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\n                    revert(0x00, 0x84)\n                }\n            }\n            unchecked { ++i; }\n        }\n        // Finally, make sure the msg.value = SUM(call[0...i].value)\n        require(msg.value == valAccumulator, \"Multicall3: value mismatch\");\n    }\n\n    /// @notice Returns the block hash for the given block number\n    /// @param blockNumber The block number\n    function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\n        blockHash = blockhash(blockNumber);\n    }\n\n    /// @notice Returns the block number\n    function getBlockNumber() public view returns (uint256 blockNumber) {\n        blockNumber = block.number;\n    }\n\n    /// @notice Returns the block coinbase\n    function getCurrentBlockCoinbase() public view returns (address coinbase) {\n        coinbase = block.coinbase;\n    }\n\n    /// @notice Returns the block difficulty\n    function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\n        difficulty = block.difficulty;\n    }\n\n    /// @notice Returns the block gas limit\n    function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n        gaslimit = block.gaslimit;\n    }\n\n    /// @notice Returns the block timestamp\n    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\n        timestamp = block.timestamp;\n    }\n\n    /// @notice Returns the (ETH) balance of a given address\n    function getEthBalance(address addr) public view returns (uint256 balance) {\n        balance = addr.balance;\n    }\n\n    /// @notice Returns the block hash of the last block\n    function getLastBlockHash() public view returns (bytes32 blockHash) {\n        unchecked {\n            blockHash = blockhash(block.number - 1);\n        }\n    }\n\n    /// @notice Gets the base fee of the given block\n    /// @notice Can revert if the BASEFEE opcode is not implemented by the given chain\n    function getBasefee() public view returns (uint256 basefee) {\n        basefee = block.basefee;\n    }\n\n    /// @notice Returns the chain id\n    function getChainId() public view returns (uint256 chainid) {\n        chainid = block.chainid;\n    }\n\n     function multiSend(bytes memory transactions) public payable {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let length := mload(transactions)\n            let i := 0x20\n            for {\n                // Pre block is not used in \"while mode\"\n            } lt(i, length) {\n                // Post block is not used in \"while mode\"\n            } {\n                // First byte of the data is the operation.\n                // We shift by 248 bits (256 - 8 [operation byte]) it right since mload will always load 32 bytes (a word).\n                // This will also zero out unused data.\n                let operation := shr(0xf8, mload(add(transactions, i)))\n                // We offset the load address by 1 byte (operation byte)\n                // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.\n                let to := shr(0x60, mload(add(transactions, add(i, 0x01))))\n                // We offset the load address by 21 byte (operation byte + 20 address bytes)\n                let value := mload(add(transactions, add(i, 0x15)))\n                // We offset the load address by 53 byte (operation byte + 20 address bytes + 32 value bytes)\n                let dataLength := mload(add(transactions, add(i, 0x35)))\n                // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\n                let data := add(transactions, add(i, 0x55))\n                let success := 0\n                switch operation\n                    case 0 {\n                        success := call(gas(), to, value, data, dataLength, 0, 0)\n                    }\n                    // This version does not allow delegatecalls\n                    case 1 {\n                        revert(0, 0)\n                    }\n                if eq(success, 0) {\n                    revert(0, 0)\n                }\n                // Next entry starts at 85 byte + data length\n                i := add(i, add(0x55, dataLength))\n            }\n        }\n        }\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-core/interfaces/IERC20Minimal.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IERC20Minimal {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-core/interfaces/IUniswapV2Callee.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-core/interfaces/IUniswapV2ERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2ERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-core/interfaces/IUniswapV2Factory.sol": {
      "content": "// // SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-core/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.16;\n\n/** solhint-disable func-name-mixedcase */\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/interfaces/IUniswapV2Migrator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Migrator {\n    function migrate(\n        address token,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/interfaces/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.6.2;\n/** solhint-disable no-global-import */\nimport \"./IUniswapV2Router01.sol\";\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}"
    },
    "src/contracts/vendor/uniswap/v2-periphery/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.6.6;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n}\n"
    },
    "src/contracts/vendor/uniswap/v2-periphery/libraries/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: APGL-3.0\npragma solidity >=0.5.0;\n\nimport \"../../v2-core/interfaces/IUniswapV2Pair.sol\";\nimport \"../../v2-core/interfaces/IUniswapV2Factory.sol\";\n\nimport \"./SafeMath.sol\";\n\nlibrary UniswapV2Library {\n    using SafeMath for uint256;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (address pair) {\n        pair = IUniswapV2Factory(factory).getPair(tokenA, tokenB);\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n        require(reserveA > 0 && reserveB > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        uint256 amountOut,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "src/contracts/vendor/WETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.19;\n\ncontract WETH9 {\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    function deposit() public payable virtual {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public virtual {\n        require(balanceOf[msg.sender] >= wad, \"WETH9: Error\");\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public virtual returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public virtual returns (bool) {\n        require(balanceOf[src] >= wad, \"WETH9: Error\");\n\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\n            require(allowance[src][msg.sender] >= wad, \"WETH9: Error\");\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 2000000,
      "details": {
        "constantOptimizer": false,
        "deduplicate": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "metadata",
          "abi",
          "storageLayout",
          "evm.methodIdentifiers",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "evm.byteCode",
          "evm.bytecode",
          "evm.deployedBytecode"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}